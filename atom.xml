<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ISeeyou</title>
  
  
  <link href="https://www.mingsrc.work/atom.xml" rel="self"/>
  
  <link href="https://www.mingsrc.work/"/>
  <updated>2022-07-09T13:56:46.217Z</updated>
  <id>https://www.mingsrc.work/</id>
  
  <author>
    <name>mingming.shi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STL和C++11</title>
    <link href="https://www.mingsrc.work/posts/136ce074"/>
    <id>https://www.mingsrc.work/posts/136ce074</id>
    <published>2022-07-09T12:30:04.884Z</published>
    <updated>2022-07-09T13:56:46.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="STL和C-11"><a href="#STL和C-11" class="headerlink" title="STL和C++11"></a>STL和C++11</h1><blockquote><p>参考《C++ primer Plus 第六版》</p></blockquote><h2 id="1-array容器"><a href="#1-array容器" class="headerlink" title="1 array容器"></a>1 array容器</h2><div class="note red no-icon disable simple"><p>array容易一旦声明，其长度就是固定的，他使用静态（栈）内存，而不是动态分配的内存。提供它旨在替代数组；array受到的显示比vector多，<mark style="color:white;background:red;font-weight:600;border_radius:100px">但效率更高</mark>。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    <category term="附录G 标准模板库方法和函数" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/%E9%99%84%E5%BD%95G-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="STL" scheme="https://www.mingsrc.work/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++成“神”之路—浮点数</title>
    <link href="https://www.mingsrc.work/posts/1bbee39e"/>
    <id>https://www.mingsrc.work/posts/1bbee39e</id>
    <published>2022-07-09T12:30:04.870Z</published>
    <updated>2022-07-09T13:56:46.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇为基础浮点数用法学习记录</p><span id="more"></span><h2 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h2><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">表示范围</th><th align="center"></th></tr></thead><tbody><tr><td align="center">char</td><td align="center">4字节</td><td align="center">-128~127</td><td align="center"></td></tr><tr><td align="center">signed char</td><td align="center">4字节</td><td align="center">-128~127</td><td align="center"></td></tr><tr><td align="center">unsiged char</td><td align="center">4字节</td><td align="center">0~255</td><td align="center"></td></tr><tr><td align="center">wchar_t(整数类型、宽字符类型)</td><td align="center">8字节</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>wcahr_t：可以拜师扩展字符集，<code>iostream</code>头文件的最新版提供了作用相似的工具——wcin和wcout，可用于处理wchar_t流，&#x3D;&#x3D;可以通过加上前缀L来指示宽字符常量和宽字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">wcahr_t</span> bob = <span class="hljs-string">L&#x27;P&#x27;</span>;<br>wcout &lt;&lt; <span class="hljs-string">L&quot;tall&quot;</span>;<br></code></pre></td></tr></table></figure><p>C++11新增的类型char16_t和char32_t（两者均是无符号的）</p><table><thead><tr><th>char16_t</th><th>使用前缀u表示</th><th>char16_t ch1 &#x3D;u’q’;</th></tr></thead><tbody><tr><td>char32_t</td><td>使用前缀U表示</td><td>char32_t ch2 &#x3D; U’\U000022B’;</td></tr></tbody></table><h2 id="原始（raw）字符串"><a href="#原始（raw）字符串" class="headerlink" title="原始（raw）字符串"></a>原始（raw）字符串</h2><blockquote><p> 使用前缀R来标识原值字符串</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">R&quot;(Jim &quot;Kingt Tutt uses·&quot;\n&quot; inatead of endl)&quot;</span> &lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-comment">//也可以使用</span><br>cout &lt;&lt; <span class="hljs-string">R&quot;+*(此处输入原始字符串)+*&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//输出：</span><br>Jim <span class="hljs-string">&quot;Kingt Tutt uses·&quot;</span>\n<span class="hljs-string">&quot; inatead of endl</span><br></code></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><blockquote><p>如果程序在多个地方使用同一个常量，则需要修改该常量时，只需修改一个符号定义即可(const)。</p><p>g++将指出程序试图给一个只读变量赋值。 关键字 const 叫做限定符，因为它限定了声明的含义。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//creat &#x27;const&#x27;</span><br><span class="hljs-comment">//const type name = value;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Months = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><p>​即：在声明中对const进行初始化。</p><p>​一种常见的做法是将名称的首字母大写，以提醒您 Months是个常量。这决不是一种通用约定，但在阅读程序时有助于区分常量和变量。另一种约定是将整个名称大写，使用Wdefime 创建常量时通常使用这种约定。还有一种约定是以字母k打头，如kmonths。当然，还有其他约定。许多组织都有特殊的编码约定，要求其程序员遵守。</p><h2 id="C-浮点数"><a href="#C-浮点数" class="headerlink" title="C++ 浮点数"></a>C++ 浮点数</h2><blockquote><p>计算机将(2.5、3.64564)这样的值分成两部分存储。一部分表示值，另一部分（缩放因子）用于对值进行放大或缩小。</p></blockquote><h3 id="浮点数的两种表示方法"><a href="#浮点数的两种表示方法" class="headerlink" title="浮点数的两种表示方法"></a>浮点数的两种表示方法</h3><pre><code>    #### 1. 使用常用的标准小数点表示法（如3.1415926）</code></pre><h4 id="2-E表示法（如2-52e-8-x3D-x3D-252-000-000）"><a href="#2-E表示法（如2-52e-8-x3D-x3D-252-000-000）" class="headerlink" title="2. E表示法（如2.52e+8&#x3D;&#x3D;252 000 000）"></a>2. E表示法（如2.52e+8&#x3D;&#x3D;252 000 000）</h4><p>​需要注意的是:</p><pre><code>1. 既可以使用E，也可以使用e2. 指数可以是正数，也可以是负数3. 数字中间不能有空格（7.2 E6是错误的）</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">float</span> f1 = <span class="hljs-number">3834e-10</span>;<br>    <span class="hljs-type">float</span> f2 = <span class="hljs-number">3834</span>/<span class="hljs-number">1e10</span>,f3 = f1;<br><span class="hljs-comment">//输出f1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;当前输出为f1：&quot;</span> &lt;&lt; f1 &lt;&lt; std::endl;<br><span class="hljs-comment">//输出f2</span><br>    std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前输出为f2：%.10f\n&quot;</span>,f2);<br><span class="hljs-comment">//输出f3</span><br>    std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前输出为f3：%.10f\n&quot;</span>, f3);<br>    <br>    <span class="hljs-comment">//int 隐式转换</span><br>    <span class="hljs-type">float</span> f4 = <span class="hljs-number">10</span> / <span class="hljs-number">3</span>; <span class="hljs-comment">//10和3 被默认为两个int型变量  赋值操作向下取整</span><br>    std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前输出为f4：%.10f\n&quot;</span>, f4);  <span class="hljs-comment">//f4=3.0</span><br>    <span class="hljs-type">float</span> f5 = <span class="hljs-number">10.0</span> / <span class="hljs-number">3.0</span>;<br>    std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前输出为f5：%.10f\n&quot;</span>, f5); <span class="hljs-comment">// 10.0/3 = 10/3.0 = 3.33</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浮点数优缺点"><a href="#浮点数优缺点" class="headerlink" title="浮点数优缺点"></a>浮点数优缺点</h3><blockquote><ul><li>优势</li></ul><ol><li>可以表示整数之间的值</li><li>由于有缩放因此，表示范围较大</li></ol><ul><li>不足<ol><li>浮点运算的速度比整数运算慢</li><li>精度降低（如下所示）</li></ol></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//该程序将f6加1，然后减去1</span><br><span class="hljs-type">float</span> f6 = <span class="hljs-number">2.34E+22</span>f;<br><span class="hljs-type">float</span> f7 = f6 + <span class="hljs-number">1.0f</span>;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;f6:&quot;</span> &lt;&lt; f6 &lt;&lt; std::endl &lt;&lt; <span class="hljs-string">&quot;f7-f6:&quot;</span> &lt;&lt; f7 - f6 &lt;&lt; std::endl;<br>std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前输出为f6：%.1f\n当前输出为f7-f6：%.1f\n&quot;</span>, f6, f7-f6);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇为基础浮点数用法学习记录&lt;/p&gt;</summary>
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    <category term="第四章、数据类型" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="浮点型" scheme="https://www.mingsrc.work/tags/%E6%B5%AE%E7%82%B9%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>枚举（enum）</title>
    <link href="https://www.mingsrc.work/posts/9e0a28a8"/>
    <id>https://www.mingsrc.work/posts/9e0a28a8</id>
    <published>2022-07-09T12:30:04.859Z</published>
    <updated>2022-07-09T13:56:46.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>C++的枚举工具提供了另一种创建符号常量的方式，这种方式可以代替<code>const</code>。还允许定义新类型，但必须按严格的限制执行。使用<code>enum</code>的句法与<code>struct</code>类似。</p><p><code>enum color &#123; red, orange, blue, green, red, black&#125;</code></p><p>这条语句定义了一个名为<code>color</code>的新类型，它的取值范围为<code>red, orange, blue, green, red, black</code>，称为符号常量，同时将<code>0~5</code>分别对应于<code>red~black</code>。在默认情况下，<code>0</code>对应的是<code>red</code>,<code>5</code>对应的是<code>black</code>,其他以此类推。</p><h2 id="声明与使用"><a href="#声明与使用" class="headerlink" title="声明与使用"></a>声明与使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">color cor1; <span class="hljs-comment">//定义了一个类型为color的变量cor1</span><br><span class="hljs-comment">//枚举变量的赋值</span><br>cor1 = red; <span class="hljs-comment">//正常赋值</span><br>cor1 = <span class="hljs-number">20</span>; <span class="hljs-comment">//非法，20不是枚举变量</span><br></code></pre></td></tr></table></figure><p>由此可以看出，枚举变量的赋值受到限制，与程序员的定义有关。</p><ul><li><p>对枚举而言，它的操作符只有赋值运算符<code>=</code>，这就意味着枚举变量不能执行<code>++、--、+、—</code>等<code>等号</code>以外的操作。</p></li><li><p>枚举量是整形，可被提升为int类型，但int类型不能自动转换为枚举类型</p></li><li><p>枚举可以进行强制类型转换，但不确定其结果，如<code>cor1 = spectrum(100);</code></p></li><li><p>如果只打算使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称 <code>enum &#123;red,orange&#125;</code>；</p></li></ul><h2 id="设置枚举的值"><a href="#设置枚举的值" class="headerlink" title="设置枚举的值"></a>设置枚举的值</h2><p>可以使用赋值运算符显式地来设置枚举量的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">bits</span> &#123;one = <span class="hljs-number">1</span>, two = <span class="hljs-number">2</span>, three = <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><p>但是，指定的值必须是整数。也可以只显式的设置其中一部分的值，默认情况下，枚举的 第一个常量始终是从<code>0</code>开始的，这一点需要注意。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">digits</span> &#123;zero, one = <span class="hljs-number">0</span>, two, three = <span class="hljs-number">1</span>&#125;;<br></code></pre></td></tr></table></figure><p>这里，<code>zero</code>和<code>one</code>的枚举量都为<code>0</code>,<code>two</code>和<code>three</code>都是<code>1</code>。</p><p>除了可以将<code>int</code>类型的值赋值给枚举量，还可以使用<code>long</code>和<code>long long</code>类型的值。</p><h2 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h2><p>现在有指定了枚举量的枚举如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">enum</span> <span class="hljs-title">bits</span><span class="hljs-params">(one = <span class="hljs-number">1</span>, two = <span class="hljs-number">2</span>,four = <span class="hljs-number">4</span>,eight = <span class="hljs-number">8</span>&#125;;</span></span><br><span class="hljs-params"><span class="hljs-function">bits myflag;</span></span><br><span class="hljs-params"><span class="hljs-function">myflag = bits(<span class="hljs-number">6</span>);</span></span><br></code></pre></td></tr></table></figure><p>问：</p><div align="center">    上述赋值是否合法    <div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>答案</span></div>    <div class="hide-content"><p>合法，虽然<code>6</code>不是枚举量，但它位于枚举定义的取值范围内。    </p></div></div></div><p>关于取值范围的定义（参考C++ primer 第六版）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">enum</span> <span class="hljs-title">bigstep</span><span class="hljs-params">(firat,second = <span class="hljs-number">100</span>, third&#125;;</span></span><br></code></pre></td></tr></table></figure><blockquote><p>首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。例如，定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0∶否则，采用与寻找上限方式相同的方式，但加上负号。</p><hr><p>例如，如果最小的枚举量为-6，而比它小的、最大的2的幂是-8（加上负号），因此下限为-7。选择用多少空间来存储枚举由编译器决定。对于取值范围较小的枚举，使用一个字节或更少的空间∶而对于包含 long类型值的枚举，则使用4个字节。</p></blockquote><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;main.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">myFlag</span> &#123;<br>one,<br>two = <span class="hljs-number">0</span>,<br>three,<br>four = <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; three &lt;&lt; endl;<br>myFlag flag = <span class="hljs-built_in">myFlag</span>(<span class="hljs-number">0</span>);<br>cout &lt;&lt; flag &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><div style="background:black;color:white">1<br>0<br></div><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">color</span> &#123; red=<span class="hljs-number">1</span>, green, blue &#125;;<br> <br>    <span class="hljs-keyword">enum</span>  <span class="hljs-title class_">color</span> favorite_color;<br> <br>    <span class="hljs-comment">/* 用户输入数字来选择颜色 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%u&quot;</span>, &amp;favorite_color);<br> <br>    <span class="hljs-comment">/* 输出结果 */</span><br>    <span class="hljs-keyword">switch</span> (favorite_color)<br>    &#123;<br>    <span class="hljs-keyword">case</span> red:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是红色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> green:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是绿色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> blue:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是蓝色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你没有选择你喜欢的颜色&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div style="background:black;color:white">请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1<br>你喜欢的颜色是红色</div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    <category term="第四章、数据类型" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="enum" scheme="https://www.mingsrc.work/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>共用体（union）</title>
    <link href="https://www.mingsrc.work/posts/c63335c7"/>
    <id>https://www.mingsrc.work/posts/c63335c7</id>
    <published>2022-07-09T12:30:04.849Z</published>
    <updated>2022-07-09T13:56:46.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也</p><p>就是说，结构可以同时存储int、long 和double，共用体只能存储 int、long或double。共用体的句法与结</p><p>构相似，但含义不同。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">one4all</span> &#123;<br><span class="hljs-type">int</span> int_val;<br><span class="hljs-type">long</span> long_val;<br><span class="hljs-type">double</span> double_val;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;main.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//创建一个共用体</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">one4all</span> &#123;<br><span class="hljs-type">int</span> int_val;<br><span class="hljs-type">long</span> long_val;<br><span class="hljs-type">double</span> double_val;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//在同一时间只能之勇union中变量的一种</span><br>one4all temp;<br>temp.int_val = <span class="hljs-number">10</span>;<br>cout &lt;&lt; temp.int_val &lt;&lt; endl;<br>temp.double_val = <span class="hljs-number">3.1415926</span>;<br>cout &lt;&lt; temp.double_val &lt;&lt; endl;<br>cout &lt;&lt; &amp;temp.double_val &lt;&lt; endl;<br>cout &lt;&lt; &amp;temp.long_val &lt;&lt; endl;<br>cout &lt;&lt; &amp;temp.int_val &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fole-del/img@3f4a1f1680269224b3728e4869cbc54b33109707/2020/10/24/662aa3b91116d089c4d3e669dd8ab6f4.png"></p><p>为什么每次只能使用一个，直接打印地址可以发现，<code>union</code>中变量共同使用一个地址，所以每次也只能存储一种类型的值。那么，共用体在什么时候才会用到呢？</p><hr><p>《C++ primer 第六版》中给的定义是：</p><div class="note red no-icon flat"><p>共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。</p></div><h1 id="匿名共用体-anonymous-union"><a href="#匿名共用体-anonymous-union" class="headerlink" title="匿名共用体 (anonymous union)"></a>匿名共用体 (anonymous union)</h1><p>没有名称的共同体，启程苑将成为位于相同地址处的变量。每次只有一个成员是当前的成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">worker</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">bool</span> gender;<br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-type">long</span> id_num;<br>        <span class="hljs-type">char</span> id_char[<span class="hljs-number">20</span>];<br>    &#125;;<br>&#125;;<br><br>worker programmer;<br><span class="hljs-keyword">if</span>(programmer.gender == <span class="hljs-number">1</span>)<br>    cout &lt;&lt; programmer.id_num;<br><span class="hljs-keyword">else</span><br>    cout &lt;&lt; programmer.id_char;<br></code></pre></td></tr></table></figure><p><code>id_num</code>和<code>id_char[20]</code>使用的还是同一个地址。使用中只需确定当前是哪个成员活动就行。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>共用体常用语节省内存。尤其是嵌入式系统编程，对内存要求较为严格。另外，共用体常用于操作系统数据结构或硬件数据结构。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    <category term="第四章、数据类型" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="union" scheme="https://www.mingsrc.work/tags/union/"/>
    
  </entry>
  
  <entry>
    <title>string函数的用法</title>
    <link href="https://www.mingsrc.work/posts/17269114"/>
    <id>https://www.mingsrc.work/posts/17269114</id>
    <published>2022-07-09T12:30:04.841Z</published>
    <updated>2022-07-09T13:56:46.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇教程为基础string用法</p><span id="more"></span><h1 id="1、sizeof（）与strlen（）get（）与getline（）的区别"><a href="#1、sizeof（）与strlen（）get（）与getline（）的区别" class="headerlink" title="1、sizeof（）与strlen（）get（）与getline（）的区别"></a>1、sizeof（）与strlen（）get（）与getline（）的区别</h1><blockquote><p>两者都能读取一行输入，知道到达换行符，但是getline()将丢弃换行符，而get()会将换行符保留在输入序列中</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">long</span> totals[<span class="hljs-number">500</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//只要显式地将第一个元素初始化为0，然后让编译器将其他元素都初始化为0；如果初始化为1）而不是&#123;0&#125;，则第一个元素被设置为1.其他元素都被设置为</span><br></code></pre></td></tr></table></figure><blockquote><p>再确定存储字符串所需的最短数组时，别忘了将结尾的空字符串计算在内</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;S&quot;</span> = <span class="hljs-string">&#x27;S&#x27;</span> + <span class="hljs-string">&#x27;\0&#x27;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;sizeof&#x3D;&#x3D;运算符指出整个数组的长度，但&#x3D;&#x3D;strlen()&#x3D;&#x3D;函数返回的是当前存储在数组中的字符串长度，而不是数组本身的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">int</span> Arsize = <span class="hljs-number">15</span>;<br><span class="hljs-type">char</span> name2[Arsize] = <span class="hljs-string">&quot;C++OWboy&quot;</span>;<br><span class="hljs-comment">//通过设置符号常量的地址即可对数组长度进行修改</span><br>name2[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>strlen()</code>对于未被初始化的数据， 第一个空字符的出现位置是随机的，因此您在运行该程序时，得到的数据长度很可能与此不同</p><h2 id="面向行的输入：getline"><a href="#面向行的输入：getline" class="headerlink" title="面向行的输入：getline()"></a>面向行的输入：getline()</h2><p>getline是istream类的一个类方法</p><p>getline（）函数每次读取一行。它通过&#x3D;&#x3D;换行符&#x3D;&#x3D;来确定行尾，但不保存&#x3D;&#x3D;换行符&#x3D;&#x3D;。相反，在存储字符串时，它用空字符来替换换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;istream&gt;</span></span><br><span class="hljs-comment">//设要使用gtline（（）将姓名读入到一个包含20个元素的nme数组中</span><br><span class="hljs-comment">//第一个参数是目标数组;第二个参数数组长度</span><br><span class="hljs-comment">//长度‘20’包含\0</span><br>cin.<span class="hljs-built_in">getling</span>(name,<span class="hljs-number">20</span>); <br></code></pre></td></tr></table></figure><h2 id="面向行的输入：get"><a href="#面向行的输入：get" class="headerlink" title="面向行的输入：get()"></a>面向行的输入：get()</h2><p>get()会读取换行符（&#x3D;&#x3D;所输入的[<strong>enter</strong>]需要一个get()消化&#x3D;&#x3D;）；用不带任何参数的cin.get（）调用可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。</p><img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gjvu25gt0rj30uu0a2gv1.jpg" alt="String函数用法1" width="1110" data-width="1110" data-height="362"><h2 id="如何消化换行符"><a href="#如何消化换行符" class="headerlink" title="如何消化换行符"></a>如何消化换行符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br><br><span class="hljs-type">char</span> charr[<span class="hljs-number">20</span>];<br>string str;<br><span class="hljs-type">int</span> year;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入年份：&quot;</span>;<br>cin &gt;&gt; year;<br>cout &lt;&lt; <span class="hljs-string">&quot;获取char字符串：&quot;</span>;<br>cin.<span class="hljs-built_in">getline</span>(charr, <span class="hljs-number">20</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;获取string字符串：&quot;</span>;<br><span class="hljs-built_in">getline</span>(cin, str);<br>cout &lt;&lt; <span class="hljs-string">&quot;第一次输入为：&quot;</span> &lt;&lt; charr &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-string">&quot;第二次输入为：&quot;</span> &lt;&lt; str;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvu364erfj30fl01rdfp.jpg" alt="String函数用法2" width="561" data-width="561" data-height="63"><p>运行上述代码可以发现：在输入1997以及<code>回车</code>确定之后，第一个字符串，也就是代码中的<code>cin.getline(charr,20)</code>将回车键吸收并保留，导致第一次getline()直接被调用。所以可以使用get()函数吸收<code>1997</code>之后的换行符；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//以下两种方式均可以</span><br><span class="hljs-comment">//---1---</span><br>cin &gt;&gt; year;<br>cin.<span class="hljs-built_in">get</span>();<span class="hljs-comment">//句点表示法</span><br><br><span class="hljs-comment">//---2---</span><br>(cin&gt;&gt;yeat).<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><p>在添加上述语句之后：便可以正常输入<code>charr</code>与<code>str</code>两个字符串。</p><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gjvu4239ktj30ff02vq2y.jpg" alt="String函数用法3" width="555" data-width="555" data-height="103"><h1 id="2、string类"><a href="#2、string类" class="headerlink" title="2、string类"></a>2、string类</h1><h3 id="1-注意点"><a href="#1-注意点" class="headerlink" title="1.注意点"></a>1.注意点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//string类位于命名空间std中</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure><ul><li>可以使用C-风格字符串来初始化sring 对象。</li><li>可以使用cin来将键盘输入存储到sring对象中。</li><li>可以使用cout 来显示 string对象。</li><li>可以使用数组表示法来访问存储在string对象中的字符。</li></ul><ol><li><p>在未输入之前，string对象的长度被自动设置为0</p></li><li><p>~~~ C++<br>&#x2F;&#x2F;使用以下方法获取string对象的输入<br>char charr[20];<br>int length &#x3D; strlen(charr);<br>cout &lt;&lt; “strlen（charr）：” &lt;&lt; length &lt;&lt; endl;<br>getline(cin,str);&#x2F;&#x2F;此时getline()不是istream中的类方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>3. 上述代码中的charr由于定义时未初始化，第一个空字符的出现位置是随机的吗，因此在运行上述strlen(charr)时，会得到一个不确定的数值&lt;img src=&quot;https://tvax1.sinaimg.cn/large/0072YHp3ly1gjvu4tpiw6j3083011we9.jpg&quot; alt=&quot;String函数用法4&quot; width=&quot;291&quot; data-width=&quot;291&quot; data-height=&quot;37&quot;&gt;<br><br>### 2.string类的赋值、拼接和附加<br><br>~~~ C++<br>string str1=&quot;hello &quot;;<br>string str2=&quot;world!&quot;;<br><br>string str3 = str1+str2;//str3 = &quot;hello world!&quot;<br><br>str1 += str2; //str1 = &quot;hello world!&quot;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-其他形式的字符串字面值"><a href="#3-其他形式的字符串字面值" class="headerlink" title="3.其他形式的字符串字面值"></a>3.其他形式的字符串字面值</h3><p>除了char类型，C++还有wchar_t；并且C++11新增了char16_t和char32_t 可以创建这些类型的数组和这些类型的字符串面值。<code>C++11分别使用前缀L、u和U表示上述三种字符</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">wchar_t</span> c1[] = <span class="hljs-string">L&quot;first&quot;</span>;<br><span class="hljs-type">char16_t</span> c2[] = <span class="hljs-string">u&quot;second&quot;</span>;<br><span class="hljs-type">char32_t</span> c3[] = <span class="hljs-string">U&quot;third&quot;</span>;<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;除了上述之外，C++11还支持Unicode编码，使用前缀<code>u8</code>表示这种类型的字符串面值&#x3D;&#x3D;</p><p>在不使用转移字符时，即保留<code>\n</code>的原样输出是，常规的做法就是<code>“\\\n”</code>输出\n到序列中，但原始字符串将”（和）”用作定界符，并使用前缀 R来标识原始字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">R&quot;(i am a &quot;big&quot;one .)&quot;</span><br></code></pre></td></tr></table></figure><p>上述代码输出为:</p><p> i am “big” one.</p><p>就不必使用\来表示转义序列。</p><p>同时也可以使用自定义定界符控制开始和结尾R”+*(输出内容)+*“</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">R&quot;+*(&quot;(how are you?)&quot;,i&#x27;m fine. )+*&quot;</span><br></code></pre></td></tr></table></figure><p>上述代码输出为：</p><p>“(how are you?)”,i’m fine.</p><p><code>需要注意的是，在默认定界符之间可以添加任意数量额基本的字符，但是不包括(空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）)</code>，还可以结合着字符串前缀使用，如Ru、UR等</p><h3 id="substr-size-type-pos-size-type-n-x3D-npos-函数"><a href="#substr-size-type-pos-size-type-n-x3D-npos-函数" class="headerlink" title="substr(size_type pos,size_type n &#x3D; npos)函数"></a>substr(size_type pos,size_type n &#x3D; npos)函数</h3><p>返回一个字符串——这是从pos开始，复制n个字符（或到字符串尾部）得到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">messgae</span> <span class="hljs-params">(<span class="hljs-string">&quot;this is a test string!&quot;</span>)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">firstWord</span><span class="hljs-params">(message.substr(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>))</span></span><br></code></pre></td></tr></table></figure><h1 id="3、结构体"><a href="#3、结构体" class="headerlink" title="3、结构体"></a>3、结构体</h1><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//创建结构体</span><br><span class="hljs-comment">//定义一个student结构体，包括三种类型的变量</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">bool</span> gender;<br>&#125;;<br><span class="hljs-comment">//还可以在创建的结构体的时候就创建结构变量，同时也可以对变量初始化</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">bool</span> gender;<br>&#125;ming_xiao,hua_li=<br>&#123;<br>  <span class="hljs-string">&quot;lihua&quot;</span>,<br>    <span class="hljs-number">18</span>,<br>    <span class="hljs-number">0</span><br>&#125;;<br><span class="hljs-comment">//还可以声明没有名称的结构体，省略名称就行</span><br><span class="hljs-keyword">struct</span>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">bool</span> gender;<br>&#125; Danny; <span class="hljs-comment">//这样就创建了一个Danny的结构体变量，可以使用Danny.name调用成员变量</span><br></code></pre></td></tr></table></figure><h3 id="2-结构数组"><a href="#2-结构数组" class="headerlink" title="2.结构数组"></a>2.结构数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//创建结构体</span><br>student stu[<span class="hljs-number">100</span>];<br><br><span class="hljs-comment">//stu中的每个元素都是stu对象，可以与成员运算符一起使用</span><br>cin &gt;&gt; stu[<span class="hljs-number">0</span>].name;<br>cout &lt;&lt; stu[<span class="hljs-number">99</span>].age;<br><br><span class="hljs-comment">//结构数组在定义的时候也可以初始化</span><br><br>student stu[<span class="hljs-number">2</span>] =&#123;<br>    &#123;<span class="hljs-string">&quot;LiMing&quot;</span>，<span class="hljs-number">19</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;Danny&quot;</span>,<span class="hljs-number">21</span>,<span class="hljs-number">0</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇教程为基础string用法&lt;/p&gt;</summary>
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    <category term="第四章、数据类型" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="string" scheme="https://www.mingsrc.work/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>C++关键字——extern</title>
    <link href="https://www.mingsrc.work/posts/510cef8a"/>
    <id>https://www.mingsrc.work/posts/510cef8a</id>
    <published>2022-07-09T12:30:04.826Z</published>
    <updated>2022-07-09T13:56:46.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="C-x2F-C-中extern关键字详解"><a href="#C-x2F-C-中extern关键字详解" class="headerlink" title="C&#x2F;C++中extern关键字详解"></a>C&#x2F;C++中extern关键字详解</h2><blockquote><p>一个很容易忽略的关键字</p></blockquote><h2 id="基本解释"><a href="#基本解释" class="headerlink" title="基本解释"></a>基本解释</h2><p>extern可以放在<mark style="color:white;background:rgb(101,90,225);border-radius:25px;padding:2px">变量或者函数</mark>前。表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找定义。此外<code>exrtern</code>也可以用来进行链接指定。</p><h3 id="1-用作外部变量的声明与使用"><a href="#1-用作外部变量的声明与使用" class="headerlink" title="1. 用作外部变量的声明与使用"></a>1. 用作外部变量的声明与使用</h3><p>如果在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用<code>extern</code>声明它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//file01.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> cat = <span class="hljs-number">20</span>; <span class="hljs-comment">//定一个flag变量并初始化</span><br><span class="hljs-type">int</span> dog = <span class="hljs-number">22</span>;<br><span class="hljs-type">int</span> fleas;<br><span class="hljs-comment">//file02.cpp</span><br><span class="hljs-comment">//使用file01的cat和dog</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> cat;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> dog;<br></code></pre></td></tr></table></figure><p>在上述例子中，因为file02并没有声明<code>fleas</code>变量，因此无法使用，但是声明了<code>cat</code>和<code>dog</code>，因此可以使用这两个变量。由此可见，<mark style="color:white;background:rgb(101,90,225);border-radius:25px;padding:2px">关键字extern并非必不可少的</mark>，因为即使省略它，效果也相同。</p><h2 id="2、函数的声明"><a href="#2、函数的声明" class="headerlink" title="2、函数的声明"></a>2、函数的声明</h2><p>函数的声明中extern关键字是可有可无的，因为函数本身不加修饰的话就是extern。但是引用的时候一样需要声明。</p><h3 id="3、可以多次声明，但是定义只能一次"><a href="#3、可以多次声明，但是定义只能一次" class="headerlink" title="3、可以多次声明，但是定义只能一次"></a>3、可以多次声明，但是定义只能一次</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">//声明，不是定义</span><br><span class="hljs-type">int</span> i; <span class="hljs-comment">//声明，也是定义</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    <category term="关键字" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>类型转换</title>
    <link href="https://www.mingsrc.work/posts/61165acd"/>
    <id>https://www.mingsrc.work/posts/61165acd</id>
    <published>2022-07-09T12:30:04.820Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>标准类型转换太不严格。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Doof</span> &#123;<br>    <span class="hljs-type">double</span> feeb;<br>    <span class="hljs-type">double</span> steeb;<br>    <span class="hljs-type">char</span> sgif[<span class="hljs-number">10</span>];<br>&#125;;<br>Doof leam;<br>shart * ps = (<span class="hljs-type">short</span> *) &amp; leam;<br><span class="hljs-type">int</span> * pi = <span class="hljs-type">int</span> * (&amp;leam);<br></code></pre></td></tr></table></figure><p>《C++ Prime Plus》中的例子。C语言不能防止将一种类型的指针转换为另一种完全不相关的类型的指针。</p><p>因此，C++中使用了：</p><ul><li><code>dynamic_cast</code></li><li><code>static_cast</code></li><li><code>const_cast</code></li><li><code>reinterpret_cast</code></li></ul><p>四种类型转换运算符来执行涉及指针的类型转换。</p></blockquote><h2 id="1-dynamic-cast"><a href="#1-dynamic-cast" class="headerlink" title="1. dynamic_cast"></a><font color font-weight="900">1. dynamic_cast</font></h2><p>该运算符的用途是，<span style="border-bottom:3px solid green">使得能够在类层次结构中进行向上转换（由于is-a关系，这样的类型转换是安全的），而不允许其他转换。</span>用法如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">dynamic_cast</span> &lt;type-name&gt; (expression)<br></code></pre></td></tr></table></figure><p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化是，如果是非法的对于指针返回NULL,对于引用跑一场。要深入了解内部转换的原理。</p><ul><li>向上转换：指的是子类向基类的转换</li><li>向下转换：指的是基类想子类的转换</li></ul><p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够向下转换。</p><h2 id="2-const-cast"><a href="#2-const-cast" class="headerlink" title="2. const_cast"></a>2. const_cast</h2><p><code>const_cast</code>运算符用于执行只有一种用途的类型转换，及改变值为<code>const</code>为<code>volatile</code>，其语法与<code>dynamic_cast</code>运算符相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">const_cast</span>&lt;type-name&gt; (expression)<br></code></pre></td></tr></table></figure><p>通俗讲，就是const_cast用于（is-a）关系中将const转换为非const。</p><p>提供该运算符的原因是，有时候可能需要这样一个值，它在大多数时候是常量，而有时又是可以修改的。在这种情况下，可以将这个值声明为const，并在需要修改它的时候，使用const_cast。</p><p>此外，还用于将const变量转为非const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> age = <span class="hljs-number">40</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> agep = age;<br>cout &lt;&lt; <span class="hljs-string">&quot;const of age:&quot;</span> &lt;&lt; agep &lt;&lt; endl;<br><span class="hljs-type">int</span> &amp;nConstAge = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(agep);<br><span class="hljs-comment">// 修改nConstAge的值看看是否能成功修改age的值</span><br>nConstAge = <span class="hljs-number">18</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;new const of age：&quot;</span> &lt;&lt; agep &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210111134448789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1ZWxfTWluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-static-cast"><a href="#3-static-cast" class="headerlink" title="3. static_cast"></a>3. static_cast</h2><p><code>static_cast</code>运算符的语法与其它运算符一致,用于将const变量转为非const：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static_cast</span> &lt;type-name&gt; (expression)<br></code></pre></td></tr></table></figure><p>仅当type_name可被隐式转换为expression所属的类型或expression可被隐式转换为type_name所属类型时，上述转换才是合法的，否则将出错。</p><blockquote><p>假设High是Low的基类，而Pond是一个无关的类，则从High到Low的转换、从Low到High的转换都是合法的，而从Low到Pond的转换是不允许的：</p></blockquote><h2 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. reinterpret_cast</h2><p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p>]]></content>
    
    
    <summary type="html">四种类型转换运算符</summary>
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>头文件(.h)</title>
    <link href="https://www.mingsrc.work/posts/524b4b01"/>
    <id>https://www.mingsrc.work/posts/524b4b01</id>
    <published>2022-07-09T12:30:04.810Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="头文件-header-files"><a href="#头文件-header-files" class="headerlink" title="头文件(header files)"></a>头文件(header files)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>C++&#x2F;C程序的头文件以<code>.h</code>为后缀。使用时需要在<code>.cpp</code>文件中意<code>#include&lt;fileName.h&gt;</code>的方式引入。头文件作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明，而定义文件用于保存程序的实现。</p><h2 id="头文件中常包含的内容"><a href="#头文件中常包含的内容" class="headerlink" title="头文件中常包含的内容"></a>头文件中常包含的内容</h2><ol><li><p>函数原型</p></li><li><p>使用<code>#define</code>或<code>const</code>定义的符号常量</p></li><li><p>结构声明</p><p>将结构声明放在头文件中是可以的，因为它们不创建变量，而只是在源代码文件中声明结构变量时，告诉编译器如何创建该结构变量。</p></li><li><p>类声明</p></li><li><p>内联函数(inline)</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++“多态”</title>
    <link href="https://www.mingsrc.work/posts/fc3d8b80"/>
    <id>https://www.mingsrc.work/posts/fc3d8b80</id>
    <published>2022-07-09T12:30:04.804Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本篇是自己阅读加上自己对“多态”的理解，若有不足之处，感谢指出~</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态最常见的用法就是<mark style="background:pink">声明基类类型的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法</mark>。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是固定的，因此将始终调用到同一个函数，这就无法实现“一个接口，多种方法”的目的了。</p><div class="note pink icon simple"><i class="note-icon fa fa-3x fa-wheelchair-alt faa-horizontal animated"></i><p>在C++ Primer有关于OOP编程的描述是这样的。</p><p>OOP不仅仅是将数据和方法合并为类定义；还有助于创建可重用的代码，这将减少大量的工作（继承、类的复用）。</p><ul><li><strong>封装</strong>（信息隐藏）可以保护数据，使其免遭不适当的访问（使得代码模块化）；</li><li><strong>多态</strong>让您能够为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义；<ul><li>编译时多态：通过重载函数实现</li><li>运行时多态性：通过虚函数实现</li></ul></li><li><strong>继承</strong>让您能够使用旧类派生出新类(扩展已存在的代码)。</li></ul><p>这些都是面向对象（OOP)所指的特性。还包括：</p><ul><li><strong>抽象</strong></li><li><strong>代码的可重用性</strong></li></ul></div><p>在C++面试中很有可能会问你C++的三个特性：<strong>封装、继承、多态</strong>。</p><p>有关于这三点特性，从设计模式中会受益许多，一个好的建议就是去学习设计模式。推荐《Easy搞定设计模式》这本PDF，网上可以搜到。</p><hr><p>关于多态，<mark style="background:pink;border:2px solid">C++ primer</mark>给的定义包括多个方面：</p><ol><li>函数重载</li></ol><p>函数多态是C++在C语言的基础上新增的功能，默认参数让您能够使用不同数目的参数调用同一个函数，而函数多态（函数重载）让您能够使用多个同名的函数。术语“多态”指的是拥有多种形式，因此函数多态允许函数可以有多种形式。类似地，术语“函数重载”指的是可以有多个同名的含糊，因此对名称进行了重载。</p><ol start="2"><li>类继承：有些继承关系是多态的，这意味着相同的方法名称可能导致依赖于对象类型的行为。（如下代码所示）</li><li>运算符重载</li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;一种水果&quot;</span> &lt;&lt; endl;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;水果的颜色&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">还可以声明其他的类和添加您所需要的方法以满足业务需求</span><br><span class="hljs-comment">您可以尝试创建一个Pear类来更加了解多态行为，更多的可以去了解纯虚函数、抽象等</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> : <span class="hljs-keyword">public</span> Fruit &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是苹果&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;红色苹果&quot;</span> &lt;&lt; endl;;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//声明父类和子类的对象</span><br>Fruit fruit;<br>Apple apple;<br><span class="hljs-comment">//声明一个指向父类的父类指针</span><br>Fruit *anotherFruit = &amp;fruit;<br>anotherFruit-&gt;<span class="hljs-built_in">getName</span>();<br>anotherFruit-&gt;<span class="hljs-built_in">getColor</span>();<br><span class="hljs-comment">//令父类指针指向子类对象</span><br>anotherFruit = &amp;apple;<br>anotherFruit-&gt;<span class="hljs-built_in">getName</span>(); <span class="hljs-comment">//由于fetName()是虚函数，因此调用时指向虚函数表中该函数所在的位置</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    有virtual才能发生多态现象，没有virtual就按类型调用。</span><br><span class="hljs-comment">    而getColor()不是虚函数，因此调用基类的getColor()</span><br><span class="hljs-comment">    */</span><br>anotherFruit-&gt;<span class="hljs-built_in">getColor</span>(); <br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="https://cdn.jsdelivr.net/gh/fole-del/img@efbea9b01d4d12b1df5b28ef74f1572047f4e5b2/2020/10/24/2c3d166689bbe5bffacd45bd9c5854e6.png"></p><h1 id="再谈“接口”"><a href="#再谈“接口”" class="headerlink" title="再谈“接口”"></a>再谈“接口”</h1><p>不同对象调用使用相同方法实现不同操作，也即，方法完成的行为取决于调用该方法的对象。说着有点拗口，我自己理解就是类层面的“重载”。怎么去理解？代码！还是刚才的两个类，额外添加一个Pear类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//先修改基类，使其变为抽象类</span><br><span class="hljs-comment">// 1. 抽象类不用定义，只需声明即可</span><br><span class="hljs-comment">// 2. 抽象类方法前必须有virtual声明</span><br><span class="hljs-comment">// 3. 抽象类不能实例化对象，但是可以创建对象指针</span><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">定义一个水果类抽象基类。用于定操作和规定函数，提供方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但凡是纯虚函数，子类继承必须全部重定义！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 定义苹果类和犁类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> : <span class="hljs-keyword">public</span> Fruit &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是苹果&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;红色苹果&quot;</span> &lt;&lt; endl;;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pear</span> : <span class="hljs-keyword">public</span> Fruit &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是犁&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;黄犁&quot;</span> &lt;&lt; endl;;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>创建指针对象指向不同的子类，实现不同的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 通过创建基类的指针对象可以实现多台，就不用访问具体的类，只需要根据基类知道其中的操作即可</span><br>    Fruit *apple = <span class="hljs-keyword">new</span> Apple;<br>Fruit *pear = <span class="hljs-keyword">new</span> Pear;<br>apple-&gt;<span class="hljs-built_in">getName</span>();<br>apple-&gt;<span class="hljs-built_in">getColor</span>();<br>pear-&gt;<span class="hljs-built_in">getName</span>();<br>pear-&gt;<span class="hljs-built_in">getColor</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="https://cdn.jsdelivr.net/gh/fole-del/img@f3cb5d2dc32212f0cc788c6f2ba6b1a1057c762a/2020/10/24/ad7856d16df0440bb96974c1e1954d0e.png"></p>]]></content>
    
    
    <summary type="html">C++多态你在第几层？</summary>
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="多态" scheme="https://www.mingsrc.work/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>易混点😖：函数指针与指针函数</title>
    <link href="https://www.mingsrc.work/posts/3e98108d"/>
    <id>https://www.mingsrc.work/posts/3e98108d</id>
    <published>2022-07-09T12:30:04.791Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数指针与指针函数"><a href="#函数指针与指针函数" class="headerlink" title="函数指针与指针函数"></a>函数指针与指针函数</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
  </entry>
  
  <entry>
    <title>C++“内联函数”</title>
    <link href="https://www.mingsrc.work/posts/fb55278d"/>
    <id>https://www.mingsrc.work/posts/fb55278d</id>
    <published>2022-07-09T12:30:04.780Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>参考文章：<a href="https://www.cnblogs.com/P3nguin/p/7977860.html">[c++] 用宏定义一个函数 - 推杯问盏 - 博客园</a></p></blockquote><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>对于一个频繁使用的短小函数，在C语言中应该用<code>宏定义</code>实现，在C++中用<code>inline</code>实现。宏定义与内联函数的不同用法000。</p><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>在c语言中，写一手漂亮的宏定义是非常有必要的，方式出错；提高代码的移植性和可读性等。尤其是一些常用或通用的功能函数或者代码段，这些功能既可以写成函数，也可以封装为宏定义。就功能性上来讲，用宏定义自然有函数无法比拟的优势所在。</p><p>*<em>要点：变量都用括号括起来，防止出错，结尾不需要;。在实际编程中，不推荐把复杂的函数使用宏，不容易调试。多行用\*</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a,b) ((a)&gt;(b)？(a):(b)) <span class="hljs-comment">//一个简单的大小比较的宏定义函数</span></span><br></code></pre></td></tr></table></figure><p>但是如果用函数实现的话，你可能得先声明，并且定义，尤其是对变量类型的局限性上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a ,<span class="hljs-type">int</span> b)</span>; <span class="hljs-comment">//声明</span><br><span class="hljs-comment">//定义</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a&gt;b?a:b;<br>&#125;<br></code></pre></td></tr></table></figure><p>比较明显，宏定义简单又方便；同时，<mark>函数地调用会带来额外的开销，他需要开辟一片栈空间，记录返回地址，函数返回还要释放</mark>。这种开销很明显地会降低代码效率，而且代码量也会大大增加，而使用宏定义则在代码规模和速度方面都有优势。其次就是变量类型上，在C++中因为有模板还可以实现多类型变量的比较，但是在上述代码中仅仅支持int类型的变量进行比较。但宏定义就有所不同，可以用于整形、长整型、单浮点型、双浮点型以及其他一些可以用<code>&gt;</code>操作符进行比较的变量类型，就是说，宏定义是不需要考虑类型的。</p><p>在具体使用中，较多场合会因为使用宏定义重命名函数名以及定义一些变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MALLOC(n, type) \</span><br><span class="hljs-meta">((type *) malloc((n)* sizeof(type))</span><br></code></pre></td></tr></table></figure><p>利用这个宏，我们就可以简单的为任何类型分配一段我们指定的空间大小，并返回指向这段空间的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> *ptr;<br>ptr = MALLOC( <span class="hljs-number">5</span>, <span class="hljs-type">int</span> );<span class="hljs-comment">//申请5int大小的空间</span><br></code></pre></td></tr></table></figure><p>关于宏定义还会有一些小问题，可能也会导致你使用上的错误，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE_SUM(x,y) x*x+y*y</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>,j = <span class="hljs-number">2</span>,k ;<br>    k = SQUARE_SUM(i+<span class="hljs-number">1</span>,j);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,k);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码真实的调用是<code>1+1*1+1+2*2=7</code>，这一点需要注意，所以如果有需要的话，建议给变量小括号带上。</p><h2 id="宏定义小结"><a href="#宏定义小结" class="headerlink" title="宏定义小结"></a>宏定义小结</h2><table><thead><tr><th>属性</th><th>#define宏</th><th>函数</th></tr></thead><tbody><tr><td>代码长度</td><td>每次使用时，宏代码都被插入到程序中。除了非常小的宏之外，程序的长度将大幅度增长。</td><td>函数代码只出现于一个地方：每次使用这个函数时，都调用那个地方的同一份代码</td></tr><tr><td>执行速度</td><td>更快</td><td>存在函数调用、返回的额外开销</td></tr><tr><td>操作符优先级</td><td>宏参数的求值是在所有周围表达式的上下文环境里，除非它们加上括号，否则邻近操作符的优先级可能产生不可预料的结果。</td><td>函数参数只在函数调用时求值一次，它的结果值传递给函数。表达式的求值结果更容易预测。</td></tr><tr><td>参数求值</td><td>参数用于宏定义时，每次都将重新求值，由于多次求值，具有副作用的参数可能会产生不可预测的结果。</td><td>参数在函数调用前只求值一次，在函数中多次使用参数并不会导致多次求值过程，参数的副作用并不会造成任何特殊问题。</td></tr><tr><td>参数类型</td><td>宏与类型无关，只要参数的操作是合法的，它可以用于任何参数类型。</td><td>函数的参数是与类型有关系的，如果参数的类型不同，就需要使用不同的函数，即使它们执行的任务是相同的。</td></tr></tbody></table><hr><h1 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a><code>inline</code>函数</h1><p>在系统下，栈空间是有限的，加入频繁大量的使用就会造成因栈空间不足所造成的程序出错的问题，内联函数的引入也是为了解决一些频繁调用的小函数大量消耗栈空间的问题。</p><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-comment">//函数定义为inline即:内联函数  </span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span>* <span class="hljs-title">dbtest</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;奇&quot;</span> : <span class="hljs-string">&quot;偶&quot;</span>;  <br>&#125;   <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>   <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;  <br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i:%d    奇偶性:%s /n&quot;</span>, i, <span class="hljs-built_in">dbtest</span>(i));      <br>   &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>在这种情况时当在下表调用函数时，会变成<code>(i%2&gt;0)?&quot;奇&quot;:&quot;偶&quot;</code>；避免了函数的重复调用对栈内存重复开辟所带来的消耗；当然，inline函数不是在任何条件下都可以使用的，只有函数本身没有调用本身并且函数不是复杂函数（<strong>当函数中存在while循环或swich语句时为复杂函数</strong>，但是不是复杂函数还要看编译器对它的判断）时，才可以使用；</p><hr><p><strong>注意点：</strong><div class="note purple no-icon simple"><p>inline函数仅仅是一个建议,对编译器的建议,所以最后能否真正内联,看编译器的意思,它如果认为函数不复杂,能在调用点展开,就会真正内联,并不是说声明了内联就会内联,声明内联只是一个建议而已。</p><p>其次,因为内联函数要在调用点展开,所以编译器必须随处可见内联函数的定义,要不然,就成了非内联函数的调用了.所以,这要求每个调用了内联函数的文件都出现了该内联函数的定义。因此,<strong>将内联函数放在头文件里实现是合适的</strong>,省却你为每个文件实现一次的麻烦.而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为,即是说,如果不是每个文件里的定义都一样,那么,编译器展开的是哪一个,那要看具体的编译器而定.所以,最好将内联函数定义放在头文件中.<br>而类中的成员函数缺省都是内联的,如果在类定义时就在类内给出函数,那当然最好;如果在类中未给出成员函数定义,而又想内联该函数的话,那在类外要加上inline,否则就认为不是内联的.<br>为了方便,将内联函数直接声明时就定义,放在头文件中.这样其它文件包含了该头文件,就在每个文件都出现了内联函数的定义.就可以内联了.</p></div></p>]]></content>
    
    
    <summary type="html">短小函数在C和C++中的不同实现</summary>
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="内联函数" scheme="https://www.mingsrc.work/tags/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>shared_ptr详细用法</title>
    <link href="https://www.mingsrc.work/posts/e340a684"/>
    <id>https://www.mingsrc.work/posts/e340a684</id>
    <published>2022-07-09T12:30:04.774Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p><code>#include&lt;memory&gt;</code></p><p>要确保用 new 动态分配的内存空间在程序的各条执行路径都能被释放是一件麻烦的事情。<a href="http://c.biancheng.net/cplus/">C++</a> 11 模板库的 <memory> 头文件中定义的智能<a href="http://c.biancheng.net/c/80/">指针</a>，即 shared _ptr 模板，就是用来部分解决这个问题的。</memory></p><p>只要将 new 运算符返回的指针 p 交给一个 shared_ptr 对象“托管”，就不必担心在哪里写<code>delete p</code>语句——实际上根本不需要编写这条语句，托管 p 的 shared_ptr 对象在消亡时会自动执行<code>delete p</code>。而且，该 shared_ptr 对象能像指针 p —样使用，即假设托管 p 的 shared_ptr 对象叫作 ptr，那么 *ptr 就是 p 指向的对象。</p><p>通过 shared_ptr 的构造函数，可以让 shared_ptr 对象托管一个 new 运算符返回的指针，写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>; <span class="hljs-comment">// T 可以是 int、char、类等各种类型</span><br></code></pre></td></tr></table></figure><p>此后，ptr 就可以像 T* 类型的指针一样使用，即 *ptr 就是用 new 动态分配的那个对象。</p><p>多个 shared_ptr 对象可以共同托管一个指针 p，当所有曾经托管 p 的 shared_ptr 对象都解除了对其的托管时，就会执行<code>delete p</code>。</p><p>例如下面的程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">i</span>(n) &#123; &#125;;<br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;destructed&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A(<span class="hljs-number">2</span>))</span></span>; <span class="hljs-comment">//A(2)由sp1托管，</span><br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;       <span class="hljs-comment">//A(2)同时交由sp2托管</span><br>    shared_ptr&lt;A&gt; sp3;<br>    sp3 = sp2;   <span class="hljs-comment">//A(2)同时交由sp3托管</span><br>    cout &lt;&lt; sp1-&gt;i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; sp2-&gt;i &lt;&lt;<span class="hljs-string">&quot;,&quot;</span> &lt;&lt; sp3-&gt;i &lt;&lt; endl;<br>    A * p = sp3.<span class="hljs-built_in">get</span>();      <span class="hljs-comment">// get返回托管的指针，p 指向 A(2)</span><br>    cout &lt;&lt; p-&gt;i &lt;&lt; endl;  <span class="hljs-comment">//输出 2</span><br>    sp1.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>));    <span class="hljs-comment">// reset导致托管新的指针, 此时sp1托管A(3)</span><br>    sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">4</span>));    <span class="hljs-comment">// sp2托管A(4)</span><br>    cout &lt;&lt; sp1-&gt;i &lt;&lt; endl; <span class="hljs-comment">//输出 3</span><br>    sp3.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">5</span>));    <span class="hljs-comment">// sp3托管A(5),A(2)无人托管，被delete</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>程序的输出结果如下：<br>2,2,2<br>2<br>3<br>2 destructed<br>end<br>5 destructed<br>4 destructed<br>3 destructed</p></blockquote><p>可以用第 14 行及第 16 行的形式让多个 sharecLptr 对象托管同一个指针。这多个 shared_ptr 对象会共享一个对共同托管的指针的“托管计数”。有 n 个 shared_ptr 对象托管同一个指针 p，则 p 的托管计数就是 n。当一个指针的托管计数减为 0 时，该指针会被释放。shared_ptr 对象消亡或托管了新的指针，都会导致其原托管指针的托管计数减 1。</p><p>第 20、21 行，shared_ptr 的 reset 成员函数可以使得对象解除对原托管指针的托管（如果有的话），并托管新的指针。原指针的托管计数会减 1。</p><p>输出的第 4 行说明，用 new 创建的动态对象 A(2) 被释放了。程序中没有写 delete 语句，而 A(2) 被释放，是因为程序的第 23 行执行后，已经没有 shared_ptr 对象托管 A(2)，于是 A(2) 的托管计数变为 0。最后一个解除对 A(2) 托管的 shared_ptr 对象会释放 A(2)。</p><p>main 函数结束时，sp1、sp2、sp3 对象消亡，各自将其托管的指针的托管计数减为 0，并且释放其托管的指针，于是会有以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 destructed<br>4 destructed<br>3 destructed<br></code></pre></td></tr></table></figure><p>只有指向动态分配的对象的指针才能交给 shared_ptr 对象托管。将指向普通局部变量、全局变量的指针交给 shared_ptr 托管，编译时不会有问题，但程序运行时会出错，因为不能析构一个并没有指向动态分配的内存空间的指针。</p><p>注意，不能用下面的方式使得两个 shared_ptr 对象托管同一个指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">A* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">10</span>);<br>shared_ptr &lt;A&gt; <span class="hljs-built_in">sp1</span>(p), <span class="hljs-built_in">sp2</span>(p);<br></code></pre></td></tr></table></figure><p>sp1 和 sp2 并不会共享同一个对 p 的托管计数，而是各自将对 p 的托管计数都记为 1（sp2 无法知道 p 已经被 sp1 托管过）。这样，当 sp1 消亡时要析构 p，sp2 消亡时要再次析构 p，这会导致程序崩溃。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Pointer And Const</title>
    <link href="https://www.mingsrc.work/posts/7d0efebf"/>
    <id>https://www.mingsrc.work/posts/7d0efebf</id>
    <published>2022-07-09T12:30:04.770Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一文搞懂指针常量与常量指针"><a href="#一文搞懂指针常量与常量指针" class="headerlink" title="一文搞懂指针常量与常量指针"></a>一文搞懂指针常量与常量指针</h1><h1 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h1><p>通俗点，你可以理解为<code>const *</code>，声明一个指针常量就是 <code>const int* a</code>，如果你容易混淆它只能修改指向的位置，可以试着按这种方式去理解。</p><h1 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h1><p><code>const int* ptr</code>或者<code>int const* ptr</code>，两者都表示常量指针。表示一个指针指向常量地址，使用就是可以修改指针指向的位置，但是不能修改指针指向位置的值。定义时可以不赋初值。</p><p>那么如何在以后的使用中更加准确地记住？倒着读！</p><p>上述两个定义方式可以理解为：</p><blockquote><p><code>const int *ptr</code>：a ptr is pointer to <u>int const</u>，一个变量ptr指向常整型</p><p><code>int const* ptr</code>: a ptr is pointer to const int，含义同上</p></blockquote><h1 id="指针常量-1"><a href="#指针常量-1" class="headerlink" title="指针常量"></a>指针常量</h1><p><code>int * const ptr</code>,即指针常量，表示一个常指针指向整型变量。使用就是可以修改指针指向位置的值，但是不能修改指针的指向。</p><p>同上，定义方式可以倒着理解：</p><blockquote><p><code>int * const ptr</code>：a ptr is a const pointer to int，ptr是一个指向整型变量的常指针</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">100</span>;<br><span class="hljs-comment">//常量指针</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* ptr; <span class="hljs-comment">//指针指向的地址所存储的值不可以被修改</span><br><span class="hljs-comment">//可以理解为pointer to const int</span><br>ptr = &amp;i;<br><br><span class="hljs-type">int</span> i_2 = <span class="hljs-number">120</span>;<br><span class="hljs-comment">// *a = 1090; // 这里会报错，因为a是一个常量指针，不可以修改指向位置的值</span><br>ptr = &amp;i_2; <span class="hljs-comment">//但是可以修改常量指针a所指向的位置</span><br>cout &lt;&lt; &amp;ptr &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; *ptr &lt;&lt; endl;<br><br><br><span class="hljs-comment">//指针常量</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr2 = &amp;i_2; <span class="hljs-comment">//可以理解为a const pointer to int,必须赋初值</span><br><br><span class="hljs-comment">//ptr2 = &amp;i; //因为ptr2是一个const pointer to int。就是指针指向的位置不能改变，但是指针指向的值可以改变</span><br>*ptr2 = <span class="hljs-number">10000</span>; <span class="hljs-comment">//修改指针指向位置的值</span><br>cout &lt;&lt; &amp;a &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; *a &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>附上运行结果（vs2017）：</p><p>![image-20210202090917363](..&#x2F;..&#x2F;..&#x2F;images&#x2F;pointer and const&#x2F;image-20210202090917363.png)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
  </entry>
  
  <entry>
    <title>C++文件操作</title>
    <link href="https://www.mingsrc.work/posts/a83ff634"/>
    <id>https://www.mingsrc.work/posts/a83ff634</id>
    <published>2022-07-09T12:30:04.767Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一个最简单的打开文件写的demo"><a href="#一个最简单的打开文件写的demo" class="headerlink" title="一个最简单的打开文件写的demo"></a>一个最简单的打开文件写的demo</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @fn           ReadJson</span><br><span class="hljs-comment">* @brief        从制定路径的文件中读取Json字符串保存到sJson中</span><br><span class="hljs-comment">* @param[in]    wsFilePath: 读取Json文件的路径</span><br><span class="hljs-comment">sJson: 保存读取文件内容的字符串</span><br><span class="hljs-comment">* @param[out]   </span><br><span class="hljs-comment">* @return       </span><br><span class="hljs-comment">*               </span><br><span class="hljs-comment">* @detail      </span><br><span class="hljs-comment">* @author      mingming.shi</span><br><span class="hljs-comment">* @date        2021-09-16</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">BOOL <span class="hljs-title">ReadJson</span><span class="hljs-params">(__in tstring wsFilePath, __out std::string&amp; sJson, <span class="hljs-type">int</span> *pErr)</span></span><br><span class="hljs-function"></span>&#123;<br>FILE* fp_read = <span class="hljs-literal">NULL</span>;<br>fp_read = _wfopen(wsFilePath.<span class="hljs-built_in">c_str</span>(), _T(<span class="hljs-string">&quot;w+&quot;</span>));<br><span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span>( fp_read == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (pErr)<br>&#123;<br>_get_errno(pErr);<br>&#125;<br><br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br>size = <span class="hljs-built_in">ftell</span>(fp_read)<br><br><span class="hljs-comment">/* 查找文件的开头 */</span><br><span class="hljs-built_in">fseek</span>(fp_read, <span class="hljs-number">0</span>, SEEK_SET);<br><br><span class="hljs-built_in">fread</span>(sJson.<span class="hljs-built_in">c_str</span>(), size, <span class="hljs-number">1</span>, fp_read);<br><span class="hljs-built_in">fclose</span>(fp_read);<br><br><span class="hljs-keyword">return</span> TRUE;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++常识与通识</title>
    <link href="https://www.mingsrc.work/posts/9d0d833e"/>
    <id>https://www.mingsrc.work/posts/9d0d833e</id>
    <published>2022-07-09T12:30:04.763Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><h3 id="将引用作为返回值的通常原因是避免创建副本以提高效率，包括其他的函数传参亦是如此"><a href="#将引用作为返回值的通常原因是避免创建副本以提高效率，包括其他的函数传参亦是如此" class="headerlink" title="将引用作为返回值的通常原因是避免创建副本以提高效率，包括其他的函数传参亦是如此"></a>将引用作为返回值的通常原因是避免创建副本以提高效率，包括其他的函数传参亦是如此</h3></li><li><h3 id="std-nothrow可以消除抛出异常"><a href="#std-nothrow可以消除抛出异常" class="headerlink" title="std::nothrow可以消除抛出异常"></a><code>std::nothrow</code>可以消除抛出异常</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100000000ul</span>];   <span class="hljs-comment">// throwing overload</span><br>        &#125;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc&amp; e) &#123;<br>        std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span>* p = <span class="hljs-built_in">new</span>(std::nothrow) <span class="hljs-type">int</span>[<span class="hljs-number">100000000ul</span>]; <span class="hljs-comment">// non-throwing overload</span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Allocation returned nullptr\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>输出：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">std::bad_alloc<br>Allocation returned nullptr<br></code></pre></td></tr></table></figure></p><ol start="3"><li><h3 id="枚举用法——类静态成员"><a href="#枚举用法——类静态成员" class="headerlink" title="枚举用法——类静态成员"></a>枚举用法——类静态成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">year</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">enum</span> &#123;MONTH = <span class="hljs-number">12</span>&#125;; <span class="hljs-comment">// 可以当做一个 static const</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>具体使用场景自己探索哦~</p></li><li><h3 id="可以通过terminate-（默认行为）、abort-、exit-来终止程序"><a href="#可以通过terminate-（默认行为）、abort-、exit-来终止程序" class="headerlink" title="可以通过terminate()（默认行为）、abort()、exit()来终止程序"></a>可以通过<code>terminate()（默认行为）、abort()、exit()</code>来终止程序</h3></li><li><h3 id="虽然算法、数据结构是基础，但是设计模式也一定要看"><a href="#虽然算法、数据结构是基础，但是设计模式也一定要看" class="headerlink" title="虽然算法、数据结构是基础，但是设计模式也一定要看"></a>虽然算法、数据结构是基础，但是设计模式也一定要看</h3></li><li><h3 id><a href="#" class="headerlink" title></a></h3></li></ol>]]></content>
    
    
    <summary type="html">整理自个人学习过程中的所见所得</summary>
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>内存分配</title>
    <link href="https://www.mingsrc.work/posts/d5b66195"/>
    <id>https://www.mingsrc.work/posts/d5b66195</id>
    <published>2022-07-09T12:30:04.749Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h1><blockquote><p>存储区域主要为<code>栈</code>和<code>自由存储区</code>，栈多服务于临时变量和一些非动态申请的数据类型</p><p><code>自由存储区或堆</code>通常为一个概念，存储动态申请的变量和数据类型（new）、vector</p></blockquote><span id="more"></span><h2 id="1、自动存储（栈）"><a href="#1、自动存储（栈）" class="headerlink" title="1、自动存储（栈）"></a>1、自动存储（栈）</h2><blockquote><p>自动存储的为<code>自动变量</code>，自动变量一般都是程序云心过程中函数的局部变量，常存储在<code>栈</code>中，所以在执行代码时，是按照<code>后进先出</code>进行变量存储，这也就意味着，在程序执行过程中，栈的大小是不断变化的。 </p></blockquote><h2 id="2、静态存储（堆）"><a href="#2、静态存储（堆）" class="headerlink" title="2、静态存储（堆）"></a>2、静态存储（堆）</h2><p>​ 静态存储的两种方式：</p><pre><code>1. 在函数外面定义2. 在声明变量时，加上关键字static</code></pre><h2 id="3、动态存储（堆）"><a href="#3、动态存储（堆）" class="headerlink" title="3、动态存储（堆）"></a>3、动态存储（堆）</h2><p>&#x3D;&#x3D;new和delete&#x3D;&#x3D;的应用，其管理着一个<code>内存池</code>（在C++中也被称为自由存储空间或<code>堆</code>），所创建的变量同存储静态存储的内存是分开的。</p><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjvu5y7zguj310908jamo.jpg" alt="动态存储" width="1305" data-width="1305" data-height="307">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;自动存储、静态存储和动态存储&quot;&gt;&lt;a href=&quot;#自动存储、静态存储和动态存储&quot; class=&quot;headerlink&quot; title=&quot;自动存储、静态存储和动态存储&quot;&gt;&lt;/a&gt;自动存储、静态存储和动态存储&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;存储区域主要为&lt;code&gt;栈&lt;/code&gt;和&lt;code&gt;自由存储区&lt;/code&gt;，栈多服务于临时变量和一些非动态申请的数据类型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;自由存储区或堆&lt;/code&gt;通常为一个概念，存储动态申请的变量和数据类型（new）、vector&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++操作符</title>
    <link href="https://www.mingsrc.work/posts/2c746baa"/>
    <id>https://www.mingsrc.work/posts/2c746baa</id>
    <published>2022-07-09T12:30:04.746Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-操作符"><a href="#1-操作符" class="headerlink" title="1 操作符"></a>1 操作符</h1><h2 id="补码运算符"><a href="#补码运算符" class="headerlink" title="~(补码运算符)"></a>~(补码运算符)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> y = ~x; <span class="hljs-comment">//1.</span><br>cout &lt;&lt; y;<br><span class="hljs-comment">//输出&#x27;254&#x27;</span><br></code></pre></td></tr></table></figure><p>解释：</p><p>x &#x3D; 0000 0001<br>~x &#x3D; 1111  1110,<code>-x</code>为负数，负数在计算机中用补码表示，所以符号位不变，取反加1<br>y &#x3D; 1 0000 0010,<code>1000 0010(BIN) = -2(DEX)</code></p><img src="//tvax3.sinaimg.cn/large/0072YHp3ly1gjp909adtvj30ep02b0sj.jpg" alt="操作符1" width="529" data-width="529" data-height="83"><h2 id="操作符"><a href="#操作符" class="headerlink" title="++操作符"></a>++操作符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> i1 = <span class="hljs-number">4</span>；<br><span class="hljs-type">int</span> y1 = i1++; <span class="hljs-comment">//如大家所知，点调用、再自增 y1 = 4 , i1 = 5; </span><br><span class="hljs-type">int</span> i2 = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> y2 = ++i2; <span class="hljs-comment">//先自增再调用 y2 = 5 , i2 = 5; </span><br></code></pre></td></tr></table></figure><p>大体上是类似的，但是<code>i++</code>在计算时会用到<strong>中间变量</strong>，会占用更多的内存和时间，所以<code>++i</code>更好</p><h1 id="2-C-不能重载的操作符"><a href="#2-C-不能重载的操作符" class="headerlink" title="2 C++不能重载的操作符"></a>2 C++不能重载的操作符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">（1） &quot;.&quot;（类成员访问运算符） <br>（2）&quot; .*&quot;（类成员指针访问运算符） <br>（3） &quot;::&quot;（域运算符） <br>（4）&quot;sizeof&quot;（长度运算符） <br>（5） &quot; ?:&quot;（条件运算符/三目运算符）<br>（6） dynamic_cast<br>（7） static_cast<br>（8） reinterpret_cast<br> (9) const_cast<br> (10) typeid(获取类型信息)<br></code></pre></td></tr></table></figure><h1 id="3-运算符重载后，优先级和结合性怎么办？"><a href="#3-运算符重载后，优先级和结合性怎么办？" class="headerlink" title="3 运算符重载后，优先级和结合性怎么办？"></a>3 运算符重载后，优先级和结合性怎么办？</h1><div class="note primary simple"><p>用户重载新定义运算符，不改变元运算符的优先级和结合性。这就是说，对运算符重载不改变运算的优先级和结合性，并且运算符重载后，也不改变运算符的语法结构，即单目运算符的语法结构只能冲仔尾单目运算符，双目运算符只能重载为双目运算符。</p></div><h1 id="4-编译程序如何选用那一个运算符函数？"><a href="#4-编译程序如何选用那一个运算符函数？" class="headerlink" title="4 编译程序如何选用那一个运算符函数？"></a>4 编译程序如何选用那一个运算符函数？</h1><div class="note warning simple"><p>运算符重载实际是一个函数，所以运算符的重载实际上是函数的重载。编译程序对运算符重载的选择，遵循着函数重载的算则原则。当遇到不很明显的运算时，编译程序将去寻找参数相匹配的运算符函数。</p></div><h1 id="5-重载你算符有哪些限制？"><a href="#5-重载你算符有哪些限制？" class="headerlink" title="5 重载你算符有哪些限制？"></a>5 重载你算符有哪些限制？</h1><div class="note success simple"><ul><li><p>不可臆造新的运算符。必须把重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中。</p></li><li><p>重载运算符坚持4个“不能改变”</p><ul><li>不能改变运算符操作数的个数；</li><li>不能改变运算符原有的优先级；</li><li>不能改变运算符原有的结核性；</li><li>不能改变运算符原有的语法结构。</li></ul></li></ul></div><h1 id="6-运算符重载时必须遵循哪些原则？"><a href="#6-运算符重载时必须遵循哪些原则？" class="headerlink" title="6 运算符重载时必须遵循哪些原则？"></a>6 运算符重载时必须遵循哪些原则？</h1>  <div class="note info simple"><p>运算符重载可以是程序更加简洁，是表达式更加直观，增加可读性。但是运算符重载使用不宜过多，否则会带来一定麻烦。</p><p>  使用重载运算符是应遵循如下原则：</p><ol><li>重载运算符含义必须清楚</li><li>重载运算符不能有二义性</li></ol></div><p>  以下是C++编程语言中的所有运算符的优先级和结合性列表。</p><table><thead><tr><th align="left">优先级</th><th align="left">运算符</th><th align="left">叙述</th><th align="left">示例</th><th align="left">重载性</th><th align="left">结合性</th></tr></thead><tbody><tr><td align="left"><code>1</code></td><td align="left"><code>::</code></td><td align="left">作用域解析(C++专有)</td><td align="left"><code>Class::age = 2;</code></td><td align="left">否</td><td align="left">由左至右</td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>++</code></td><td align="left">后缀递增</td><td align="left">i++</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>--</code></td><td align="left">后缀递减</td><td align="left">i–</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>&#123;&#125;</code></td><td align="left">组合</td><td align="left">{i++;a*&#x3D;i;}</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>()</code></td><td align="left">函数调用或变量初始化</td><td align="left">c_tor(int x, int y) : _x(x), _y(y * 10) {}</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>[]</code></td><td align="left">数组访问</td><td align="left">array[4] &#x3D; 2;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>.</code></td><td align="left">以对象方式访问成员</td><td align="left">obj.age &#x3D; 34;</td><td align="left">否</td><td align="left"></td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>-&gt;</code></td><td align="left">以指针方式访问成员</td><td align="left">ptr-&gt;age &#x3D; 34;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>dynamic_cast</code></td><td align="left">运行时检查类型转换(C++专有)</td><td align="left">Y&amp; y &#x3D; dynamic_cast&lt;Y&amp;&gt;(x);</td><td align="left">否</td><td align="left"></td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>static_cast</code></td><td align="left">未经检查的类型转换(C++专有)</td><td align="left">Y&amp; y &#x3D; static_cast&lt;Y&amp;&gt;(x);</td><td align="left">否</td><td align="left"></td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>reinterpret_cast</code></td><td align="left">重定义类型转换(C++专有)</td><td align="left">int const* p &#x3D; reinterpret_cast&lt;int const*&gt;(0x1234);</td><td align="left">否</td><td align="left"></td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>const_cast</code></td><td align="left">更改非常量属性(C++专有)</td><td align="left">int* q &#x3D; const_cast&lt;int*&gt;(p);</td><td align="left">否</td><td align="left"></td></tr><tr><td align="left"><code>2</code></td><td align="left"><code>typeid</code></td><td align="left">获取类型信息(C++专有)</td><td align="left">std::type_info const&amp; t &#x3D; typeid(x);</td><td align="left">否</td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>++</code></td><td align="left">前缀递增</td><td align="left">++i</td><td align="left"></td><td align="left">由右至左</td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>--</code></td><td align="left">前缀递减</td><td align="left">–i</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>+</code></td><td align="left">一元正号</td><td align="left">int i &#x3D; +1;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>-</code></td><td align="left">一元负号</td><td align="left">int i &#x3D; -1;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>!</code> <code>not</code></td><td align="left">逻辑非 <code>!</code>的备用拼写</td><td align="left">if (!done) …</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>~</code> <code>compl</code></td><td align="left">按位取反 <code>~</code>的备用拼写</td><td align="left">flag1 &#x3D; ~flag2;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>(*type*)</code></td><td align="left">强制类型转换</td><td align="left">int i &#x3D; (int)floatNum;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>*</code></td><td align="left">取指针指向的值</td><td align="left">int data &#x3D; *intPtr;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>&amp;</code></td><td align="left">取变量的地址</td><td align="left">int *intPtr &#x3D; &amp;data;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>sizeof</code></td><td align="left">某某的大小</td><td align="left">size_t s &#x3D; sizeof(int);</td><td align="left">否</td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>new</code></td><td align="left">动态内存分配(C++专有)</td><td align="left">long* pVar &#x3D; new long;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>new[]</code></td><td align="left">动态数组内存分配(C++专有)</td><td align="left">long* array &#x3D; new long[20];</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>delete</code></td><td align="left">动态内存释放(C++专有)</td><td align="left">delete pVar;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>3</code></td><td align="left"><code>delete[]</code></td><td align="left">动态数组内存释放(C++专有)</td><td align="left">delete [] array;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>4</code></td><td align="left"><code>.*</code></td><td align="left">成员对象选择(C++专有)</td><td align="left">obj.*var &#x3D; 24;</td><td align="left">否</td><td align="left">由左至右</td></tr><tr><td align="left"></td><td align="left"><code>-&gt;*</code></td><td align="left">成员指针选择(C++专有)</td><td align="left">ptr-&gt;*var &#x3D; 24;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>5</code></td><td align="left"><code>*</code></td><td align="left">乘法</td><td align="left">int i &#x3D; 2 * 4;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>/</code></td><td align="left">除法</td><td align="left">float f &#x3D; 10.0 &#x2F; 3.0;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>%</code></td><td align="left">模数(取余)</td><td align="left">int rem &#x3D; 4 % 3;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>6</code></td><td align="left"><code>+</code></td><td align="left">加法</td><td align="left">int i &#x3D; 2 + 3;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>-</code></td><td align="left">减法</td><td align="left">int i &#x3D; 5 - 1;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>7</code></td><td align="left"><code>&lt;&lt;</code></td><td align="left">比特左移</td><td align="left">int flags &#x3D; 33 &lt;&lt; 1;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>&gt;&gt;</code></td><td align="left">比特右移</td><td align="left">int flags &#x3D; 33 &gt;&gt; 1;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>8</code></td><td align="left"><code>&lt;</code></td><td align="left">小于关系</td><td align="left">if (i &lt; 42) …</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>&lt;=</code></td><td align="left">小于等于关系</td><td align="left">if (i &lt;&#x3D; 42) …</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>&gt;</code></td><td align="left">大于关系</td><td align="left">if (i &gt; 42) …</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>&gt;=</code></td><td align="left">大于等于关系</td><td align="left">if (i &gt;&#x3D; 42) …</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>9</code></td><td align="left"><code>==</code> <code>eq</code></td><td align="left">等于关系 <code>==</code>的备用拼写</td><td align="left">if (i &#x3D;&#x3D; 42) …</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>!=</code> <code>not_eq</code></td><td align="left">不等于关系 <code>!=</code>的备用拼写</td><td align="left">if (i !&#x3D; 42) …</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>10</code></td><td align="left"><code>&amp;</code> <code>bitand</code></td><td align="left">比特 AND <code>&amp;</code>的备用拼写</td><td align="left">flag1 &#x3D; flag2 &amp; 42;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>11</code></td><td align="left"><code>^</code> <code>xor</code></td><td align="left">比特 XOR(独占or) <code>^</code>的备用拼写</td><td align="left">flag1 &#x3D; flag2 ^ 42;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>12</code></td><td align="left">&#96;</td><td align="left"><code> </code>bitor&#96;</td><td align="left">比特 OR(包含or) &#96;</td><td align="left">&#96;的备用拼写</td><td align="left">flag1 &#x3D; flag2 | 42;</td></tr><tr><td align="left"><code>13</code></td><td align="left"><code>&amp;&amp;</code> <code>and</code></td><td align="left">逻辑 AND <code>&amp;&amp;</code>的备用拼写</td><td align="left">if (conditionA &amp;&amp; conditionB) …</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>14</code></td><td align="left">&#96;</td><td align="left"></td><td align="left"><code> </code>or&#96;</td><td align="left">逻辑 OR &#96;</td><td align="left"></td></tr><tr><td align="left"><code>15</code></td><td align="left"><code>*c*?*t*:*f*</code></td><td align="left">三元条件运算</td><td align="left">int i &#x3D; a &gt; b ? a : b;</td><td align="left">否</td><td align="left">由右至左</td></tr><tr><td align="left"><code>16</code></td><td align="left"><code>=</code></td><td align="left">直接赋值</td><td align="left">int a &#x3D; b;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>16</code></td><td align="left"><code>+=</code></td><td align="left">以和赋值</td><td align="left">a +&#x3D; 3;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>16</code></td><td align="left"><code>-=</code></td><td align="left">以差赋值</td><td align="left">b -&#x3D; 4;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>16</code></td><td align="left"><code>*=</code></td><td align="left">以乘赋值</td><td align="left">a *&#x3D; 5;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>16</code></td><td align="left"><code>/=</code></td><td align="left">以除赋值</td><td align="left">a &#x2F;&#x3D; 2;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>16</code></td><td align="left"><code>%=</code></td><td align="left">以取余数赋值</td><td align="left">a %&#x3D; 3;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>16</code></td><td align="left"><code>&lt;&lt;=</code></td><td align="left">以比特左移赋值</td><td align="left">flags &lt;&lt;&#x3D; 2;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>16</code></td><td align="left"><code>&gt;&gt;=</code></td><td align="left">以比特右移赋值</td><td align="left">flags &gt;&gt;&#x3D; 2;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>16</code></td><td align="left"><code>&amp;=</code> <code>and_eq</code></td><td align="left">以比特AND赋值 <code>&amp;=</code>的备用拼写</td><td align="left">flags &amp;&#x3D; new_flags;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>16</code></td><td align="left"><code>^=</code> <code>xor_eq</code></td><td align="left">以比特XOR赋值 <code>^=</code>的备用拼写</td><td align="left">flags ^&#x3D; new_flags;</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>16</code></td><td align="left">&#96;</td><td align="left">&#x3D;<code> </code>or_eq&#96;</td><td align="left">以比特OR赋值 &#96;</td><td align="left">&#x3D;&#96;的备用拼写</td><td align="left">flags |&#x3D; new_flags;</td></tr><tr><td align="left"><code>17</code></td><td align="left"><code>throw</code></td><td align="left">抛出异常</td><td align="left">throw EClass(“Message”);</td><td align="left">否</td><td align="left"></td></tr><tr><td align="left"><code>18</code></td><td align="left"><code>,</code></td><td align="left">逗号运算符</td><td align="left">for (i &#x3D; 0, j &#x3D; 0; i &lt; 10; i++, j++) …</td><td align="left"></td><td align="left">由左至右</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="操作符" scheme="https://www.mingsrc.work/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>共用体（union）</title>
    <link href="https://www.mingsrc.work/posts/c63335c7"/>
    <id>https://www.mingsrc.work/posts/c63335c7</id>
    <published>2022-07-09T12:30:04.743Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也</p><p>就是说，结构可以同时存储int、long 和double，共用体只能存储 int、long或double。共用体的句法与结</p><p>构相似，但含义不同。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">one4all</span> &#123;<br><span class="hljs-type">int</span> int_val;<br><span class="hljs-type">long</span> long_val;<br><span class="hljs-type">double</span> double_val;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;main.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//创建一个共用体</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">one4all</span> &#123;<br><span class="hljs-type">int</span> int_val;<br><span class="hljs-type">long</span> long_val;<br><span class="hljs-type">double</span> double_val;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//在同一时间只能之勇union中变量的一种</span><br>one4all temp;<br>temp.int_val = <span class="hljs-number">10</span>;<br>cout &lt;&lt; temp.int_val &lt;&lt; endl;<br>temp.double_val = <span class="hljs-number">3.1415926</span>;<br>cout &lt;&lt; temp.double_val &lt;&lt; endl;<br>cout &lt;&lt; &amp;temp.double_val &lt;&lt; endl;<br>cout &lt;&lt; &amp;temp.long_val &lt;&lt; endl;<br>cout &lt;&lt; &amp;temp.int_val &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../../../../images/5%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%EF%BC%88union%EF%BC%89/%E5%85%B1%E7%94%A8%E4%BD%931.png"></p><p>为什么每次只能使用一个，直接打印地址可以发现，<code>union</code>中变量共同使用一个地址，所以每次也只能存储一种类型的值。那么，共用体在什么时候才会用到呢？</p><hr><p>《C++ primer 第六版》中给的定义是：</p><div class="note red no-icon flat"><p>共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。</p></div><h1 id="匿名共用体-anonymous-union"><a href="#匿名共用体-anonymous-union" class="headerlink" title="匿名共用体 (anonymous union)"></a>匿名共用体 (anonymous union)</h1><p>没有名称的共同体，启程苑将成为位于相同地址处的变量。每次只有一个成员是当前的成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">worker</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">bool</span> gender;<br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-type">long</span> id_num;<br>        <span class="hljs-type">char</span> id_char[<span class="hljs-number">20</span>];<br>    &#125;;<br>&#125;;<br><br>worker programmer;<br><span class="hljs-keyword">if</span>(programmer.gender == <span class="hljs-number">1</span>)<br>    cout &lt;&lt; programmer.id_num;<br><span class="hljs-keyword">else</span><br>    cout &lt;&lt; programmer.id_char;<br></code></pre></td></tr></table></figure><p><code>id_num</code>和<code>id_char[20]</code>使用的还是同一个地址。使用中只需确定当前是哪个成员活动就行。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>共用体常用语节省内存。尤其是嵌入式系统编程，对内存要求较为严格。另外，共用体常用于操作系统数据结构或硬件数据结构。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="union" scheme="https://www.mingsrc.work/tags/union/"/>
    
  </entry>
  
  <entry>
    <title>虚函数与纯虚函数</title>
    <link href="https://www.mingsrc.work/posts/5dd98e7e"/>
    <id>https://www.mingsrc.work/posts/5dd98e7e</id>
    <published>2022-07-09T12:30:04.730Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇讲述虚函数与纯虚函数的区别与用法</p><span id="more"></span><p><font color="red" size="4px"><strong>对于抽象类来说，它无法实例化对象，而对于抽象类的子类来说，只有把抽象类中的纯虚函数全部实现之后，那么这个子类才可以实例化对象</strong></font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">bool</span> gender;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span></span>; <br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>简单理解就是父类定义了一个群体将会有的动作以及行为：如Worker类，我们仅知道工人们会工作，但是我们不知道具体是什么工人以及从事于什么样的工作，因此，可以把worker类定义为抽象类，用以规定可能会有的行为以及操作。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">worker</span>：<span class="hljs-keyword">public</span> person<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">bool</span> gender;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义为抽象基类是避免实例化造成的编译报错，并且基类的定义时1为了规定大致的行为操作，具体的内容实现是基于继承类</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>&#125;;<br></code></pre></td></tr></table></figure><p>同时，<strong>对于抽象类的子类也可以是抽象类</strong>，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">dustMan</span>：<span class="hljs-keyword">public</span> worker<br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">bool</span> gender;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义为抽象基类是避免实例化造成的编译报错，并且基类的定义时1为了规定大致的行为操作，具体的内容实现是基于继承类</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;扫地&quot;</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;我是清洁工&quot;</span>;&#125; <br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，如果基类中有纯虚函数（该类为抽象类，不能实例化对象），那么子类实现过程中必须重新定义纯虚函数，编译器才不会报错。</p></blockquote><ol><li><p><strong>虚函数是动态绑定的</strong>，也就是说。使用虚函数的指针和引用能够正确找到实际类的相应函数，而不是运行定义类的函数。</p><p>这是虚函数的基本功能，就不再解释了。</p></li><li><p><strong>构造函数不能是虚函数</strong>。并且，在构造函数中调用虚函数，实际运行的是父类的相应函数。由于自己还没有构造好, 多态是被<code>disable</code>的。</p></li><li><p><strong>析构函数能够是虚函数。并且，在一个复杂类结构中。这往往是必须的</strong>。</p></li><li><p><strong>将一个函数定义为纯虚函数。实际上是将这个类定义为抽象类，不能实例化对象</strong>。</p></li><li><p><strong>纯虚函数通常未定义体，但也全然能够拥有</strong>, 甚至能够显示调用。</p></li><li><p>**析构函数能够是纯虚的，但纯虚析构函数必须有定义体，*由于析构函数的调用是在子类中隐含的***。</p></li><li><p>非纯的虚函数必须有定义体，不然是一个错误。</p></li><li><p>派生类的<code>override</code>虚函数定义必须和父类全然一致(<code>c++11</code>中使用<code>override</code>进行编译器检查)。除了一个特例，假设父类中返回值是一个指针或引用。子类<code>override</code>时能够返回这个指针（或引用）的派生。</p><p>比如，在上面的样例中，在<code>Base</code>中定义了 <code>virtual Base* clone()</code>; 在<code>Derived</code>中能够定义为 <code>virtual Derived* clone()</code>。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇讲述虚函数与纯虚函数的区别与用法&lt;/p&gt;</summary>
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="浮点型" scheme="https://www.mingsrc.work/tags/%E6%B5%AE%E7%82%B9%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>class与struct的区别与用法</title>
    <link href="https://www.mingsrc.work/posts/79effa92"/>
    <id>https://www.mingsrc.work/posts/79effa92</id>
    <published>2022-07-09T12:30:04.726Z</published>
    <updated>2022-07-09T13:56:46.214Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇讲述class与struct的区别与用法</p><span id="more"></span><h3 id="命名常识"><a href="#命名常识" class="headerlink" title="命名常识"></a>命名常识</h3><img src="../../../../images/3-struct%E4%B8%8Eclass%E7%9A%84%E5%8C%BA%E5%88%AB/image-20200808135010677.png" style="zoom:60%"><h1 id="struct与class的区别"><a href="#struct与class的区别" class="headerlink" title="struct与class的区别"></a>struct与class的区别</h1><blockquote><p>C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。</p><p>struct能包含成员函数吗？ 能！</p><p>struct能继承吗？ 能！！</p><p>struct能实现多态吗？ 能！！！</p></blockquote><h2 id="1）默认的继承访问权限。struct是public的，class是private的。"><a href="#1）默认的继承访问权限。struct是public的，class是private的。" class="headerlink" title="1）默认的继承访问权限。struct是public的，class是private的。"></a>1）默认的继承访问权限。struct是public的，class是private的。</h2><h2 id="2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。"><a href="#2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。" class="headerlink" title="2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。"></a>2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</h2><blockquote><p>coutpu（）函数，该函数显示一个字符</p></blockquote><p>decltype类似于typedef，但是typedef加类型，decltype加变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">decltype</span>(n) n2;<span class="hljs-comment">//n2是int类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> INT;<br>INT n3;<span class="hljs-comment">//n3也是int类型</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*pfun)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//类外声明</span><br><span class="hljs-keyword">auto</span> add（<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b）<br>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-built_in">itn</span> (*p)(<span class="hljs-type">int</span> ,<span class="hljs-type">int</span>) = add;<br><span class="hljs-keyword">using</span> PFUN = <span class="hljs-built_in">void</span> (*)();<br><br></code></pre></td></tr></table></figure><p><img src="/../../../../images/3-struct%E4%B8%8Eclass%E7%9A%84%E5%8C%BA%E5%88%AB/image-20200907213340088.png"></p><p>typedef 重定义类型时不能用于vector</p><p>此时就需要using</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-type">int</span>&gt; int_vec;<span class="hljs-comment">//此时就会报错</span><br><br><span class="hljs-keyword">using</span> int_vec = vector&lt;<span class="hljs-type">int</span>&gt;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇讲述class与struct的区别与用法&lt;/p&gt;</summary>
    
    
    
    <category term="立志博览群书" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/"/>
    
    <category term="C++_Primer_Plus" scheme="https://www.mingsrc.work/categories/%E7%AB%8B%E5%BF%97%E5%8D%9A%E8%A7%88%E7%BE%A4%E4%B9%A6/C-Primer-Plus/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="class" scheme="https://www.mingsrc.work/tags/class/"/>
    
    <category term="struct" scheme="https://www.mingsrc.work/tags/struct/"/>
    
  </entry>
  
</feed>
