<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欧恩意</title>
  
  
  <link href="https://www.mingsrc.work/atom.xml" rel="self"/>
  
  <link href="https://www.mingsrc.work/"/>
  <updated>2022-12-27T03:12:54.115Z</updated>
  <id>https://www.mingsrc.work/</id>
  
  <author>
    <name>mingming.shi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我|❤️</title>
    <link href="https://www.mingsrc.work/posts/f2745b45"/>
    <id>https://www.mingsrc.work/posts/f2745b45</id>
    <published>2022-12-27T03:12:54.115Z</published>
    <updated>2022-12-27T03:12:54.115Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><style>body {background:white}    h1.post-title{color:red;}div#post {    background: fixed;    color: antiquewhite;}.meta {    background: black;    width: fit-content;    padding-right: 10px;    border-radius: 50px;    filter: drop-shadow(2px 4px 6px black);}.meta p {    color: white;}div.timenode .body {    margin: 14px 0 16px 24px;}</style><script>var t2 = window.setInterval(function () {        divMe.className = imglist[index];        index++;        index %= imglist.length;        console.log('每隔5秒钟执行一次')    }, 5000)</script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=33756016&auto=0&height=66"></iframe><div class="timeline"><p class="p h2">2021</p> <div class="timenode"><div class="meta"><p></p><p>2021-04-02 从今天开始啦</p><p></p></div><div class="body"><p><span style="text-align:center;font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;">“ 既许一人以偏爱，愿尽余生之慷慨 ”</span></p></div></div><div class="timenode"><div class="meta"><p></p><p>2021-04-02 闲着就容易犯愁</p><p></p></div><div class="body"><p><span class="animated-hover" style="font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;">“ 如果运气不行那就试试勇气 ”</span></p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210403154845.jpg" style="zoom: 25%; border-radius: 50px;"></div></div><div class="timenode"><div class="meta"><p></p><p>2021-05-17 营养</p><p></p></div><div class="body"><p><span class="faa-passing-reverse animated-hover" style="font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;">“ 你说，营养是什么！ ”</span></p></div></div><div class="timenode"><div class="meta"><p></p><p>2021-10-25 DAY100</p><p></p></div><div class="body"><p><span class="faa-passing-reverse animated-hover" style="font-size:20px;font:30px 汉仪尚巍手书简;color:blueviolent;word-spacing:30px;">“ One For You ”</span></p></div></div></div>]]></content>
    
    
    <summary type="html">有感而发，也关你我</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>痕迹</title>
    <link href="https://www.mingsrc.work/posts/252a5848"/>
    <id>https://www.mingsrc.work/posts/252a5848</id>
    <published>2022-12-27T03:12:54.115Z</published>
    <updated>2022-12-27T03:43:18.540Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="“M-Y-L-I-F-E”"><a href="#“M-Y-L-I-F-E”" class="headerlink" title="“M Y L I F E”"></a><span style="text-align:center;font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;">“M Y L I F E”</span></h1><div class="timeline"><p class="p h2">2021</p> <div class="timenode"><div class="meta"><p></p><p>2021-03-18</p><p></p></div><div class="body"><p><u><a href="https://www.cnblogs.com/fole-del/diary/2021/03/18/14556295.html">今天，该想的我都想了</a></u></p></div></div><div class="timenode"><div class="meta"><p></p><p>2021-05-14</p><p></p></div><div class="body"><p><u><a href="https://www.cnblogs.com/fole-del/diary/2021/05/14/14767918.html">“精神食粮”</a></u></p></div></div><div class="timenode"><div class="meta"><p></p><p>2021-05-17</p><p></p></div><div class="body"><p><u><a href="https://www.cnblogs.com/fole-del/diary/2021/05/17/14776258.html">“灵魂与肉体”</a></u></p></div></div><div class="timenode"><div class="meta"><p></p><p>2021-06-07</p><p></p></div><div class="body"><p>今天的苦算吃完了，明天的苦还远得很，这一夜的身心安适是向不属今明两天的中立时间里的躲避。</p><p><span style="align:left"> ——钱钟书《围城》</span></p><p>{% note green ‘fas fa-key’  modern %}<br>原来钱老的围城，可以把人世间的苦，说的这么遥远。<br>{% endnote %}</p></div></div><div class="timenode"><div class="meta"><p></p><p>2020-10-12</p><p></p></div><div class="body"><p>我希望有个如你一般的人，如山间清爽的风，如古城温暖的光，从清晨到夜晚，由山野到书房，只要最后是你就好。</p></div></div><div class="timenode"><div class="meta"><p></p><p>2020-10-20</p><p></p></div><div class="body"><p>说好了不再继续入坑，但是看了别人家的主页后······😂 😂 😂 </p></div></div><div class="timenode"><div class="meta"><p></p><p>2020-10-24</p><p></p></div><div class="body"><p>今天你不快乐的原因是因为什么？</p></div></div><div class="timenode"><div class="meta"><p></p><p>2020-12-14</p><p></p></div><div class="body"><p>也许，一个人要是想在茫茫人海中要保持一点独立性，那么他必须让自己显得古怪些才成。可我不喜欢这句话，最近实在是太烂了。</p></div></div><div class="timenode"><div class="meta"><p></p><p>2021-2-24</p><p></p></div><div class="body"><p>及时当勉励，岁月不待人。</p></div></div><div class="timenode"><div class="meta"><p></p><p>2021-10-27</p><p></p></div><div class="body"><p>见字如面，既爱又恨，那段时光</p></div></div></div>]]></content>
    
    
    <summary type="html">不起眼分母</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>windows右键菜单添加</title>
    <link href="https://www.mingsrc.work/posts/8fe8a499"/>
    <id>https://www.mingsrc.work/posts/8fe8a499</id>
    <published>2022-12-27T03:12:54.100Z</published>
    <updated>2022-12-27T03:12:54.100Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="注册表添加桌面右键二级菜单"><a href="#注册表添加桌面右键二级菜单" class="headerlink" title="注册表添加桌面右键二级菜单"></a>注册表添加桌面右键二级菜单</h1><p>效果图：<br><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gmbyfpatquj30dr0dbn2y.jpg" alt="效果图"><br>想要通过注册表实现这种效果，只需要创建一个爸爸、一个儿子。</p><center><img src="../../images/鼠标右键添加二级菜单/15.png" alt="image-20201201093934430" style="zoom:50%;text-align:center"></center><h2 id="注册表修改详细步骤讲解"><a href="#注册表修改详细步骤讲解" class="headerlink" title="注册表修改详细步骤讲解"></a>注册表修改详细步骤讲解</h2><p>1、<code>win+r</code>输入<code>regedit</code>快捷打开注册表。（当然也可以去C路径下的Windows目录下寻找）</p><p><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gmbyvyuttij306900nt8h.jpg" alt="image-20210104210752102"></p><p>注册表这东西长这个样子。</p><p>2、第二步就要先创建一个儿子，也就是二级菜单里面的每一个子文件。</p><p>划重点：<code>按照这个路径去寻找shell：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell<br></code></pre></td></tr></table></figure><p>找到shell之后右键单击找到新建，然后在新建的子菜单中选择项，创建一个项（没懂看图）</p><p><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gmbyfpzjmzj30cc06mmx4.jpg" alt="小步骤"><br>然后，你会看见有一个新建的<code>新项 #1</code>，这个就是你创建儿子（二级菜单子文件），现在右键单击重命名，对你创建的儿子起个好记的名字（这个名字不会出现在桌面二级菜单，内部使用），<code>自定义、尽量字母或英文</code>，避免出现不必要的麻烦。（no懂得看图）<br><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gmbyfpzjmzj30cc06mmx4.jpg" alt="小步骤">这里我改为了<code>CSDN</code>，新建项的右方会有一个默认的字符串值，双击打开编辑，这里创建自定义名称，就是桌面你想显示的软件名称（no懂看图）<br><img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gmbyfnw1fbj30rd074wer.jpg" alt="小步骤"><br>在这个新建的文件内右键点击新建一个字符串值（重命名为<code>Icon</code>），来存放二级菜单内要显示的软件的图标。（no懂得看图）<img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gmbyfqk30dj30qf07kjrm.jpg" alt="小步骤"><br>双击打开创建的<code>Icon</code>字符串进行编辑，放入软件路径默认显示软件图标，可以自己制作icon图标进行自定义。（no懂得看图）<br><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gmbyfnj5hlj30sc07x75h.jpg" alt="小步骤"></p><p>接着按相同的步骤在自己刚创建儿子（二级菜单子文件）里面创建一个<code>项</code>，no<code>字符串值</code>，是<code>项</code>！是<code>项</code>！是<code>项</code>！项的名字重命名为<code>command</code>，这个里面存放二级菜单子文件软件路径。（no懂看图）<img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gmbyfqa7ajj30po07jaaa.jpg" alt="小步骤"><br>重命名为<code>command</code>（no懂得看图）<br><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gmbyluj7whj30t702igma.jpg" alt="小步骤"><br>双击command右边框中的字符串值，在弹出的编辑框中，数值数据输入你所要在二级菜单目录下显示的软件的路径，这里我放的Xshell的路径。（no懂看图）</p><p><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gmbyfqfz8qj30sh074jse.jpg" alt="小步骤"><br>到这里儿子就创建好了，我们来创建爸爸。</p><p>3、找爸爸：</p><p>在注册表中找到这个地方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">HKEY_CLASSES_ROOT\Directory\Background\shell<br></code></pre></td></tr></table></figure><p>然后新建一个爸爸（项），名字自定义<br><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gmbyfo1el7j30gc07c0sq.jpg" alt="小步骤"><br>在这个项里面创建两个字符串值文件，一个重命名<code>Icon</code>，放图标路径，自定义，这个就参照上面详细介绍。<br>另一个是把儿子链接过来的，重命名<code>SubCommands</code>，注意大小写，把刚才创建的儿子名字输入到这个里面，如果要放多个的话，英文分号隔开。（no懂看图）</p><h2 id="单个："><a href="#单个：" class="headerlink" title="单个："></a>单个：</h2><p><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gmbyfo72gvj30r508h0t3.jpg" alt="小步骤"></p><h2 id="多个："><a href="#多个：" class="headerlink" title="多个："></a>多个：</h2><p><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gmbyfpqi8nj30ay04kjr8.jpg" alt="小步骤"><br>慢慢一步一步来，看不懂去个厕所，回来再看一遍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Windows不常用快捷键合集</title>
    <link href="https://www.mingsrc.work/posts/d8fac1ab"/>
    <id>https://www.mingsrc.work/posts/d8fac1ab</id>
    <published>2022-12-27T03:12:54.099Z</published>
    <updated>2022-12-27T06:57:36.946Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Windows不常用快捷键"><a href="#Windows不常用快捷键" class="headerlink" title="Windows不常用快捷键"></a>Windows不常用快捷键</h1><blockquote><p>单纯敲键盘比鼠标快的原因，所以整理一些不常用的快捷键给想要速度更快的你</p></blockquote><span id="more"></span><p><img src="https://pic1.zhimg.com/v2-0cc09a51bf30dbaaaa3ed7f9c6c53e1a_r.jpg?source=1940ef5c" alt="preview"></p><p>@## note [success] [no-icon] [flat] ##@<br>Windows快捷键<br>@## endnote ##@</p><h1 id="窗口放大缩小快捷键"><a href="#窗口放大缩小快捷键" class="headerlink" title="窗口放大缩小快捷键"></a>窗口放大缩小快捷键</h1><h2 id="最大化"><a href="#最大化" class="headerlink" title="最大化"></a>最大化</h2><p><code>Alt</code>+<code>Space</code>+<code>X</code></p><h2 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h2><p><code>Alt</code>+<code>Space</code>+<code>N</code></p><h2 id="改变窗口大小"><a href="#改变窗口大小" class="headerlink" title="改变窗口大小"></a>改变窗口大小</h2><p><code>Alt</code>+<code>Space</code>+<code>S</code></p><h2 id="多个窗口切换"><a href="#多个窗口切换" class="headerlink" title="多个窗口切换"></a>多个窗口切换</h2><p><code>alt</code>+<code>tab</code></p><h2 id="最小化所有窗口"><a href="#最小化所有窗口" class="headerlink" title="最小化所有窗口"></a>最小化所有窗口</h2><p><code>Windows</code>+<code>M</code></p><h2 id="全部最小化-即显示zhi桌面"><a href="#全部最小化-即显示zhi桌面" class="headerlink" title="全部最小化(即显示zhi桌面)"></a>全部最小化(即显示zhi桌面)</h2><p><code>WIN</code>+<code>D</code></p><h2 id="最大化窗口"><a href="#最大化窗口" class="headerlink" title="最大化窗口"></a>最大化窗口</h2><p><code>win</code>+<code>↑（方向键上）</code></p><h2 id="往下缩放窗口。"><a href="#往下缩放窗口。" class="headerlink" title="往下缩放窗口。"></a>往下缩放窗口。</h2><p><code>win</code>+<code>↓（方向键下）</code></p><h2 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h2><p><kbd>Win</kbd>+<kbd>Shift</kbd>+<kbd>s</kbd></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Windows不常用快捷键&quot;&gt;&lt;a href=&quot;#Windows不常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;Windows不常用快捷键&quot;&gt;&lt;/a&gt;Windows不常用快捷键&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;单纯敲键盘比鼠标快的原因，所以整理一些不常用的快捷键给想要速度更快的你&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Windows系列" scheme="https://www.mingsrc.work/categories/Windows%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Windows" scheme="https://www.mingsrc.work/tags/Windows/"/>
    
    <category term="桌面美化" scheme="https://www.mingsrc.work/tags/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"/>
    
    <category term="快捷方式" scheme="https://www.mingsrc.work/tags/%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows壁纸软件推荐</title>
    <link href="https://www.mingsrc.work/posts/db382da4"/>
    <id>https://www.mingsrc.work/posts/db382da4</id>
    <published>2022-12-27T03:12:54.099Z</published>
    <updated>2022-12-27T06:58:43.008Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="爱壁纸UWP"><a href="#爱壁纸UWP" class="headerlink" title="爱壁纸UWP"></a>爱壁纸UWP</h1><p><a href="http://www.microsoftuwp.com/pc/apps/978.html">爱壁纸UWP下载链接</a></p><blockquote><p> 有影视明星、风光风景、性感美女、花卉植物、体育运动、动物宠物、游戏CG、卡通动漫、机车世界、炫彩美图、品牌欣赏、美食天下、影视剧集、艺术设计、节庆假日、美图杂烩等的壁纸分类内容。</p></blockquote><h2 id="★WIN10商店娱乐分类第一"><a href="#★WIN10商店娱乐分类第一" class="headerlink" title="★WIN10商店娱乐分类第一"></a>★WIN10商店娱乐分类第一</h2><p> ★ 最高人气必备应用<br> ★ 壁纸类下载排名第一应用<br> ★诺基亚“春 Phone 计划”优秀应用<br> ★ 微软“Live SDK应用大赛”优秀应用<br> 全球首款跨平台服务专业级壁纸应用，提供海量优质壁纸，超乎想象的精彩！</p><h2 id="特-点"><a href="#特-点" class="headerlink" title="[特 点]"></a>[特 点]</h2><p> 1.方便便捷，锁屏预览、一键设置锁屏；<br> 2.天气锁屏，精彩锁屏壁纸上天气早知道；<br> 3.自动换景，定时自动更换个性锁屏壁纸；<br> 4.批量下载，收藏后批量下载到本地壁纸；<br> 5.高清壁纸，榜单、精选、专题、每日更新；<br> 6.贴心服务，分类、标签、搜索、预览、收藏；<br> 7.特色功能，颜色筛选、猜你喜欢、壁纸拼图；<br> 8.节省流量，自动缓存图片,更有缓存清理功能，解除存储烦忧。 我们有影视明星、风光风景、性感美女、花卉植物、体育运动、动物宠物、游戏CG、卡通动漫、机车世界、炫彩美图、品牌欣赏、美食天下、影视剧集、艺术设计、节庆假日、美图杂烩等的壁纸分类内容。</p><h1 id="附上一些比较好看壁纸"><a href="#附上一些比较好看壁纸" class="headerlink" title="附上一些比较好看壁纸"></a>附上一些比较好看壁纸</h1><p><img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gjvw1yzkafj343c2awnph.jpg" alt><br><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gjvw1zx0z7j31z4140kjm.jpg" alt><br><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjvw209hknj34802tcqv5.jpg" alt><br><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" alt><br><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjvw20udytj33kw2oo7ma.jpg" alt><br><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gjvw2181omj32gu1dznpd.jpg" alt></p>]]></content>
    
    
    <summary type="html">爱壁纸UWP——一款你肯定会喜欢的壁纸软件</summary>
    
    
    
    <category term="Windows系列" scheme="https://www.mingsrc.work/categories/Windows%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Windows" scheme="https://www.mingsrc.work/tags/Windows/"/>
    
    <category term="桌面美化" scheme="https://www.mingsrc.work/tags/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Windows右键添加Windows Terminal</title>
    <link href="https://www.mingsrc.work/posts/3a70d3a5"/>
    <id>https://www.mingsrc.work/posts/3a70d3a5</id>
    <published>2022-12-27T03:12:54.099Z</published>
    <updated>2022-12-27T06:59:33.486Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Windows-Terminal添加到鼠标右键"><a href="#Windows-Terminal添加到鼠标右键" class="headerlink" title="Windows Terminal添加到鼠标右键"></a>Windows Terminal添加到鼠标右键</h1><p><strong>Windows Terminal 右键顺滑上手</strong></p><p>折腾博客主题的时候看见了Windows Terminal的快捷打开方式，那就试试~</p><p>如果Windows上有比从cmd和PowerShell好用的终端，还能添加到鼠标右键菜单，你想要试试吗?</p><h2 id="下载Windows-Terminal"><a href="#下载Windows-Terminal" class="headerlink" title="下载Windows Terminal"></a>下载Windows Terminal</h2><p><a href="https://www.microsoft.com/zh-cn/p/windows-terminal-preview/9n0dx20hk701?activetab=pivot:overviewtab">Windows Teriminl</a></p><p>并且，这个是支持自己去编译的，如果你够厉害，可以根据自己需要修改源文件，github上有源文件。</p><p><a href="https://github.com/microsoft/terminal">GitHub - microsoft/terminal: The new Windows Terminal, and the original Windows console host - all in the same place!</a></p><h2 id="添加Windows-Terminal到右键菜单"><a href="#添加Windows-Terminal到右键菜单" class="headerlink" title="添加Windows Terminal到右键菜单"></a>添加Windows Terminal到右键菜单</h2><h3 id="测试变量"><a href="#测试变量" class="headerlink" title="测试变量"></a>测试变量</h3><p>先检测下边两个变量是否可以正常输出</p><ul><li>第一种：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> %USERPROFILE%<br><span class="hljs-built_in">echo</span> %LOCALAPPDATA%<br></code></pre></td></tr></table></figure><p>如果输出的是<code>%USERPROFILE%</code>和<code>%LOCALAPPDATA%</code>或者报错的情况下,替换掉<code>%USERPROFILE%</code>和<code>%LOCALAPPDATA%</code>，如下所示，在reg文档中同样：</p><ul><li>第二种：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> C:\Users\[userName]<br><span class="hljs-built_in">echo</span> C:\Users\[userName]\AppData\Local<br></code></pre></td></tr></table></figure><p>如果使用的是第一种，后边的命令行就都可以使用第一种，如果是第二种，后边操作中的文件路径都使用<mark>绝对路径</mark></p><p><code>[userName]</code>是你的用户名</p><p><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gjmavezmhkj30fn04bgls.jpg" alt="image" width="563" data-width="563" data-height="155"></p><h3 id="创建terminal文件夹"><a href="#创建terminal文件夹" class="headerlink" title="创建terminal文件夹"></a>创建terminal文件夹</h3><p>打开命令行，输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mkdir &quot;%USERPROFILE%\AppData\Local\terminal&quot;<br></code></pre></td></tr></table></figure><p>或者直接在<mark>文件管理器</mark><code>[userName]\AppData\Local\</code>直接新建<mark>teriminal</mark>文件夹。</p><h3 id="写入注册表"><a href="#写入注册表" class="headerlink" title="写入注册表"></a>写入注册表</h3><p>在Terminal中创建txt文档，后缀名为<code>reg</code>， 右键菜单会出现<code>Windows Terminal</code>的当时有两种，一种是：<code>shift</code>+<code>鼠标右键</code>，另一种是：<code>鼠标右键</code>。接下来根据自己需要选择两种方式中的一种即可：</p><ul><li><code>shift</code>+<code>鼠标右键</code></li></ul><p>把下边的内容复制到reg中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">Windows Registry Editor Version 5.00<br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]<br>@=<span class="hljs-string">&quot;Windows Terminal&quot;</span><br><span class="hljs-string">&quot;Extended&quot;</span>=<span class="hljs-string">&quot;&quot;</span><br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\<span class="hljs-built_in">command</span>]<br>@=<span class="hljs-string">&quot;C:\\Users\\[userName]\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</span><br></code></pre></td></tr></table></figure><p><mark>注意</mark>:需要把[userName]改为自己电脑的用户名</p><ul><li><code>右键</code></li></ul><p>把下边内容复制到reg中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">Windows Registry Editor Version 5.00<br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]<br>@=<span class="hljs-string">&quot;Windows terminal here&quot;</span><br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\<span class="hljs-built_in">command</span>]<br>@=<span class="hljs-string">&quot;C:\\Users\\[userName]\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</span><br></code></pre></td></tr></table></figure><p><mark>注意</mark>:需要把[userName]改为自己电脑的用户名</p><h3 id="修改Windows-Terminal的profile-json"><a href="#修改Windows-Terminal的profile-json" class="headerlink" title="修改Windows Terminal的profile.json"></a>修改<mark>Windows Terminal</mark>的<mark>profile.json</mark></h3><p>打开profile.json</p><p><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gjmbb19qllj30vd0mtacg.jpg" alt="image" width="1129" data-width="1129" data-height="821"></p><p>然后按照下图修改对应的内容就可以：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-string">&quot;startingDirectory&quot;</span>: null<br></code></pre></td></tr></table></figure><p><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjmbbymoxrj30ix0j3jsf.jpg" alt="image" width="681" data-width="681" data-height="687"></p><p>到此，就成功把Terminal添加到鼠标右键了</p><p><img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gjmbgk0sg3j30bc0d8793.jpg" alt="2020-10-12 (2)" width="408" data-width="408" data-height="476"></p><h1 id="一些常用的键与命令"><a href="#一些常用的键与命令" class="headerlink" title="一些常用的键与命令"></a>一些常用的键与命令</h1><ol><li><kbd>tab</kbd> 命令补全</li><li><code>ls</code>  查看文件及文件结构</li><li><code>type</code> 查看文件内容<ul><li>直接输入文件名会用默认应用打开</li></ul></li><li><code>cd</code> 切换工作目录</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Windows系列" scheme="https://www.mingsrc.work/categories/Windows%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Windows" scheme="https://www.mingsrc.work/tags/Windows/"/>
    
    <category term="桌面美化" scheme="https://www.mingsrc.work/tags/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"/>
    
    <category term="快捷方式" scheme="https://www.mingsrc.work/tags/%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【一文搞懂】【WIN】【CMD】netsh用法整理</title>
    <link href="https://www.mingsrc.work/posts/66ebbc05"/>
    <id>https://www.mingsrc.work/posts/66ebbc05</id>
    <published>2022-12-27T03:12:54.098Z</published>
    <updated>2022-12-27T03:12:54.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Netsh 是命令行脚本实用工具，可让你显示或修改当前正在运行的计算机的网络配置。 可以通过在 netsh 提示符下键入命令来运行 Netsh 命令，并且可以在批处理文件或脚本中使用 Netsh 命令。 可以使用 netsh 命令来配置远程计算机和本地计算机。</p><p>Netsh 还提供脚本功能，可让你在批处理模式下对指定的计算机运行一组命令。 你可以使用 Netsh 将配置脚本保存在文本文件中，以便存档或者帮助你配置其他计算机。</p><h1 id="一、如何正确使用netsh"><a href="#一、如何正确使用netsh" class="headerlink" title="一、如何正确使用netsh"></a>一、如何正确使用<code>netsh</code></h1><ol><li>当我们忘记netsh的相关命令时，可以直接使用netsh自带的帮助功能，就能看到一些可以使用的命令。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh /?<br><br>C:\Users\ming Ming&gt;netsh /?<br><br>Usage: netsh [-a AliasFile] [-c Context] [-r RemoteMachine] [-u [DomainName\]UserName] [-p Password | *]<br>             [Command | -f ScriptFile]<br><br>The following commands are available:<br><br>Commands in this context:<br>?              - Displays a list of commands.<br>add            - Adds a configuration entry to a list of entries.<br>advfirewall    - Changes to the `netsh advfirewall&#x27; context.<br>bridge         - Changes to the `netsh bridge&#x27; context.<br>delete         - Deletes a configuration entry from a list of entries.<br>dhcpclient     - Changes to the `netsh dhcpclient&#x27; context.<br>dnsclient      - Changes to the `netsh dnsclient&#x27; context.<br>dump           - Displays a configuration script.<br>exec           - Runs a script file.<br>firewall       - Changes to the `netsh firewall&#x27; context.<br>help           - Displays a list of commands.<br>http           - Changes to the `netsh http&#x27; context.<br>interface      - Changes to the `netsh interface&#x27; context.<br>ipsec          - Changes to the `netsh ipsec&#x27; context.<br>lan            - Changes to the `netsh lan&#x27; context.<br>mbn            - Changes to the `netsh mbn&#x27; context.<br>namespace      - Changes to the `netsh namespace&#x27; context.<br>netio          - Changes to the `netsh netio&#x27; context.<br>nlm            - Changes to the `netsh nlm&#x27; context.<br>p2p            - Changes to the `netsh p2p&#x27; context.<br>ras            - Changes to the `netsh ras&#x27; context.<br>rpc            - Changes to the `netsh rpc&#x27; context.<br>set            - Updates configuration settings.<br>show           - Displays information.<br>trace          - Changes to the `netsh trace&#x27; context.<br>wcn            - Changes to the `netsh wcn&#x27; context.<br>wfp            - Changes to the `netsh wfp&#x27; context.<br>winhttp        - Changes to the `netsh winhttp&#x27; context.<br>winsock        - Changes to the `netsh winsock&#x27; context.<br>wlan           - Changes to the `netsh wlan&#x27; context.<br><br>The following sub-contexts are available:<br> advfirewall bridge dhcpclient dnsclient firewall http interface ipsec lan mbn namespace netio nlm p2p ras rpc trace wcn wfp winhttp winsock wlan<br><br>To view help for a command, type the command, followed by a space, and then<br> type ?.<br></code></pre></td></tr></table></figure><ol start="2"><li><p>那知道有哪些可选功能后，我们就可以进一步输入二级命令去执行我们将要进行的操作，比如下边我就以查看当前tcp链接状态位列展示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&gt;netsh</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">netsh&gt;int</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">netsh interface&gt;ip</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">netsh interface ipv4&gt;show tcpstats</span><br><br>TCP Statistics<br>------------------------------------------------------<br>Timeout Algorithm:                      Van Jacobson&#x27;s Algorithm<br>Minimum Timeout:                        5<br>Maximum Timeout:                        4294967295<br>Maximum Connections:                    Dynamic<br>Active Opens:                           3971<br>Passive Opens:                          556<br>Attempts Failed:                        1017<br>Established Resets:                     407<br>Currently Established:                  34<br>In Segments:                            202193<br>Out Segments:                           149657<br>Retransmitted Segments:                 0<br>In Errors:                              0<br>Out Resets:                             845<br>Fastopen Active Opens:                  0<br>Fastopen Passive Opens:                 0<br>Fastopen Attempts Failed:               0<br>Retransmits Of First SYN:               644<br>Retransmits Of First SYN (Fastopen):    0<br></code></pre></td></tr></table></figure></li></ol><h1 id="二、netsh命令整理"><a href="#二、netsh命令整理" class="headerlink" title="二、netsh命令整理"></a>二、<code>netsh</code>命令整理</h1><h2 id="1-导出导入脚本"><a href="#1-导出导入脚本" class="headerlink" title="1. 导出导入脚本"></a>1. 导出导入脚本</h2><ol><li><p>导出配置脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh -c interface ip dump &gt; c:/interface.txt<br></code></pre></td></tr></table></figure></li><li><p>导入配置脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh -f c:/interface.txt<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-固定IP地址批处理"><a href="#2-固定IP地址批处理" class="headerlink" title="2. 固定IP地址批处理"></a>2. 固定IP地址批处理</h2><p>&#x2F;&#x2F;SETIPDNS.bat（ “本地连接”换成你网卡的名字, 具体的 ip 地址，网关，请自行修改 ）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">@echo off<br><br>echo 正在修改本机IP...<br><br>netsh interface ip set address name=&quot;本地连接&quot; source=static 192.168.1.188  255.255.255.0 192.168.1.1 1<br><br>echo 正在添加本机主DNS...<br><br>netsh interface ip set dns &quot;本地连接&quot; static 18.0.0.10 primary<br><br>echo 正在添加本机副DNS...<br><br>netsh interface ip add dns &quot;本地连接&quot; 18.0.0.10<br><br>echo 设置完成...<br><br>echo 检查当前本机配置...<br><br>ipconfig /all<br><br>echo 导出配置脚本...<br><br>netsh -c interface ip dump<br><br>pause<br></code></pre></td></tr></table></figure><h2 id="3-自动获取-IP"><a href="#3-自动获取-IP" class="headerlink" title="3. 自动获取 IP"></a>3. 自动获取 IP</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">@echo off<br><br>echo 正在修改本机IP...<br><br>netsh interface ip set address name=&quot;本地连接&quot; source=dhcp<br><br>echo 正在添加本机主DNS...<br><br>netsh interface ip set dns &quot;本地连接&quot; dhcp<br><br>echo 设置完成...<br><br>echo 检查当前本机配置...<br><br>ipconfig /all<br><br>echo 导出配置脚本...<br><br>netsh -c interface ip dump<br><br>pause<br></code></pre></td></tr></table></figure><h2 id="4-netsh用法"><a href="#4-netsh用法" class="headerlink" title="4. netsh用法"></a>4. netsh用法</h2><ol><li><p>查看网络配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh interface ip show &#123;选项&#125;<br><br>&#123;选项&#125;可以是：<br>address-显示IP地址配置。<br>config-显示IP地址和更多信息。<br>dns-显示DNS服务器地址。<br>icmp-显示ICMP统计。<br>interface-显示IP接口统计。<br>ipaddress-显示当前IP地址。<br>ipnet-显示IP的网络到媒体的映射。<br>ipstats-显示IP统计。<br>joins-显示加入的多播组。<br>offload-显示卸载信息。<br>tcpconn-显示TCP连接。<br>tcpstats-显示TCP统计。<br>udpconn-显示UDP连接。<br>udpstats-显示UDP统计。<br>wins-显示WINS服务器地址。<br></code></pre></td></tr></table></figure></li><li><p>查看网络配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh interface ip show &#123;选项&#125;<br><br>&#123;选项&#125;可以是：<br>address-显示IP地址配置。<br>config-显示IP地址和更多信息。<br>dns-显示DNS服务器地址。<br>icmp-显示ICMP统计。<br>interface-显示IP接口统计。<br>ipaddress-显示当前IP地址。<br>ipnet-显示IP的网络到媒体的映射。<br>ipstats-显示IP统计。<br>joins-显示加入的多播组。<br>offload-显示卸载信息。<br>tcpconn-显示TCP连接。<br>tcpstats-显示TCP统计。<br>udpconn-显示UDP连接。<br>udpstats-显示UDP统计。<br>wins-显示WINS服务器地址。<br></code></pre></td></tr></table></figure></li><li><p>配置接口IP&#x2F;网关IP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh interface ip set address &quot;本地连接&quot; static 10.1.2.90 255.255.255.0 10.1.2.254 1<br></code></pre></td></tr></table></figure></li><li><p>配置自动换取IP地址,DNS地址及wins地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh interface ip set address &quot;本地连接&quot; dhcp<br>netsh interface ip set dns &quot;本地连接&quot; dhcp<br>netsh interface ip set wins &quot;本地连接&quot; dhcp<br></code></pre></td></tr></table></figure></li><li><p>配置静态IP地址，DNS地址及wins地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh interface ip set address &quot;本地连接&quot; static 10.1.2.90<br>netsh interface ip set dns &quot;本地连接&quot; static 202.99.160.68<br>netsh interface ip set wins &quot;本地连接&quot; static 10.1.2.200<br></code></pre></td></tr></table></figure></li><li><p>看网络配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">C:&gt;netsh -c interface dump<br></code></pre></td></tr></table></figure></li><li><p>导出网络配置文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh -c interface dump &gt; d:/1.txt<br></code></pre></td></tr></table></figure></li><li><p>导入网络配置文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh -f d:/1.txt<br>netsh exec d:/2.txt <br></code></pre></td></tr></table></figure></li><li><p>netsh 配置防火墙<br>查看、开启或禁用系统防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看防火墙的状态</span><br>netsh firewall show state<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">禁用系统防火墙</span><br>netsh firewall set opmode disable<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用防火墙</span><br>netsh firewall set opmode enable<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="WIN" scheme="https://www.mingsrc.work/categories/WIN/"/>
    
    <category term="CMD" scheme="https://www.mingsrc.work/categories/WIN/CMD/"/>
    
    
    <category term="WIN" scheme="https://www.mingsrc.work/tags/WIN/"/>
    
    <category term="CMD" scheme="https://www.mingsrc.work/tags/CMD/"/>
    
  </entry>
  
  <entry>
    <title>并发与多线程</title>
    <link href="https://www.mingsrc.work/posts/12e8fad9"/>
    <id>https://www.mingsrc.work/posts/12e8fad9</id>
    <published>2022-12-27T03:12:54.097Z</published>
    <updated>2022-12-27T03:12:54.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="并发与多线程"><a href="#并发与多线程" class="headerlink" title="并发与多线程"></a>并发与多线程</h3><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p><span id="more"></span><h1 id="1、创建线程"><a href="#1、创建线程" class="headerlink" title="1、创建线程  "></a>1、创建线程  </h1><h2 id="调用线程函数："><a href="#调用线程函数：" class="headerlink" title="调用线程函数： "></a>调用线程函数： </h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">thread myThread(函数名);<br></code></pre></td></tr></table></figure><h2 id="可调用对象做参数："><a href="#可调用对象做参数：" class="headerlink" title="可调用对象做参数：  "></a>可调用对象做参数：  </h2><ul><li>线程的入口函数在对象的类重载()的函数<code>void operator()()</code>中,对象是值传递所以还必须有拷贝构造函数<code>Obj(const &amp;obj)</code>，这里对象是值传递<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void operator()()&#123;&#125;;<br>thread myThread(对象);<br>void operator()(int val);<br>thread myThread(对象,val); <br></code></pre></td></tr></table></figure>lambda表达式：</li></ul><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">auto mylamthread = [] &#123;  ;&#125;<br>````<br>使用线程：<br>-----------<br>* 实际只使用join()：只有当所有线程运行结束后才运行主线程<br>```cpp<br>threadObj.detach();<br>threadObj.join();<br>threadObj.joinable();       //判断是否可以使用join()<br></code></pre></td></tr></table></figure><h1 id="2、线程传参"><a href="#2、线程传参" class="headerlink" title="2、线程传参"></a>2、线程传参</h1><h2 id="普通类型做线程参数"><a href="#普通类型做线程参数" class="headerlink" title="普通类型做线程参数  "></a>普通类型做线程参数  </h2><ul><li>创建线程时，即使线程函数参数是&amp;，主线程传递也依旧是值传递重新拷贝一份给线程函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;var,)</span></span>&#123;&#125;    <br><span class="hljs-function">thread <span class="hljs-title">myThread</span><span class="hljs-params">(func,var)</span></span>;          <span class="hljs-comment">//myTread中var和func中的var不同地址</span><br></code></pre></td></tr></table></figure>类对象做线程参数</li></ul><hr><ul><li>传递类对象，应避免隐式类型转换，全部使用构建临时对象，线程函数必须用const &amp;来接，避免再次构造对象。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> Obj &amp;obj)</span></span>&#123;&#125;     <br><span class="hljs-function">thread <span class="hljs-title">myThread</span><span class="hljs-params">(func,Obj(<span class="hljs-number">0</span>))</span></span>;       <span class="hljs-comment">//先构造临时对象Obj(0)，值传递复制给func函数obj对象</span><br></code></pre></td></tr></table></figure></li><li>如果非要用主线程的对象本身做线程参数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Obj &amp;obj)</span>                 <span class="hljs-comment">//可以不用const</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">Obj obj</span>;           <br><span class="hljs-function">thread <span class="hljs-title">myThread</span><span class="hljs-params">(func,std::ref(obj))</span></span>;                <span class="hljs-comment">//相当于&amp;obj</span><br><br></code></pre></td></tr></table></figure>用类成员函数指针做线程函数</li></ul><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadWorkFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;&#125;;<br><span class="hljs-function">thread <span class="hljs-title">myThread</span><span class="hljs-params">(&amp;Obj::threadWorkFunc,&amp;obj,val)</span></span>;     <span class="hljs-comment">//使用&amp;obj也可保证主线程和线程使用同一个对象</span><br></code></pre></td></tr></table></figure><h1 id="3、互斥量"><a href="#3、互斥量" class="headerlink" title="3、互斥量"></a>3、互斥量</h1><h2 id="mutex类"><a href="#mutex类" class="headerlink" title="mutex类"></a>mutex类</h2><ul><li>相当于一把锁。<code>lock()</code> 与<code>unlock()</code>必须成对使用，先<code>lock</code>，再操作共享数据，然后<code>unlock</code></li></ul><h2 id="lock-guard类模板"><a href="#lock-guard类模板" class="headerlink" title="lock_guard类模板"></a>lock_guard类模板</h2><ul><li>为了防止忘记unlock，引入<code>std::lock_guard</code>类模板,在定义时，构造函数中自动调用<code>lock()</code>，在析构函数中自动调用<code> unlock()</code>，直接取代<code>unlock</code> <code>lock</code>函数，不能共用;  </li><li>使用：只需要在操作共享数据前加一行将互斥量加入模板即可，不需要考虑解锁</li><li>一般项目使用lock_guard就足够了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">mutexGuard</span><span class="hljs-params">(my_mutex)</span></span>;<br></code></pre></td></tr></table></figure>死锁</li></ul><hr><ul><li>至少有两个互斥量存在，在两个进程中，两个互斥量的<code>lock()</code>次序不同，就会引起死锁只要保持上锁的顺序一致就行</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj</span>&#123;                                                <span class="hljs-comment">//线程类</span><br><span class="hljs-keyword">private</span>:<br>  std:List&lt;<span class="hljs-type">int</span>&gt; MsgRecvQueue;                             <span class="hljs-comment">//共享数据容器</span><br>  mutex my_mutex;                                         <span class="hljs-comment">//互斥锁</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">outMsgRecvQueue</span><span class="hljs-params">()</span></span>&#123;                                 <span class="hljs-comment">//读数据线程函数</span><br>       my_mutex.<span class="hljs-built_in">lock</span>();<br>       <span class="hljs-keyword">if</span>(!MsgRecvQueue.<span class="hljs-built_in">empty</span>())&#123;                         <span class="hljs-comment">//判断也是操作共享数据</span><br>           MsgRecvQueue.<span class="hljs-built_in">pop_front</span>();                      <span class="hljs-comment">//if函数的每个分支都要解锁</span><br>           my_mutex.<span class="hljs-built_in">unlock</span>();             <br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           my_mutex.<span class="hljs-built_in">unlock</span>();<br>       &#125;<br>    &#125;;       <br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inMsgRecvQueue</span><span class="hljs-params">()</span></span>&#123;                                   <span class="hljs-comment">//写数据线程函数</span><br>       my_mutex.<span class="hljs-built_in">lock</span>();                                    <span class="hljs-comment">//锁住</span><br>       MsgRecvQueue.<span class="hljs-built_in">push_back</span>();                           <span class="hljs-comment">//写数据</span><br>       my_mutex.<span class="hljs-built_in">unlock</span>();                                  <span class="hljs-comment">//解锁</span><br>    &#125;;        <br>&#125;;<br><br>Obj obj;<br><span class="hljs-function">std::thread <span class="hljs-title">myInMsgThread</span><span class="hljs-params">(&amp;Obj::inMsgRecvQueue,&amp;obj)</span></span>;     <span class="hljs-comment">//写数据线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">myOutMsgThread</span><span class="hljs-params">(&amp;Obj::outMsgRecvQueue,&amp;obj)</span></span>;   <span class="hljs-comment">//读数据线程</span><br>myInMsgThread.<span class="hljs-built_in">join</span>();<br>myOutMsgThread.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><h1 id="4、单例模式与数据共享问题"><a href="#4、单例模式与数据共享问题" class="headerlink" title="4、单例模式与数据共享问题"></a>4、单例模式与数据共享问题</h1><ul><li><code>构造函数私有化</code> <code>本类指针类型的静态成员变量</code> <code>返回本类指针得静态成员函数</code></li><li>对象只能创建一次</li><li>推荐主线程中创建对象（例如初始化配置信息），多线程只读访问，不需要互斥</li><li>线程中创建单例对象需要建立互斥<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Obj</span>()&#123;&#125;;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Obj* obj;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Obj* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;  <br>        <span class="hljs-keyword">if</span>(obj==null)&#123;                  <span class="hljs-comment">//双重锁定提高效率</span><br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">mutexGuard</span><span class="hljs-params">(myMutex)</span></span>;<br>            <span class="hljs-keyword">if</span>(obj==null)               <span class="hljs-comment">//即if判断两次，因为=null时不一定指对象没有new，可能多个线程争抢权限</span><br>                obj=<span class="hljs-keyword">new</span> Obj;<br>         &#125;<br>         <span class="hljs-keyword">return</span> obj;<br>     &#125;<br>&#125;;<br><br>Obj* Obj::obj=null;<br></code></pre></td></tr></table></figure></li></ul><p>std::this_thread::get_id()   </p><h1 id="5、效率问题"><a href="#5、效率问题" class="headerlink" title="5、效率问题"></a>5、效率问题</h1><h2 id="双重锁定"><a href="#双重锁定" class="headerlink" title="双重锁定"></a>双重锁定</h2><ul><li>使用两个判断，第一次提高效率，第二次只有加锁后的判断成立，才是真正的obj&#x3D;&#x3D;bull<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(obj==null)&#123;                 <br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">mutexGuard</span><span class="hljs-params">(myMutex)</span></span>;<br>    <span class="hljs-keyword">if</span>(obj==null)              <br>        obj=<span class="hljs-keyword">new</span> Obj;<br></code></pre></td></tr></table></figure></li></ul><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><ul><li><code>std::condition_variable</code> 是一个类，函数<code>waite()</code>等待通知<code>notify_noce()</code>，收到通知后，将开启循环尝试拿锁</li><li>拿锁成功后，第二参数判断为true：往后执行代码</li><li>拿锁成功后，第二参数判断为false:继续休眠，等待<code>notify_noce()</code>通知  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">写数据线程<span class="hljs-number">1</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">mutexGuard</span><span class="hljs-params">(myMutex)</span></span><br><span class="hljs-function">dataQueue.<span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>my_condition.<span class="hljs-built_in">notyfy_one</span>();                         <span class="hljs-comment">//my_condition是condition_variable类对象</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">读数据线程<span class="hljs-number">2</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">mutexGuard</span><span class="hljs-params">(myMutex)</span></span><br><span class="hljs-function"><span class="hljs-title">my_condition</span><span class="hljs-params">(mutexGuard,[<span class="hljs-keyword">this</span>]&#123;                    <span class="hljs-comment">//第二参数使用lambda表达式</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">if</span>(!dataQueue.empty())</span></span><br><span class="hljs-params"><span class="hljs-function">          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">   &#125;)</span></span>;<br>dataQueue.<span class="hljs-built_in">pop_front</span>();                             <span class="hljs-comment">//收到通知，持续拿锁，拿到后判断非空，则读数据</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;并发与多线程&quot;&gt;&lt;a href=&quot;#并发与多线程&quot; class=&quot;headerlink&quot; title=&quot;并发与多线程&quot;&gt;&lt;/a&gt;并发与多线程&lt;/h3&gt;&lt;p&gt;转自：🔥&lt;a href=&quot;https://github.com/liuwentao1992&quot;&gt;【github】&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="力扣" scheme="https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="Liux" scheme="https://www.mingsrc.work/tags/Liux/"/>
    
    <category term="多线程" scheme="https://www.mingsrc.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>笔试题汇总</title>
    <link href="https://www.mingsrc.work/posts/e72c822"/>
    <id>https://www.mingsrc.work/posts/e72c822</id>
    <published>2022-12-27T03:12:54.097Z</published>
    <updated>2022-12-27T03:12:54.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2021届秋招笔试题汇总"><a href="#2021届秋招笔试题汇总" class="headerlink" title="2021届秋招笔试题汇总"></a>2021届秋招笔试题汇总</h1><span id="more"></span><ul><li><a href="#%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E20200815">科大讯飞</a></li><li><a href="#%E5%A4%A7%E7%96%862020816">大疆</a></li><li><a href="#%E7%BE%8E%E7%9A%8420200820">美的</a></li><li><a href="#%E5%95%86%E6%B1%A4%E7%A7%91%E6%8A%8020200820">商汤科技</a>  </li><li>[中兴1](#中兴20200824）</li><li><a href="#%E6%B1%87%E9%A1%B6%E7%A7%91%E6%8A%8020200824">汇顶科技</a>  </li><li><a href="#%E7%83%BD%E7%81%AB%E7%A7%91%E6%8A%8020200829">烽火科技</a></li><li><a href="#oppo20200829">oppo</a></li><li><a href="#%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E20200829">科大讯飞</a></li><li><a href="#%E7%BE%8E%E7%9A%8420200831">美的</a></li><li><a href="#%E4%B8%AD%E5%85%B420200903">中兴2</a></li><li><a href="#%E6%B7%B1%E4%BF%A1%E6%9C%8D20200910">深信服</a></li><li><a href="#%E7%BD%91%E6%98%9320200912">网易</a></li><li><a href="#VIVO20200912">VIVO</a></li><li><a href="#%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%8420200913">美团点评</a></li></ul><h1 id="科大讯飞20200815"><a href="#科大讯飞20200815" class="headerlink" title="科大讯飞20200815"></a>科大讯飞20200815</h1><h1 id="第1题"><a href="#第1题" class="headerlink" title="第1题"></a>第1题</h1><p>定义一个n*m的数字矩阵，要求你再当中找到两个不在用一行同一列的数组，使得乘积最大</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><blockquote><p>第一行数字n、m表示矩阵大小<br>接下来又n行数字，每行m个数字，约定n和m都是小于等于1000，大于等于1的整数。</p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p>一个数字表示最大的乘积值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n , m;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">arr</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            cin &gt;&gt; arr[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> MAX = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-type">int</span> num1 = arr[i][j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; n; ++x) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; m; ++y) &#123;<br>                    <span class="hljs-type">int</span> num2 = arr[x][y];<br>                    <span class="hljs-keyword">if</span> (x == i || y == j) <span class="hljs-keyword">continue</span>;<br>                    MAX = <span class="hljs-built_in">max</span>(MAX, num1 * num2);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt;MAX&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第2题"><a href="#第2题" class="headerlink" title="第2题"></a>第2题</h1><p>用某种排序方法对32位整数序列<code>(25,84,21,47,15,27,68,35,20)</code>进行行排序，序列变化的情况如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">21 25 84 47 15 27 68 35 20  <br>15 20 21 25 35 27 47 68 84<br>15 20 21 25 27 35 47 68 84<br></code></pre></td></tr></table></figure><p>请以该排序方法对其他的输入序列进行排序并输出结果</p><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><blockquote><p>第一行为给定数字序列中的元素个数<br>第二行为给定的数字序列，以空格分割  </p></blockquote><h3 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h3><blockquote><p>输出排序后的数字序列，以空格分割  </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">help</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> tmp = arr[left];<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= tmp) right--;<br>        arr[left] = arr[right];<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= tmp) left++;<br>        arr[right] = arr[left];<br>    &#125;<br>    arr[left] = tmp;<br>    <span class="hljs-keyword">return</span>  left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = <span class="hljs-built_in">help</span>(arr, left, right);<br>    <span class="hljs-built_in">qsort</span>(arr, left, mid - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">qsort</span>(arr, mid + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt;arr[i];<br>    &#125;<br>    <span class="hljs-built_in">qsort</span>(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cout &lt;&lt; arr[i] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第3题"><a href="#第3题" class="headerlink" title="第3题"></a>第3题</h1><p>统计数字二进制形式1的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num;<br>    cin &gt;&gt; num;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (num) &#123;<br>        <span class="hljs-keyword">if</span> (num &amp; <span class="hljs-number">1</span>) cnt++;<br>        num &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h1><p>将一个长度位m的字符串左移n位</p><h3 id="输入描述：-1"><a href="#输入描述：-1" class="headerlink" title="输入描述："></a>输入描述：</h3><blockquote><p>第一行位长度位m的字符串<br>第二行位左移的位数n<br>1 &lt; n,m &lt; 2000</p></blockquote><h3 id="输出描述：-1"><a href="#输出描述：-1" class="headerlink" title="输出描述："></a>输出描述：</h3><blockquote><p>一行输出左移后的字符串</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str;<br>    <span class="hljs-type">int</span> n ;<br>    <span class="hljs-built_in">getline</span>(cin, str);<br>    cin &gt;&gt; n;<br>    n %= str.<span class="hljs-built_in">size</span>();<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> cnt = str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> idx = n;<br>    <span class="hljs-keyword">while</span> (cnt--) &#123;<br>        idx %= str.<span class="hljs-built_in">size</span>();<br>        res += str[idx++];<br>    &#125;<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="大疆2020816"><a href="#大疆2020816" class="headerlink" title="大疆2020816"></a>大疆2020816</h1><p>给定一个整数序列，你需要找到两个的子段，保证这两个子段不能重复，并且使得这两个子段中得所有整数得和最大。</p><h3 id="输入描述：-2"><a href="#输入描述：-2" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">第1行整数，测试用例数<br>每个测试用例包括3行，<br>第1行整数，整数序列得长度n<br>第2行，n个整数<br>第3行空格<br></code></pre></td></tr></table></figure><h3 id="输出描述：-2"><a href="#输出描述：-2" class="headerlink" title="输出描述："></a>输出描述：</h3><p>每个测试用例一行，输出一个整数表示最大子段和</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">input:<br>3<br>10<br>1 -1 2 2 3 -3 4 -4 5 -5<br>5<br>-5 9 -5 11 20<br>10<br>-1 -1 -1 -1 -1 -1 -1 -1 -1 -1<br>output:<br>13<br>40<br>-2<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span>&amp; left, <span class="hljs-type">int</span>&amp; right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(len)</span></span>;<br>    <span class="hljs-type">int</span> maxSum = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>] + nums[i] &lt; nums[i])&#123;<br>                dp[i] = nums[i];<br>                left = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (maxSum&lt;dp[i]) &#123;<br>            right = i;<br>            maxSum = dp[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>        left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt;<br>    cin &gt;&gt; cnt;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">input</span>(cnt);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++i) &#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; n;<br>        input[i].<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            cin &gt;&gt; input[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++i) &#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">maxSubArray</span>(input[i], left, right);<br>        <span class="hljs-built_in">sort</span>(input[i].<span class="hljs-built_in">begin</span>(), input[i].<span class="hljs-built_in">begin</span>()+ right - left + <span class="hljs-number">1</span>, <span class="hljs-built_in">less</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        res = left != right ? res - *input[i].<span class="hljs-built_in">begin</span>() : input[i][<span class="hljs-number">0</span>] * <span class="hljs-number">2</span>;<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="美的20200820"><a href="#美的20200820" class="headerlink" title="美的20200820"></a>美的20200820</h1><ul><li>部分选择题  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************【1】**********************/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  clrscr() 100</span><br><span class="hljs-built_in">main</span>()<br>&#123;<br>    <span class="hljs-built_in">clrscr</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">clrscr</span>());<br>&#125;<br><span class="hljs-comment">/******************【2】**********************/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span>* p = <span class="hljs-string">&quot;ayqm&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ++*(p++));<br>&#125;<br><span class="hljs-comment">/******************【3】**********************/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-type">const</span>* p = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ++(*p));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/******************【4】**********************/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">emp</span><br>    &#123;<br>        <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>        <span class="hljs-type">int</span> age;<br>        <span class="hljs-type">float</span> sal;<br>    &#125;;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">emp</span> e = &#123;<span class="hljs-string">&quot;Tiger&quot;</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d %f&quot;</span>, e.age, e.sal);<br>&#125;<br><span class="hljs-comment">/******************【5】**********************/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-type">long</span> a1;<br>    <span class="hljs-type">short</span> a2;<br>    <span class="hljs-type">int</span> a3;<br>    <span class="hljs-type">int</span> *a4;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">char</span> c2;<br>&#125;;<br><span class="hljs-comment">/******************【6】**********************/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span> &#123;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">double</span> v;<br>&#125; SA1;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S2</span>&#123;<br>    <span class="hljs-type">double</span> x;<br>    <span class="hljs-type">int</span> i[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> c;<br>&#125;SA2;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n sizeof S1 %d: sizeof S2 %d&quot;</span>, <span class="hljs-built_in">sizeof</span>(SA1), <span class="hljs-built_in">sizeof</span>(SA2));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/******************【7】**********************/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> s[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br>    <span class="hljs-type">char</span> *p, *str, *str1;<br>    p = &amp;s[<span class="hljs-number">3</span>];<br>    str = p;<br>    str1 = s;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ++*p + ++*str1 - <span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/******************【8】**********************/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">enum</span> &#123;i = <span class="hljs-number">10</span>, j = <span class="hljs-number">20</span>, k = <span class="hljs-number">50</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ++k);<br>&#125;<br><span class="hljs-comment">/******************【9】**********************/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NULL&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(FALSE)<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;TRUE&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;FALSE&quot;</span>);<br>&#125;<br><span class="hljs-comment">/******************【10】**********************/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m = <span class="hljs-number">32</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%X&quot;</span>, ~m);<br>&#125;<br><span class="hljs-comment">/******************【11】**********************/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> square(x) x * x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i ;<br>    i = <span class="hljs-number">64</span> / <span class="hljs-built_in">square</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, i);<br>&#125;<br><span class="hljs-comment">/******************【12】**********************/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> </span>&#123;<br>    *a ^= *b;<br>    *b ^= *a;<br>    *a ^= *b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>, y = <span class="hljs-number">8</span>;<br>    <span class="hljs-built_in">swap</span>(&amp;x, &amp;y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %d y = %d&quot;</span>, x, y);<br>&#125;<br><span class="hljs-comment">/******************【13】**********************/</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> something == 0</span><br><span class="hljs-type">int</span> some = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> thing = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, some, thing);<br>&#125;<br><span class="hljs-comment">/******************【14】**********************/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> *p;<br>    p = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, *&amp;*p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="商汤科技20200820"><a href="#商汤科技20200820" class="headerlink" title="商汤科技20200820"></a>商汤科技20200820</h1><h3 id="选择题："><a href="#选择题：" class="headerlink" title="选择题："></a>选择题：</h3><p>2、 transformer的位置编码使用交替的多维sin、cos函数实现，不属于设计原理的一项是。    </p><ul><li>对于不同长度的序列，其相隔同样距离的两个序列元素，进行位置编码后的编码值的距离相同。</li><li>保持序列中的绝对位置关系。  </li><li>保证序列中元素在一定范围内的相对位置关系。  </li><li>限定在固定值域内，避免不同长度序列取值范围不同，以及过大数值对序列的影响。<br>3、 链表访问i位置的时间复杂度。<br>4、 现代CPU都有较大的缓存，cache来提高内存的访问效率。    </li><li>c的数组的访问可以使用cache来加速，但数组大小不要超过cache大小    </li><li>cache使用需要考虑到不用的cpu核的同步    </li><li>cache的访问时按cache entry来进行的，c的数组需要按行优先访问    </li><li>一般的cache越大，程序效率越高<br>5、 当多个程序连接动态库，所占内存是多少<br>6、 docker使用什么技术来运行环境的隔离    <h3 id="编程题："><a href="#编程题：" class="headerlink" title="编程题："></a>编程题：</h3>给出一个数字矩阵，寻找一条最上上升路径，每个位置只能向上下左右四个位置移动  <h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">9 1 4<br>6 2 8 <br>5 5 7<br>[1, 2, 5, 7, 8]<br>输出5<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> row, col;<br><span class="hljs-type">int</span> cnt;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br><span class="hljs-type">int</span> dff[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; arr, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; isVis)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isVis[x][y]) <span class="hljs-keyword">return</span>;<br>    isVis[x][y] = <span class="hljs-literal">true</span>;<br>    cnt++;<br><br>    <span class="hljs-type">int</span> MAX = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> m = x + dff[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> n = y + dff[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (m &lt; row &amp;&amp; m &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt; col &amp;&amp; n &gt;= <span class="hljs-number">0</span>)&#123;<br>            MAX = <span class="hljs-built_in">max</span>(MAX, arr[m][n]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (arr[x][y] &gt; MAX) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(cnt);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> m = x + dff[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> n = y + dff[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (m &lt; row &amp;&amp; m &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt; col &amp;&amp; n &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[m][n] &gt; arr[x][y])&#123;<br>            <span class="hljs-built_in">dfs</span>(m, n,arr,isVis);<br>        &#125;<br>    &#125;<br>    isVis[x][y] = <span class="hljs-literal">false</span>;<br>    cnt--;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; row;<br>    cin &gt;&gt; col;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">arr</span>(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(col, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            cin &gt;&gt; arr[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> MIN = INT_MAX;<br>    <span class="hljs-type">int</span> min_x = <span class="hljs-number">0</span>, min_y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i][j] &lt; MIN) &#123;<br>                min_x = i;<br>                min_y = j;<br>                MIN = arr[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">isVis</span>(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-built_in">dfs</span>(min_x, min_y, arr, isVis);<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    cout &lt;&lt; res.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="中兴20200824"><a href="#中兴20200824" class="headerlink" title="中兴20200824"></a>中兴20200824</h1><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><p>1、shell语言连接到127.0.0.1：8080服务器上的所有ip。<code>netstat -anp | grep &quot;127.0.0.1:8080&quot; | awk - F&#39;:&#39; &#39;&#123;print $5&#125;&#39;</code><br>2、手动测试和自动化测试的区别。<br>3、在浏览器里面输入http网址，哪些协议不会用到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">ARP,SMTP,IP,HTTP,DNS,TCP<br></code></pre></td></tr></table></figure><p>4、平衡二叉树AVL失衡，时空复杂度。<br>5、构建类的设计模式。<br>6、某个服务器通过域名+端口无法访问，但通过IP+端口可以访问的原因  </p><h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><h1 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h1><p>给定一个长度为n得数组a,求最大连续子区间内平均数最大得值。  </p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">9// 数组长度<br>3 5 3 7 7 6 6 5 6// 数组<br></code></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">7// 最大平均子区间为[4, 5],值为7<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> arr[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        cin &gt;&gt; arr[i];<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> avg = (dp[i - <span class="hljs-number">1</span>] + arr[i]) / (i - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (avg &gt; arr[i]) &#123;<br>            dp[i] = avg;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[i] = arr[i];<br>            left = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>());<br>    cout &lt;&lt; dp[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h1><p>给出一个字符串S，S中可能包含(0-9)和(A-Z),现在我们将字符串S(x)看作一个由x进制转为十进制的数字，<br>给定l和r(l &lt;&#x3D; r)，问S(l) + S(l + 1) … S(r - 1) + S(r - 1)是奇数还是偶数？  </p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2// 测试的字符串组数<br>101 2 3// 计算2进制到3进制所有数字十进制下之和，并判断奇偶。<br>4B 12 13<br></code></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1<br>0<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">transfer</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>,k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>            sum += (s[i] - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">1</span> + <span class="hljs-number">9</span>) * k;<br>        <span class="hljs-keyword">else</span><br>            sum += (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * k;<br>        k *= x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">num</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">x</span><span class="hljs-params">(n)</span>, <span class="hljs-title">y</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; num[i] &gt;&gt; x[i] &gt;&gt; y[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = x[i]; j &lt;= y[i]; ++j) &#123;<br>            ans += <span class="hljs-built_in">transfer</span>(num[i], j);<br>        &#125;<br>        cout &lt;&lt; ((ans &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="汇顶科技20200824"><a href="#汇顶科技20200824" class="headerlink" title="汇顶科技20200824"></a>汇顶科技20200824</h1><h3 id="部分选择题"><a href="#部分选择题" class="headerlink" title="部分选择题"></a>部分选择题</h3><p>奇偶校验<br>static关键字作用<br>do while循环次数   </p><h3 id="编程题-1"><a href="#编程题-1" class="headerlink" title="编程题"></a>编程题</h3><p>查找一行字符串中子字符串的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">del_sub</span><span class="hljs-params">(<span class="hljs-type">char</span>* str, <span class="hljs-type">char</span>* sub)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*str != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-type">char</span>* s1 = str;<br>        <span class="hljs-type">char</span>* s2 = sub;<br>        <span class="hljs-keyword">while</span>(*s2 == *s1 &amp;&amp; *s2 != <span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; *s1 != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>            s2++;<br>            s1++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(*s2 == <span class="hljs-string">&#x27;\0&#x27;</span>) cnt++;<br>        str++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">char</span> sub[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,sub);<br>    num = <span class="hljs-built_in">del_sub</span>(str, sub);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,num);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="科大讯飞20200829"><a href="#科大讯飞20200829" class="headerlink" title="科大讯飞20200829"></a>科大讯飞20200829</h1><h1 id="编程题-2"><a href="#编程题-2" class="headerlink" title="编程题"></a>编程题</h1><h3 id="第一题：-1"><a href="#第一题：-1" class="headerlink" title="第一题："></a>第一题：</h3><p>写一个函数用递归实现将一个正整数分解质因数，如50，则程序打印”2<em>5</em>5”</p><h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">50<br></code></pre></td></tr></table></figure><h3 id="输出描述：-3"><a href="#输出描述：-3" class="headerlink" title="输出描述："></a>输出描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2*5*5<br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>            s += (<span class="hljs-string">&#x27;0&#x27;</span> + i);<br>            s += <span class="hljs-string">&#x27;*&#x27;</span>;<br>            <span class="hljs-built_in">fun</span>(n / i);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">fun</span>(n);<br>    s.<span class="hljs-built_in">pop_back</span>();<br>    cout &lt;&lt; s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二题：-1"><a href="#第二题：-1" class="headerlink" title="第二题："></a>第二题：</h3><p>去除多余的下划线，要求再原串上进行操作</p><h3 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">___aaa__b___c__dd__<br></code></pre></td></tr></table></figure><h3 id="输出描述：-4"><a href="#输出描述：-4" class="headerlink" title="输出描述："></a>输出描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">aaa_b_c_dd<br></code></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteSpace</span><span class="hljs-params">(string&amp; str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (str[cur] == <span class="hljs-string">&#x27;_&#x27;</span>) cur++;<br>    <span class="hljs-type">int</span> tail = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur &lt; str.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (str[cur] != <span class="hljs-string">&#x27;_&#x27;</span>)<br>            str[tail++] = str[cur];<br>        <span class="hljs-keyword">if</span> (str[cur] == <span class="hljs-string">&#x27;_&#x27;</span> &amp;&amp; str[cur - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;_&#x27;</span>)<br>            str[tail++] = str[cur];<br>        cur++;<br>    &#125;<br>    cur--;<br>    <span class="hljs-keyword">while</span> (str[cur] == <span class="hljs-string">&#x27;_&#x27;</span>) &#123;<br>        str.<span class="hljs-built_in">pop_back</span>();<br>        cur--;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str;<br>    cin &gt;&gt; str;<br>    <span class="hljs-built_in">deleteSpace</span>(str);<br>    cout &lt;&lt; str;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="美的20200831"><a href="#美的20200831" class="headerlink" title="美的20200831"></a>美的20200831</h1><ul><li>部分选择题<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> prod(a, b) a * b</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">3</span>,y = <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">prod</span>(x + <span class="hljs-number">2</span>, y <span class="hljs-number">-1</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> C = <span class="hljs-number">32</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, C ^= C, !(C &amp; <span class="hljs-number">128</span>) &amp;&amp; !(C &amp; <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> s[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br>    <span class="hljs-type">char</span> *p, *str, *str1;<br>    p = &amp;s[<span class="hljs-number">3</span>];<br>    str = p;<br>    str1 = s;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ++*p + ++*str1 - <span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> square(x) x * x</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i ;<br>    i = <span class="hljs-number">64</span> / <span class="hljs-built_in">square</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">float</span> a = <span class="hljs-number">5.375</span>;<br>    <span class="hljs-type">char</span> *p;<br>    <span class="hljs-type">int</span> i;<br>    p = (<span class="hljs-type">char</span>*) &amp;a;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)p[i]);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a,b) (a &gt; b) ? a : b</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a,b;a=<span class="hljs-number">3</span>;b=<span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ++<span class="hljs-built_in">max</span>(a++,b--));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> f(g, g2) g##g2</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> var12 = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-built_in">f</span>(var,<span class="hljs-number">12</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> &amp;b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    c =* a;<br>    b = <span class="hljs-number">30</span>;<br>    *a = <span class="hljs-number">20</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>, c = <span class="hljs-number">30</span>;<br>    <span class="hljs-built_in">change</span>(&amp;a,b, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %d, %d&quot;</span>, a, b, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myStruct</span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>&#125;*ptr;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">myStruct</span> ms = &#123;<span class="hljs-number">400</span>,<span class="hljs-string">&#x27;A&#x27;</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d  %d&quot;</span>, ptr-&gt;a, ptr-&gt;b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">typedef</span>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Error</span><br>&#123;<br>    <span class="hljs-type">int</span> warning;<br>    <span class="hljs-type">int</span> error;<br>    <span class="hljs-type">int</span> exception;<br>&#125;error;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    error g1;<br>    g1.error = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, g1.error);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    i = !i &gt; <span class="hljs-number">14</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i=%d&quot;</span>,i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x, y = <span class="hljs-number">2</span>, z, a;<br>    x = (y *= <span class="hljs-number">2</span>) + ( z = a = y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0x80</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>,i &lt;&lt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> *p;<br>    p = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, *&amp;*p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x, y = <span class="hljs-number">2</span>, z, a;<br>    <span class="hljs-keyword">if</span> (x = y % <span class="hljs-number">2</span>);<br>    z=<span class="hljs-number">2</span>;<br>    a=<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,z,x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="中兴20200903"><a href="#中兴20200903" class="headerlink" title="中兴20200903"></a>中兴20200903</h1><h2 id="编程题二："><a href="#编程题二：" class="headerlink" title="编程题二："></a>编程题二：</h2><p>A城和B城是双向路径，求A城到B城的最短路径</p><h3 id="输入描述：-3"><a href="#输入描述：-3" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">5 3 3// n m q 代表：n个城市 m条双向路径 q次询问<br>1 2 1// x y l 代表x到y有一条距离为l的双向路径<br>2 3 1<br>3 5 2<br>1 2// a b 代表要询问的两个城市<br>2 4<br>1 5<br></code></pre></td></tr></table></figure><h3 id="输出描述：-5"><a href="#输出描述：-5" class="headerlink" title="输出描述："></a>输出描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1// 查询的最短路，若不存在输出-1<br>-1<br>4<br></code></pre></td></tr></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dist;<br>vector&lt;<span class="hljs-type">bool</span>&gt; isVis;<br><span class="hljs-type">int</span> MIN = INT_MAX;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> dst, <span class="hljs-type">int</span> distance)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == dst) &#123;<br>        MIN = <span class="hljs-built_in">min</span>(MIN, distance);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : graph[cur]) &#123;<br>        <span class="hljs-keyword">if</span> (isVis[v]) <span class="hljs-keyword">continue</span>;<br>        isVis[v] = <span class="hljs-literal">true</span>;<br>        distance += dist[cur][v];<br>        <span class="hljs-built_in">dfs</span>(v, dst, distance);<br>        isVis[v] = <span class="hljs-literal">false</span>;<br>        distance -= dist[cur][v];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, q;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; m;<br>    cin &gt;&gt; q;<br>    graph.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>    dist.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    isVis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>, v = <span class="hljs-number">0</span>, dis = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; u;<br>        cin &gt;&gt; v;<br>        cin &gt;&gt; dis;<br>        graph[u].<span class="hljs-built_in">push_back</span>(v);<br>        graph[v].<span class="hljs-built_in">push_back</span>(u);<br>        dist[u][v] = dis;<br>        dist[v][u] = dis;<br>    &#125;<br><br>    <span class="hljs-type">int</span> src[q], dst[q];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>        cin &gt;&gt; src[i];<br>        cin &gt;&gt; dst[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>        MIN = INT_MAX;<br>        <span class="hljs-built_in">dfs</span>(src[i], dst[i], <span class="hljs-number">0</span>);<br>        cout &lt;&lt; ((MIN == INT_MAX) ? <span class="hljs-number">-1</span> : MIN) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="深信服20200910"><a href="#深信服20200910" class="headerlink" title="深信服20200910"></a>深信服20200910</h1><h3 id="选择题考点："><a href="#选择题考点：" class="headerlink" title="选择题考点："></a>选择题考点：</h3><ul><li>时间复杂度</li><li>结构体内存对齐</li><li>位运算符</li><li>八大排序算法时间复杂度</li></ul><h3 id="编程题：-1"><a href="#编程题：-1" class="headerlink" title="编程题："></a>编程题：</h3><p>x*y的矩阵，从一个房间进入，从另一个房间出来，要求不重复的走完全部房间的路径数量。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> off[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; isVis;<br><span class="hljs-type">int</span> row, col;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> endX, endY;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> depth)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (isVis[x][y]) <span class="hljs-keyword">return</span>;<br>isVis[x][y] = <span class="hljs-literal">true</span>;<br>depth++;<br><span class="hljs-keyword">if</span> (x == endX &amp;&amp; y == endY &amp;&amp; depth == row * col) &#123;<br>cnt++;<br>isVis[x][y] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br><span class="hljs-type">int</span> m = x + off[i][<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> n = y + off[i][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (m &gt;= <span class="hljs-number">0</span> &amp;&amp; m &lt; row &amp;&amp; n &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt; col &amp;&amp; !isVis[m][n])<br><span class="hljs-built_in">dfs</span>(m, n, depth);<br>&#125;<br>depth--;<br>isVis[x][y] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; row;<br>cin &gt;&gt; col;<br>isVis.<span class="hljs-built_in">resize</span>(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br><span class="hljs-type">int</span> stratX, startY;<br>cin &gt;&gt; stratX;<br>cin &gt;&gt; startY;<br>cin &gt;&gt; endX;<br>cin &gt;&gt; endY;<br><span class="hljs-built_in">dfs</span>(stratX, startY, <span class="hljs-number">0</span>);<br>cout &lt;&lt; cnt &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="网易20200912"><a href="#网易20200912" class="headerlink" title="网易20200912"></a>网易20200912</h1><h3 id="编程题1"><a href="#编程题1" class="headerlink" title="编程题1"></a>编程题1</h3><p>一颗二叉树，叶子结点定义为“樱桃”，统计一串上刚好有两颗“樱桃”的串的个数</p><h3 id="输入描述：-4"><a href="#输入描述：-4" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 2// 3个结点 2条边<br>1 1 2// 1的左子树为2<br>1 2 3// 1的右子树为3<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br><span class="hljs-type">int</span> val;<br>TreeNode *left;<br>TreeNode *right;<br><span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right &amp;&amp;<br>!root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right &amp;&amp; <br>!root-&gt;right-&gt;left &amp;&amp; !root-&gt;right-&gt;right) <br>cnt++;<br><span class="hljs-built_in">dfs</span>(root-&gt;left);<br><span class="hljs-built_in">dfs</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n;<br>cin &gt;&gt; m;<br>unordered_map&lt;<span class="hljs-type">int</span>, TreeNode*&gt; hash;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br><span class="hljs-type">int</span> uid, dir, vid;<br>cin &gt;&gt; uid;<br>cin &gt;&gt; dir;<br>cin &gt;&gt; vid;<br><br><span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(uid) == hash.<span class="hljs-built_in">end</span>()) &#123;<br>hash[uid] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(uid);<br>&#125;<br><br><span class="hljs-keyword">if</span> (dir == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// left</span><br><span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(vid) == hash.<span class="hljs-built_in">end</span>())<br>hash[vid] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vid);<br>hash[uid]-&gt;left = hash[vid];<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// right</span><br><span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(vid) == hash.<span class="hljs-built_in">end</span>())<br>hash[vid] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vid);<br>hash[uid]-&gt;right = hash[vid];<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(hash[<span class="hljs-number">1</span>]);<br>cout &lt;&lt; cnt;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h3><p>快递员城市中送快递，每个城市距离1km，求图的最大深度</p><h3 id="输入描述：-5"><a href="#输入描述：-5" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">6 3// 共6个城市 还能再开3公里<br>0 0 2 3 3 // 想象成一个数组S[5] 下标i+1 到 S[i]之间有一条路径<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">bool</span>&gt; isVis;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; G;<br><span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> MAX = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (isVis[root]) <span class="hljs-keyword">return</span>;<br>isVis[root] = <span class="hljs-literal">true</span>;<br>depth++;<br>MAX = <span class="hljs-built_in">max</span>(MAX, depth);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : G[root]) &#123;<br><span class="hljs-built_in">dfs</span>(v);<br>&#125;<br>depth--;<br>isVis[root] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, k;<br>cin &gt;&gt; n;<br>cin &gt;&gt; k;<br>G.<span class="hljs-built_in">resize</span>(n);<br>isVis.<span class="hljs-built_in">resize</span>(n, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br><span class="hljs-type">int</span> v;<br>cin &gt;&gt; v;<br>G[i+<span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(v);<br>G[v].<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>cout &lt;&lt; (MAX &gt; (k + <span class="hljs-number">1</span>) ? (k + <span class="hljs-number">1</span>) : MAX);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编程题3"><a href="#编程题3" class="headerlink" title="编程题3"></a>编程题3</h3><p>给定一个字符串，求最长字符串的长度，前提这个字符串满足aeiou元音字母在字符串中出现次数刚好为偶数次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//暴力法会超时</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;str)</span> </span>&#123;<br><span class="hljs-type">char</span> count[<span class="hljs-number">256</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> i : str) &#123;<br>count[i]++;<br>&#125;<br><span class="hljs-keyword">return</span> count[<span class="hljs-string">&#x27;a&#x27;</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp;<br>count[<span class="hljs-string">&#x27;e&#x27;</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp;<br>count[<span class="hljs-string">&#x27;i&#x27;</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp;<br>count[<span class="hljs-string">&#x27;o&#x27;</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp;<br>count[<span class="hljs-string">&#x27;u&#x27;</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sol</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span> </span>&#123;<br><span class="hljs-type">int</span> maxVal = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; s.<span class="hljs-built_in">length</span>(); j++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">judge</span>(s.<span class="hljs-built_in">substr</span>(i, j + <span class="hljs-number">1</span> - i))) &#123;<br>maxVal = <span class="hljs-built_in">max</span>(maxVal, j - i + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> maxVal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string str;<br><span class="hljs-built_in">getline</span>(cin, str);<br>cout &lt;&lt; <span class="hljs-built_in">sol</span>(str);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="VIVO20200912"><a href="#VIVO20200912" class="headerlink" title="VIVO20200912"></a>VIVO20200912</h1><h3 id="编程题1-1"><a href="#编程题1-1" class="headerlink" title="编程题1"></a>编程题1</h3><p>给定非空字符串str，在最多可以删除一个字符情况下，判定能够成为回文串，<br>如果可以则输出首次删除一个字符所能得到的回文字，如果不行则输出字符串“false”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPali</span><span class="hljs-params">(string str)</span> </span>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br><span class="hljs-keyword">if</span> (str[left] != str[right]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>left++, right--;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str;<br><span class="hljs-built_in">getline</span>(cin, str);<br>string res = <span class="hljs-string">&quot;false&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>string s = str;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPoli</span>(s)) &#123;<br>res = s;<br><span class="hljs-keyword">break</span>;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPali</span>(s.<span class="hljs-built_in">erase</span>(i, <span class="hljs-number">1</span>))) &#123;<br>res = s;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br>cout &lt;&lt; res;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编程题2-1"><a href="#编程题2-1" class="headerlink" title="编程题2"></a>编程题2</h3><p>矩形格子，字符 ‘@’ 和 ‘#’ 代表障碍物，指定起点和终点，求最短路径的长度，无法到达则返回-1</p><h3 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3// 维度为3*3的矩形<br>0 0 2 2// 起点 （0，0）终点（2，2）<br>1@3// 迷宫描述<br>1@#<br>123<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; map;<br>vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; isVis;<br><span class="hljs-type">int</span> endX, endY, n;<br><span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> MIN = INT_MAX;<br><span class="hljs-type">int</span> off[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125; &#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (isVis[x][y]) <span class="hljs-keyword">return</span>;<br>isVis[x][y] = <span class="hljs-literal">true</span>;<br>depth++;<br><br><span class="hljs-keyword">if</span> (x == endX &amp;&amp; y == endY) &#123;<br>MIN = <span class="hljs-built_in">min</span>(MIN, depth);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br><span class="hljs-type">int</span> xi = x + off[i][<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> yi = y + off[i][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (xi &gt;= <span class="hljs-number">0</span> &amp;&amp; xi &lt; n &amp;&amp; yi &gt;= <span class="hljs-number">0</span> &amp;&amp; yi &lt; n &amp;&amp;<br>map[xi][yi] != <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; map[xi][yi] != <span class="hljs-string">&#x27;@&#x27;</span>) &#123;<br><span class="hljs-built_in">dfs</span>(xi, yi);<br>&#125;<br>&#125;<br>depth--;<br>isVis[x][y] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> startX, startY;<br>cin &gt;&gt; n;<br>cin &gt;&gt; startX;<br>cin &gt;&gt; startY;<br>cin &gt;&gt; endX;<br>cin &gt;&gt; endY;<br>map.<span class="hljs-built_in">resize</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(n, <span class="hljs-string">&#x27; &#x27;</span>));<br>isVis.<span class="hljs-built_in">resize</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>cin &gt;&gt; map[i][j];<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">dfs</span>(startX, startY);<br>cout &lt;&lt; (MIN == INT_MAX ?  <span class="hljs-number">-1</span> : MIN );<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="美团点评20200913"><a href="#美团点评20200913" class="headerlink" title="美团点评20200913"></a>美团点评20200913</h1><h3 id="编程题1-2"><a href="#编程题1-2" class="headerlink" title="编程题1"></a>编程题1</h3><p>回文矩阵，按行回文，找到最小非回文矩阵</p><h3 id="输入描述：-6"><a href="#输入描述：-6" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">8 3// 8 * 3矩阵<br>1 0 1<br>0 1 0<br>0 1 0<br>1 0 1<br>1 0 1<br>0 1 0<br>0 1 0<br>1 0 1<br></code></pre></td></tr></table></figure><h3 id="输出描述：-6"><a href="#输出描述：-6" class="headerlink" title="输出描述："></a>输出描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1 0 1<br>0 1 0<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; arr;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; v1, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; v2) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v1.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><span class="hljs-keyword">if</span> (v1[i] != v2[i])<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPali</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; arr)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br><span class="hljs-keyword">if</span> (arr[left] != arr[right])<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>left++, right--;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main1</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n;<br>cin &gt;&gt; m;<br>arr.<span class="hljs-built_in">resize</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>cin &gt;&gt; arr[i][j];<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> right = n;<br><span class="hljs-keyword">while</span> (right) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPali</span>(arr)) &#123;<br>right /= <span class="hljs-number">2</span>;<br>arr.<span class="hljs-built_in">erase</span>(arr.<span class="hljs-built_in">begin</span>() + right, arr.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">continue</span>;<br>&#125; <br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> lev : arr) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : lev) &#123;<br>cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编程题2-2"><a href="#编程题2-2" class="headerlink" title="编程题2"></a>编程题2</h3><p>一个齿轮，26个齿A~Z，每个齿轮两个按钮，按钮1：跟前轮啮合并逆时针转一格，按钮2：跟后轮啮合并逆时针转一格，按完按钮恢复原状。<br>用所有齿轮正上方的字母组成一个字符串，给定初始齿轮状态，统计所有无重复字符串的个数。<br>注意：A不能转到Z，Z不能转到A, </p><h3 id="输入描述：-7"><a href="#输入描述：-7" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">2// 2个齿轮<br>BB// 2个齿轮初始状态 B B<br>3// 3个齿轮<br>ABA// 3个齿轮初始状态 A B A <br></code></pre></td></tr></table></figure><h3 id="输出描述：-7"><a href="#输出描述：-7" class="headerlink" title="输出描述："></a>输出描述：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3// 结果对998244353取模<br>3<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; res;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">sol</span><span class="hljs-params">(string str)</span> </span>&#123;<br>res.<span class="hljs-built_in">clear</span>();<br>string s = str;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>s = str;<br>s[i] += <span class="hljs-number">1</span>;<br>s[i + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; s[i + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;A&#x27;</span>)<br>res.<span class="hljs-built_in">push_back</span>(s);<br>&#125; <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (i == str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>s = str;<br>s[i] += <span class="hljs-number">1</span>;<br>s[i - <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;A&#x27;</span>)<br>res.<span class="hljs-built_in">push_back</span>(s);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s = str;<br>s[i] += <span class="hljs-number">1</span>;<br>s[i + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; s[i + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;A&#x27;</span>)<br>res.<span class="hljs-built_in">push_back</span>(s);<br>s = str;<br>s[i] += <span class="hljs-number">1</span>;<br>s[i - <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;A&#x27;</span>)<br>res.<span class="hljs-built_in">push_back</span>(s);<br>&#125;<br>&#125;<br><span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">set</span><span class="hljs-params">(res.begin(), res.end())</span></span>;<br><span class="hljs-keyword">return</span> (set.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) % <span class="hljs-number">998244353</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n;<br>string str;<br>vector&lt;string&gt; strs;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, str)) &#123; <span class="hljs-comment">// 必须使用ctrl + z结束输入</span><br><span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>strs.<span class="hljs-built_in">push_back</span>(str);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>cout &lt;&lt; <span class="hljs-built_in">sol</span>(strs[i]) &lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="联发科20200915"><a href="#联发科20200915" class="headerlink" title="联发科20200915"></a>联发科20200915</h1><h3 id="选择题考点：-1"><a href="#选择题考点：-1" class="headerlink" title="选择题考点："></a>选择题考点：</h3><ul><li>linux进程间通信有哪些</li><li>关于内存泄漏</li><li>C++函数中参数传递的方式</li><li>static修饰的局部变量、全局变量、函数、成员变量的作用分别是</li><li>列举TCP&#x2F;IP五层参考模型</li><li>可执行程序加载时系统分配的内存可以分为哪几段</li></ul><h3 id="编程题1-3"><a href="#编程题1-3" class="headerlink" title="编程题1"></a>编程题1</h3><p>手写查找子字符串C函数<code>int strstr(char * str1, char * str2)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：&quot;abcdefabcdef&quot;,&quot;def&quot;<br>输出：3//找到输出第一个下标 没找到输出-1<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">my_strstr</span><span class="hljs-params">(<span class="hljs-type">char</span>* str1, <span class="hljs-type">char</span>* str2)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (str2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (*str1 != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span> (*str1 != *str2) &#123;<br>str1++;<br>idx++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">char</span> * p1 = str1;<br><span class="hljs-type">char</span> * p2 = str2;<br><span class="hljs-keyword">while</span> (*p2 != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span> (*p2 == *p1) &#123;<br>p1++; p2++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (*p2 == <span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-keyword">return</span> idx;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">char</span> str1[<span class="hljs-number">100</span>];<br><span class="hljs-type">char</span> str2[<span class="hljs-number">100</span>];<br>cin &gt;&gt; str1;<br>cin &gt;&gt; str2;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">my_strstr</span>(str1, str2));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2021届秋招笔试题汇总&quot;&gt;&lt;a href=&quot;#2021届秋招笔试题汇总&quot; class=&quot;headerlink&quot; title=&quot;2021届秋招笔试题汇总&quot;&gt;&lt;/a&gt;2021届秋招笔试题汇总&lt;/h1&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="面试" scheme="https://www.mingsrc.work/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>题解目录</title>
    <link href="https://www.mingsrc.work/posts/fca5c66f"/>
    <id>https://www.mingsrc.work/posts/fca5c66f</id>
    <published>2022-12-27T03:12:54.075Z</published>
    <updated>2022-12-27T03:12:54.075Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="books-Leetcode题解目录-转载"><a href="#books-Leetcode题解目录-转载" class="headerlink" title=":books: Leetcode题解目录(转载)"></a>:books: Leetcode题解目录(转载)</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p><ul><li><p>为了进大厂🐛，目前进度<strong>208&#x2F;300</strong>题，特此记录刷过的所有题，涵盖了基本题型，精简的解题思路，此repo属于 <em><strong>C++</strong></em> 版的题解。</p></li><li><p>感谢您的观看，希望对您有帮助，欢迎热烈的交流🎉！如果感觉还不错就点个赞 <em><strong>star</strong></em> 吧✨✨✨~</p></li><li><p>这是我的🔥<a href="https://github.com/liuwentao1992">【github】</a> 里面有适合 <em><strong>C++</strong></em> 萌新的练手项目，热烈欢迎🎉帮助我收集整理题目或者提供解题思路🐳~。</p><span id="more"></span></li></ul><h1 id="🚀剑指offer题解"><a href="#🚀剑指offer题解" class="headerlink" title=" 🚀剑指offer题解  "></a> 🚀<a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%89%91%E6%8C%87offer.md">剑指offer题解</a>  </h1><h1 id="🚀程序员面试金典-​"><a href="#🚀程序员面试金典-​" class="headerlink" title=" 🚀程序员面试金典  ​"></a> 🚀<a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8.md">程序员面试金典</a>  ​</h1><h1 id="🎨算法思想"><a href="#🎨算法思想" class="headerlink" title="🎨算法思想"></a>🎨算法思想</h1><ul><li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%8F%8C%E6%8C%87%E9%92%88.md">双指针</a></li><li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E6%8E%92%E5%BA%8F.md">排序</a></li><li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md">贪心思想</a></li><li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E4%BA%8C%E5%88%86%E6%B3%95.md">二分查找</a></li><li>[分治]</li><li>[搜索]</li><li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md">动态规划</a></li><li>[数学]</li></ul><h1 id="snowflake-数据结构相关"><a href="#snowflake-数据结构相关" class="headerlink" title=":snowflake:数据结构相关"></a>:snowflake:数据结构相关</h1><ul><li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E9%93%BE%E8%A1%A8.md">链表</a></li><li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E6%A0%91.md">树</a></li><li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.md">栈和队列</a></li><li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%93%88%E5%B8%8C%E8%A1%A8.md">哈希表</a></li><li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2.md">字符串</a></li><li>[数组与矩阵]</li><li>[图]</li><li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E4%BD%8D%E8%BF%90%E7%AE%97.md">位运算</a></li></ul><h1 id="🎨力扣周赛"><a href="#🎨力扣周赛" class="headerlink" title="🎨力扣周赛"></a>🎨<a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B.md">力扣周赛</a></h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;books-Leetcode题解目录-转载&quot;&gt;&lt;a href=&quot;#books-Leetcode题解目录-转载&quot; class=&quot;headerlink&quot; title=&quot;:books: Leetcode题解目录(转载)&quot;&gt;&lt;/a&gt;:books: Leetcode题解目录(转载)&lt;/h1&gt;&lt;p&gt;转自：🔥&lt;a href=&quot;https://github.com/liuwentao1992&quot;&gt;【github】&lt;/a&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为了进大厂🐛，目前进度&lt;strong&gt;208&amp;#x2F;300&lt;/strong&gt;题，特此记录刷过的所有题，涵盖了基本题型，精简的解题思路，此repo属于 &lt;em&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/em&gt; 版的题解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;感谢您的观看，希望对您有帮助，欢迎热烈的交流🎉！如果感觉还不错就点个赞 &lt;em&gt;&lt;strong&gt;star&lt;/strong&gt;&lt;/em&gt; 吧✨✨✨~&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这是我的🔥&lt;a href=&quot;https://github.com/liuwentao1992&quot;&gt;【github】&lt;/a&gt; 里面有适合 &lt;em&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/em&gt; 萌新的练手项目，热烈欢迎🎉帮助我收集整理题目或者提供解题思路🐳~。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="力扣" scheme="https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>Linux指令（转载）</title>
    <link href="https://www.mingsrc.work/posts/10ebf187"/>
    <id>https://www.mingsrc.work/posts/10ebf187</id>
    <published>2022-12-27T03:12:54.075Z</published>
    <updated>2022-12-27T03:12:54.075Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p><span id="more"></span><h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><ul><li><a href="#%E5%88%87%E6%8D%A2%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB">切换运行级别</a>  </li><li><a href="#%E5%B8%AE%E5%8A%A9%E6%8C%87%E4%BB%A4">帮助指令</a>  </li><li><a href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B1%BB">文件目录</a>  </li><li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91">重定向(覆盖追加操作)</a>  </li><li><a href="#%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%91%BD%E4%BB%A4">时间日期</a>  </li><li><a href="#%E6%90%9C%E7%B4%A2%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4">搜索查找</a>  </li><li><a href="#%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B">压缩解压</a></li></ul><h2 id="切换运行级别"><a href="#切换运行级别" class="headerlink" title="切换运行级别"></a>切换运行级别</h2><p><code>0:关机</code> <code>1:单用户</code> <code>2:多用户没有网络</code> <code>3:多用户有网络</code><br><code>4:系统未使用保留给用户</code> <code>5:图像界面</code> <code>6:系统重启</code> 常用3和5，忘记密码时切到1改密码<br></p><pre><code>init 0~5</code></pre><h2 id="帮助指令-不如百度）"><a href="#帮助指令-不如百度）" class="headerlink" title="帮助指令(不如百度）"></a>帮助指令(不如百度）</h2><pre><code>man ls                                 //获取帮助信息help cd                                //获取shell内置命令帮助信息</code></pre><h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><pre><code>pwd                                     //当前绝对路径ls -al                                  //列表方式显示所有文件和目录包括隐藏的cd ~  cd                                      //回到家目录cd ..                                   //回到上一级目录mkdir -p /home/animals/dog              //创建多级目录 rmdir /home/animals/dog                 //删除空目录rm -rf                                  //删除非空目录 -r递归 -f忽略警告rm                                      //删除文件tough hello.txt world.txt               //创建多个空文件cp hello.txt dest/                      //将文件拷贝到destcp -r source/ dest/                     //将source整个目录所有文件拷贝到dest，同名文件回提示\cp -r source/ dest/                    //强制覆盖同名文件且不提示mv old.txt new.txt                      //重命名mv old.txt /root/                       //将当前目录中old文件移动到根目录中   </code></pre><h2 id="查看文件"><a href="#查看文件" class="headerlink" title=" 查看文件"></a> 查看文件</h2><pre><code>cat -n /etc/profile                     //只读方式查看文件内容 -n显示行号cat -n /etc/profile | more              //长配合一个管道 more分页浏览more                                    //space下翻 enter上翻 q离开 ctrl+f下滚 ctrl+b上滚less                                    //适合加载查看大日志，space pageDown pageUp上下翻 q离开head /etc/profile                       //查看前10行head -n 5 /etc/profile                  //查看前5行tail /etc/profile                       //查看后10行tail -n 5 /etc/profile                  //查看后5行tail -f data.txt                        //实时监控，如有变化立即显示</code></pre><h2 id="重定向-覆盖追加操作）"><a href="#重定向-覆盖追加操作）" class="headerlink" title="重定向(覆盖追加操作）"></a>重定向(覆盖追加操作）</h2><pre><code>ls -l &gt; new.txt                         //列表内容覆盖写入文件ls -l /home/ &gt; /home/info.txt           //home目录列表写入文件中ls -l &gt;&gt; new.txt                        //只追加cat /etc/profile &gt; new.txt              //覆盖echo &quot;hello&quot;                            //输出内容到控制台echo $PATH                              //输出环境变量history 10                              //显示最近使用过的10个命令！5                                     //执行编号为5的指令</code></pre><h2 id="时间日期命令"><a href="#时间日期命令" class="headerlink" title=" 时间日期命令"></a> 时间日期命令</h2><pre><code>data                        //显示当前时间data &quot;+%Y-%m-%d %H:%M:%S&quot;   //年-月-日 时：分：秒data -s &quot;2020-3-3 23:22:00&quot; //设置系统当前时间cal                         //显示本月日历cal 2020                    //显示一年的</code></pre><h2 id="搜索查找命令"><a href="#搜索查找命令" class="headerlink" title="搜索查找命令"></a>搜索查找命令</h2><pre><code>find /home -name hello.txt              //搜home目录下（包括子目录）名为hello的文件，find /opt -user lwt                     //搜索用户为lwt的所有文件find / -size +20M                       //搜整个系统下大于20m的文件find / -size -20M                       //小于find / -name *.txt                      //搜所有后缀为txt文件updatedb                                //第一次使用locate命令前必须先更新数据库locate hello.txt                        //快速定位文件路径cat hello.txt |grep -n yes              //过滤查找，查找yes所在行显示行号，区分大小写cat hello.txt |grep -ni yes             //过滤查找，区分大小写</code></pre><h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><pre><code>gzip hello.txt                          //压缩不保留原来文件，压缩成*.gz文件 gunzip hello.txt.gz                     //当前目录下解压zip -r package.zip /home/               //将home下所有文件压缩成package.zipunzip -d /opt/tmp package.zip           //解压到/opt/tmp目录下tar -zcvf dest.tar.gz source1.txt source2.txt  //压缩多个文件，打包结尾*.tar.gz文件tar -zcvf dest.tar.gz /home/            //压缩整个honme文件tar -zxvf dest.tar.gz                   //解压到当前目录tar -zxvf dest.tar.gz -C /opt/tmp       //-C指定到目录，tmp必须先存在</code></pre><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;转自：🔥&lt;a href=&quot;https://github.com/liuwentao1992&quot;&gt;【github】&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    <category term="Linux" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/Linux/"/>
    
    
    <category term="Liux" scheme="https://www.mingsrc.work/tags/Liux/"/>
    
    <category term="Linux指令" scheme="https://www.mingsrc.work/tags/Linux%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>C++&amp;LeetCode</title>
    <link href="https://www.mingsrc.work/posts/da77844e"/>
    <id>https://www.mingsrc.work/posts/da77844e</id>
    <published>2022-12-27T03:12:54.074Z</published>
    <updated>2022-12-27T03:12:54.074Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="贪心算法" scheme="https://www.mingsrc.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>🐳链表🐳</title>
    <link href="https://www.mingsrc.work/posts/2bc70af9"/>
    <id>https://www.mingsrc.work/posts/2bc70af9</id>
    <published>2022-12-27T03:12:54.074Z</published>
    <updated>2022-12-27T03:12:54.074Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🐳链表🐳"><a href="#🐳链表🐳" class="headerlink" title="🐳链表🐳"></a>🐳链表🐳</h1><span id="more"></span><p>排序由易到难  </p><ul><li><a href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9">19.删除链表的倒数第N个节点</a></li><li><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">21.合并两个有序链表</a></li><li><a href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9">24.两两交换链表中的节点</a></li><li><a href="#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">83.删除排序链表中的重复元素</a></li><li><a href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">141.环形链表</a></li><li><a href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8">160.相交链表</a></li><li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">206.反转链表</a></li><li><a href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">234.回文链表</a></li><li><a href="#%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8">328.奇偶链表</a></li><li><a href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II">445.两数相加II</a></li><li><a href="#%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8">725.分隔链表</a>  </li><li><a href="#%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6">817.链表组件</a></li></ul><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">Leetcode</a>  给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>使用快慢指针法，让快指针提前先走n+1步，再同步快慢指针直到快指针指向链表结尾时，慢指针刚好停留在需要删除结点的前驱。</li><li>添加头结点 <code>dummy</code> 是为了统一对链表增删的操作。</li><li>删除结点相当于链接时跳过此结点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next=head;<br>    ListNode* fast=dummy;<br>    ListNode* slow=dummy；<br>    <span class="hljs-type">int</span> cnt=n+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(cnt--)&#123;<br>        fast=fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(fast)&#123;<br>        fast=fast-&gt;next;<br>        slow=slow-&gt;next;<br>    &#125;<br>    slow-&gt;next=slow-&gt;next-&gt;next;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">Leetcode</a>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3></li><li>合并为一个新的链表用尾插法，三个指针：l1，l2用于遍历两个链表，cur用于遍历新的链表</li><li>涉及新建链表一般都需要new一个头结点和定义一个指针用于遍历。</li><li>同时遍历两个链表，把比较小的结点用尾插法插入到新的链表中，再更新指针。</li><li><code>while</code>结束标志为：其中一个链表遍历结束</li><li>如果一个链表遍历结束，另一个未结束，则把未结束的剩余部分链接上<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    ListNode* head=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* cur=head;<br>    <span class="hljs-comment">//尾插法</span><br>    <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;<br>        <span class="hljs-keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;<br>            cur-&gt;next=l1;<br>            l1=l1-&gt;next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cur-&gt;next=l2;<br>            l2=l2-&gt;next;<br>        &#125;<br>        cur=cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!l1) cur-&gt;next=l2;<br>    <span class="hljs-keyword">if</span>(!l2) cur-&gt;next=l1;<br>    <span class="hljs-keyword">return</span> head-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">Leetcode</a>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.<br></code></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3></li><li>使用头节点，用于链表第一结点与其他结点增删改的统一。</li><li>定义三个指针，cur用于遍历原链表，p1,p2用于交换（p2指向p1的后继结点）</li><li>链接的顺序：1-&gt;3  2-&gt;1 cur-&gt;2</li><li>注意：cur指针每次向前跳两步。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next=head;<br>    ListNode* cur=dummy;<br>    ListNode* p1=dummy;<br>    ListNode* p2=dummy;<br>    <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123;<br>        p1=cur-&gt;next;<br>        p2=cur-&gt;next-&gt;next;<br>        p1-&gt;next=p2-&gt;next;<br>        p2-&gt;next=p1;<br>        cur-&gt;next=p2;<br>        cur=cur-&gt;next-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素  "></a>删除排序链表中的重复元素  </h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">Leetcode</a>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>链表中删除一个结点相当于指针越过该结点（next指针指向要删除结点的后继）</li><li>直到cur与下一个结点值不同时，更新指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>       ListNode* cur=head;<br>       <span class="hljs-keyword">while</span>(cur &amp;&amp; cur-&gt;next)&#123;<br>           <span class="hljs-keyword">if</span>(cur-&gt;val == cur-&gt;next-&gt;val) <br>cur-&gt;next=cur-&gt;next-&gt;next;<br>           <span class="hljs-keyword">else</span> <br>cur=cur-&gt;next; <br>       &#125;<br>       <span class="hljs-keyword">return</span> head;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">leetcode</a>给定一个链表，判断链表中是否有环。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>当快指针检查到无下一节点时，说明该链表无环，当链表中不存在环时，快指针终将优先到达链表尾部。</li><li>当快指针与慢指针相遇（指向同一个节点）时，说明该链表有环。快指针追上慢指针了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    ListNode* slow = head;<br>    ListNode* fast = head;<br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">leetcode</a>编写一个程序，找到两个单链表相交的起始节点。  </p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>分别遍历一条链表，当遍历到结尾时让指针指向另一条链表的头部继续遍历另一条，当两个指针相等时即相交的位置</li><li>原理：加入两条链表相交，链表1为<code>A+C</code>,链表2为<code>B+C</code>， C为两条链表相交以后的公共部分，此时指针p1遍历的长度为<code>A+C+B</code>,指针p2遍历长度为<code>B+C+A</code>,两指针刚好落在相交部分的开头，因为如果继续遍历的话，两个指针都将同时遍历C部分。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">NULL</span> &amp;&amp; headB == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">NULL</span> || headB == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    ListNode* p1 = headA;<br>    ListNode* p2 = headB;<br>    <span class="hljs-keyword">while</span>(p1 != p2) &#123;<br>        p1 = p1 == <span class="hljs-literal">NULL</span> ? headB : p1-&gt;next;<br>        p2 = p2 == <span class="hljs-literal">NULL</span> ? headA : p2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表  "></a>反转链表  </h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">Leetcode</a> 反转一个单链表。</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>链表的头插法实现反转，需要两个指针，当前指针<code>cur</code>,新链表头部指针<code>pre</code></li><li>因为需要改变当前结点next指针指向pre，所以必须先记录下next指针最后再恢复，才能让cur继续在链中遍历下去。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* pre = <span class="hljs-literal">NULL</span>;<br>    ListNode* cur = head;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">leetcode</a>请判断一个链表是否为回文链表。  <h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3></li><li>用快慢指针法先找到中间结点，用头插法反转后一半链表，用双指针比较两个链表。</li><li>快慢指针注意while的结束条件：<ul><li>如果<code>while(fast &amp;&amp; fast-&gt;next)</code>则奇数链表慢指针指向中间结点，偶数链表慢指针指向后一半链表头部。</li><li>如果<code>while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next</code>则不论奇数偶数链表，慢指针都指向后一半链表的前一个结点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    ListNode * slow = head;<br>    ListNode * fast = head;<br>    <span class="hljs-keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br>    ListNode* cur = slow-&gt;next;<br>    ListNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = tmp;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (pre &amp;&amp; head) &#123;<br>        <span class="hljs-keyword">if</span>(pre-&gt;val != head-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = pre-&gt;next;<br>        head =head-&gt;next;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h1><p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">leetcode</a>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。  </p><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>需要两个指针，一个指向奇数结点，一个指向偶数结点，分别往后跳跃遍历</li><li>注意while循环的结束条件，因为两个指针都是跳跃一步的往后遍历，所以只有指针的下一步不是NULL时才能跳跃。</li><li>注意提前保存偶数链表的头部，用于之后的拼接。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>     ListNode* odd = head;<br>     ListNode* even = head-&gt;next;<br>     ListNode* preEven = even;<br>     <span class="hljs-keyword">while</span> (odd-&gt;next &amp;&amp; even-&gt;next) &#123;<br>         odd-&gt;next = odd-&gt;next-&gt;next;<br>         odd = odd-&gt;next;<br>         even-&gt;next = even-&gt;next-&gt;next;<br>         even = even-&gt;next;<br>     &#125;<br>     odd-&gt;next = preEven;<br>     <span class="hljs-keyword">return</span> head;<br> &#125; <br></code></pre></td></tr></table></figure></li></ul><h1 id="两数相加II"><a href="#两数相加II" class="headerlink" title="两数相加II"></a>两数相加II</h1><p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">leetcode</a>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。<br>你可以假设除了数字 0 之外，这两个数字都不会以零开头。如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>题意，不能反转链表，那么对于这种逆序操作第一要想到用栈。</li><li>本体使用了三种技巧：1、使用栈逆序储存，2、两数相加（涉及到进位carry的操作），3、头插法建立链表.</li><li>注意：当某一个位没有数时（即栈为空时）用0代替，进行相加。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; sck1, sck2;<br>    <span class="hljs-keyword">while</span> (l1) &#123;<br>        sck1.<span class="hljs-built_in">push</span>(l1-&gt;val);<br>        l1 = l1-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l2) &#123;<br>        sck2.<span class="hljs-built_in">push</span>(l2-&gt;val);<br>        l2 = l2-&gt;next;<br>    &#125;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, carry = <span class="hljs-number">0</span>;<br>    ListNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (!sck1.<span class="hljs-built_in">empty</span>() || !sck2.<span class="hljs-built_in">empty</span>() || carry) &#123;<br>        <span class="hljs-keyword">if</span> (!sck1.<span class="hljs-built_in">empty</span>()) &#123;<br>            a = sck1.<span class="hljs-built_in">top</span>();<br>            sck1.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            a = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!sck2.<span class="hljs-built_in">empty</span>()) &#123;<br>            b = sck2.<span class="hljs-built_in">top</span>();<br>            sck2.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            b = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = a + b + carry;<br>        carry = sum / <span class="hljs-number">10</span>;<br>        sum %= <span class="hljs-number">10</span>;<br>        ListNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum);<br>        newNode-&gt;next = pre;<br>        pre = newNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h1><p><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">leetcode</a>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。<br>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。<br>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。<br>返回一个符合上述规则的链表的列表。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: <br>root = [1, 2, 3], k = 5<br>输出: [[1],[2],[3],[],[]]<br><br>输入: <br>root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3<br>输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br></code></pre></td></tr></table></figure><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本体涉及的技巧有：计算链表长度，计算每段的长度，分割并储存链表(定位尾部，保存头部)</li><li>首先计算链表总长度，根据k值求出每段的平均长度，由题意任意两部分的长度差距不能超过 1，且较长的在前面，所以将余的部分平均分给前面的链表长度上面。</li><li>得到每一段的长度后，开始分割链表，链表的分割只需要遍历到尾结点，在尾节点后加NULL即可，而储存链表时只需要储存链表头结点即可。</li><li>注意：已知链表长度，通过<code>while(--len &gt; 0）</code>来定位链表尾部时，<code>while</code>里面要先自减。</li><li>注意：在尾结点后加NULL分割链表之前，防止下一步丢失，要事先保存下一步的结点，以便更新当前结点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">splitListToParts</span><span class="hljs-params">(ListNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    ListNode* cur = root;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        len++;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-type">int</span> averageLen = len / k;<br>    <span class="hljs-type">int</span> surplusLen = len % k;<br>    <span class="hljs-type">int</span> curLen = <span class="hljs-number">0</span>;<br>    cur = root;<br>    vector&lt;ListNode*&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(cur);<br>        <span class="hljs-keyword">if</span> (surplusLen-- &gt; <span class="hljs-number">0</span>) &#123;<br>            curLen = averageLen + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            curLen = averageLen;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (--curLen &gt; <span class="hljs-number">0</span> )&#123;<br>            cur = cur-&gt;next;   <br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>            ListNode* tmp = cur-&gt;next;<br>            cur-&gt;next = <span class="hljs-literal">NULL</span>;<br>            cur = tmp;<br>        &#125;   <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="链表组件"><a href="#链表组件" class="headerlink" title="链表组件"></a>链表组件</h1><p><a href="https://leetcode-cn.com/problems/linked-list-components/">leetcode</a>给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。<br>同时给定列表 G，该列表是上述链表中整型值的一个子集。<br>返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: <br>head: 0-&gt;1-&gt;2-&gt;3<br>G = [0, 1, 3]<br>输出: 2<br>解释: <br>链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。<br><br>输入: <br>head: 0-&gt;1-&gt;2-&gt;3-&gt;4<br>G = [0, 3, 1, 4]<br>输出: 2<br>解释: <br>链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。<br><br></code></pre></td></tr></table></figure><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>首先为<code>G</code>列表的值建立一个bool类数组，（也可以使用哈希表，但是效率太低）用于遍历链表时检查结点是否属于G列表中的结点。</li><li>一遍遍历整个链表，当遇到第一个属于<code>G</code>列表中的结点时，组件数量就加1，并继续往后遍历找到组件的结尾，非<code>G</code>列表中的结点直接忽略即可。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> isIn[<span class="hljs-number">10000</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numComponents</span><span class="hljs-params">(ListNode* head, vector&lt;<span class="hljs-type">int</span>&gt;&amp; G)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : G) &#123;<br>        isIn[it] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    ListNode* cur = head;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (isIn[cur-&gt;val] == <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> &amp;&amp; isIn[cur-&gt;val] == <span class="hljs-literal">true</span>) <br>                cur = cur-&gt;next;<br>            cnt++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur-&gt;next;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;🐳链表🐳&quot;&gt;&lt;a href=&quot;#🐳链表🐳&quot; class=&quot;headerlink&quot; title=&quot;🐳链表🐳&quot;&gt;&lt;/a&gt;🐳链表🐳&lt;/h1&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="力扣" scheme="https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="链表" scheme="https://www.mingsrc.work/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>树🌲</title>
    <link href="https://www.mingsrc.work/posts/ca16bf90"/>
    <id>https://www.mingsrc.work/posts/ca16bf90</id>
    <published>2022-12-27T03:12:54.073Z</published>
    <updated>2022-12-27T03:12:54.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="seedling-树"><a href="#seedling-树" class="headerlink" title=":seedling:树"></a>:seedling:树</h1><span id="more"></span><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">94.二叉树的中序遍历</a>  </li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">144.二叉树的前序遍历</a>  </li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">145.二叉树的后序遍历</a>  </li><li><a href="%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">98.验证二叉搜索树</a></li><li><a href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">101.对称二叉树</a>  </li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">102.二叉树的层序遍历</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86II">107.二叉树的层次遍历II</a></li><li><a href="#103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86">103.二叉树的锯齿形层次遍历</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">104.二叉树的最大深度</a>  </li><li><a href="#110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">110.平衡二叉树</a>  </li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6">111.二叉树的最小深度</a>  </li><li><a href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C">112.路径总和</a>  </li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C">124.二叉树中的最大路径和</a></li><li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">230.二叉搜索树中第K小的元素</a>  </li><li><a href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">226.翻转二叉树</a>  </li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">236.二叉树的最近公共祖先</a></li><li><a href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC">513.找树左下角的值</a>     </li><li><a href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91">617.合并二叉树</a>  </li><li><a href="#%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84">687.最长同值路径</a>  </li><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9">671.二叉树中第二小的节点</a>  </li><li><a href="#%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">669.修剪二叉搜索树</a>  </li><li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">701.二叉搜索树中的插入操作</a></li></ul><!--more--><h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">Leetcode</a>给定一个二叉树，返回它的迭代中序遍历。  </p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>使用辅助栈，中序遍历是访问顺序左-中-右</li><li>所以每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;res;<br>    stack&lt;TreeNode*&gt;sck;<br>    TreeNode*cur=root;<br>    <span class="hljs-keyword">while</span>(cur || !sck.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            sck.<span class="hljs-built_in">push</span>(cur);<br>            cur=cur-&gt;left;<br>        &#125;<br>        cur=sck.<span class="hljs-built_in">top</span>();<br>        res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        sck.<span class="hljs-built_in">pop</span>();<br>        cur=cur-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">Leetcode</a>  </p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>非递归实现需要辅助栈</li><li>因为栈是先进后出，而前序遍历顺序是：<code>root =&gt; left =&gt; right</code>  所以right先入栈left后入栈</li><li>由于一开始的left和right的地址需要通过root结点获得，所以开始需要先将root入栈<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; sck;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    TreeNode*cur = <span class="hljs-literal">NULL</span>;<br>    sck.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!sck.<span class="hljs-built_in">empty</span>())&#123;<br>        cur = sck.<span class="hljs-built_in">top</span>();<br>        res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        sck.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cur-&gt;right) sck.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left) sck.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">Leetcode</a>  </p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>后序遍历顺序<code>left =&gt; right =&gt; root</code> ,变换的前序遍历顺序<code>root =&gt; right =&gt; left</code>，结果反转则为后序</li><li>前序遍历 + 反转结果即可<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; sck;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    sck.<span class="hljs-built_in">push</span>(root);<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(!sck.<span class="hljs-built_in">empty</span>())&#123;<br>        cur = sck.<span class="hljs-built_in">top</span>();<br>        res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        sck.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cur-&gt;left) sck.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right) sck.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(res);<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; arr)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; --i)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">leetcode</a>给定一个二叉树，判断其是否是一个有效的二叉搜索树。<br>假设一个二叉搜索树具有如下特征：<br>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>二叉搜索树的典型特点：中序遍历就是一个升序的序列，所以验证的方法就显而易见</li><li>中序遍历存入数组，验证数组是否是严格单调递增的</li><li>看大佬得题解还有更简洁的方法 : 因为是中序遍历，所以只要维护一个记录上一个结点值得变量，每遍历一个点进行一次比较和更新，如果发现小于上个结点值就返回<code>false</code>，注意比较和更新得顺序不能反。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; res;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">inorder</span>(root);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; res.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (res[i - <span class="hljs-number">1</span>] &gt;= res[i]) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>    res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>更简洁得方式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> pre = Long.MIN_VALUE;<br><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == null)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidBST</span>(root.left)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    <span class="hljs-keyword">if</span> (root.val &lt;= pre)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    pre = root.val;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isValidBST</span>(root.right);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">Leetcode</a>给定一个二叉树，检查它是否是镜像对称的。</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>双指针再树中应用。</li><li>两个指针分别递归遍历两颗树。</li><li>两棵树要想对称，首先他们的子树必须对称，其次他们的根结点必须相等，可以使用后序遍历<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(root-&gt;left, root-&gt;right);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span>&#123;<br>   <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> || right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(left-&gt;left, right-&gt;right) &amp;&amp; <br>          <span class="hljs-built_in">isSymmetric</span>(left-&gt;right, right-&gt;left) &amp;&amp;<br>          left-&gt;val == right-&gt;val;  <br> &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">leetcode</a>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回其层次遍历结果：<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]<br></code></pre></td></tr></table></figure><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>典型的BFS遍历二叉树，使用了队列，</li><li>牢记模板，注意：输出的数组是二维数组，并不是简单的遍历，中间需要<code>size</code>变量来记录每一行的个数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; res; <br>    queue&lt;TreeNode*&gt; que;<br>    <span class="hljs-keyword">if</span> (root) que.<span class="hljs-built_in">push</span>(root);<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; level;<br>        <span class="hljs-keyword">while</span> (size--) &#123;               <br>            cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            level.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right) que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125; <br>        <span class="hljs-keyword">if</span> (!level.<span class="hljs-built_in">empty</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;  <br></code></pre></td></tr></table></figure></li></ul><h1 id="二叉树的层次遍历II"><a href="#二叉树的层次遍历II" class="headerlink" title="二叉树的层次遍历II"></a>二叉树的层次遍历II</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">leetcode</a>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>基本过程与上题的层序遍历一样，</li><li>区别在对结果的处理，两种方式：<code>reverse()</code>反转结果，或者插入的时候用头插法，但是因为使用的是vector所以头插法效率极低。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br>    queue&lt;TreeNode*&gt; que;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; res;<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; level;<br>        <span class="hljs-keyword">while</span> (size--) &#123;<br>            cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            level.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur-&gt;left !=<span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right !=<span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(level);<br>        <span class="hljs-comment">//res.insert(res.begin(),level); // 头插法</span><br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="二叉树的锯齿形层次遍历"><a href="#二叉树的锯齿形层次遍历" class="headerlink" title="二叉树的锯齿形层次遍历"></a>二叉树的锯齿形层次遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">leetcode</a>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>主题部分与上两题的层序遍历一致，只是多了一个层数的变量，当层数为偶数从左到右插入，层数为奇数头插法实现从右到左。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>    queue&lt;TreeNode*&gt; que;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; res;<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-type">int</span> levelNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; level;<br>        <span class="hljs-keyword">while</span> (size--) &#123;<br>            cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (levelNum % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                level.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                level.<span class="hljs-built_in">insert</span>(level.<span class="hljs-built_in">begin</span>(), cur-&gt;val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right) que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        levelNum++;<br>        res.<span class="hljs-built_in">push_back</span>(level);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">Leetcode</a>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。</p><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>每个结点得最大深度都需要先知道其两个子结点的最大深度，所以使用后序遍历，先遍历左右子树。</li><li>函数意义：返回该结点的最大深度。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">maxDepth</span>(root-&gt;left);<br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">maxDepth</span>(root-&gt;right);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">Leetcode</a>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>先判断左右两个子节点是否平衡，再处理当前结点，所以采用后序遍历</li><li>使用哈希表来记录每个结点的最高高度，而每个结点的最高高度也是受其左右子结点的影响，所以可以借着第一条的后序遍历来添加每个结点的高度 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_map&lt;TreeNode*, <span class="hljs-type">int</span>&gt; height;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        height[root] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isBalanced</span>(root-&gt;left) || !<span class="hljs-built_in">isBalanced</span>(root-&gt;right)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    height[root] = <span class="hljs-built_in">max</span>(height[root-&gt;left], height[root-&gt;right]) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(height[root-&gt;left] - height[root-&gt;right]) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">leetcode</a>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>与二叉树最大深度类似，要求每个结点的深度都需要先计算其左右子节点的深度，所以采用后序遍历</li><li>注意：有些结点只有一个子结点，再比较左右子结点的最小值时，返回值可能会返回最小值0，所以应该避免这种情况，返回非空的那条子结点深度  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">minDepth</span>(root-&gt;left);<br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">minDepth</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(left, right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h1><p><a href="https://leetcode-cn.com/problems/path-sum/">leetcode</a>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>从root结点开始遍历，每经过一个结点，sum 值就减去当前节点的权值，直到sum值为0时表示发现路径，由题意路径结尾必须是叶子，所以还需要判断最后是否是叶子结点  </li><li>因为每个子结点需要处理的sum值都与母结点有关，所以采用自上而下的先序遍历，先处理母结点，再处理子结点  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    sum-=root-&gt;val;<br>    <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span> &amp;&amp; root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">leetcode</a>给定一个非空二叉树，返回其最大路径和。<br>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这种可以不经过root结点的路径和，首先想到一条路径一定由三部分构成，<code>左子树路径+中间结点+右子树路径</code></li><li>当前结点的最大路径和与他的左右子树相关，所以先访问子树，是后序遍历。</li><li>注意：一个结点返回的不应该是此结点的最大路径和，而应该是单边最大路径给上游</li><li>注意：因为路径和可能会有负数出现，可以采用<code>max(0,)</code>的方式去掉负值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = INT_MIN;<br>    <span class="hljs-built_in">maxPathSum</span>(root, sum);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span>&amp; sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">maxPathSum</span>(root-&gt;left, sum));<br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">maxPathSum</span>(root-&gt;right, sum));<br>    sum = <span class="hljs-built_in">max</span>(sum, left + right + root-&gt;val);<br>    <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(left, right);<br>&#125; <br></code></pre></td></tr></table></figure><h1 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h1><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">Leetcode</a>   </p><ul><li>对于二叉搜索树中序遍历&#x3D;从小到大排序</li><li>需要记录遍历个数的变量  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,val=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">inorder</span>(root,k);<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode*root,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;left,k);<br>    <span class="hljs-keyword">if</span>(++cnt==k)val=root-&gt;val;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;right,k);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">Leetcode</a>    </p><ul><li>反转二叉树并返回根节点，交换当前根结点的左右子树<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode*tmp=<span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>    root-&gt;left=<span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>    root-&gt;right=tmp;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">leetcode</a>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><blockquote><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p></blockquote><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>首先什么样的结点才会是公共祖先：当某个结点，他的左子树中有p点，右子树中有q点，这个结点即为他俩的公共祖先</li><li>后序遍历：因为判断一个结点是否是祖先，需要知道他的左右子树有无p或q结点，所以需要先遍历子树。</li><li>注意：当发现中间结点的左右两个子树有一个返回为null说明这条路没有找到，而另一颗子树找到了，那么这个中间结点也需要向上游传递（返回）<code>我找到了的信息</code>.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p ,q);<br>    TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p ,q);<br>    <span class="hljs-keyword">if</span>(root == p || root == q) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h1><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">Leetcode</a>  </p><ul><li>层序遍历（用队列实现），从右往左，最后一个元素即为所求。</li><li>前序中序后续（用栈实现）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    queue&lt;TreeNode*&gt; NodeQueue;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    TreeNode*current=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//先让根节点入队</span><br>    NodeQueue.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-comment">//弹空队列</span><br>    <span class="hljs-keyword">while</span>(!NodeQueue.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-comment">//每个元素出队时，让其子节点入队</span><br>        current=NodeQueue.<span class="hljs-built_in">front</span>();<br>        NodeQueue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//保存每层数值</span><br>        res=current-&gt;val;*<br>        <span class="hljs-comment">//每层从右往左入队，最后一个元素即为最底层最左边的值</span><br>        <span class="hljs-keyword">if</span>(current-&gt;right!=<span class="hljs-literal">NULL</span>)NodeQueue.<span class="hljs-built_in">push</span>(current-&gt;right);<br>        <span class="hljs-keyword">if</span>(current-&gt;left!=<span class="hljs-literal">NULL</span>)NodeQueue.<span class="hljs-built_in">push</span>(current-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">Leetcode</a> 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。<br>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>函数意义：t2归并到t1里，返回t1</li><li>选择t1为主树，更新结点值到t1里。</li><li>因为树结构发生变化，所以需要重新链接左右子树</li><li>结束条件：当两个都是null结点则返回null，其中一个是null则返回另一个<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!t1 &amp;&amp; !t2) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(!t2) <span class="hljs-keyword">return</span> t1;<br>    <span class="hljs-keyword">if</span>(!t1) <span class="hljs-keyword">return</span> t2;<br>    t1-&gt;val+=t2-&gt;val;<br>    t1-&gt;left=<span class="hljs-built_in">mergeTrees</span>(t1-&gt;left,t2-&gt;left);<br>    t1-&gt;right=<span class="hljs-built_in">mergeTrees</span>(t1-&gt;right,t2-&gt;right);<br>    <span class="hljs-keyword">return</span> t1;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="最长同值路径"><a href="#最长同值路径" class="headerlink" title="最长同值路径"></a>最长同值路径</h1><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/">Leetcode</a><br>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。<br>注意：两个节点之间的路径长度由它们之间的边数表示。</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ul><li>寻找最长路径，即需要一个变量<code>ans</code>记录当前最长值，递归时用于比较。</li><li>路径可能穿过某个根结点，所以需要遍历每一个结点，将其左子树最长路径加上右子树最长路径。</li><li>设计递归函数：返回当前结点下的左右中其中一条最长路径的长度</li><li>注意如果结点值与子树的值不连续，路径即为0</li><li>路径&#x3D;结点数-1<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">height</span>(root, ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* node, <span class="hljs-type">int</span> &amp;ans)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-built_in">height</span>(root-&gt;left, ans);<br>    <span class="hljs-type">int</span> right = <span class="hljs-built_in">height</span>(root-&gt;right, ans);<br>    left = (root-&gt;left &amp;&amp; root-&gt;val == root-&gt;left-&gt;val) ? left + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    right = (root-&gt;right &amp;&amp; root-&gt;val == root-&gt;right-&gt;val) ? right + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    ans = <span class="hljs-built_in">max</span>(ans, left + right);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right);<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="二叉树中第二小的节点"><a href="#二叉树中第二小的节点" class="headerlink" title="二叉树中第二小的节点"></a>二叉树中第二小的节点</h1><p><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">Leetcode</a><br>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 <br>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p><h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>题干关键信息：节点的值不大于它的子节点的值，即root结点就是整棵树的最小值，因此第二小的值只能是<code>min(root-&gt;left-&gt;val,root-&gt;right-&gt;val)</code>。</li><li>但是当root的值与它其中一个子结点刚好相等时，第二小的值才有可能出现在更深层的子节点中，才需要继续递归搜索第二小值。</li><li>函数意义：返回第二小的值。</li><li>递归结束条件：null结点或者叶子结点（因为叶子结点的左右子结点都是null，无法访问它）。</li><li>哪边找到就返回哪边，都找到则返回较小者。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> l=root-&gt;left-&gt;val;<br>    <span class="hljs-type">int</span> r=root-&gt;right-&gt;val;<br>    <span class="hljs-keyword">if</span>(root-&gt;val == l) l=<span class="hljs-built_in">findSecondMinimumValue</span>(root-&gt;left);<br>    <span class="hljs-keyword">if</span>(root-&gt;val == r) r=<span class="hljs-built_in">findSecondMinimumValue</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span>(l!=<span class="hljs-number">-1</span> &amp;&amp; r!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(l,r);<br>    <span class="hljs-keyword">if</span>(l==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> r;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h1><p><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">Leetcode</a>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;&#x3D;L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>函数意义：修剪二叉树并完返回修剪好的二叉树的根结点</li><li>递归结束条件：遇到null</li><li>如果根结点的值小于给定的左边界L，那么当前结点及其左子树就会被修剪掉，修剪后的树应该是其右子树，所以返回修剪后的右子树。</li><li>涉及到改变树的结构，就需要更新链接，如果当前结点值在范围内，那么修建其左右子树，并且更新左右链接。最后 将当前修剪好的子树返回。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;val &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right,L,R);<br>    <span class="hljs-keyword">if</span>(root-&gt;val &gt; R) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left,L,R);<br>    root-&gt;left=<span class="hljs-built_in">trimBST</span>(root-&gt;left,L,R);<br>    root-&gt;right=<span class="hljs-built_in">trimBST</span>(root-&gt;right,L,R);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h1><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">leetcode</a>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。<br>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果</p><h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>凡是看到对一个二叉树进行过修改得题，递归得时候一定要对root的左右两个子树重新赋值</li><li>若 <code>val &gt; root.val</code>，插入到右子树。</li><li>若 <code>val &lt; root.val</code>，插入到左子树。</li><li>若 <code>root == null</code>， 即找到了该插入的地方，返回新建的 TreeNode(val)结点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>    <span class="hljs-keyword">else</span> root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="450"><li><h1 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h1><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">leetcode</a>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。<br>一般来说，删除节点可分为两个步骤：<br>首先找到需要删除的节点；<br>如果找到了，删除它。<h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3></li></ol><ul><li>必须掌握二叉树的三个性质：<ul><li>中序遍历&#x3D;递增序列 </li><li>比当前节点大的最小节点，简称中序遍历序列中的后继节点。先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。</li><li>比当前节点小的最大节点，简称中序遍历序列中的前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点</li></ul></li><li>当找到要删除的结点后，该结点有4中状态：<ul><li>如果是叶子结点，删除它就等于向上返回null结点</li><li>如果只有一个子树，删除它就等于向上返回他的那唯一一颗子树</li><li>如果两颗子树都存在，应该按照第三条性质，左子树链接到右子树中的最左下角的结点后面，然后向上返回右子树。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; key) root-&gt;left  = <span class="hljs-built_in">deleteNode</span>(root-&gt;left,  key);<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 找到要删除的结点</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 该节点是叶子</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left  == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root-&gt;right;<br>        <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root-&gt;left;<br>        <br>        TreeNode* cur = root-&gt;right;<br>        <span class="hljs-keyword">while</span> (cur-&gt;left != <span class="hljs-literal">NULL</span>) &#123;<br>            cur = cur-&gt;left;<br>        &#125;<br>        cur-&gt;left = root-&gt;left;<br>        <span class="hljs-keyword">return</span> root-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;seedling-树&quot;&gt;&lt;a href=&quot;#seedling-树&quot; class=&quot;headerlink&quot; title=&quot;:seedling:树&quot;&gt;&lt;/a&gt;:seedling:树&lt;/h1&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="力扣" scheme="https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="树" scheme="https://www.mingsrc.work/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>🎨程序员面试金典🎨</title>
    <link href="https://www.mingsrc.work/posts/2eef4cb2"/>
    <id>https://www.mingsrc.work/posts/2eef4cb2</id>
    <published>2022-12-27T03:12:54.073Z</published>
    <updated>2022-12-27T03:12:54.074Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🎨程序员面试金典🎨"><a href="#🎨程序员面试金典🎨" class="headerlink" title="🎨程序员面试金典🎨"></a>🎨程序员面试金典🎨</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p><span id="more"></span><ul><li><a href="#%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80">1.判定字符是否唯一</a></li><li><a href="#%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92">2.判定是否互为字符重排</a></li><li><a href="#URL%E5%8C%96">3.URL化</a></li><li><a href="#%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97">4.回文排列</a></li><li><a href="#%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91">5.一次编辑</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9">6.字符串压缩</a></li><li><a href="#%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5">7.旋转矩阵</a></li><li><a href="#%E9%9B%B6%E7%9F%A9%E9%98%B5">8.零矩阵</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC">9.字符串轮转</a></li><li><a href="#%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9">10.移除重复节点</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">11.返回倒数第k个节点</a></li><li><a href="#%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9">12.删除中间节点</a></li><li><a href="#%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8">13.分割链表</a></li><li><a href="#%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C">14.链表求和</a></li><li><a href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">15.回文链表</a></li><li><a href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4">16.链表相交</a></li><li><a href="#%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B">17.环路检测</a></li><li><a href="#%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC">18.栈的最小值</a></li><li><a href="#%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F">19.化栈为队</a></li><li><a href="#%E6%A0%88%E6%8E%92%E5%BA%8F">20.栈排序</a></li></ul><h1 id="判定字符是否唯一"><a href="#判定字符是否唯一" class="headerlink" title="判定字符是否唯一"></a>判定字符是否唯一</h1><p><a href="https://leetcode-cn.com/problems/is-unique-lcci/">leetcode</a>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>首先想到哈希表统计各字母出现频率，只遍历一次，频率大于1就返回false。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnique</span><span class="hljs-params">(string astr)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; astr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cnt[astr[i]]++;<br>        <span class="hljs-keyword">if</span> (cnt[astr[i]] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果面试官不想用哈希表，或者不能用额外的数据结构解题，就用一个整形数组代替来记录26个字母出现次数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnique</span><span class="hljs-params">(string astr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>];<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">26</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; astr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cnt[astr[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">if</span> (cnt[astr[i] - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>但是对于这种统计只出现一次，或者两次的题，都能够给位运算符操作</li><li>本题的思路是，把每个字母转换成二进制，例如 <code>a-&gt; 0001 b -&gt; 0010 c-&gt; 0100 d-&gt;1000</code>一次类推剩下所有字母。</li><li>还需要维护一个掩码mask，将遍历过的所有字母的二进制数合并起来(|&#x3D;运算)，<code>例如遍历了abcd,mask就等于1111</code>,再次碰到<code>a~d</code>,就能通过&amp;发现重复。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnique</span><span class="hljs-params">(string astr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : astr) &#123;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (mask &amp; num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> mask |= num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="判定是否互为字符重排"><a href="#判定是否互为字符重排" class="headerlink" title="判定是否互为字符重排"></a>判定是否互为字符重排</h1><p><a href="https://leetcode-cn.com/problems/check-permutation-lcci/">leetcode</a><br>给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p><h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><ul><li>不用哈希表的方式，记录26个字母出现的频率，同时遍历两个字符串，一个加次数，一个减次数。最后看是否所有字母的次数为0。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckPermutation</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>];<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">26</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s1.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cnt[s1[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        cnt[s2[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (cnt[i] != <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="URL化"><a href="#URL化" class="headerlink" title="URL化"></a>URL化</h1><p><a href="https://leetcode-cn.com/problems/string-to-url-lcci/">leetcode</a><br>URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：&quot;Mr John Smith    &quot;, 13<br>输出：&quot;Mr%20John%20Smith&quot;<br></code></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>理解题意很重要，在原数组的基础上进行修改，两种思路：从头开始或从尾部开始，既然原字符串在结尾已经给我预留了足够多的空位，那更方便从尾部开始插入。</li><li>维护两个指针，一个指向读入数据的位置（字符串真实长度的尾部），一个指向插入数据的位置（原字符串尾部）</li><li>读入数据进行判断，是空格，就在尾部连续插入3个字符’0’’2’’%’,否则正常插入读入的数据。</li><li>最后，将修改后的结果从字符串中提取出来，<code>substr()</code>从写入指针最后停止的位置开始提取到尾部。</li><li>substr()小技巧：如果没有指定长度或超出了源字符串的长度，则子字符串将延续到源字符串的结尾<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpaces</span><span class="hljs-params">(string S, <span class="hljs-type">int</span> length)</span> </span>&#123;<br>    <span class="hljs-type">int</span> writePos = S.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-type">int</span> readPos = length - <span class="hljs-number">1</span> - i;<br>        <span class="hljs-keyword">if</span> (S[readPos] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            S[writePos--] = S[readPos];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            S[writePos--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            S[writePos--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            S[writePos--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (writePos &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//S = S.substr(writePos + 1, S.size() - writePos - 1);</span><br>        S = S.<span class="hljs-built_in">substr</span>(writePos + <span class="hljs-number">1</span>); <br>    &#125;<br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="回文排列"><a href="#回文排列" class="headerlink" title="回文排列"></a>回文排列</h1><p><a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/">leetcode</a><br>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。<br>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。<br>回文串不一定是字典当中的单词。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>就是判断一个字符串能否变为一个回文串</li><li>统计每个字符出现的次数，偶数次数一定能组成回文，而奇数次数的字符只能有一个。<br>遍历每个字符，如果有2个以上包括2个的字母出现的次数为奇数，则不能变为回文。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPermutePalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) &#123;<br>        cnt[ch]++;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> m : cnt) &#123;<br>        <span class="hljs-keyword">if</span> (m.second % <span class="hljs-number">2</span>) res++;<br>        <span class="hljs-keyword">if</span> (res &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="一次编辑"><a href="#一次编辑" class="headerlink" title="一次编辑"></a>一次编辑</h1><p><a href="https://leetcode-cn.com/problems/one-away-lcci/">leetcode</a><br>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: <br>first = &quot;pale&quot;<br>second = &quot;ple&quot;<br>输出: True<br><br></code></pre></td></tr></table></figure><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>能够通过增删换一次操作使两个字符相同的前提一定是，两个字符个数绝对差不超过1.</li><li>使用两个指针同时遍历两个字符，字幕相同就继续同时往后遍历</li><li>如果发现字母不同，cnt++记录需要操作的次数。</li><li>删除操作实质上就是指针跳过这个字符。至于是哪个指针进行跳过，就要就比较哪个字符串比较长，就删除哪个字符串的字符。</li><li>如果两个字符串长度相等，就只能进行替换操作，替换完，两个指针是要同时前进的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">oneEditAway</span><span class="hljs-params">(string first, string second)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len1 = first.<span class="hljs-built_in">size</span>(), len2 = second.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(len1 - len2) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p1 &lt;= len2 &amp;&amp; p2 &lt;= len2) &#123;<br>        <span class="hljs-keyword">if</span> (first[p1] == second[p2]) &#123;<br>            p1++,p2++;<span class="hljs-keyword">continue</span>;<br>        &#125;<br>        len1 == len2 ? p1++,p2++ : len1 &gt; len2 ? p1++ : p2++;<br>        cnt++;<br>        <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="字符串压缩"><a href="#字符串压缩" class="headerlink" title="字符串压缩"></a>字符串压缩</h1><p><a href="https://leetcode-cn.com/problems/compress-string-lcci/">leetcode</a><br>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：&quot;aabcccccaaa&quot;<br>输出：&quot;a2b1c5a3&quot;<br></code></pre></td></tr></table></figure><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>遍历字符串，先取第一个字符作为当前值，从下标1开始遍历，统计与当前字符相等的个数。</li><li>当遍历不相等的字符时，更新当前值和个数</li><li>注意：因为每次遍历到不同的字符时，指针都会指向下一个字符，因此当遍历到最后一个字符时，需要跟字符串结尾的<code>\0</code>进行比较，所以遍历边界就不能再是<code>i &lt; s.size()</code>应改为<code>i &lt; size() + 1</code>。让i可以指向<code>\0</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">compressString</span><span class="hljs-params">(string S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> S;<br>    <span class="hljs-type">char</span> cur = S[<span class="hljs-number">0</span>];<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; S.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>        res += cur;<br>        <span class="hljs-keyword">while</span> (i &lt; S.<span class="hljs-built_in">size</span>() &amp;&amp; S[i] == cur) cnt++, i++;<br>        cur = S[i];<br>        res += <span class="hljs-built_in">to_string</span>(cnt);<br>    &#125;<br>    <span class="hljs-keyword">return</span> S.<span class="hljs-built_in">size</span>() &gt; res.<span class="hljs-built_in">size</span>() ? res : S;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h1><p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/">leetcode</a><br>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。<br>不占用额外内存空间能否做到？</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">给定 matrix = <br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],<br><br>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br></code></pre></td></tr></table></figure><ul><li>最简单的方式就是使用辅助矩阵，只要找到翻转后位置的对应关系即可，第row行变为第col行，第col列变为第n-1-row列（倒数的row列）</li><li><code>matrix[j][n-1-i] = matrix[i][j]</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">auto</span> newMat = matrix;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            newMat[j][n - <span class="hljs-number">1</span> - i] = matrix[i][j];<br>        &#125;<br>    &#125;<br>    matrix = newMat;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果面试要求原地进行翻转，首先要知道<code>matrix[j][n-1-i] = matrix[i][j]</code>会覆盖掉第2个点，</li><li>第一：因此我们需要先旋转第2个点，但第2点又会覆盖第3个点，所以先旋转第3点，第3点会覆盖第4点，第4个点刚好就是第1个点，形成一个循环，这样我们先记录第1个点，将后面得点依次覆盖，即可完成4个点得同时旋转。</li><li>第二：因为一次旋转4个点，所以我们需要知道遍历哪些点才能不重复。偶数边矩阵：最左上角的小矩阵，奇数矩阵：因为多了中间一列，所以选择最左上角的小矩阵 + 中间列。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; ++j) &#123;<br>            <span class="hljs-type">int</span> temp = matrix[i][j];<br>            matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>            matrix[n - j - <span class="hljs-number">1</span>][i] = matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>];<br>            matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>] = matrix[j][n - i - <span class="hljs-number">1</span>];<br>            matrix[j][n - i - <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>用对折翻转代替旋转，这种算法除非做过原题，一般是想不到</li><li>先水平翻转，再对角线翻转</li><li>注意：翻转需要两个元素：1、翻转前后点得对应关系。2、枚举需要遍历的点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 水平翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[n - <span class="hljs-number">1</span> - i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 对角线翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h1><p><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/">leetcode</a><br>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>暴力法；先全部遍历，找到并记录全部0的行列坐标。</li><li>第二次只遍历这些0的位置，模拟操作：往上下左右四个方向进行置0操作。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; indexs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                indexs.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(i, j));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (indexs.<span class="hljs-built_in">size</span>() == row * col) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : indexs) &#123;<br>        <span class="hljs-type">int</span> i = it.first;<br>        <span class="hljs-type">int</span> j = it.second;<br>        <span class="hljs-type">int</span> i1 = i;<br>        <span class="hljs-keyword">while</span> (++i1 &lt; row) &#123;<br>            matrix[i1][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> i2 = i;<br>        <span class="hljs-keyword">while</span> (--i2 &gt;= <span class="hljs-number">0</span>) &#123;<br>            matrix[i2][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> j1 = j;<br>        <span class="hljs-keyword">while</span> (++j1 &lt; col) &#123;<br>            matrix[i][j1] = <span class="hljs-number">0</span>;<br>        &#125; <br>        <span class="hljs-type">int</span> j2 = j;<br>        <span class="hljs-keyword">while</span> (--j2 &gt;= <span class="hljs-number">0</span>) &#123;<br>            matrix[i][j2] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>同样是先记录所以出现0的行和列，然后第二次遍历时，判断当前行或者列是否是需要置0的</li><li>需要两个bool数组，记录每个行或列是否是需要置0的行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">bool</span> isZeroRow[n], isZeroCol[m];<br>    <span class="hljs-built_in">memset</span>(isZeroRow, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>) * n);<br>    <span class="hljs-built_in">memset</span>(isZeroCol, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>) * m);<br>    <span class="hljs-comment">// 统计哪些行，列需要全置位0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                isZeroRow[i] = <span class="hljs-literal">true</span>;<br>                isZeroCol[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (isZeroRow[i] || isZeroCol[j]) <br>                matrix[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="字符串轮转"><a href="#字符串轮转" class="headerlink" title="字符串轮转"></a>字符串轮转</h1><p><a href="https://leetcode-cn.com/problems/string-rotation-lcci/">leetcode</a><br>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。</p><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>两个思路，一种暴力的方式，旋转s2，判断s1 和s2是否相等，不相等继续旋转s2</li><li>使用C库<code>int strcmp(const char* s1, const char* s2)</code>字符串需要转换为<code>char*</code>类型，且strcmp是采用逐位相减来判断的，返回0表示相等，大于0表示大于<code>s1 &gt; s2</code>，<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFlipedString</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> n = s1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">char</span> temp = s2[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            s2[j] = s2[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        s2[<span class="hljs-number">0</span>] = temp;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(s1.<span class="hljs-built_in">c_str</span>(), s2.<span class="hljs-built_in">c_str</span>()) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>思路二：既然是循环字符串，就一定要想到拼接思想，通过s1 + s1 拼接后找是否存在s2子串的方式</li><li>找子串有两种方式：1、分割出子串<code>string substr(int index, int count)</code>需要参数位置和个数,返回分割的子串，进行比较<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFlipedString</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> n = s1.<span class="hljs-built_in">size</span>();<br>    s2 = s2 + s2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s1[<span class="hljs-number">0</span>] == s2[i] &amp;&amp; s1 == s2.<span class="hljs-built_in">substr</span>(i, n)) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>2、或使用stl库得find函数找子串，找到返回首个字符的下标，否则返回<code>npos</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFlipedString</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>    <span class="hljs-comment">// slt</span><br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> (s1 + s1).<span class="hljs-built_in">find</span>(s2) != string::npos;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="移除重复节点"><a href="#移除重复节点" class="headerlink" title="移除重复节点"></a>移除重复节点</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/">leetcode</a><br>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：[1, 2, 3, 3, 2, 1]<br>输出：[1, 2, 3]<br></code></pre></td></tr></table></figure><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题是对未排序的链表进行删重，所以需要先遍历一遍记录不重复的有哪些值。</li><li>第二次遍历针对非记录中的进行删除</li><li>链表的删除需要前驱，所以head结点我们也需要新建一个前驱，删除结点的操作最好都是枚举遍历前驱，当前结点通过前驱获得。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">removeDuplicateNodes</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode* pre = dummy;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-keyword">while</span> (pre-&gt;next) &#123;<br>        ListNode* cur = pre-&gt;next;<span class="hljs-comment">// 获取待删除结点</span><br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(cur-&gt;val) == hash.<span class="hljs-built_in">end</span>()) &#123;    <span class="hljs-comment">// 没有找到</span><br>            hash.<span class="hljs-built_in">insert</span>(cur-&gt;val);<br>            pre = pre-&gt;next;<span class="hljs-comment">// 只有遇到新元素才更新</span><br>        &#125; <span class="hljs-keyword">else</span><br>            pre-&gt;next = pre-&gt;next-&gt;next; <br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="返回倒数第-k-个节点"><a href="#返回倒数第-k-个节点" class="headerlink" title="返回倒数第 k 个节点"></a>返回倒数第 k 个节点</h1><p><a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/">leetcode</a><br>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。<br>注意：本题相对原题稍作改动</p><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2<br>输出： 4<br></code></pre></td></tr></table></figure><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>两个思路，第一快慢指针法，第二翻转链表，但是时间复杂度相对较高<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthToLast</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    ListNode* slow = head;<br>    ListNode* fast = head;<br>    <span class="hljs-keyword">while</span> (k--)<br>        fast = fast-&gt;next;<br>    <span class="hljs-keyword">while</span> (fast) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow-&gt;val;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>翻转链表法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthToLast</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    ListNode* cur = head;<br>    ListNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = temp;<br>    &#125;<br>    k--;    <span class="hljs-comment">// 第k个元素，跳k-1次就可以</span><br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        pre = pre-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre-&gt;val;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="删除中间节点"><a href="#删除中间节点" class="headerlink" title="删除中间节点"></a>删除中间节点</h1><p><a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/">leetcode</a><br>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c<br>结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f<br></code></pre></td></tr></table></figure><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>此题题意难以理解，意思是一般我们删除链表的某一个结点都通过遍历到待删除结点的前驱，通过更改前驱指针进行删除<br>本题的目的是，只给你当前待删除的结点指针，完成原地删除操作。</li><li>思路是，将当前结点替换为它的后继结点，即更新它的值和next指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>    node-&gt;val = node-&gt;next-&gt;val;<br>    node-&gt;next = node-&gt;next-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>结点的本质是结构体，通过将后继的内存内容直接覆盖掉当前待删除结点内存空间完成替换。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>    *node = *(node-&gt;next);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="分割链表"><a href="#分割链表" class="headerlink" title="分割链表"></a>分割链表</h1><p><a href="https://leetcode-cn.com/problems/partition-list-lcci/">leetcode</a><br>编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。</p><h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: head = 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1, x = 5<br>输出: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8<br></code></pre></td></tr></table></figure><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>读懂题意就很难，大致目的是根据x值将一个链表分成两条链表，其中一个是大于等于<code>x</code>的值组成的，另一条是小于<code>x</code>的值，分割完后再进行前后拼接。</li><li>用到的技巧就是分割和组装链表</li><li>新建链表需要得是头结点和用于遍历的指针，插入时用尾插法</li><li>组装链表将其中一条链表尾部<code>next</code>指针指向另一条链表的第一个元素，最后在尾部添加<code>NULL</code>完成组装。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    ListNode* small = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* big = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* cur = head;<br>    ListNode* smallCur = small;<br>    ListNode* bigCur = big;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;val &lt; x) &#123;<br>            smallCur-&gt;next = cur;<br>            smallCur = smallCur-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            bigCur-&gt;next = cur;<br>            bigCur = bigCur-&gt;next;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    smallCur-&gt;next = big-&gt;next;<br>    bigCur-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> small-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h1><p><a href="https://leetcode-cn.com/problems/sum-lists-lcci/">leetcode</a><br>给定两个用链表表示的整数，每个节点包含一个数位。<br>这些数位是反向存放的，也就是个位排在链表首部。<br>编写函数对这两个整数求和，并用链表形式返回结果。</p><h3 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295<br>输出：2 -&gt; 1 -&gt; 9，即912<br></code></pre></td></tr></table></figure><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>两个指针分别遍历两个链表，将其中的数相加，大于10的部分作为进位参与下一轮的求和，个位数即为新结点的值</li><li>关键在于边界条件，当其中一条链表遍历结束后，指向了null，因此将它的值全部赋予0，继续参与之后每轮的求和。</li><li>当两链表全部遍历结束后，再次判断还有没有剩余的进位，如果有就最后新建一个结点。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    ListNode* p1 = l1;<br>    ListNode* p2 = l2;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br><br>    ListNode* preHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* cur = preHead;<br>    <span class="hljs-keyword">while</span> (p1 || p2) &#123;<br>        <span class="hljs-type">int</span> val1 = p1 == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : p1-&gt;val;<br>        <span class="hljs-type">int</span> val2 = p2 == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : p2-&gt;val;<br>        sum = val1 + val2 + c;<br>        c = sum / <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> val = sum % <span class="hljs-number">10</span>;<br>        ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>        cur-&gt;next = node;<br>        cur = cur-&gt;next;<br>        <span class="hljs-keyword">if</span>(p1) p1 = p1-&gt;next;<br>        <span class="hljs-keyword">if</span>(p2) p2 = p2-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>        ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(c);<br>        cur-&gt;next = node;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> preHead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/">leetcode</a><br>编写一个函数，检查输入的链表是否是回文的。</p><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>翻转一半的链表进行逐点比较。</li><li>先用快慢指针寻找中间点，为了方便奇数偶数链表的统一，我们新建头结点开始遍历。这样当快指针结束时，慢指针正好指向后一半链表的前驱上，无论是否是奇数偶数链表。</li><li>翻转链表用了头插法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode* slow = dummy;<br>    ListNode* fast = dummy;<br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br>    <br>    ListNode* pre = <span class="hljs-literal">NULL</span>;<br>    ListNode* cur = slow-&gt;next;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = tmp;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (head &amp;&amp; pre) &#123;<br>        <span class="hljs-keyword">if</span> (head-&gt;val != pre-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        head = head-&gt;next;<br>        pre = pre-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">leetcode</a><br>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。</p><h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>判断两个链表是否相交，经典做法拼接两个链表，即当第一个链表遍历结束后继续从第二条头部遍历，第二条链表同样如此</li><li>这样两个链表相等的长度，当两个指针指向同一块地址时，不是null就是相交点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    ListNode* p1 = headA;<br>    ListNode* p2 = headB;<br>    <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>        p1 = p1 == <span class="hljs-literal">NULL</span> ? headB : p1-&gt;next;<br>        p2 = p2 == <span class="hljs-literal">NULL</span> ? headA : p2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1; <br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="环路检测"><a href="#环路检测" class="headerlink" title="环路检测"></a>环路检测</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/">leetcode</a><br>给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。</p><h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>题目要我们除了要判断是否是环路，还要返回环路的头部结点</li><li>判断是否环路使用快慢指针，当快指针追上慢指针时即为环路</li><li>寻找头部就需要数学推导，结论就是当快指针追上慢指针后，让快指针从头开始走，步数和慢指针相同，两指针会在环头部相遇。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    ListNode* slow = head;<br>    ListNode* fast = head;<br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span> (fast == slow) &#123; <span class="hljs-comment">// 有环</span><br>            fast = head;<br>            <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>                fast = fast-&gt;next;<br>                slow = slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> fast;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="栈的最小值"><a href="#栈的最小值" class="headerlink" title="栈的最小值"></a>栈的最小值</h1><p><a href="https://leetcode-cn.com/problems/min-stack-lcci/">leetcode</a><br>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p><h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>维护两个栈，数据栈和扎顶储存当前数据栈中的最小值的最小栈</li><li>入栈时判断入栈元素是否比当前数据中的最小值还小，还小就如栈。</li><li>出栈时需要判断出栈元素是否刚好就是当前数据中的最小值，是就同步出栈。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; data;<br>    stack&lt;<span class="hljs-type">int</span>&gt; minSck;<br>    <span class="hljs-built_in">MinStack</span>() &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        data.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">if</span> (minSck.<span class="hljs-built_in">empty</span>()) &#123;<br>            minSck.<span class="hljs-built_in">push</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (minSck.<span class="hljs-built_in">top</span>() &gt;= x)<br>                minSck.<span class="hljs-built_in">push</span>(x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">top</span>() == minSck.<span class="hljs-built_in">top</span>()) &#123;<br>            data.<span class="hljs-built_in">pop</span>();<br>            minSck.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            data.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minSck.<span class="hljs-built_in">top</span>();<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="化栈为队"><a href="#化栈为队" class="headerlink" title="化栈为队"></a>化栈为队</h1><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/">leetcode</a><br>实现一个MyQueue类，该类用两个栈来实现一个队列。</p><h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>队列是先进先出，栈先进后出，所以通过两个栈反转实现先进先出</li><li>出栈的时候先反转栈内的数据，将数据栈全部如辅助栈中，pop的数据就是辅助栈的栈顶元素。</li><li>只有当辅助栈弹空时，再继续反转数据栈内的数据进入辅助栈补充<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (helpSck.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (!dataSck.<span class="hljs-built_in">empty</span>()) &#123;<br>            helpSck.<span class="hljs-built_in">push</span>(dataSck.<span class="hljs-built_in">top</span>());<br>            dataSck.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = helpSck.<span class="hljs-built_in">top</span>();<br>    helpSck.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (helpSck.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (!dataSck.<span class="hljs-built_in">empty</span>()) &#123;<br>            helpSck.<span class="hljs-built_in">push</span>(dataSck.<span class="hljs-built_in">top</span>());<br>            dataSck.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> helpSck.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="栈排序"><a href="#栈排序" class="headerlink" title="栈排序"></a>栈排序</h1><p><a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/">leetcode</a><br>栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。</p><h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>本题相当于对栈内的元素进行排序，维护栈顶到栈底从小到大排序</li><li>因此栈顶遇到比它大的数时，先弹出比他小的元素到辅助栈中，直到到他的合适位置后，再将辅助栈内的元素倒入原栈中。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(!s1.<span class="hljs-built_in">empty</span>() &amp;&amp; s1.<span class="hljs-built_in">top</span>() &lt; val)&#123;<br>        s2.<span class="hljs-built_in">push</span>(s1.<span class="hljs-built_in">top</span>());<br>        s1.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    s1.<span class="hljs-built_in">push</span>(val);<br>    <span class="hljs-keyword">while</span>(!s2.<span class="hljs-built_in">empty</span>())&#123;<br>        s1.<span class="hljs-built_in">push</span>(s2.<span class="hljs-built_in">top</span>());<br>        s2.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!s1.<span class="hljs-built_in">empty</span>())<br>        s1.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!s1.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">top</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;🎨程序员面试金典🎨&quot;&gt;&lt;a href=&quot;#🎨程序员面试金典🎨&quot; class=&quot;headerlink&quot; title=&quot;🎨程序员面试金典🎨&quot;&gt;&lt;/a&gt;🎨程序员面试金典🎨&lt;/h1&gt;&lt;p&gt;转自：🔥&lt;a href=&quot;https://github.com/liuwentao1992&quot;&gt;【github】&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="面试" scheme="https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="C++" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="面试" scheme="https://www.mingsrc.work/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="力扣" scheme="https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>📸排序📸</title>
    <link href="https://www.mingsrc.work/posts/bafd3c38"/>
    <id>https://www.mingsrc.work/posts/bafd3c38</id>
    <published>2022-12-27T03:12:54.072Z</published>
    <updated>2022-12-27T03:12:54.072Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="📸排序📸"><a href="#📸排序📸" class="headerlink" title="📸排序📸"></a>📸排序📸</h1><span id="more"></span><p>堆排序、快速排序  </p><ul><li><a href="%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0">215.数组中的第K个最大元素</a></li></ul><p>建立哈希表并排序  </p><ul><li><a href="%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0">347.前K个高频元素</a></li><li><a href="%E6%8C%89%E7%85%A7%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F">451.按照字符出现次数对字符串排序</a></li></ul><p>荷兰国旗问题  </p><ul><li><a href="%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97">75.按颜色进行排序</a></li></ul><h1 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h1><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">leetcode</a>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><h3 id="使用SLT库排序"><a href="#使用SLT库排序" class="headerlink" title="使用SLT库排序"></a>使用SLT库排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() - k];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆排序解题思路"><a href="#堆排序解题思路" class="headerlink" title="堆排序解题思路"></a>堆排序解题思路</h3><ul><li>堆排序会使用到优先队列<code>priority_queue</code>，可以当成一种高级队列，只不过这个队列是已经排好序的。</li><li>维护一个个数为k的小顶堆，堆从从上到下按从小到大排序</li><li>始终保持堆的大小为k，超出k就pop(),直到遍历结束位置，堆中存放着前k个最大元素，堆顶的元素就是正确答案。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt; &gt; queue;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : nums) &#123;<br>        queue.<span class="hljs-built_in">push</span>(it);<br>        <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">size</span>() &gt; k) queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> queue.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序解题思路"><a href="#快速排序解题思路" class="headerlink" title="快速排序解题思路"></a>快速排序解题思路</h3></li><li>不使用STL库的情况下，手写一个快速排序算法</li><li>注意：快速排序使用的是递归，所以记得一定要写个递归结束条件<code> if (left &gt; right) return ;。</code></li><li>注意：在partition函数中while里处理要判断nums[right] &gt;&#x3D; p，还要判断left &lt; right。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() - k];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid = <span class="hljs-built_in">partition</span>(nums, left, right);<br>    <span class="hljs-built_in">quickSort</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quickSort</span>(nums, mid + <span class="hljs-number">1</span>,right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = nums[left];<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">while</span> (nums[right] &gt;= p &amp;&amp; left &lt; right) right--;<br>        nums[left] = nums[right];<br>        <span class="hljs-keyword">while</span> (nums[left] &lt;= p &amp;&amp; left &lt; right) left++;<br>        nums[right] = nums[left];<br>    &#125;<br>    nums[left] = p;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h1><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">leetcode</a>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>建立哈希表统计数字出现频率，</li><li>利用隐式转换，把无序hash转换为pair类型方便按照频率多少进行排序</li><li>使用SLT的sort()函数进行排序，大小的比较规则cmp函数需要自己写。</li><li>将排好序的前k元素输出<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; v1, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; v2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> v1.second &gt; v2.second;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        hash[nums[i]]++;<br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">arr</span>(hash.<span class="hljs-built_in">begin</span>(), hash.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(arr[i].first);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="按照字符出现次数对字符串排序"><a href="#按照字符出现次数对字符串排序" class="headerlink" title="按照字符出现次数对字符串排序"></a>按照字符出现次数对字符串排序</h1><p><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">leetcode</a>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>哈希表建立的频率表是无序的，所以需要转换为其他数据结构，再使用排序算法对其排序</li><li>可以使用隐式的类型转换为<code>pair&lt;char,int&gt;</code>，再使用STL里面的sort()函数进行排序，sort的好处是可以自定义排序的规则。</li><li>sort()函数自定义的排序规则需要写成静态的函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; a, pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : s) &#123;<br>        hash[it]++;<br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">arr</span>(hash.<span class="hljs-built_in">begin</span>(), hash.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>    string res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : arr) &#123;<br>        <span class="hljs-keyword">while</span> (it.second--) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(it.first);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="荷兰国旗"><a href="#荷兰国旗" class="headerlink" title="荷兰国旗"></a>荷兰国旗</h1><p><a href="https://leetcode-cn.com/problems/sort-colors/">Leetcode</a>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>一共三个指针，p0一直指向0的后一位，p2一直指向2的前一位，cur是用于遍历的指针。</li><li>本题属于荷兰旗帜问题：思想是遇到0就跟p0所指的数交换位置，遇到2就跟p2所指的数交换位置，遇到1就跳过。</li><li>注意：遇到2交换完位置后，cur指针不前进，因为要再次判断交换过来的数是0还是1。</li><li>注意2：while结束是 <code>cur &lt; p2</code>而不是<code>cur &lt; nums.size()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p0 = <span class="hljs-number">0</span>, p2 = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur &lt; p2) &#123;<br>        <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">1</span>) cur++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(nums[p0++], nums[cur++]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">2</span>) <span class="hljs-built_in">swap</span>(nums[cur],nums[p2--]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;📸排序📸&quot;&gt;&lt;a href=&quot;#📸排序📸&quot; class=&quot;headerlink&quot; title=&quot;📸排序📸&quot;&gt;&lt;/a&gt;📸排序📸&lt;/h1&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="力扣" scheme="https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://www.mingsrc.work/posts/340249a9"/>
    <id>https://www.mingsrc.work/posts/340249a9</id>
    <published>2022-12-27T03:12:54.072Z</published>
    <updated>2022-12-27T03:12:54.072Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li><a href="#%E5%A5%BD%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE">5460. 好数对的数目</a></li></ul><span id="more"></span><h1 id="好数对的数目"><a href="#好数对的数目" class="headerlink" title=" 好数对的数目"></a> 好数对的数目</h1><p><a href="https://leetcode-cn.com/problems/number-of-good-pairs/">leetcode</a><br>给你一个整数数组 nums 。<br>如果一组数字 (i,j) 满足 nums[i] &#x3D;&#x3D; nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。<br>返回好数对的数目。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1,2,3,1,1,3]<br>输出：4<br>解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始<br></code></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>只要想到用一个二维数组的方式来判断就很简单，用到双层for循环暴力解决。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIdenticalPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[j])<br>                cnt ++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A5%BD%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE&quot;&gt;5460. 好数对的数目&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="力扣" scheme="https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="数组" scheme="https://www.mingsrc.work/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="https://www.mingsrc.work/posts/8d66b5f2"/>
    <id>https://www.mingsrc.work/posts/8d66b5f2</id>
    <published>2022-12-27T03:12:54.072Z</published>
    <updated>2022-12-27T03:12:54.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🚑栈和队列🚑"><a href="#🚑栈和队列🚑" class="headerlink" title="🚑栈和队列🚑"></a>🚑栈和队列🚑</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p><span id="more"></span><ul><li><a href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC">7.整数反转</a> </li><li><a href="#%E5%9B%9E%E6%96%87%E6%95%B0">9.回文数</a></li><li><a href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7">20.有效的括号</a> </li><li><a href="#%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">232.用栈实现队列</a></li><li><a href="#%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88">225.用队列实现栈</a></li><li><a href="#%E6%9C%80%E5%B0%8F%E6%A0%88">155.最小栈</a>   </li><li><a href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">150.逆波兰表达式求值</a></li><li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81">394.字符串解码</a></li><li><a href="#%E5%85%8B%E9%9A%86%E5%9B%BE">133.克隆图</a></li><li><a href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F">200.岛屿数量</a></li><li><a href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2">84.柱状图中最大的矩形</a></li><li><a href="#01%E7%9F%A9%E9%98%B5">542.01矩阵</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">622.设计循环队列</a></li></ul><h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><p><a href="https://leetcode-cn.com/problems/reverse-integer/">Leetcode</a>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>从低到高位依次加入队列，然后输出</li><li>注意反转后的溢出问题<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> rev=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(rev&gt;INT_MAX/<span class="hljs-number">10</span> || rev&lt;INT_MIN/<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        rev=rev*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;<br>         x/=<span class="hljs-number">10</span>;<br>     &#125;<br>     <span class="hljs-keyword">return</span> rev;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/">Leetcode</a>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>一位数一定是回文数</li><li>负数或者个位是0的一定不是回文数。</li><li>反转整数，只反转到一半，然后进行比较（对于奇数个数得回文数，去掉中间位再比较）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;=<span class="hljs-number">9</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(x%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> || x&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> rev=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x&gt;rev)&#123;<br>        rev=rev*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;<br>        x/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> rev/<span class="hljs-number">10</span>==x || rev==x;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">Leetcode</a>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ &#x3D;&#x3D;&#x3D;的字符串，判断字符串是否有效。<br>有效字符串需满足：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1. 左括号必须用相同类型的右括号闭合。<br>2. 左括号必须以正确的顺序闭合。<br></code></pre></td></tr></table></figure><p>注意空字符串可被认为是有效字符串。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>个数为奇数肯定不对</li><li>首字符为右符号肯定不对</li><li>遇到左符号入栈</li><li>遇到右符号与栈顶元素进行匹配，配对则出栈，否则返回false，最后栈空了则说明是有效的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()%<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;&#125;&#x27;</span> || s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;)&#x27;</span> || s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    stack&lt;<span class="hljs-type">char</span>&gt; sck;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;s[i]!=<span class="hljs-string">&#x27;\0&#x27;</span>;++i)&#123;<br>        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;[&#x27;</span> || s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span> || s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            sck.<span class="hljs-built_in">push</span>(s[i]);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; sck.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; sck.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; sck.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            sck.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> sck.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">Leetcode</a>  </p><ul><li>栈的顺序为后进先出，而队列的顺序为先进先出。</li><li>使用两个栈实现队列，一个元素需要经过两个栈才能出队列<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:   <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(stack2.<span class="hljs-built_in">empty</span>())&#123;                  <span class="hljs-comment">//只有当stack2为空时，才重新加载</span><br>            <span class="hljs-keyword">while</span>(!stack1.<span class="hljs-built_in">empty</span>())&#123;         <span class="hljs-comment">//stack1装填到stack2</span><br>                stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());  <span class="hljs-comment">//c++ pop()函数返回值额为void</span><br>                stack1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=stack2.<span class="hljs-built_in">top</span>();<br>        stack2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stack2.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(!stack1.<span class="hljs-built_in">empty</span>())&#123;<br>                stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>                stack1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack2.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack1.<span class="hljs-built_in">empty</span>() &amp;&amp; stack2.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack1;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack2;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">Leetcode</a>  </p><ul><li>一个队列  </li><li>push之前判断当前是否为空</li><li>不为空则将元素插入到尾部，前面的全部弹出再去入队</li><li><code>push</code>时间复杂度O(n),而<code>pop</code>的时间复杂度O(1)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyStack</span>() &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(queue1.<span class="hljs-built_in">empty</span>())&#123;<br>            queue1.<span class="hljs-built_in">push</span>(x);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> cnt=queue1.<span class="hljs-built_in">size</span>();<br>            queue1.<span class="hljs-built_in">push</span>(x);<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)&#123;<br>                queue1.<span class="hljs-built_in">push</span>(queue1.<span class="hljs-built_in">front</span>());<br>                queue1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=queue1.<span class="hljs-built_in">front</span>();<br>        queue1.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue1.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue1;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ul><li><code>push</code>时间复杂度O(1),而<code>pop</code>的时间复杂度O(n)  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; q1; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        q1.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q2;<br>        <span class="hljs-keyword">while</span>(q1.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            q2.<span class="hljs-built_in">push</span>(q1.<span class="hljs-built_in">front</span>());<br>            q1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> res=q1.<span class="hljs-built_in">front</span>();<br>        q1=q2;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        queue&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">q2</span>(q1);<br>        <span class="hljs-keyword">while</span>(q1.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            q1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> res=q1.<span class="hljs-built_in">front</span>();<br>        q1=q2;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈  "></a>最小栈  </h1><a href="https://leetcode-cn.com/problems/min-stack/">Leetcode</a>  </li><li>维护两个栈：<code>数据栈</code> <code>最小栈</code></li><li>同步简单，异步节省<code>最小栈</code>空间</li><li>异步：当新插入的元素比最小值还小（或相等）时，插入最小栈，出栈时只有当两个栈栈顶元素相同时，两个栈同时pop，否则只有<code>数据栈</code>pop  </li><li>同步：两个栈的大小始终相同，只是<code>最小栈</code>每次都插入当前最小值，出栈时两栈同时pop</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        dataStack.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">if</span>(miniStack.<span class="hljs-built_in">empty</span>())&#123;<br>            miniStack.<span class="hljs-built_in">push</span>(x);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> min=miniStack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(min&gt;=x)&#123;                         <span class="hljs-comment">//相等时也要插入</span><br>                miniStack.<span class="hljs-built_in">push</span>(x);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>( dataStack.<span class="hljs-built_in">top</span>()==miniStack.<span class="hljs-built_in">top</span>())&#123;  <span class="hljs-comment">//只有相等时才同时弹出否则只弹出dataStack</span><br>            dataStack.<span class="hljs-built_in">pop</span>();<br>            miniStack.<span class="hljs-built_in">pop</span>();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dataStack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dataStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> miniStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; dataStack;<br>    stack&lt;<span class="hljs-type">int</span>&gt; miniStack;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h1 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h1><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">leetcode</a>根据 逆波兰表示法，求表达式的值。<br>有效的运算符包括 +, -, *, &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9<br></code></pre></td></tr></table></figure><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>典型的后缀表达式，栈得应用场景</li><li>遍历字符串数组，遇到字符就弹出栈顶两个元素进行运算，再将结果填入栈。遇到数字就直接入栈</li><li>这里使用了c语言<code>stoi()</code>函数直接将字符串转换为数字，也可以使用ASCII值转，<code>atoi(string.c_str())</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; sck;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : tokens) &#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-string">&quot;+&quot;</span>) &#123;<br>            <span class="hljs-type">int</span> a = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> b = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            sck.<span class="hljs-built_in">push</span>(b + a);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (it == <span class="hljs-string">&quot;-&quot;</span>) &#123;<br>            <span class="hljs-type">int</span> a = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> b = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            sck.<span class="hljs-built_in">push</span>(b - a);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (it == <span class="hljs-string">&quot;*&quot;</span>)&#123;<br>            <span class="hljs-type">int</span> a = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> b = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            sck.<span class="hljs-built_in">push</span>(a * b);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (it == <span class="hljs-string">&quot;/&quot;</span>)&#123;<br>            <span class="hljs-type">int</span> a = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> b = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            sck.<span class="hljs-built_in">push</span>(b / a);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sck.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(it));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sck.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h1><p><a href="https://leetcode-cn.com/problems/decode-string/">leetcode</a>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。<br>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;3[a]2[bc]&quot;<br>输出：&quot;aaabcbc&quot;<br><br>输入：s = &quot;3[a2[c]]&quot;<br>输出：&quot;accaccacc&quot;<br></code></pre></td></tr></table></figure><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>一看到<code>[</code> <code>]</code> 匹配得题，首先想到使用栈，既有数字又有字母，想到使用两个栈</li><li>这类题基本思路就是找到什么时候入栈，什么时候出栈。</li><li>同时涉及了遍历数组，提取数字和提取字符串算法</li><li>本题的当遍历到’[‘时同时入栈，遍历到’]’时出栈进行操作,strSck.top()可以理解为到当前为止前面已经展开的字符串，cur为刚刚<code>[ ]</code>中合成的字符串。</li><li>讲道理此题过于难以理解🐛<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    string cur = <span class="hljs-string">&quot;&quot;</span>;<br>    stack&lt;<span class="hljs-type">int</span>&gt; numSck;<br>    stack&lt;string&gt; strSck;<br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            val = val * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>            numSck.<span class="hljs-built_in">push</span>(val);<br>            strSck.<span class="hljs-built_in">push</span>(cur);<br>            val = <span class="hljs-number">0</span>;<br>            cur = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;=<span class="hljs-string">&#x27;z&#x27;</span>) || (s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)) &#123;<br>            cur += s[i];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> cnt = numSck.<span class="hljs-built_in">top</span>();<br>            numSck.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++i) &#123;<br>                strSck.<span class="hljs-built_in">top</span>() += cur;<br>            &#125;<br>            cur = strSck.<span class="hljs-built_in">top</span>();<br>            strSck.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="克隆图"><a href="#克隆图" class="headerlink" title="克隆图"></a>克隆图</h1><p><a href="https://leetcode-cn.com/problems/clone-graph/">leetcode</a>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。<br>图中的每个节点都包含它的值<code> val  int</code> 和其邻居的列表<code>vector[Node]</code>。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：adjList = [[2,4],[1,3],[2,4],[1,3]]<br>输出：[[2,4],[1,3],[2,4],[1,3]]<br>解释：<br>图中有 4 个节点。<br>节点 1 的值是 1，它有两个邻居：节点 2 和 4 。<br>节点 2 的值是 2，它有两个邻居：节点 1 和 3 。<br>节点 3 的值是 3，它有两个邻居：节点 2 和 4 。<br>节点 4 的值是 4，它有两个邻居：节点 1 和 3 。<br><br></code></pre></td></tr></table></figure><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>图得遍历有两种深度DFS和广度BFS</li><li>深度优先遍历：使用递归同时还需要记录哪些是已经复制过得，函数得意义是复制并返回复制得结点，如果发现该结点已经复制过，直接返回复制得结点</li><li>由于是深拷贝，一定需要new，所以该结点没有复制，就new一个新结点，并标记已经拷贝过。</li><li>新得结点还需要链接它得邻接点，遍历它得所以邻接点，并继续复制。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Node* isClone[<span class="hljs-number">101</span>];<br><span class="hljs-function">Node* <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (isClone[node-&gt;val] != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> isClone[node-&gt;val];<br>    Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>    isClone[node-&gt;val] = newNode;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : node-&gt;neighbors) &#123;<br>        newNode-&gt;neighbors.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">cloneGraph</span>(it));<br>    &#125;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用广度优先遍历就必须使用队列</li><li>首先先复制第一个结点并加入到队列中，然后进入循环，注意：队列加入得都是原结点不是新创建得结点，因为新结点还没有链接邻接点</li><li>对每个出队列得结点广度遍历，即遍历完它得所有邻接点，没有复制过得就新建并加入队列，最后链接新建的结点和邻接点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">   Node* isClone[<span class="hljs-number">101</span>];<br>   <span class="hljs-function">Node* <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>       queue&lt;Node*&gt; que;<br>       Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>       isClone[node-&gt;val] = newNode;<br>       que.<span class="hljs-built_in">push</span>(node);<br>       <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>Node* cur = que.<span class="hljs-built_in">front</span>();<br>que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (Node* e : cur-&gt;neighbors) &#123;<br>       <span class="hljs-keyword">if</span> (isClone[e-&gt;val] == <span class="hljs-literal">NULL</span>) &#123;<br>que.<span class="hljs-built_in">push</span>(e);<br>isClone[e-&gt;val] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(e-&gt;val);<br>       &#125;<br>       isClone[cur-&gt;val]-&gt;neighbors.<span class="hljs-built_in">push_back</span>(isClone[e-&gt;val]);<br>&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h1><p><a href="https://leetcode-cn.com/problems/number-of-islands/">leetcode</a>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入:<br>[<br>[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],<br>[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],<br>[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],<br>[&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;]<br>]<br>输出: 1<br></code></pre></td></tr></table></figure><h3 id="DFS解题思路"><a href="#DFS解题思路" class="headerlink" title="DFS解题思路"></a>DFS解题思路</h3><ul><li>把二维表格当作一个图来处理，每个结点的上下左右都是它的邻接点</li><li>两个for循环遍历二维数组，当遇到<code>1</code>时开始深度遍历它的邻接点，凡是dfs遍历途中遇到<code>1</code>的都改为0，直到所有相连的1全部改为0，这就算找到了一个岛，后面继续遍历改后的二维数组。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(grid, i, j);<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;&amp; grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> row = grid.<span class="hljs-built_in">szie</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">szie</span>() - <span class="hljs-number">1</span>;<br>    grid[row][col] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (x &lt; row &amp;&amp; grid[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-built_in">dfs</span>(grid, x + <span class="hljs-number">1</span>, y);<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>   &amp;&amp; grid[x - <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-built_in">dfs</span>(grid, x - <span class="hljs-number">1</span>, y);<br>    <span class="hljs-keyword">if</span> (y &lt; col &amp;&amp; grid[x][y + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-built_in">dfs</span>(grid, x, y + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span>   &amp;&amp; grid[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-built_in">dfs</span>(grid, x, y - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFS解题"><a href="#BFS解题" class="headerlink" title="BFS解题"></a>BFS解题</h3></li><li>md，超出时间限制找了一个多小时的原因，一个字一个字对比最后才发现，一个<code>= </code>写成<code>==</code>，日啊。第二次犯这种错误了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (grid.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; que;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                cnt++;<br>                grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(i, j));<br>                <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>                    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>();<br>                    que.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-type">int</span> x = cur.first;<br>                    <span class="hljs-type">int</span> y = cur.second;<br>                    <span class="hljs-keyword">if</span> (x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>  &amp;&amp; grid[x - <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        grid[x - <span class="hljs-number">1</span>][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x - <span class="hljs-number">1</span>, y));<br>                    &#125;  <br>                    <span class="hljs-keyword">if</span> (y - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>  &amp;&amp; grid[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x, y - <span class="hljs-number">1</span>));<br>                        grid[x][y - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    &#125;  <br>                    <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt; row &amp;&amp; grid[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x + <span class="hljs-number">1</span>, y));<br>                        grid[x + <span class="hljs-number">1</span>][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt; row &amp;&amp; grid[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x + <span class="hljs-number">1</span>, y));<br>                        grid[x + <span class="hljs-number">1</span>][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (y + <span class="hljs-number">1</span> &lt; col &amp;&amp; grid[x][y + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x, y + <span class="hljs-number">1</span>));<br>                        grid[x][y + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h1><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">leetcode</a>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png">dd</a><br>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>暴力解法可以枚举以每个柱形为高度的最大矩形的面积。具体来说就是：依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。</li><li>左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标；</li><li>右边看一下，看最多能向右延伸多长；找到大于等于当前柱形高度的最右边元素的下标。</li><li>以下题解会超时。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (heights.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-type">int</span> left = i, right = i; <br>        <span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span> &amp;&amp; heights[left - <span class="hljs-number">1</span>] &gt;= heights[i]) left--;<br>        <span class="hljs-keyword">while</span> (right &lt; heights.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; heights[right + <span class="hljs-number">1</span>] &gt;= heights[i]) right++;<br>        <span class="hljs-type">int</span> len = right - left + <span class="hljs-number">1</span>;<br>        res = <span class="hljs-built_in">max</span>(res, heights[i] * len);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="01矩阵"><a href="#01矩阵" class="headerlink" title="01矩阵"></a>01矩阵</h1><p><a href="https://leetcode-cn.com/problems/01-matrix/">leetcode</a><br>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。<br>两个相邻元素间的距离为 1 。</p><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 输入:"><br>0 0 0<br>0 1 0<br>1 1 1<br>输出:<br><br>0 0 0<br>0 1 0<br>1 2 1<br></code></pre></td></tr></table></figure><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>理解题意比较难，题意要求我们找到每个1离0最近的距离，正常会想到遍历每个1，最每个1进行DFS或者BFS，但是这样就涉及到对上下左右每个分支的距离最短筛选的操作。时间复杂度也会大大增加。</li><li>因此我们可以反过来遍历，先遍历找到所有0的结点，他的4个上下左右分支点一定是1，而1的上下左右4个未访问过的分支点一定是2，依次展开。</li><li>BFS解法一般都涉及队列的使用：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> off[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>    <span class="hljs-type">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-type">bool</span> isVis[row][col];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-built_in">memset</span>(isVis[i], <span class="hljs-number">0</span>, col);<br>    &#125;<br>    <span class="hljs-comment">// 入队列的顺序：所有0的位置，所有离0点距离为1的点，所有离0点距离为2的点....</span><br>    queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; que;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                que.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>                isVis[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> x = que.<span class="hljs-built_in">front</span>().first;<br>        <span class="hljs-type">int</span> y = que.<span class="hljs-built_in">front</span>().second;<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> xi = x + off[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> yi = y + off[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (xi &gt;= <span class="hljs-number">0</span> &amp;&amp; xi &lt; row &amp;&amp; yi &gt;= <span class="hljs-number">0</span> &amp;&amp; yi &lt; col &amp;&amp; !isVis[xi][yi]) &#123;<br>                isVis[xi][yi] = <span class="hljs-literal">true</span>;<br>                matrix[xi][yi] = matrix[x][y] + <span class="hljs-number">1</span>; <br>                que.<span class="hljs-built_in">push</span>(&#123;xi, yi&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> matrix;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="设计循环队列"><a href="#设计循环队列" class="headerlink" title="设计循环队列"></a>设计循环队列</h1><p><a href="https://leetcode-cn.com/problems/design-circular-queue/">leetcode</a>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。<br>你的实现应该支持如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">MyCircularQueue(k): 构造器，设置队列长度为 k 。<br>Front: 从队首获取元素。如果队列为空，返回 -1 。<br>Rear: 获取队尾元素。如果队列为空，返回 -1 。<br>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>isEmpty(): 检查循环队列是否为空。<br>isFull(): 检查循环队列是否已满。<br></code></pre></td></tr></table></figure><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>两个指针，<code>head</code>和<code>tail</code>，注意满队和空队的条件，满队时：<code>tail</code>就在<code>head</code>的前一格，空队时：<code>tail</code>和<code>head</code>都指向-1。</li><li>凡涉及到循环，指针移动后都要对<code>size</code>取模才能保证不超过<code>size</code>大小。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; data;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> head;<br>    <span class="hljs-type">int</span> tail;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyCircularQueue</span>(<span class="hljs-type">int</span> k) &#123;<br>        data.<span class="hljs-built_in">resize</span>(k);<br>        size = k;<br>        head = <span class="hljs-number">-1</span>;<br>        tail = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFull</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) head = <span class="hljs-number">0</span>;<br>        tail = (tail + <span class="hljs-number">1</span>) % size;<br>        data[tail] = value;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (head == tail) &#123;     <span class="hljs-comment">// 只剩一个元素时</span><br>            head = <span class="hljs-number">-1</span>;<br>            tail = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        head = (head + <span class="hljs-number">1</span>) % size;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> data[head];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> data[tail];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> head == <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (tail + <span class="hljs-number">1</span>) % size == head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;🚑栈和队列🚑&quot;&gt;&lt;a href=&quot;#🚑栈和队列🚑&quot; class=&quot;headerlink&quot; title=&quot;🚑栈和队列🚑&quot;&gt;&lt;/a&gt;🚑栈和队列🚑&lt;/h1&gt;&lt;p&gt;转自：🔥&lt;a href=&quot;https://github.com/liuwentao1992&quot;&gt;【github】&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="力扣" scheme="https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="栈" scheme="https://www.mingsrc.work/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="https://www.mingsrc.work/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="https://www.mingsrc.work/posts/91a7e4d1"/>
    <id>https://www.mingsrc.work/posts/91a7e4d1</id>
    <published>2022-12-27T03:12:54.071Z</published>
    <updated>2022-12-27T03:12:54.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🐛双指针🐛"><a href="#🐛双指针🐛" class="headerlink" title="🐛双指针🐛"></a>🐛双指针🐛</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p><span id="more"></span><ul><li><a href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9">19. 删除链表的倒数第N个节点</a></li><li><a href="#%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB">75.颜色分类</a></li><li><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">88.合并两个有序数组</a></li><li><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">167.两数之和II-输入有序数组</a></li><li><a href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D">345.反转字符串中的元音字母</a></li><li><a href="#%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D">524.通过删除字母匹配到字典里最长单词</a></li><li><a href="#%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C">633.平方数之和</a></li><li><a href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">647.回文子串</a></li><li><a href="#%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1">680.验证回文字符串Ⅱ</a></li><li><a href="#%E4%BB%85%E5%90%AB1%E7%9A%84%E5%AD%90%E4%B8%B2%E6%95%B0">5461.仅含1的子串数</a></li></ul><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">leetcode</a>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>使用快慢指针，让快指针提前先走n+1步，然后双指针再同时让前走，当快指针指到结尾时，慢指针指向要删除结点得前驱  </li><li>为了让整个链表得删除操作都统一起来，所以加入了头节点<code>dummy</code>,因为删除某个结点得操作需要它得前驱，而第一个结点没有前驱，所以加入头结点会更方便，删除操作与其他结点统一。</li><li>链表所谓删除结点，即前一个结点得next指针越过此结点，指向下一结点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode* slow = dummy;<br>    ListNode* fast = dummy;<br>    n++;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        fast = fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (fast) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next;<br>    &#125;<br>    slow-&gt;next = slow-&gt;next-&gt;next;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h1><p><a href="https://leetcode-cn.com/problems/sort-colors/">Leetcode</a>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>一共三个指针，p0一直指向0的后一位，p2一直指向2的前一位，cur是用于遍历的指针。</li><li>本题属于荷兰旗帜问题：思想是遇到0就跟p0所指的数交换位置，遇到2就跟p2所指的数交换位置，遇到1就跳过。</li><li>注意：遇到2交换完位置后，cur指针不前进，因为要再次判断交换过来的数是0还是1。</li><li>注意2：while结束是 <code>cur &lt; p2</code>而不是<code>cur &lt; nums.size()</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p0 = <span class="hljs-number">0</span>, p2 = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur &lt; p2) &#123;<br>        <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">1</span>) cur++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(nums[p0++], nums[cur++]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">2</span>) <span class="hljs-built_in">swap</span>(nums[cur],nums[p2--]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">leetcode</a>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>合并有两种写法：while结束条件不同可分为写在while里和while外。</li><li>注意：数组的边界条件,对于链表指针<code>cur = NULL</code>为结束，而数组是<code>i = -1</code>和<code>i = size()</code>为结束。</li><li>思路：从后往前插入num1，两个指针分别从后往前遍历两个数组，较大值插入num1中。<h3 id="用-amp-amp-与作为结束条件"><a href="#用-amp-amp-与作为结束条件" class="headerlink" title="用&amp;&amp;与作为结束条件"></a>用&amp;&amp;与作为结束条件</h3></li><li>意思是：当两个数组其中一个遍历结束时，结束while循环，所以还需要将另一个数组的剩余部分依次插入nums1。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>      <span class="hljs-type">int</span> p1 = m - <span class="hljs-number">1</span>, p2 = n - <span class="hljs-number">1</span>, cur = m + n - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> ( p1 &gt;= <span class="hljs-number">0</span> &amp;&amp; p2 &gt;= <span class="hljs-number">0</span>)&#123;<br>          nums1[cur--] = nums1[p1] &gt; nums2[p2] ? nums1[p1--] : nums2[p2--];<br>      &#125;<br>      <span class="hljs-keyword">if</span> (p1 &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">while</span> (p2 &gt;= <span class="hljs-number">0</span>)<br>              nums1[cur--] = nums2[p2--];<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="用-或作为结束条件"><a href="#用-或作为结束条件" class="headerlink" title="用||或作为结束条件"></a>用||或作为结束条件</h3></li><li>意思是，只要当两个数组全部遍历完后，才结束while循环，所以再循环体内就要考虑其中一个遍历结束后的操作。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p1 = m - <span class="hljs-number">1</span>, p2 = n - <span class="hljs-number">1</span>, cur = n + m - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(cur &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> (p1 &lt; <span class="hljs-number">0</span>) nums1[cur--] = nums2[p2--];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 &lt; <span class="hljs-number">0</span>) nums1[cur--] = nums1[p1--];<br>        <span class="hljs-keyword">else</span> nums1[cur--] = nums1[p1] &gt; nums2[p2] ? nums1[p1--] : nums2[p2--];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="两数之和II-输入有序数组"><a href="#两数之和II-输入有序数组" class="headerlink" title="两数之和II-输入有序数组"></a>两数之和II-输入有序数组</h1><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">Leetcode</a>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>双指针相向遍历，</li><li>因为是有序数组，所以left指向小的数，right指向大的数，当两指针所指的数之和大于target，就前移right指针缩小大的数，当和小于target，就后移left指针，增大小的数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] == target)&#123;<br>            <span class="hljs-keyword">return</span> &#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] &lt; target) &#123;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] &gt; target) &#123;<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="反转字符串中的元音字母"><a href="#反转字符串中的元音字母" class="headerlink" title="反转字符串中的元音字母"></a>反转字符串中的元音字母</h1><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">leetcode</a>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>首尾各一个指针，当都指向元音字母时，交换字符串<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVolew</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;a&#x27;</span> || ch==<span class="hljs-string">&#x27;e&#x27;</span>||ch==<span class="hljs-string">&#x27;i&#x27;</span> || ch==<span class="hljs-string">&#x27;o&#x27;</span>||ch==<span class="hljs-string">&#x27;u&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;A&#x27;</span> || ch==<span class="hljs-string">&#x27;E&#x27;</span>||ch==<span class="hljs-string">&#x27;I&#x27;</span> || ch==<span class="hljs-string">&#x27;O&#x27;</span>||ch==<span class="hljs-string">&#x27;U&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">reverseVowels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>, right=s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isVolew</span>(s[left])) ++left;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isVolew</span>(s[right])) --right;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isVolew</span>(s[left]) &amp;&amp; <span class="hljs-built_in">isVolew</span>(s[right])) &#123;<br>            <span class="hljs-built_in">swap</span>(s[left++], s[right--]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="通过删除字母匹配到字典里最长单词"><a href="#通过删除字母匹配到字典里最长单词" class="headerlink" title="通过删除字母匹配到字典里最长单词"></a>通过删除字母匹配到字典里最长单词</h1><p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">leetcode</a>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入:<br>s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]<br>输出: <br>&quot;apple&quot;<br>输入:<br>s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br>输出: <br>&quot;a&quot;<br></code></pre></td></tr></table></figure><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>核心时判断一个字符串是不是另一个字符串的子序列，注意这里是子序列而不是子串，子序列是指每个字母在母串中的前后顺序不变。</li><li>使用双指针判断子序列，2各指针指向两个串，相同字母时指针后移，不同字母时只有母串指针后移，直到结束，看另一个指针是否指向结尾。</li><li>根据题意，要寻找最长的，所以一定要有一个变量储存当前最长值，然后不断进行比较。</li><li>compare()函数可以根据字典顺序比较，&lt;0表示字典顺序在前<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">findLongestWord</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; d)</span> </span>&#123;<br>    string longest = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; d.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>        <span class="hljs-keyword">if</span>(d[i].<span class="hljs-built_in">size</span>() &lt; longest.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(d[i].<span class="hljs-built_in">size</span>() == longest.<span class="hljs-built_in">size</span>() &amp;&amp; longest.<span class="hljs-built_in">compare</span>(d[i]) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSub</span>(s, d[i])) longest = d[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> longest;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSub</span><span class="hljs-params">(string s,string d)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; d.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == d[j])&#123;<br>            i++;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j == d.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="平方数之和"><a href="#平方数之和" class="headerlink" title="平方数之和"></a>平方数之和</h1><p><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/">Leetcode</a>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 &#x3D; c。</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>a,b可以为0，所以左指针从0开始而不是1，右指针sqrt(c)开始,效率高。</li><li>因为a和b可能是同一个数，所以while里的l可以&#x3D;r。</li><li>考虑s可能溢出，所以用r使用long型。<h3 id="为什么防止s溢出要将r设置为long型："><a href="#为什么防止s溢出要将r设置为long型：" class="headerlink" title="为什么防止s溢出要将r设置为long型："></a>为什么防止s溢出要将r设置为long型：</h3></li><li>问题在于计算过程中溢出了，计算式完全是以int运算来执行的，并且只有在运算完成之后，其结果才被提升为 long，而此时已经太迟：计算已经溢出。</li><li>解决方法使计算表达式的其中一个因子明确为long型，这样可以强制表达式中所有的后续计算都用long运算来完成，防止溢出<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> right = <span class="hljs-built_in">sqrt</span>(c);<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> sum = left * left + right * right;<br>        <span class="hljs-keyword">if</span> (sum &lt; c) &#123;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; c) &#123;<br>            right--;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum == c)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h1><a href="https://leetcode-cn.com/problems/palindromic-substrings/">Leetcode</a>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: &quot;aaa&quot;<br>输出: 6<br>说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.<br></code></pre></td></tr></table></figure><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3></li><li>双指针应用：中心扩展</li><li>回文串特性：对称相同</li><li>回文串：奇数个数和偶数个数，因此有两种扩展：当前字符向两边扩展笔记，当前字符和下一个字符向两边扩展比较。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>     <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i)&#123;<br>         <span class="hljs-built_in">expand</span>(s, i, i+<span class="hljs-number">1</span>, cnt);<br>         <span class="hljs-built_in">expand</span>(s, i, i, cnt);<br>     &#125;<br>     <span class="hljs-keyword">return</span> cnt;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span>&amp; cnt)</span></span>&#123;<br>     <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[left] == s[right])&#123;<br>         left--;<br>         right++;<br>         cnt++;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="680-验证回文字符串Ⅱ"><a href="#680-验证回文字符串Ⅱ" class="headerlink" title="680.验证回文字符串Ⅱ"></a>680.验证回文字符串Ⅱ</h1><p><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">Leetcode</a><br>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>传统思路：遍历每个结点，判断剩余结点能否形成回文，时间复杂度O(n^2)</li><li>因为回文对称相等，所以从两头开始遍历，当遇到不相同时，再删除其中一个再进行判断</li><li>优化：一开始就是从两头遍历的，所以已经遍历过的地方一定是相等，所以在<code>isPalindrome()</code>函数中不用从两头再重复遍历<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (s[left] != s[right]) <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">isPalindrome</span>(s, left + <span class="hljs-number">1</span>, right) || <span class="hljs-built_in">isPalindrome</span>(s, left, right - <span class="hljs-number">1</span>);<br>        left++; right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (s[left] != s[right]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        left++;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="仅含-1-的子串数"><a href="#仅含-1-的子串数" class="headerlink" title="仅含 1 的子串数"></a>仅含 1 的子串数</h1><p><a href="https://leetcode-cn.com/problems/number-of-substrings-with-only-1s/">leetcode</a><br>给你一个二进制字符串 s（仅由 ‘0’ 和 ‘1’ 组成的字符串）。<br>返回所有字符都为 1 的子字符串的数目。<br>由于答案可能很大，请你将它对 10^9 + 7 取模后返回。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：s = &quot;0110111&quot;<br>输出：9<br>解释：共有 9 个子字符串仅由 &#x27;1&#x27; 组成<br>&quot;1&quot; -&gt; 5 次<br>&quot;11&quot; -&gt; 3 次<br>&quot;111&quot; -&gt; 1 次<br><br></code></pre></td></tr></table></figure><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>刚开始想到用双指针，类似于滑动窗口的思想，每次窗口把连续的1框住，计算窗口中最大子串数。</li><li>滑动窗口思想，左右指针从0开始，先移动右指针，当右指针达到要求后，再移动左子针，直到左指针也满足一定要求，最后处理中间的字符，处理完继续移动右指针。</li><li>这里右指针的要求指向连续1的最后一位，即当<code>right</code>指向1，而<code>right+1</code>指向0,然后开始移动左子针，直到做指针指向第一个1停，至此形成一个窗口，处理结束后记得更新左指针。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSub</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (right + <span class="hljs-number">1</span> &lt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (s[right] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[right + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span> || <br>            s[right] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[right + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>            <span class="hljs-keyword">while</span> (s[left] == <span class="hljs-string">&#x27;0&#x27;</span>) left++;<br>            <span class="hljs-type">long</span> len = right - left + <span class="hljs-number">1</span>;<br>            res += (<span class="hljs-number">1</span> + len ) * len / <span class="hljs-number">2</span>;<br>            res %= <span class="hljs-number">1000000007</span>;<br>            left = right + <span class="hljs-number">1</span>;<br>        &#125;  <br>        right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果仔细发现当中的规律，1个1有1个子串，2个连续的有3个子串，3个连续的1有6个子串，n个连续的1有<code>1 + 2 + 3+...+n)</code>个子串,即连续1每当增加一个1就会多加len(1)个子串。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSub</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; ch : s) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            len++;<br>            res += len;<br>            res %= <span class="hljs-number">1000000007</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            len = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;🐛双指针🐛&quot;&gt;&lt;a href=&quot;#🐛双指针🐛&quot; class=&quot;headerlink&quot; title=&quot;🐛双指针🐛&quot;&gt;&lt;/a&gt;🐛双指针🐛&lt;/h1&gt;&lt;p&gt;转自：🔥&lt;a href=&quot;https://github.com/liuwentao1992&quot;&gt;【github】&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="力扣" scheme="https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="双指针" scheme="https://www.mingsrc.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://www.mingsrc.work/posts/850f2080"/>
    <id>https://www.mingsrc.work/posts/850f2080</id>
    <published>2022-12-27T03:12:54.071Z</published>
    <updated>2022-12-27T03:12:54.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="⚗哈希表⚗"><a href="#⚗哈希表⚗" class="headerlink" title="⚗哈希表⚗"></a>⚗哈希表⚗</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p><span id="more"></span><ul><li><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">1.两数之和</a>  </li><li><a href="#%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2">205.同构字符串</a>  </li><li><a href="#%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">217.存在重复元素</a>  </li><li><a href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">242.有效的字母异位词</a></li><li><a href="#%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0">347.前K个高频元素</a></li><li><a href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2">409.最长回文串</a></li><li><a href="#%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F">451.根据字符出现频率排序</a></li><li><a href="#%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97">594.最长和谐子序列 </a></li></ul><!--more--><h1 id="C-哈希表的基本使用"><a href="#C-哈希表的基本使用" class="headerlink" title="C++哈希表的基本使用  "></a>C++哈希表的基本使用  </h1><ul><li>查找元素是否存在<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">若有unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>查找x是否在map中<br>方法<span class="hljs-number">1</span>:  若存在  mp.<span class="hljs-built_in">find</span>(x)!=mp.<span class="hljs-built_in">end</span>()；<br>方法<span class="hljs-number">2</span>:  若存在  mp.<span class="hljs-built_in">count</span>(x)!=<span class="hljs-number">0</span>；<br></code></pre></td></tr></table></figure></li><li>遍历map<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    unordered_map&lt;key,T&gt;::iterator it;<br>    (*it).first;        <br>    (*it).<span class="hljs-function">second  </span><br><span class="hljs-function">    <span class="hljs-title">for</span><span class="hljs-params">(unordered_map&lt;key,T&gt;::iterator iter=mp.begin();iter!=mp.end();iter++)</span></span><br><span class="hljs-function">          cout&lt;&lt;&quot;key value is&quot;&lt;&lt;iter-&gt;first&lt;&lt;&quot; the mapped value is &quot;&lt;&lt; iter-&gt;second</span>;<br></code></pre></td></tr></table></figure></li><li>用高级for循环时<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; it : mp)&#123;<br>        cout&lt;&lt; it.first &lt;&lt;it.second;<br>&#125;<br>````<br><br>两数之和    <br>=============  <br>[Leetcode](https:<span class="hljs-comment">//leetcode-cn.com/problems/two-sum/description/)给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍<br>### 解题思路<br>* 一次遍历法<br>*  如果发现满足条件的key值就<span class="hljs-keyword">return</span>它得值出去，没发现就加入map中<br>```cpp<br>    vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(target - nums[i]) != hash.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;hash[target - nums[i]], i&#125;;<br>            &#125;<br>            hash[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="同构字符串"><a href="#同构字符串" class="headerlink" title="同构字符串"></a>同构字符串</h1><p><a href="https://leetcode-cn.com/problems/isomorphic-strings/">leetcode</a>给定两个字符串 s 和 t，判断它们是否是同构的。<br>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。<br>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>哈希交叉映射</li><li>比如对于tit和pap，对于tit所有的t对应p，所有的i对应a。对于pap所有的p对应t，所有的a对应i</li><li>同时遍历两个字符串，就去map中寻找 该字母是否有对应值（映射），</li><li>如果有就去查该映射的值是否与另一个字符串中对应位字母相同，如果不同就不是同构字符串<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() != t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>&gt; shash;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>&gt; thash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (shash.<span class="hljs-built_in">find</span>(s[i]) != shash.<span class="hljs-built_in">end</span>() &amp;&amp; shash[s[i]] != t[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (thash.<span class="hljs-built_in">find</span>(t[i]) != thash.<span class="hljs-built_in">end</span>() &amp;&amp; thash[t[i]] != s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        shash[s[i]] = t[i];<br>        thash[t[i]] = s[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素  "></a>存在重复元素  </h1><p><a href="https://leetcode-cn.com/problems/contains-duplicate/description/">Leetcode</a>给定一个整数数组，判断是否存在重复元素。<br>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。  </p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>哈希表建立每个数字出现的频率</li><li>大于1说明重复<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; frequence;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : nums)&#123;<br>        <span class="hljs-keyword">if</span>(++frequence[it] &gt; <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><p><a href="https://leetcode-cn.com/problems/valid-anagram/">leetcode</a>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;<br>输出: true<br></code></pre></td></tr></table></figure><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>对字符串s建立字母的哈希频率表，再遍历t串，对应的字母频率-1，最后遍历哈希表，如果仍有字母频率不为0，说明有多余的字母。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() != t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        hash[s[i]]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; t[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        hash[t[i]]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : hash) &#123;<br>        <span class="hljs-keyword">if</span> (it.second) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h1><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">leetcode</a>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br></code></pre></td></tr></table></figure><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>建立哈希表统计数字出现频率，</li><li>利用隐式转换，把无序hash转换为pair类型方便按照频率多少进行排序</li><li>使用SLT的sort()函数进行排序，大小的比较规则cmp函数需要自己写。</li><li>将排好序的前k元素输出<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; v1, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; v2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> v1.second &gt; v2.second;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        hash[nums[i]]++;<br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">arr</span>(hash.<span class="hljs-built_in">begin</span>(), hash.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(arr[i].first);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h1><p><a href="https://leetcode-cn.com/problems/longest-palindrome/">leetcode</a>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。<br>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>根据题意，只需求出最长回文串的长度，而不需要找出最长回文串，所以我们只需利用回文串的特性，统计哪些字母出现了偶数次，哪些出现了奇数次，只需计算他们次数即可。</li><li>出现偶数次的字母一定是回文串的一部分，奇数次的字母只需-1次也能组成回文串，最后如果组成的回文串长度小于母串，还可以再再中间加一个字母组成回文串。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : s) &#123;<br>        hash[it]++;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : hash) &#123;<br>       res += it.second % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? it.second : it.second - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res = res &lt; s.<span class="hljs-built_in">size</span>() ? res + <span class="hljs-number">1</span> : res ;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="根据字符出现频率排序"><a href="#根据字符出现频率排序" class="headerlink" title="根据字符出现频率排序"></a>根据字符出现频率排序</h1><p><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">leetcode</a>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>哈希表建立的频率表是无序的，所以需要转换为其他数据结构，再使用排序算法对其排序</li><li>可以使用隐式的类型转换为<code>pair&lt;char,int&gt;</code>，再使用STL里面的sort()函数进行排序，sort的好处是可以自定义排序的规则。</li><li>sort()函数自定义的排序规则需要写成静态的函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; a, pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : s) &#123;<br>        hash[it]++;<br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">arr</span>(hash.<span class="hljs-built_in">begin</span>(), hash.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>    string res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : arr) &#123;<br>        <span class="hljs-keyword">while</span> (it.second--) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(it.first);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="最长和谐子序列"><a href="#最长和谐子序列" class="headerlink" title="最长和谐子序列  "></a>最长和谐子序列  </h1><p><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/description/">Leetcode</a>  和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。<br>现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。    </p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: [1,3,2,2,5,2,3,7]<br>输出: 5<br>原因: 最长的和谐数组是：[3,2,2,2,3].<br></code></pre></td></tr></table></figure><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>找最长的长度，一定需要一个数字去记录当前最长值，并不断跟后面的数进行比较</li><li>统计数字出现频率，遍历哈希表的每一个key时，找当前key值大1的数也存不存在哈希表中，如果存在就相加与当前的max变量进行比较。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLHS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-type">int</span> longest = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : nums) &#123;<br>        hash[it]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : hash) &#123;<br>        <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(it.first+<span class="hljs-number">1</span>) != hash.<span class="hljs-built_in">end</span>())&#123;<br>            longest = <span class="hljs-built_in">max</span>(longest, it.second + hash[it.first+<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> longest;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;⚗哈希表⚗&quot;&gt;&lt;a href=&quot;#⚗哈希表⚗&quot; class=&quot;headerlink&quot; title=&quot;⚗哈希表⚗&quot;&gt;&lt;/a&gt;⚗哈希表⚗&lt;/h1&gt;&lt;p&gt;转自：🔥&lt;a href=&quot;https://github.com/liuwentao1992&quot;&gt;【github】&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="大神们の笔记" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="C++" scheme="https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"/>
    
    <category term="github" scheme="https://www.mingsrc.work/categories/github/"/>
    
    
    <category term="C++" scheme="https://www.mingsrc.work/tags/C/"/>
    
    <category term="力扣" scheme="https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"/>
    
    <category term="哈希" scheme="https://www.mingsrc.work/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
</feed>
