{"meta":{"title":"欧恩意","subtitle":"","description":"信仰就是力量","author":"mingming.shi","url":"https://www.mingsrc.work"},"posts":[{"title":"我|❤️","slug":"情话","date":"2022-12-27T03:12:54.115Z","updated":"2022-12-27T03:12:54.115Z","comments":true,"path":"posts/f2745b45.html","link":"","permalink":"https://www.mingsrc.work/posts/f2745b45","excerpt":"","text":"body {background:white} h1.post-title{color:red;}div#post { background: fixed; color: antiquewhite; }.meta { background: black; width: fit-content; padding-right: 10px; border-radius: 50px; filter: drop-shadow(2px 4px 6px black); } .meta p { color: white; } div.timenode .body { margin: 14px 0 16px 24px; } var t2 = window.setInterval(function () { divMe.className = imglist[index]; index++; index %= imglist.length; console.log('每隔5秒钟执行一次') }, 5000) 2021 2021-04-02 从今天开始啦 “ 既许一人以偏爱，愿尽余生之慷慨 ” 2021-04-02 闲着就容易犯愁 “ 如果运气不行那就试试勇气 ” 2021-05-17 营养 “ 你说，营养是什么！ ” 2021-10-25 DAY100 “ One For You ”","raw":null,"content":null,"categories":[],"tags":[]},{"title":"痕迹","slug":"自述","date":"2022-12-27T03:12:54.115Z","updated":"2022-12-27T03:43:18.540Z","comments":true,"path":"posts/252a5848.html","link":"","permalink":"https://www.mingsrc.work/posts/252a5848","excerpt":"","text":"“M Y L I F E”2021 2021-03-18 今天，该想的我都想了 2021-05-14 “精神食粮” 2021-05-17 “灵魂与肉体” 2021-06-07 今天的苦算吃完了，明天的苦还远得很，这一夜的身心安适是向不属今明两天的中立时间里的躲避。 ——钱钟书《围城》{% note green ‘fas fa-key’ modern %}原来钱老的围城，可以把人世间的苦，说的这么遥远。{% endnote %} 2020-10-12 我希望有个如你一般的人，如山间清爽的风，如古城温暖的光，从清晨到夜晚，由山野到书房，只要最后是你就好。 2020-10-20 说好了不再继续入坑，但是看了别人家的主页后······😂 😂 😂 2020-10-24 今天你不快乐的原因是因为什么？ 2020-12-14 也许，一个人要是想在茫茫人海中要保持一点独立性，那么他必须让自己显得古怪些才成。可我不喜欢这句话，最近实在是太烂了。 2021-2-24 及时当勉励，岁月不待人。 2021-10-27 见字如面，既爱又恨，那段时光","raw":null,"content":null,"categories":[],"tags":[]},{"title":"windows右键菜单添加","slug":"K_Windows系列/鼠标右键添加二级菜单","date":"2022-12-27T03:12:54.100Z","updated":"2022-12-27T03:12:54.100Z","comments":true,"path":"posts/8fe8a499.html","link":"","permalink":"https://www.mingsrc.work/posts/8fe8a499","excerpt":"","text":"注册表添加桌面右键二级菜单效果图：想要通过注册表实现这种效果，只需要创建一个爸爸、一个儿子。 注册表修改详细步骤讲解1、win+r输入regedit快捷打开注册表。（当然也可以去C路径下的Windows目录下寻找） 注册表这东西长这个样子。 2、第二步就要先创建一个儿子，也就是二级菜单里面的每一个子文件。 划重点：按照这个路径去寻找shell： 1HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell 找到shell之后右键单击找到新建，然后在新建的子菜单中选择项，创建一个项（没懂看图） 然后，你会看见有一个新建的新项 #1，这个就是你创建儿子（二级菜单子文件），现在右键单击重命名，对你创建的儿子起个好记的名字（这个名字不会出现在桌面二级菜单，内部使用），自定义、尽量字母或英文，避免出现不必要的麻烦。（no懂得看图）这里我改为了CSDN，新建项的右方会有一个默认的字符串值，双击打开编辑，这里创建自定义名称，就是桌面你想显示的软件名称（no懂看图）在这个新建的文件内右键点击新建一个字符串值（重命名为Icon），来存放二级菜单内要显示的软件的图标。（no懂得看图）双击打开创建的Icon字符串进行编辑，放入软件路径默认显示软件图标，可以自己制作icon图标进行自定义。（no懂得看图） 接着按相同的步骤在自己刚创建儿子（二级菜单子文件）里面创建一个项，no字符串值，是项！是项！是项！项的名字重命名为command，这个里面存放二级菜单子文件软件路径。（no懂看图）重命名为command（no懂得看图）双击command右边框中的字符串值，在弹出的编辑框中，数值数据输入你所要在二级菜单目录下显示的软件的路径，这里我放的Xshell的路径。（no懂看图） 到这里儿子就创建好了，我们来创建爸爸。 3、找爸爸： 在注册表中找到这个地方： 1HKEY_CLASSES_ROOT\\Directory\\Background\\shell 然后新建一个爸爸（项），名字自定义在这个项里面创建两个字符串值文件，一个重命名Icon，放图标路径，自定义，这个就参照上面详细介绍。另一个是把儿子链接过来的，重命名SubCommands，注意大小写，把刚才创建的儿子名字输入到这个里面，如果要放多个的话，英文分号隔开。（no懂看图） 单个： 多个：慢慢一步一步来，看不懂去个厕所，回来再看一遍","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Windows不常用快捷键合集","slug":"K_Windows系列/Windows快捷键","date":"2022-12-27T03:12:54.099Z","updated":"2022-12-27T06:57:36.946Z","comments":true,"path":"posts/d8fac1ab.html","link":"","permalink":"https://www.mingsrc.work/posts/d8fac1ab","excerpt":"Windows不常用快捷键\n单纯敲键盘比鼠标快的原因，所以整理一些不常用的快捷键给想要速度更快的你\n","text":"Windows不常用快捷键 单纯敲键盘比鼠标快的原因，所以整理一些不常用的快捷键给想要速度更快的你 @## note [success] [no-icon] [flat] ##@Windows快捷键@## endnote ##@ 窗口放大缩小快捷键最大化Alt+Space+X 最小化Alt+Space+N 改变窗口大小Alt+Space+S 多个窗口切换alt+tab 最小化所有窗口Windows+M 全部最小化(即显示zhi桌面)WIN+D 最大化窗口win+↑（方向键上） 往下缩放窗口。win+↓（方向键下） 截屏Win+Shift+s","raw":null,"content":null,"categories":[{"name":"Windows系列","slug":"Windows系列","permalink":"https://www.mingsrc.work/categories/Windows%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.mingsrc.work/tags/Windows/"},{"name":"桌面美化","slug":"桌面美化","permalink":"https://www.mingsrc.work/tags/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"},{"name":"快捷方式","slug":"快捷方式","permalink":"https://www.mingsrc.work/tags/%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"}]},{"title":"Windows壁纸软件推荐","slug":"K_Windows系列/一款精美简约的Windows壁纸软件","date":"2022-12-27T03:12:54.099Z","updated":"2022-12-27T06:58:43.008Z","comments":true,"path":"posts/db382da4.html","link":"","permalink":"https://www.mingsrc.work/posts/db382da4","excerpt":"","text":"爱壁纸UWP爱壁纸UWP下载链接 有影视明星、风光风景、性感美女、花卉植物、体育运动、动物宠物、游戏CG、卡通动漫、机车世界、炫彩美图、品牌欣赏、美食天下、影视剧集、艺术设计、节庆假日、美图杂烩等的壁纸分类内容。 ★WIN10商店娱乐分类第一 ★ 最高人气必备应用 ★ 壁纸类下载排名第一应用 ★诺基亚“春 Phone 计划”优秀应用 ★ 微软“Live SDK应用大赛”优秀应用 全球首款跨平台服务专业级壁纸应用，提供海量优质壁纸，超乎想象的精彩！ [特 点] 1.方便便捷，锁屏预览、一键设置锁屏； 2.天气锁屏，精彩锁屏壁纸上天气早知道； 3.自动换景，定时自动更换个性锁屏壁纸； 4.批量下载，收藏后批量下载到本地壁纸； 5.高清壁纸，榜单、精选、专题、每日更新； 6.贴心服务，分类、标签、搜索、预览、收藏； 7.特色功能，颜色筛选、猜你喜欢、壁纸拼图； 8.节省流量，自动缓存图片,更有缓存清理功能，解除存储烦忧。 我们有影视明星、风光风景、性感美女、花卉植物、体育运动、动物宠物、游戏CG、卡通动漫、机车世界、炫彩美图、品牌欣赏、美食天下、影视剧集、艺术设计、节庆假日、美图杂烩等的壁纸分类内容。 附上一些比较好看壁纸","raw":null,"content":null,"categories":[{"name":"Windows系列","slug":"Windows系列","permalink":"https://www.mingsrc.work/categories/Windows%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.mingsrc.work/tags/Windows/"},{"name":"桌面美化","slug":"桌面美化","permalink":"https://www.mingsrc.work/tags/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"}]},{"title":"Windows右键添加Windows Terminal","slug":"K_Windows系列/右键添加Windows Terminal","date":"2022-12-27T03:12:54.099Z","updated":"2022-12-27T06:59:33.486Z","comments":true,"path":"posts/3a70d3a5.html","link":"","permalink":"https://www.mingsrc.work/posts/3a70d3a5","excerpt":"","text":"Windows Terminal添加到鼠标右键Windows Terminal 右键顺滑上手 折腾博客主题的时候看见了Windows Terminal的快捷打开方式，那就试试~ 如果Windows上有比从cmd和PowerShell好用的终端，还能添加到鼠标右键菜单，你想要试试吗? 下载Windows TerminalWindows Teriminl 并且，这个是支持自己去编译的，如果你够厉害，可以根据自己需要修改源文件，github上有源文件。 GitHub - microsoft/terminal: The new Windows Terminal, and the original Windows console host - all in the same place! 添加Windows Terminal到右键菜单测试变量先检测下边两个变量是否可以正常输出 第一种： 12echo %USERPROFILE%echo %LOCALAPPDATA% 如果输出的是%USERPROFILE%和%LOCALAPPDATA%或者报错的情况下,替换掉%USERPROFILE%和%LOCALAPPDATA%，如下所示，在reg文档中同样： 第二种： 12echo C:\\Users\\[userName]echo C:\\Users\\[userName]\\AppData\\Local 如果使用的是第一种，后边的命令行就都可以使用第一种，如果是第二种，后边操作中的文件路径都使用绝对路径 [userName]是你的用户名 创建terminal文件夹打开命令行，输入 1mkdir &quot;%USERPROFILE%\\AppData\\Local\\terminal&quot; 或者直接在文件管理器[userName]\\AppData\\Local\\直接新建teriminal文件夹。 写入注册表在Terminal中创建txt文档，后缀名为reg， 右键菜单会出现Windows Terminal的当时有两种，一种是：shift+鼠标右键，另一种是：鼠标右键。接下来根据自己需要选择两种方式中的一种即可： shift+鼠标右键 把下边的内容复制到reg中： 12345678Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt]@=&quot;Windows Terminal&quot;&quot;Extended&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command]@=&quot;C:\\\\Users\\\\[userName]\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe&quot; 注意:需要把[userName]改为自己电脑的用户名 右键 把下边内容复制到reg中： 1234567Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt]@=&quot;Windows terminal here&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command]@=&quot;C:\\\\Users\\\\[userName]\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe&quot; 注意:需要把[userName]改为自己电脑的用户名 修改Windows Terminal的profile.json打开profile.json 然后按照下图修改对应的内容就可以： 1&quot;startingDirectory&quot;: null 到此，就成功把Terminal添加到鼠标右键了 一些常用的键与命令 tab 命令补全 ls 查看文件及文件结构 type 查看文件内容 直接输入文件名会用默认应用打开 cd 切换工作目录","raw":null,"content":null,"categories":[{"name":"Windows系列","slug":"Windows系列","permalink":"https://www.mingsrc.work/categories/Windows%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.mingsrc.work/tags/Windows/"},{"name":"桌面美化","slug":"桌面美化","permalink":"https://www.mingsrc.work/tags/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"},{"name":"快捷方式","slug":"快捷方式","permalink":"https://www.mingsrc.work/tags/%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"}]},{"title":"【一文搞懂】【WIN】【CMD】netsh用法整理","slug":"K_Windows系列/Windows安全/netsh用法整理","date":"2022-12-27T03:12:54.098Z","updated":"2022-12-27T03:12:54.098Z","comments":true,"path":"posts/66ebbc05.html","link":"","permalink":"https://www.mingsrc.work/posts/66ebbc05","excerpt":"","text":"Netsh 是命令行脚本实用工具，可让你显示或修改当前正在运行的计算机的网络配置。 可以通过在 netsh 提示符下键入命令来运行 Netsh 命令，并且可以在批处理文件或脚本中使用 Netsh 命令。 可以使用 netsh 命令来配置远程计算机和本地计算机。 Netsh 还提供脚本功能，可让你在批处理模式下对指定的计算机运行一组命令。 你可以使用 Netsh 将配置脚本保存在文本文件中，以便存档或者帮助你配置其他计算机。 一、如何正确使用netsh 当我们忘记netsh的相关命令时，可以直接使用netsh自带的帮助功能，就能看到一些可以使用的命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546netsh /?C:\\Users\\ming Ming&gt;netsh /?Usage: netsh [-a AliasFile] [-c Context] [-r RemoteMachine] [-u [DomainName\\]UserName] [-p Password | *] [Command | -f ScriptFile]The following commands are available:Commands in this context:? - Displays a list of commands.add - Adds a configuration entry to a list of entries.advfirewall - Changes to the `netsh advfirewall&#x27; context.bridge - Changes to the `netsh bridge&#x27; context.delete - Deletes a configuration entry from a list of entries.dhcpclient - Changes to the `netsh dhcpclient&#x27; context.dnsclient - Changes to the `netsh dnsclient&#x27; context.dump - Displays a configuration script.exec - Runs a script file.firewall - Changes to the `netsh firewall&#x27; context.help - Displays a list of commands.http - Changes to the `netsh http&#x27; context.interface - Changes to the `netsh interface&#x27; context.ipsec - Changes to the `netsh ipsec&#x27; context.lan - Changes to the `netsh lan&#x27; context.mbn - Changes to the `netsh mbn&#x27; context.namespace - Changes to the `netsh namespace&#x27; context.netio - Changes to the `netsh netio&#x27; context.nlm - Changes to the `netsh nlm&#x27; context.p2p - Changes to the `netsh p2p&#x27; context.ras - Changes to the `netsh ras&#x27; context.rpc - Changes to the `netsh rpc&#x27; context.set - Updates configuration settings.show - Displays information.trace - Changes to the `netsh trace&#x27; context.wcn - Changes to the `netsh wcn&#x27; context.wfp - Changes to the `netsh wfp&#x27; context.winhttp - Changes to the `netsh winhttp&#x27; context.winsock - Changes to the `netsh winsock&#x27; context.wlan - Changes to the `netsh wlan&#x27; context.The following sub-contexts are available: advfirewall bridge dhcpclient dnsclient firewall http interface ipsec lan mbn namespace netio nlm p2p ras rpc trace wcn wfp winhttp winsock wlanTo view help for a command, type the command, followed by a space, and then type ?. 那知道有哪些可选功能后，我们就可以进一步输入二级命令去执行我们将要进行的操作，比如下边我就以查看当前tcp链接状态位列展示： 1234567891011121314151617181920212223242526$&gt;netsh$netsh&gt;int$netsh interface&gt;ip$netsh interface ipv4&gt;show tcpstatsTCP Statistics------------------------------------------------------Timeout Algorithm: Van Jacobson&#x27;s AlgorithmMinimum Timeout: 5Maximum Timeout: 4294967295Maximum Connections: DynamicActive Opens: 3971Passive Opens: 556Attempts Failed: 1017Established Resets: 407Currently Established: 34In Segments: 202193Out Segments: 149657Retransmitted Segments: 0In Errors: 0Out Resets: 845Fastopen Active Opens: 0Fastopen Passive Opens: 0Fastopen Attempts Failed: 0Retransmits Of First SYN: 644Retransmits Of First SYN (Fastopen): 0 二、netsh命令整理1. 导出导入脚本 导出配置脚本： 1netsh -c interface ip dump &gt; c:/interface.txt 导入配置脚本： 1netsh -f c:/interface.txt 2. 固定IP地址批处理&#x2F;&#x2F;SETIPDNS.bat（ “本地连接”换成你网卡的名字, 具体的 ip 地址，网关，请自行修改 ） 12345678910111213141516171819202122232425@echo offecho 正在修改本机IP...netsh interface ip set address name=&quot;本地连接&quot; source=static 192.168.1.188 255.255.255.0 192.168.1.1 1echo 正在添加本机主DNS...netsh interface ip set dns &quot;本地连接&quot; static 18.0.0.10 primaryecho 正在添加本机副DNS...netsh interface ip add dns &quot;本地连接&quot; 18.0.0.10echo 设置完成...echo 检查当前本机配置...ipconfig /allecho 导出配置脚本...netsh -c interface ip dumppause 3. 自动获取 IP123456789101112131415161718192021@echo offecho 正在修改本机IP...netsh interface ip set address name=&quot;本地连接&quot; source=dhcpecho 正在添加本机主DNS...netsh interface ip set dns &quot;本地连接&quot; dhcpecho 设置完成...echo 检查当前本机配置...ipconfig /allecho 导出配置脚本...netsh -c interface ip dumppause 4. netsh用法 查看网络配置 123456789101112131415161718netsh interface ip show &#123;选项&#125;&#123;选项&#125;可以是：address-显示IP地址配置。config-显示IP地址和更多信息。dns-显示DNS服务器地址。icmp-显示ICMP统计。interface-显示IP接口统计。ipaddress-显示当前IP地址。ipnet-显示IP的网络到媒体的映射。ipstats-显示IP统计。joins-显示加入的多播组。offload-显示卸载信息。tcpconn-显示TCP连接。tcpstats-显示TCP统计。udpconn-显示UDP连接。udpstats-显示UDP统计。wins-显示WINS服务器地址。 查看网络配置 123456789101112131415161718netsh interface ip show &#123;选项&#125;&#123;选项&#125;可以是：address-显示IP地址配置。config-显示IP地址和更多信息。dns-显示DNS服务器地址。icmp-显示ICMP统计。interface-显示IP接口统计。ipaddress-显示当前IP地址。ipnet-显示IP的网络到媒体的映射。ipstats-显示IP统计。joins-显示加入的多播组。offload-显示卸载信息。tcpconn-显示TCP连接。tcpstats-显示TCP统计。udpconn-显示UDP连接。udpstats-显示UDP统计。wins-显示WINS服务器地址。 配置接口IP&#x2F;网关IP 1netsh interface ip set address &quot;本地连接&quot; static 10.1.2.90 255.255.255.0 10.1.2.254 1 配置自动换取IP地址,DNS地址及wins地址 123netsh interface ip set address &quot;本地连接&quot; dhcpnetsh interface ip set dns &quot;本地连接&quot; dhcpnetsh interface ip set wins &quot;本地连接&quot; dhcp 配置静态IP地址，DNS地址及wins地址 123netsh interface ip set address &quot;本地连接&quot; static 10.1.2.90netsh interface ip set dns &quot;本地连接&quot; static 202.99.160.68netsh interface ip set wins &quot;本地连接&quot; static 10.1.2.200 看网络配置文件 1C:&gt;netsh -c interface dump 导出网络配置文件 1netsh -c interface dump &gt; d:/1.txt 导入网络配置文件 12netsh -f d:/1.txtnetsh exec d:/2.txt netsh 配置防火墙查看、开启或禁用系统防火墙 12345678# 查看防火墙的状态netsh firewall show state# 禁用系统防火墙netsh firewall set opmode disable# 启用防火墙netsh firewall set opmode enable","raw":null,"content":null,"categories":[{"name":"WIN","slug":"WIN","permalink":"https://www.mingsrc.work/categories/WIN/"},{"name":"CMD","slug":"WIN/CMD","permalink":"https://www.mingsrc.work/categories/WIN/CMD/"}],"tags":[{"name":"WIN","slug":"WIN","permalink":"https://www.mingsrc.work/tags/WIN/"},{"name":"CMD","slug":"CMD","permalink":"https://www.mingsrc.work/tags/CMD/"}]},{"title":"并发与多线程","slug":"J_LeetCode/并发与多线程","date":"2022-12-27T03:12:54.097Z","updated":"2022-12-27T03:12:54.097Z","comments":true,"path":"posts/12e8fad9.html","link":"","permalink":"https://www.mingsrc.work/posts/12e8fad9","excerpt":"并发与多线程转自：🔥【github】 ","text":"并发与多线程转自：🔥【github】 1、创建线程 调用线程函数： 1thread myThread(函数名); 可调用对象做参数： 线程的入口函数在对象的类重载()的函数void operator()()中,对象是值传递所以还必须有拷贝构造函数Obj(const &amp;obj)，这里对象是值传递1234void operator()()&#123;&#125;;thread myThread(对象);void operator()(int val);thread myThread(对象,val); lambda表达式： 123456789auto mylamthread = [] &#123; ;&#125;````使用线程：-----------* 实际只使用join()：只有当所有线程运行结束后才运行主线程```cppthreadObj.detach();threadObj.join();threadObj.joinable(); //判断是否可以使用join() 2、线程传参普通类型做线程参数 创建线程时，即使线程函数参数是&amp;，主线程传递也依旧是值传递重新拷贝一份给线程函数。12void func(int &amp;var,)&#123;&#125; thread myThread(func,var); //myTread中var和func中的var不同地址 类对象做线程参数 传递类对象，应避免隐式类型转换，全部使用构建临时对象，线程函数必须用const &amp;来接，避免再次构造对象。12void func(const Obj &amp;obj)&#123;&#125; thread myThread(func,Obj(0)); //先构造临时对象Obj(0)，值传递复制给func函数obj对象 如果非要用主线程的对象本身做线程参数12345void func(Obj &amp;obj) //可以不用constObj obj; thread myThread(func,std::ref(obj)); //相当于&amp;obj 用类成员函数指针做线程函数 12void threadWorkFunc(int val)&#123;&#125;;thread myThread(&amp;Obj::threadWorkFunc,&amp;obj,val); //使用&amp;obj也可保证主线程和线程使用同一个对象 3、互斥量mutex类 相当于一把锁。lock() 与unlock()必须成对使用，先lock，再操作共享数据，然后unlock lock_guard类模板 为了防止忘记unlock，引入std::lock_guard类模板,在定义时，构造函数中自动调用lock()，在析构函数中自动调用 unlock()，直接取代unlock lock函数，不能共用; 使用：只需要在操作共享数据前加一行将互斥量加入模板即可，不需要考虑解锁 一般项目使用lock_guard就足够了1std::lock_guard&lt;std::mutex&gt; mutexGuard(my_mutex); 死锁 至少有两个互斥量存在，在两个进程中，两个互斥量的lock()次序不同，就会引起死锁只要保持上锁的顺序一致就行 示例123456789101112131415161718192021222324252627class Obj&#123; //线程类private: std:List&lt;int&gt; MsgRecvQueue; //共享数据容器 mutex my_mutex; //互斥锁public: void outMsgRecvQueue()&#123; //读数据线程函数 my_mutex.lock(); if(!MsgRecvQueue.empty())&#123; //判断也是操作共享数据 MsgRecvQueue.pop_front(); //if函数的每个分支都要解锁 my_mutex.unlock(); &#125;else&#123; my_mutex.unlock(); &#125; &#125;; void inMsgRecvQueue()&#123; //写数据线程函数 my_mutex.lock(); //锁住 MsgRecvQueue.push_back(); //写数据 my_mutex.unlock(); //解锁 &#125;; &#125;;Obj obj;std::thread myInMsgThread(&amp;Obj::inMsgRecvQueue,&amp;obj); //写数据线程std::thread myOutMsgThread(&amp;Obj::outMsgRecvQueue,&amp;obj); //读数据线程myInMsgThread.join();myOutMsgThread.join(); 4、单例模式与数据共享问题 构造函数私有化 本类指针类型的静态成员变量 返回本类指针得静态成员函数 对象只能创建一次 推荐主线程中创建对象（例如初始化配置信息），多线程只读访问，不需要互斥 线程中创建单例对象需要建立互斥1234567891011121314151617class Obj&#123;private: Obj()&#123;&#125;;private: static Obj* obj;public: static Obj* GetInstance()&#123; if(obj==null)&#123; //双重锁定提高效率 std::lock_guard&lt;std::mutex&gt; mutexGuard(myMutex); if(obj==null) //即if判断两次，因为=null时不一定指对象没有new，可能多个线程争抢权限 obj=new Obj; &#125; return obj; &#125;&#125;;Obj* Obj::obj=null; std::this_thread::get_id() 5、效率问题双重锁定 使用两个判断，第一次提高效率，第二次只有加锁后的判断成立，才是真正的obj&#x3D;&#x3D;bull1234if(obj==null)&#123; std::lock_guard&lt;std::mutex&gt; mutexGuard(myMutex); if(obj==null) obj=new Obj; 条件变量 std::condition_variable 是一个类，函数waite()等待通知notify_noce()，收到通知后，将开启循环尝试拿锁 拿锁成功后，第二参数判断为true：往后执行代码 拿锁成功后，第二参数判断为false:继续休眠，等待notify_noce()通知 1234写数据线程1std::lock_guard&lt;std::mutex&gt; mutexGuard(myMutex)dataQueue.push_back(1);my_condition.notyfy_one(); //my_condition是condition_variable类对象 12345678读数据线程2std::lock_guard&lt;std::mutex&gt; mutexGuard(myMutex)my_condition(mutexGuard,[this]&#123; //第二参数使用lambda表达式 if(!dataQueue.empty()) return true; return false; &#125;);dataQueue.pop_front(); //收到通知，持续拿锁，拿到后判断非空，则读数据","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"Liux","slug":"Liux","permalink":"https://www.mingsrc.work/tags/Liux/"},{"name":"多线程","slug":"多线程","permalink":"https://www.mingsrc.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"笔试题汇总","slug":"J_LeetCode/《EffectiveC++》/资料","date":"2022-12-27T03:12:54.097Z","updated":"2022-12-27T03:12:54.097Z","comments":true,"path":"posts/e72c822.html","link":"","permalink":"https://www.mingsrc.work/posts/e72c822","excerpt":"2021届秋招笔试题汇总","text":"2021届秋招笔试题汇总 科大讯飞 大疆 美的 商汤科技 [中兴1](#中兴20200824） 汇顶科技 烽火科技 oppo 科大讯飞 美的 中兴2 深信服 网易 VIVO 美团点评 科大讯飞20200815第1题定义一个n*m的数字矩阵，要求你再当中找到两个不在用一行同一列的数组，使得乘积最大 输入描述 第一行数字n、m表示矩阵大小接下来又n行数字，每行m个数字，约定n和m都是小于等于1000，大于等于1的整数。 输出 一个数字表示最大的乘积值 123456789101112131415161718192021222324252627int main() &#123; int n , m; cin &gt;&gt; n; cin &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; arr(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; arr[i][j]; &#125; &#125; int MAX = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; int num1 = arr[i][j]; for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; m; ++y) &#123; int num2 = arr[x][y]; if (x == i || y == j) continue; MAX = max(MAX, num1 * num2); &#125; &#125; &#125; &#125; cout &lt;&lt;MAX&lt;&lt;endl; return 0;&#125; 第2题用某种排序方法对32位整数序列(25,84,21,47,15,27,68,35,20)进行行排序，序列变化的情况如下 12321 25 84 47 15 27 68 35 20 15 20 21 25 35 27 47 68 8415 20 21 25 27 35 47 68 84 请以该排序方法对其他的输入序列进行排序并输出结果 输入描述： 第一行为给定数字序列中的元素个数第二行为给定的数字序列，以空格分割 输出描述： 输出排序后的数字序列，以空格分割 12345678910111213141516171819202122232425262728293031int help(vector&lt;int&gt;&amp; arr, int left, int right) &#123; int tmp = arr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; arr[right] &gt;= tmp) right--; arr[left] = arr[right]; while (left &lt; right &amp;&amp; arr[left] &lt;= tmp) left++; arr[right] = arr[left]; &#125; arr[left] = tmp; return left;&#125;void qsort(vector&lt;int&gt;&amp; arr, int left, int right) &#123; if (left &gt; right) return; int mid = help(arr, left, right); qsort(arr, left, mid - 1); qsort(arr, mid + 1, right);&#125;int main() &#123; int n = 0; cin &gt;&gt; n; vector&lt;int&gt; arr(n, 0); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt;arr[i]; &#125; qsort(arr, 0, n - 1); for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; arr[i] &lt;&lt;&quot; &quot;; &#125;&#125; 第3题统计数字二进制形式1的个数 1234567891011int main() &#123; int num; cin &gt;&gt; num; int cnt = 0; while (num) &#123; if (num &amp; 1) cnt++; num &gt;&gt;= 1; &#125; cout &lt;&lt; cnt; return 0;&#125; 第4题将一个长度位m的字符串左移n位 输入描述： 第一行位长度位m的字符串第二行位左移的位数n1 &lt; n,m &lt; 2000 输出描述： 一行输出左移后的字符串 123456789101112131415int main() &#123; string str; int n ; getline(cin, str); cin &gt;&gt; n; n %= str.size(); string res = &quot;&quot;; int cnt = str.size(); int idx = n; while (cnt--) &#123; idx %= str.size(); res += str[idx++]; &#125; cout &lt;&lt; res;&#125; 大疆2020816给定一个整数序列，你需要找到两个的子段，保证这两个子段不能重复，并且使得这两个子段中得所有整数得和最大。 输入描述：12345第1行整数，测试用例数每个测试用例包括3行，第1行整数，整数序列得长度n第2行，n个整数第3行空格 输出描述：每个测试用例一行，输出一个整数表示最大子段和 示例123456789101112input:3101 -1 2 2 3 -3 4 -4 5 -55-5 9 -5 11 2010-1 -1 -1 -1 -1 -1 -1 -1 -1 -1output:1340-2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int maxSubArray(vector&lt;int&gt;&amp; nums, int&amp; left, int&amp; right) &#123; int len = nums.size(); vector&lt;int&gt; dp(len); int maxSum = nums[0]; for (int i = 0; i &lt; len; ++i) &#123; if (i == 0) dp[0] = nums[0]; else &#123; if (dp[i - 1] + nums[i] &lt; nums[i])&#123; dp[i] = nums[i]; left = i; &#125; else &#123; dp[i] = dp[i - 1] + nums[i]; &#125; &#125; if (maxSum&lt;dp[i]) &#123; right = i; maxSum = dp[i]; &#125; &#125; if (left &gt; right) &#123; left = 0, right = 0; return dp[0]; &#125; return maxSum;&#125;int main() &#123; int cnt; cin &gt;&gt; cnt; vector&lt;vector&lt;int&gt;&gt; input(cnt); for (int i = 0; i &lt; cnt; ++i) &#123; int n = 0; cin &gt;&gt; n; input[i].resize(n); for (int j = 0; j &lt; n; ++j) &#123; cin &gt;&gt; input[i][j]; &#125; &#125; for (int i = 0; i &lt; cnt; ++i) &#123; int left = 0, right = 0; int res = maxSubArray(input[i], left, right); sort(input[i].begin(), input[i].begin()+ right - left + 1, less&lt;int&gt;()); res = left != right ? res - *input[i].begin() : input[i][0] * 2; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; 美的20200820 部分选择题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/******************【1】**********************/#include &lt;stdio.h&gt;#define clrscr() 100main()&#123; clrscr(); printf(&quot;%d\\n&quot;, clrscr());&#125;/******************【2】**********************/void main()&#123; char* p = &quot;ayqm&quot;; printf(&quot;%c&quot;, ++*(p++));&#125;/******************【3】**********************/int main()&#123; int const* p = 5; printf(&quot;%d&quot;, ++(*p)); return 0;&#125;/******************【4】**********************/void main()&#123; struct emp &#123; char name[20]; int age; float sal; &#125;; struct emp e = &#123;&quot;Tiger&quot;&#125;; printf(&quot;\\n%d %f&quot;, e.age, e.sal);&#125;/******************【5】**********************/struct A&#123; long a1; short a2; int a3; int *a4; char c; char c2;&#125;;/******************【6】**********************/struct S1 &#123; char c; int i[2]; double v;&#125; SA1;struct S2&#123; double x; int i[2]; char c;&#125;SA2;int main()&#123; printf(&quot;\\n sizeof S1 %d: sizeof S2 %d&quot;, sizeof(SA1), sizeof(SA2)); return 0;&#125;/******************【7】**********************/int main() &#123; char s[] = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;\\n&#x27;,&#x27;c&#x27;,&#x27;\\0&#x27;&#125;; char *p, *str, *str1; p = &amp;s[3]; str = p; str1 = s; printf(&quot;%d&quot;, ++*p + ++*str1 - 32); return 0;&#125;/******************【8】**********************/void main() &#123; enum &#123;i = 10, j = 20, k = 50&#125;; printf(&quot;%d&quot;, ++k);&#125;/******************【9】**********************/#define FALSE -1#define TRUE 1#define NULL 0int main() &#123; if (NULL) puts(&quot;NULL&quot;); else if(FALSE) puts(&quot;TRUE&quot;); else puts(&quot;FALSE&quot;);&#125;/******************【10】**********************/void main()&#123; unsigned int m = 32; printf(&quot;%X&quot;, ~m);&#125;/******************【11】**********************/#define square(x) x * xvoid main() &#123; int i ; i = 64 / square(4); printf(&quot;%d&quot;, i);&#125;/******************【12】**********************/void swap(int *a, int *b) &#123; *a ^= *b; *b ^= *a; *a ^= *b;&#125;void main()&#123; int x = 10, y = 8; swap(&amp;x, &amp;y); printf(&quot;x = %d y = %d&quot;, x, y);&#125;/******************【13】**********************/#if something == 0int some = 0;#endifvoid main()&#123; int thing = 0; printf(&quot;%d %d\\n&quot;, some, thing);&#125;/******************【14】**********************/int main() &#123; char *p; p = &quot;Hello&quot;; printf(&quot;%c\\n&quot;, *&amp;*p); return 0;&#125; 商汤科技20200820选择题：2、 transformer的位置编码使用交替的多维sin、cos函数实现，不属于设计原理的一项是。 对于不同长度的序列，其相隔同样距离的两个序列元素，进行位置编码后的编码值的距离相同。 保持序列中的绝对位置关系。 保证序列中元素在一定范围内的相对位置关系。 限定在固定值域内，避免不同长度序列取值范围不同，以及过大数值对序列的影响。3、 链表访问i位置的时间复杂度。4、 现代CPU都有较大的缓存，cache来提高内存的访问效率。 c的数组的访问可以使用cache来加速，但数组大小不要超过cache大小 cache使用需要考虑到不用的cpu核的同步 cache的访问时按cache entry来进行的，c的数组需要按行优先访问 一般的cache越大，程序效率越高5、 当多个程序连接动态库，所占内存是多少6、 docker使用什么技术来运行环境的隔离 编程题：给出一个数字矩阵，寻找一条最上上升路径，每个位置只能向上下左右四个位置移动 示例123459 1 46 2 8 5 5 7[1, 2, 5, 7, 8]输出5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int row, col;int cnt;vector&lt;int&gt; res;int dff[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;,&#123;0, 1&#125;,&#123;0, -1&#125;&#125;;void dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; arr, vector&lt;vector&lt;bool&gt;&gt;&amp; isVis) &#123; if (isVis[x][y]) return; isVis[x][y] = true; cnt++; int MAX = INT_MIN; for (int i = 0; i &lt; 4; ++i) &#123; int m = x + dff[i][0]; int n = y + dff[i][1]; if (m &lt; row &amp;&amp; m &gt;= 0 &amp;&amp; n &lt; col &amp;&amp; n &gt;= 0)&#123; MAX = max(MAX, arr[m][n]); &#125; &#125; if (arr[x][y] &gt; MAX) &#123; res.push_back(cnt); return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; int m = x + dff[i][0]; int n = y + dff[i][1]; if (m &lt; row &amp;&amp; m &gt;= 0 &amp;&amp; n &lt; col &amp;&amp; n &gt;= 0 &amp;&amp; arr[m][n] &gt; arr[x][y])&#123; dfs(m, n,arr,isVis); &#125; &#125; isVis[x][y] = false; cnt--;&#125;int main() &#123; cin &gt;&gt; row; cin &gt;&gt; col; vector&lt;vector&lt;int&gt;&gt; arr(row, vector&lt;int&gt;(col, 0)); for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; cin &gt;&gt; arr[i][j]; &#125; &#125; int MIN = INT_MAX; int min_x = 0, min_y = 0; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; ++j) &#123; if (arr[i][j] &lt; MIN) &#123; min_x = i; min_y = j; MIN = arr[i][j]; &#125; &#125; &#125; vector&lt;vector&lt;bool&gt;&gt; isVis(row, vector&lt;bool&gt;(col, false)); dfs(min_x, min_y, arr, isVis); sort(res.begin(), res.end()); cout &lt;&lt; res.back(); return 0;&#125; 中兴20200824选择题1、shell语言连接到127.0.0.1：8080服务器上的所有ip。netstat -anp | grep &quot;127.0.0.1:8080&quot; | awk - F&#39;:&#39; &#39;&#123;print $5&#125;&#39;2、手动测试和自动化测试的区别。3、在浏览器里面输入http网址，哪些协议不会用到： 1ARP,SMTP,IP,HTTP,DNS,TCP 4、平衡二叉树AVL失衡，时空复杂度。5、构建类的设计模式。6、某个服务器通过域名+端口无法访问，但通过IP+端口可以访问的原因 编程题第一题：给定一个长度为n得数组a,求最大连续子区间内平均数最大得值。 输入描述129 // 数组长度3 5 3 7 7 6 6 5 6 // 数组 输出17 // 最大平均子区间为[4, 5],值为7 1234567891011121314151617181920212223int main() &#123; int n = 0; cin &gt;&gt; n; int arr[n]; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; arr[i]; vector&lt;int&gt; dp(n); dp[0] = arr[0]; int left = 0; for (int i = 1; i &lt; n; ++i) &#123; int avg = (dp[i - 1] + arr[i]) / (i - left + 1); if (avg &gt; arr[i]) &#123; dp[i] = avg; &#125; else &#123; dp[i] = arr[i]; left = i; &#125; &#125; sort(dp.begin(), dp.end()); cout &lt;&lt; dp[n - 1]; return 0;&#125; 第二题：给出一个字符串S，S中可能包含(0-9)和(A-Z),现在我们将字符串S(x)看作一个由x进制转为十进制的数字，给定l和r(l &lt;&#x3D; r)，问S(l) + S(l + 1) … S(r - 1) + S(r - 1)是奇数还是偶数？ 输入描述1232 // 测试的字符串组数101 2 3 // 计算2进制到3进制所有数字十进制下之和，并判断奇偶。4B 12 13 输出描述:1210 123456789101112131415161718192021222324252627282930int transfer(string s, int x) &#123; int sum = 0,k = 1; for (int i = s.size() - 1; i &gt;= 0; i--) &#123; if (s[i] &gt;= &#x27;A&#x27; &amp;&amp; s[i] &lt;= &#x27;Z&#x27;) sum += (s[i] - &#x27;A&#x27; + 1 + 9) * k; else sum += (s[i] - &#x27;0&#x27;) * k; k *= x; &#125; return sum;&#125;int main() &#123; int n = 0; cin &gt;&gt; n; vector&lt;string&gt; num(n); vector&lt;int&gt; x(n), y(n); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; num[i] &gt;&gt; x[i] &gt;&gt; y[i]; &#125; for (int i = 0; i &lt; n; ++i) &#123; int ans = 0; for (int j = x[i]; j &lt;= y[i]; ++j) &#123; ans += transfer(num[i], j); &#125; cout &lt;&lt; ((ans &amp; 1) == 1) &lt;&lt;endl; &#125; return 0;&#125; 汇顶科技20200824部分选择题奇偶校验static关键字作用do while循环次数 编程题查找一行字符串中子字符串的个数。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int del_sub(char* str, char* sub)&#123; int cnt = 0; while(*str != &#x27;\\0&#x27;) &#123; char* s1 = str; char* s2 = sub; while(*s2 == *s1 &amp;&amp; *s2 != &#x27;\\0&#x27; &amp;&amp; *s1 != &#x27;\\0&#x27;) &#123; s2++; s1++; &#125; if(*s2 == &#x27;\\0&#x27;) cnt++; str++; &#125; return cnt;&#125;int main() &#123; char str[100]; char sub[100]; int num = 0; scanf(&quot;%s&quot;,str); scanf(&quot;%s&quot;,sub); num = del_sub(str, sub); printf(&quot;%d&quot;,num);&#125; 科大讯飞20200829编程题第一题：写一个函数用递归实现将一个正整数分解质因数，如50，则程序打印”255” 输入描述150 输出描述：12*5*5 代码123456789101112131415161718192021string s;void fun(int n)&#123; if (n == 1 || n == 0) return; for (int i = 2; i &lt;= n; i++)&#123; if (n % i == 0) &#123; s += (&#x27;0&#x27; + i); s += &#x27;*&#x27;; fun(n / i); break; &#125; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; fun(n); s.pop_back(); cout &lt;&lt; s; return 0;&#125; 第二题：去除多余的下划线，要求再原串上进行操作 输入描述1___aaa__b___c__dd__ 输出描述：1aaa_b_c_dd 代码1234567891011121314151617181920212223242526void deleteSpace(string&amp; str) &#123; int cur = 0; while (str[cur] == &#x27;_&#x27;) cur++; int tail = 0; while (cur &lt; str.size()) &#123; if (str[cur] != &#x27;_&#x27;) str[tail++] = str[cur]; if (str[cur] == &#x27;_&#x27; &amp;&amp; str[cur - 1] != &#x27;_&#x27;) str[tail++] = str[cur]; cur++; &#125; cur--; while (str[cur] == &#x27;_&#x27;) &#123; str.pop_back(); cur--; &#125;&#125;int main() &#123; string str; cin &gt;&gt; str; deleteSpace(str); cout &lt;&lt; str; return 0;&#125; 美的20200831 部分选择题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#define prod(a, b) a * bint main() &#123; int x = 3,y = 4; printf(&quot;%d&quot;,prod(x + 2, y -1)); return 0;&#125;int main() &#123; unsigned char C = 32; printf(&quot;%d %d&quot;, C ^= C, !(C &amp; 128) &amp;&amp; !(C &amp; 1)); return 0;&#125;int main() &#123; char s[] = &#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;\\n&#x27;,&#x27;c&#x27;,&#x27;\\0&#x27;&#125;; char *p, *str, *str1; p = &amp;s[3]; str = p; str1 = s; printf(&quot;%d&quot;, ++*p + ++*str1 - 32); return 0;&#125;#define square(x) x * xint main() &#123; int i ; i = 64 / square(4); printf(&quot;%d&quot;, i); return 0;&#125;int main() &#123; float a = 5.375; char *p; int i; p = (char*) &amp;a; for (int i = 0; i &lt;= 3; i++) printf(&quot;%02X&quot;, (unsigned char)p[i]);&#125;#define max(a,b) (a &gt; b) ? a : bint main()&#123; int a,b;a=3;b=4; printf(&quot;%d&quot;, ++max(a++,b--)); return 0;&#125;#define f(g, g2) g##g2int main()&#123; int var12 = 100; printf(&quot;%d&quot;, f(var,12)); return 0;&#125;void change(int* a, int &amp;b,int c)&#123; c =* a; b = 30; *a = 20;&#125;int main() &#123; int a = 10, b = 20, c = 30; change(&amp;a,b, c); printf(&quot;%d, %d, %d&quot;, a, b, c); return 0;&#125;struct myStruct&#123; int a; char b;&#125;*ptr;int main() &#123; struct myStruct ms = &#123;400,&#x27;A&#x27;&#125;; printf(&quot;%d %d&quot;, ptr-&gt;a, ptr-&gt;b); return 0;&#125;typedef struct Error&#123; int warning; int error; int exception;&#125;error;int main() &#123; error g1; g1.error = 1; printf(&quot;%d&quot;, g1.error); return 0;&#125;int main() &#123; int i = 10; i = !i &gt; 14; printf(&quot;i=%d&quot;,i); return 0;&#125;int main() &#123; int x, y = 2, z, a; x = (y *= 2) + ( z = a = y); printf(&quot;%d&quot;, x); return 0;&#125;int main()&#123; unsigned char i = 0x80; printf(&quot;\\n%d&quot;,i &lt;&lt; 1); return 0;&#125;int main() &#123; char *p; p = &quot;hello&quot;; printf(&quot;%c\\n&quot;, *&amp;*p); return 0;&#125;int main() &#123; int x, y = 2, z, a; if (x = y % 2); z=2; a=2; printf(&quot;%d %d&quot;,z,x); return 0;&#125; 中兴20200903编程题二：A城和B城是双向路径，求A城到B城的最短路径 输入描述：12345675 3 3 // n m q 代表：n个城市 m条双向路径 q次询问1 2 1 // x y l 代表x到y有一条距离为l的双向路径2 3 1 3 5 21 2 // a b 代表要询问的两个城市2 41 5 输出描述：1231 // 查询的最短路，若不存在输出-1-14 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152vector&lt;vector&lt;int&gt;&gt; graph;vector&lt;vector&lt;int&gt;&gt; dist;vector&lt;bool&gt; isVis;int MIN = INT_MAX;void dfs(int cur, int dst, int distance) &#123; if (cur == dst) &#123; MIN = min(MIN, distance); &#125; for (auto v : graph[cur]) &#123; if (isVis[v]) continue; isVis[v] = true; distance += dist[cur][v]; dfs(v, dst, distance); isVis[v] = false; distance -= dist[cur][v]; &#125;&#125;int main() &#123; int n, m, q; cin &gt;&gt; n; cin &gt;&gt; m; cin &gt;&gt; q; graph.resize(n + 1); dist.resize(n + 1, vector&lt;int&gt;(n + 1, 0)); isVis.resize(n + 1, false); for (int i = 0; i &lt; m; ++i) &#123; int u = 0, v = 0, dis = 0; cin &gt;&gt; u; cin &gt;&gt; v; cin &gt;&gt; dis; graph[u].push_back(v); graph[v].push_back(u); dist[u][v] = dis; dist[v][u] = dis; &#125; int src[q], dst[q]; for (int i = 0; i &lt; q; ++i) &#123; cin &gt;&gt; src[i]; cin &gt;&gt; dst[i]; &#125; for (int i = 0; i &lt; q; ++i) &#123; MIN = INT_MAX; dfs(src[i], dst[i], 0); cout &lt;&lt; ((MIN == INT_MAX) ? -1 : MIN) &lt;&lt; endl; &#125; return 0;&#125; 深信服20200910选择题考点： 时间复杂度 结构体内存对齐 位运算符 八大排序算法时间复杂度 编程题：x*y的矩阵，从一个房间进入，从另一个房间出来，要求不重复的走完全部房间的路径数量。 1234567891011121314151617181920212223242526272829303132333435363738394041int off[4][2] = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;vector&lt;vector&lt;bool&gt;&gt; isVis;int row, col;int cnt = 0;int endX, endY;void dfs(int x, int y, int depth)&#123; if (isVis[x][y]) return; isVis[x][y] = true; depth++; if (x == endX &amp;&amp; y == endY &amp;&amp; depth == row * col) &#123; cnt++; isVis[x][y] = false; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; int m = x + off[i][0]; int n = y + off[i][1]; if (m &gt;= 0 &amp;&amp; m &lt; row &amp;&amp; n &gt;= 0 &amp;&amp; n &lt; col &amp;&amp; !isVis[m][n]) dfs(m, n, depth); &#125; depth--; isVis[x][y] = false;&#125;int main()&#123; cin &gt;&gt; row; cin &gt;&gt; col; isVis.resize(row, vector&lt;bool&gt;(col, false)); int stratX, startY; cin &gt;&gt; stratX; cin &gt;&gt; startY; cin &gt;&gt; endX; cin &gt;&gt; endY; dfs(stratX, startY, 0); cout &lt;&lt; cnt &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 网易20200912编程题1一颗二叉树，叶子结点定义为“樱桃”，统计一串上刚好有两颗“樱桃”的串的个数 输入描述：1233 2 // 3个结点 2条边1 1 2 // 1的左子树为21 2 3 // 1的右子树为3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;int cnt = 0;void dfs(TreeNode* root) &#123; if (!root) return; if (root-&gt;left &amp;&amp; root-&gt;right &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right &amp;&amp; !root-&gt;right-&gt;left &amp;&amp; !root-&gt;right-&gt;right) cnt++; dfs(root-&gt;left); dfs(root-&gt;right);&#125;int main() &#123; int n, m; cin &gt;&gt; n; cin &gt;&gt; m; unordered_map&lt;int, TreeNode*&gt; hash; for (int i = 0; i &lt; m; ++i) &#123; int uid, dir, vid; cin &gt;&gt; uid; cin &gt;&gt; dir; cin &gt;&gt; vid; if (hash.find(uid) == hash.end()) &#123; hash[uid] = new TreeNode(uid); &#125; if (dir == 1) &#123; // left if (hash.find(vid) == hash.end()) hash[vid] = new TreeNode(vid); hash[uid]-&gt;left = hash[vid]; &#125; else &#123; // right if (hash.find(vid) == hash.end()) hash[vid] = new TreeNode(vid); hash[uid]-&gt;right = hash[vid]; &#125; &#125; dfs(hash[1]); cout &lt;&lt; cnt; return 0;&#125; 编程题2快递员城市中送快递，每个城市距离1km，求图的最大深度 输入描述：126 3 // 共6个城市 还能再开3公里0 0 2 3 3 // 想象成一个数组S[5] 下标i+1 到 S[i]之间有一条路径 1234567891011121314151617181920212223242526272829303132333435vector&lt;bool&gt; isVis;vector&lt;vector&lt;int&gt;&gt; G;int depth = 0;int MAX = 0;void dfs(int root) &#123; if (isVis[root]) return; isVis[root] = true; depth++; MAX = max(MAX, depth); for (auto v : G[root]) &#123; dfs(v); &#125; depth--; isVis[root] = false;&#125;int main() &#123; int n, k; cin &gt;&gt; n; cin &gt;&gt; k; G.resize(n); isVis.resize(n, false); for (int i = 0; i &lt; n - 1; ++i) &#123; int v; cin &gt;&gt; v; G[i+1].push_back(v); G[v].push_back(i+1); &#125; dfs(0); cout &lt;&lt; (MAX &gt; (k + 1) ? (k + 1) : MAX); return 0;&#125; 编程题3给定一个字符串，求最长字符串的长度，前提这个字符串满足aeiou元音字母在字符串中出现次数刚好为偶数次 12345678910111213141516171819202122232425262728293031//暴力法会超时bool judge(const string &amp;str) &#123; char count[256]; for (char i : str) &#123; count[i]++; &#125; return count[&#x27;a&#x27;] % 2 == 0 &amp;&amp; count[&#x27;e&#x27;] % 2 == 0 &amp;&amp; count[&#x27;i&#x27;] % 2 == 0 &amp;&amp; count[&#x27;o&#x27;] % 2 == 0 &amp;&amp; count[&#x27;u&#x27;] % 2 == 0;&#125;int sol(const string &amp;s) &#123; int maxVal = 0; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = i; j &lt; s.length(); j++) &#123; if (judge(s.substr(i, j + 1 - i))) &#123; maxVal = max(maxVal, j - i + 1); &#125; &#125; &#125; return maxVal;&#125;int main() &#123; string str; getline(cin, str); cout &lt;&lt; sol(str); return 0;&#125; VIVO20200912编程题1给定非空字符串str，在最多可以删除一个字符情况下，判定能够成为回文串，如果可以则输出首次删除一个字符所能得到的回文字，如果不行则输出字符串“false” 12345678910111213141516171819202122232425262728bool isPali(string str) &#123; int left = 0, right = str.size() - 1; while (left &lt; right) &#123; if (str[left] != str[right]) return false; left++, right--; &#125; return true;&#125;int main3()&#123; string str; getline(cin, str); string res = &quot;false&quot;; for (int i = 0; i &lt; str.size(); ++i) &#123; string s = str; if (isPoli(s)) &#123; res = s; break; &#125;else if (isPali(s.erase(i, 1))) &#123; res = s; break; &#125; &#125; cout &lt;&lt; res; return 0;&#125; 编程题2矩形格子，字符 ‘@’ 和 ‘#’ 代表障碍物，指定起点和终点，求最短路径的长度，无法到达则返回-1 输入描述123453 // 维度为3*3的矩形0 0 2 2 // 起点 （0，0）终点（2，2）1@3 // 迷宫描述1@#123 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849vector&lt;vector&lt;char&gt;&gt; map;vector&lt;vector&lt;bool&gt;&gt; isVis;int endX, endY, n;int depth = 0;int MIN = INT_MAX;int off[4][2] = &#123; &#123;1,0&#125;, &#123;-1,0&#125;, &#123;0,1&#125;, &#123;0, -1&#125; &#125;;void dfs(int x, int y)&#123; if (isVis[x][y]) return; isVis[x][y] = true; depth++; if (x == endX &amp;&amp; y == endY) &#123; MIN = min(MIN, depth); return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; int xi = x + off[i][0]; int yi = y + off[i][1]; if (xi &gt;= 0 &amp;&amp; xi &lt; n &amp;&amp; yi &gt;= 0 &amp;&amp; yi &lt; n &amp;&amp; map[xi][yi] != &#x27;#&#x27; &amp;&amp; map[xi][yi] != &#x27;@&#x27;) &#123; dfs(xi, yi); &#125; &#125; depth--; isVis[x][y] = false;&#125;int main() &#123; int startX, startY; cin &gt;&gt; n; cin &gt;&gt; startX; cin &gt;&gt; startY; cin &gt;&gt; endX; cin &gt;&gt; endY; map.resize(n, vector&lt;char&gt;(n, &#x27; &#x27;)); isVis.resize(n, vector&lt;bool&gt;(n, false)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; cin &gt;&gt; map[i][j]; &#125; &#125; dfs(startX, startY); cout &lt;&lt; (MIN == INT_MAX ? -1 : MIN ); return 0;&#125; 美团点评20200913编程题1回文矩阵，按行回文，找到最小非回文矩阵 输入描述：1234567898 3 // 8 * 3矩阵1 0 10 1 00 1 01 0 11 0 10 1 00 1 01 0 1 输出描述：121 0 10 1 0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int n, m;vector&lt;vector&lt;int&gt;&gt; arr;bool operator != (const vector&lt;int&gt;&amp; v1, const vector&lt;int&gt;&amp; v2) &#123; for (int i = 0; i &lt; v1.size(); ++i) &#123; if (v1[i] != v2[i]) return true; &#125; return false;&#125;bool isPali(vector&lt;vector&lt;int&gt;&gt; arr) &#123; int left = 0, right = arr.size() - 1; while (left &lt; right) &#123; if (arr[left] != arr[right]) return false; left++, right--; &#125; return true;&#125;int main1() &#123; cin &gt;&gt; n; cin &gt;&gt; m; arr.resize(n, vector&lt;int&gt;(m, 0)); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; arr[i][j]; &#125; &#125; int right = n; while (right) &#123; if (isPali(arr)) &#123; right /= 2; arr.erase(arr.begin() + right, arr.end()); continue; &#125; break; &#125; for (auto lev : arr) &#123; for (auto num : lev) &#123; cout &lt;&lt; num &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 编程题2一个齿轮，26个齿A~Z，每个齿轮两个按钮，按钮1：跟前轮啮合并逆时针转一格，按钮2：跟后轮啮合并逆时针转一格，按完按钮恢复原状。用所有齿轮正上方的字母组成一个字符串，给定初始齿轮状态，统计所有无重复字符串的个数。注意：A不能转到Z，Z不能转到A, 输入描述：12342 // 2个齿轮BB // 2个齿轮初始状态 B B3 // 3个齿轮ABA // 3个齿轮初始状态 A B A 输出描述：123 // 结果对998244353取模3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647vector&lt;string&gt; res;long sol(string str) &#123; res.clear(); string s = str; for (int i = 0; i &lt; str.size(); ++i) &#123; if (i == 0) &#123; s = str; s[i] += 1; s[i + 1] -= 1; if (s[i] &lt;= &#x27;Z&#x27; &amp;&amp; s[i + 1] &gt;= &#x27;A&#x27;) res.push_back(s); &#125; else if (i == str.size() - 1) &#123; s = str; s[i] += 1; s[i - 1] -= 1; if (s[i] &lt;= &#x27;Z&#x27; &amp;&amp; s[i - 1] &gt;= &#x27;A&#x27;) res.push_back(s); &#125; else &#123; s = str; s[i] += 1; s[i + 1] -= 1; if (s[i] &lt;= &#x27;Z&#x27; &amp;&amp; s[i + 1] &gt;= &#x27;A&#x27;) res.push_back(s); s = str; s[i] += 1; s[i - 1] -= 1; if (s[i] &lt;= &#x27;Z&#x27; &amp;&amp; s[i - 1] &gt;= &#x27;A&#x27;) res.push_back(s); &#125; &#125; unordered_set&lt;string&gt; set(res.begin(), res.end()); return (set.size() + 1) % 998244353;&#125;int main() &#123; int n; string str; vector&lt;string&gt; strs; while (getline(cin, str)) &#123; // 必须使用ctrl + z结束输入 if (str[0] &gt;= &#x27;0&#x27; &amp;&amp; str[0] &lt;= &#x27;9&#x27;) continue; strs.push_back(str); &#125; for (int i = 0; i &lt; strs.size(); ++i) &#123; cout &lt;&lt; sol(strs[i]) &lt;&lt;endl; &#125; return 0;&#125; 联发科20200915选择题考点： linux进程间通信有哪些 关于内存泄漏 C++函数中参数传递的方式 static修饰的局部变量、全局变量、函数、成员变量的作用分别是 列举TCP&#x2F;IP五层参考模型 可执行程序加载时系统分配的内存可以分为哪几段 编程题1手写查找子字符串C函数int strstr(char * str1, char * str2) 12输入：&quot;abcdefabcdef&quot;,&quot;def&quot;输出：3 //找到输出第一个下标 没找到输出-1 12345678910111213141516171819202122232425262728293031int my_strstr(char* str1, char* str2) &#123; if (str2 == NULL) return -1; int idx = 0; while (*str1 != &#x27;\\0&#x27;) &#123; if (*str1 != *str2) &#123; str1++; idx++; &#125; else &#123; char * p1 = str1; char * p2 = str2; while (*p2 != &#x27;\\0&#x27;) &#123; if (*p2 == *p1) &#123; p1++; p2++; &#125; else &#123; break; &#125; &#125; if (*p2 == &#x27;\\0&#x27;) return idx; &#125; &#125; return -1;&#125;int main() &#123; char str1[100]; char str2[100]; cin &gt;&gt; str1; cin &gt;&gt; str2; printf(&quot;%d\\n&quot;, my_strstr(str1, str2)); return 0;&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"题解目录","slug":"J_LeetCode/README","date":"2022-12-27T03:12:54.075Z","updated":"2022-12-27T03:12:54.075Z","comments":true,"path":"posts/fca5c66f.html","link":"","permalink":"https://www.mingsrc.work/posts/fca5c66f","excerpt":":books: Leetcode题解目录(转载)转自：🔥【github】 \n\n为了进大厂🐛，目前进度208&#x2F;300题，特此记录刷过的所有题，涵盖了基本题型，精简的解题思路，此repo属于 C++ 版的题解。\n\n感谢您的观看，希望对您有帮助，欢迎热烈的交流🎉！如果感觉还不错就点个赞 star 吧✨✨✨~\n\n这是我的🔥【github】 里面有适合 C++ 萌新的练手项目，热烈欢迎🎉帮助我收集整理题目或者提供解题思路🐳~。","text":":books: Leetcode题解目录(转载)转自：🔥【github】 为了进大厂🐛，目前进度208&#x2F;300题，特此记录刷过的所有题，涵盖了基本题型，精简的解题思路，此repo属于 C++ 版的题解。 感谢您的观看，希望对您有帮助，欢迎热烈的交流🎉！如果感觉还不错就点个赞 star 吧✨✨✨~ 这是我的🔥【github】 里面有适合 C++ 萌新的练手项目，热烈欢迎🎉帮助我收集整理题目或者提供解题思路🐳~。 🚀剑指offer题解 🚀程序员面试金典 ​🎨算法思想 双指针 排序 贪心思想 二分查找 [分治] [搜索] 动态规划 [数学] :snowflake:数据结构相关 链表 树 栈和队列 哈希表 字符串 [数组与矩阵] [图] 位运算 🎨力扣周赛","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"Linux指令（转载）","slug":"J_LeetCode/Linux/Linux指令","date":"2022-12-27T03:12:54.075Z","updated":"2022-12-27T03:12:54.075Z","comments":true,"path":"posts/10ebf187.html","link":"","permalink":"https://www.mingsrc.work/posts/10ebf187","excerpt":"转自：🔥【github】 ","text":"转自：🔥【github】 实用指令 切换运行级别 帮助指令 文件目录 重定向(覆盖追加操作) 时间日期 搜索查找 压缩解压 切换运行级别0:关机 1:单用户 2:多用户没有网络 3:多用户有网络4:系统未使用保留给用户 5:图像界面 6:系统重启 常用3和5，忘记密码时切到1改密码 init 0~5 帮助指令(不如百度）man ls //获取帮助信息 help cd //获取shell内置命令帮助信息 文件目录类pwd //当前绝对路径 ls -al //列表方式显示所有文件和目录包括隐藏的 cd ~ cd //回到家目录 cd .. //回到上一级目录 mkdir -p /home/animals/dog //创建多级目录 rmdir /home/animals/dog //删除空目录 rm -rf //删除非空目录 -r递归 -f忽略警告 rm //删除文件 tough hello.txt world.txt //创建多个空文件 cp hello.txt dest/ //将文件拷贝到dest cp -r source/ dest/ //将source整个目录所有文件拷贝到dest，同名文件回提示 \\cp -r source/ dest/ //强制覆盖同名文件且不提示 mv old.txt new.txt //重命名 mv old.txt /root/ //将当前目录中old文件移动到根目录中 查看文件cat -n /etc/profile //只读方式查看文件内容 -n显示行号 cat -n /etc/profile | more //长配合一个管道 more分页浏览 more //space下翻 enter上翻 q离开 ctrl+f下滚 ctrl+b上滚 less //适合加载查看大日志，space pageDown pageUp上下翻 q离开 head /etc/profile //查看前10行 head -n 5 /etc/profile //查看前5行 tail /etc/profile //查看后10行 tail -n 5 /etc/profile //查看后5行 tail -f data.txt //实时监控，如有变化立即显示 重定向(覆盖追加操作）ls -l &gt; new.txt //列表内容覆盖写入文件 ls -l /home/ &gt; /home/info.txt //home目录列表写入文件中 ls -l &gt;&gt; new.txt //只追加 cat /etc/profile &gt; new.txt //覆盖 echo &quot;hello&quot; //输出内容到控制台 echo $PATH //输出环境变量 history 10 //显示最近使用过的10个命令 ！5 //执行编号为5的指令 时间日期命令data //显示当前时间 data &quot;+%Y-%m-%d %H:%M:%S&quot; //年-月-日 时：分：秒 data -s &quot;2020-3-3 23:22:00&quot; //设置系统当前时间 cal //显示本月日历 cal 2020 //显示一年的 搜索查找命令find /home -name hello.txt //搜home目录下（包括子目录）名为hello的文件， find /opt -user lwt //搜索用户为lwt的所有文件 find / -size +20M //搜整个系统下大于20m的文件 find / -size -20M //小于 find / -name *.txt //搜所有后缀为txt文件 updatedb //第一次使用locate命令前必须先更新数据库 locate hello.txt //快速定位文件路径 cat hello.txt |grep -n yes //过滤查找，查找yes所在行显示行号，区分大小写 cat hello.txt |grep -ni yes //过滤查找，区分大小写 压缩和解压gzip hello.txt //压缩不保留原来文件，压缩成*.gz文件 gunzip hello.txt.gz //当前目录下解压 zip -r package.zip /home/ //将home下所有文件压缩成package.zip unzip -d /opt/tmp package.zip //解压到/opt/tmp目录下 tar -zcvf dest.tar.gz source1.txt source2.txt //压缩多个文件，打包结尾*.tar.gz文件 tar -zcvf dest.tar.gz /home/ //压缩整个honme文件 tar -zxvf dest.tar.gz //解压到当前目录 tar -zxvf dest.tar.gz -C /opt/tmp //-C指定到目录，tmp必须先存在 ​","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"},{"name":"Linux","slug":"大神们の笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/Linux/"}],"tags":[{"name":"Liux","slug":"Liux","permalink":"https://www.mingsrc.work/tags/Liux/"},{"name":"Linux指令","slug":"Linux指令","permalink":"https://www.mingsrc.work/tags/Linux%E6%8C%87%E4%BB%A4/"}]},{"title":"C++&LeetCode","slug":"J_LeetCode/LeetCode/贪心思想","date":"2022-12-27T03:12:54.074Z","updated":"2022-12-27T03:12:54.074Z","comments":true,"path":"posts/da77844e.html","link":"","permalink":"https://www.mingsrc.work/posts/da77844e","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://www.mingsrc.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"🐳链表🐳","slug":"J_LeetCode/LeetCode/链表","date":"2022-12-27T03:12:54.074Z","updated":"2022-12-27T03:12:54.074Z","comments":true,"path":"posts/2bc70af9.html","link":"","permalink":"https://www.mingsrc.work/posts/2bc70af9","excerpt":"🐳链表🐳","text":"🐳链表🐳 排序由易到难 19.删除链表的倒数第N个节点 21.合并两个有序链表 24.两两交换链表中的节点 83.删除排序链表中的重复元素 141.环形链表 160.相交链表 206.反转链表 234.回文链表 328.奇偶链表 445.两数相加II 725.分隔链表 817.链表组件 删除链表的倒数第N个节点Leetcode 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 解题思路 使用快慢指针法，让快指针提前先走n+1步，再同步快慢指针直到快指针指向链表结尾时，慢指针刚好停留在需要删除结点的前驱。 添加头结点 dummy 是为了统一对链表增删的操作。 删除结点相当于链接时跳过此结点12345678910111213141516ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummy=new ListNode(-1); dummy-&gt;next=head; ListNode* fast=dummy; ListNode* slow=dummy； int cnt=n+1; while(cnt--)&#123; fast=fast-&gt;next; &#125; while(fast)&#123; fast=fast-&gt;next; slow=slow-&gt;next; &#125; slow-&gt;next=slow-&gt;next-&gt;next; return dummy-&gt;next;&#125; 合并两个有序链表Leetcode将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。解题思路 合并为一个新的链表用尾插法，三个指针：l1，l2用于遍历两个链表，cur用于遍历新的链表 涉及新建链表一般都需要new一个头结点和定义一个指针用于遍历。 同时遍历两个链表，把比较小的结点用尾插法插入到新的链表中，再更新指针。 while结束标志为：其中一个链表遍历结束 如果一个链表遍历结束，另一个未结束，则把未结束的剩余部分链接上123456789101112131415161718 ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* head=new ListNode(-1); ListNode* cur=head; //尾插法 while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt;= l2-&gt;val)&#123; cur-&gt;next=l1; l1=l1-&gt;next; &#125;else&#123; cur-&gt;next=l2; l2=l2-&gt;next; &#125; cur=cur-&gt;next; &#125; if(!l1) cur-&gt;next=l2; if(!l2) cur-&gt;next=l1; return head-&gt;next;&#125; 两两交换链表中的节点Leetcode给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。示例1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 解题思路 使用头节点，用于链表第一结点与其他结点增删改的统一。 定义三个指针，cur用于遍历原链表，p1,p2用于交换（p2指向p1的后继结点） 链接的顺序：1-&gt;3 2-&gt;1 cur-&gt;2 注意：cur指针每次向前跳两步。12345678910111213141516 ListNode* swapPairs(ListNode* head) &#123; ListNode* dummy=new ListNode(-1); dummy-&gt;next=head; ListNode* cur=dummy; ListNode* p1=dummy; ListNode* p2=dummy; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123; p1=cur-&gt;next; p2=cur-&gt;next-&gt;next; p1-&gt;next=p2-&gt;next; p2-&gt;next=p1; cur-&gt;next=p2; cur=cur-&gt;next-&gt;next; &#125; return dummy-&gt;next;&#125; 删除排序链表中的重复元素 Leetcode给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 解题思路 链表中删除一个结点相当于指针越过该结点（next指针指向要删除结点的后继） 直到cur与下一个结点值不同时，更新指针12345678910 ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* cur=head; while(cur &amp;&amp; cur-&gt;next)&#123; if(cur-&gt;val == cur-&gt;next-&gt;val) cur-&gt;next=cur-&gt;next-&gt;next; else cur=cur-&gt;next; &#125; return head; &#125; 环形链表leetcode给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 解题思路 当快指针检查到无下一节点时，说明该链表无环，当链表中不存在环时，快指针终将优先到达链表尾部。 当快指针与慢指针相遇（指向同一个节点）时，说明该链表有环。快指针追上慢指针了。1234567891011bool hasCycle(ListNode *head) &#123; if (head == NULL) return false; ListNode* slow = head; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) return true; &#125; return false;&#125; 相交链表leetcode编写一个程序，找到两个单链表相交的起始节点。 解题思路 分别遍历一条链表，当遍历到结尾时让指针指向另一条链表的头部继续遍历另一条，当两个指针相等时即相交的位置 原理：加入两条链表相交，链表1为A+C,链表2为B+C， C为两条链表相交以后的公共部分，此时指针p1遍历的长度为A+C+B,指针p2遍历长度为B+C+A,两指针刚好落在相交部分的开头，因为如果继续遍历的话，两个指针都将同时遍历C部分。1234567891011 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if (headA == NULL &amp;&amp; headB == NULL) return NULL; if (headA == NULL || headB == NULL) return NULL; ListNode* p1 = headA; ListNode* p2 = headB; while(p1 != p2) &#123; p1 = p1 == NULL ? headB : p1-&gt;next; p2 = p2 == NULL ? headA : p2-&gt;next; &#125; return p1;&#125; 反转链表 Leetcode 反转一个单链表。 解题思路 链表的头插法实现反转，需要两个指针，当前指针cur,新链表头部指针pre 因为需要改变当前结点next指针指向pre，所以必须先记录下next指针最后再恢复，才能让cur继续在链中遍历下去。 1234567891011ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL; ListNode* cur = head; while (cur) &#123; ListNode* tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre;&#125; 回文链表leetcode请判断一个链表是否为回文链表。 解题思路 用快慢指针法先找到中间结点，用头插法反转后一半链表，用双指针比较两个链表。 快慢指针注意while的结束条件： 如果while(fast &amp;&amp; fast-&gt;next)则奇数链表慢指针指向中间结点，偶数链表慢指针指向后一半链表头部。 如果while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next则不论奇数偶数链表，慢指针都指向后一半链表的前一个结点。1234567891011121314151617181920212223bool isPalindrome(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) return true; ListNode * slow = head; ListNode * fast = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode* cur = slow-&gt;next; ListNode* pre = NULL; while (cur) &#123; ListNode* tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; while (pre &amp;&amp; head) &#123; if(pre-&gt;val != head-&gt;val) return false; pre = pre-&gt;next; head =head-&gt;next; &#125; return true;&#125; 奇偶链表leetcode给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 解题思路 需要两个指针，一个指向奇数结点，一个指向偶数结点，分别往后跳跃遍历 注意while循环的结束条件，因为两个指针都是跳跃一步的往后遍历，所以只有指针的下一步不是NULL时才能跳跃。 注意提前保存偶数链表的头部，用于之后的拼接。 1234567891011121314ListNode* oddEvenList(ListNode* head) &#123; if (head == NULL) return NULL; ListNode* odd = head; ListNode* even = head-&gt;next; ListNode* preEven = even; while (odd-&gt;next &amp;&amp; even-&gt;next) &#123; odd-&gt;next = odd-&gt;next-&gt;next; odd = odd-&gt;next; even-&gt;next = even-&gt;next-&gt;next; even = even-&gt;next; &#125; odd-&gt;next = preEven; return head; &#125; 两数相加IIleetcode给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。 解题思路 题意，不能反转链表，那么对于这种逆序操作第一要想到用栈。 本体使用了三种技巧：1、使用栈逆序储存，2、两数相加（涉及到进位carry的操作），3、头插法建立链表. 注意：当某一个位没有数时（即栈为空时）用0代替，进行相加。12345678910111213141516171819202122232425262728293031323334 ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; stack&lt;int&gt; sck1, sck2; while (l1) &#123; sck1.push(l1-&gt;val); l1 = l1-&gt;next; &#125; while (l2) &#123; sck2.push(l2-&gt;val); l2 = l2-&gt;next; &#125; int a = 0, b = 0, carry = 0; ListNode* pre = NULL; while (!sck1.empty() || !sck2.empty() || carry) &#123; if (!sck1.empty()) &#123; a = sck1.top(); sck1.pop(); &#125; else &#123; a = 0; &#125; if (!sck2.empty()) &#123; b = sck2.top(); sck2.pop(); &#125; else &#123; b = 0; &#125; int sum = a + b + carry; carry = sum / 10; sum %= 10; ListNode* newNode = new ListNode(sum); newNode-&gt;next = pre; pre = newNode; &#125; return pre;&#125; 分隔链表leetcode给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。返回一个符合上述规则的链表的列表。 示例1234567输入: root = [1, 2, 3], k = 5输出: [[1],[2],[3],[],[]]输入: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] 解题思路 本体涉及的技巧有：计算链表长度，计算每段的长度，分割并储存链表(定位尾部，保存头部) 首先计算链表总长度，根据k值求出每段的平均长度，由题意任意两部分的长度差距不能超过 1，且较长的在前面，所以将余的部分平均分给前面的链表长度上面。 得到每一段的长度后，开始分割链表，链表的分割只需要遍历到尾结点，在尾节点后加NULL即可，而储存链表时只需要储存链表头结点即可。 注意：已知链表长度，通过while(--len &gt; 0）来定位链表尾部时，while里面要先自减。 注意：在尾结点后加NULL分割链表之前，防止下一步丢失，要事先保存下一步的结点，以便更新当前结点。123456789101112131415161718192021222324252627282930 vector&lt;ListNode*&gt; splitListToParts(ListNode* root, int k) &#123; int len = 0; ListNode* cur = root; while (cur) &#123; len++; cur = cur-&gt;next; &#125; int averageLen = len / k; int surplusLen = len % k; int curLen = 0; cur = root; vector&lt;ListNode*&gt; res; for (int i = 0; i &lt; k; ++i) &#123; res.push_back(cur); if (surplusLen-- &gt; 0) &#123; curLen = averageLen + 1; &#125; else &#123; curLen = averageLen; &#125; while (--curLen &gt; 0 )&#123; cur = cur-&gt;next; &#125; if (cur != NULL) &#123; ListNode* tmp = cur-&gt;next; cur-&gt;next = NULL; cur = tmp; &#125; &#125; return res;&#125; 链表组件leetcode给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。同时给定列表 G，该列表是上述链表中整型值的一个子集。返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。 示例1234567891011121314输入: head: 0-&gt;1-&gt;2-&gt;3G = [0, 1, 3]输出: 2解释: 链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。输入: head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4]输出: 2解释: 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。 解题思路 首先为G列表的值建立一个bool类数组，（也可以使用哈希表，但是效率太低）用于遍历链表时检查结点是否属于G列表中的结点。 一遍遍历整个链表，当遇到第一个属于G列表中的结点时，组件数量就加1，并继续往后遍历找到组件的结尾，非G列表中的结点直接忽略即可。12345678910111213141516171819bool isIn[10000];int numComponents(ListNode* head, vector&lt;int&gt;&amp; G) &#123; if (head == NULL) return 0; for (auto it : G) &#123; isIn[it] = true; &#125; ListNode* cur = head; int cnt = 0; while (cur != NULL) &#123; if (isIn[cur-&gt;val] == true) &#123; while(cur != NULL &amp;&amp; isIn[cur-&gt;val] == true) cur = cur-&gt;next; cnt++; &#125; else &#123; cur = cur-&gt;next; &#125; &#125; return cnt;&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"链表","slug":"链表","permalink":"https://www.mingsrc.work/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"树🌲","slug":"J_LeetCode/LeetCode/树","date":"2022-12-27T03:12:54.073Z","updated":"2022-12-27T03:12:54.073Z","comments":true,"path":"posts/ca16bf90.html","link":"","permalink":"https://www.mingsrc.work/posts/ca16bf90","excerpt":":seedling:树","text":":seedling:树 94.二叉树的中序遍历 144.二叉树的前序遍历 145.二叉树的后序遍历 98.验证二叉搜索树 101.对称二叉树 102.二叉树的层序遍历 107.二叉树的层次遍历II 103.二叉树的锯齿形层次遍历 104.二叉树的最大深度 110.平衡二叉树 111.二叉树的最小深度 112.路径总和 124.二叉树中的最大路径和 230.二叉搜索树中第K小的元素 226.翻转二叉树 236.二叉树的最近公共祖先 513.找树左下角的值 617.合并二叉树 687.最长同值路径 671.二叉树中第二小的节点 669.修剪二叉搜索树 701.二叉搜索树中的插入操作 二叉树的中序遍历Leetcode给定一个二叉树，返回它的迭代中序遍历。 解题思路 使用辅助栈，中序遍历是访问顺序左-中-右 所以每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。12345678910111213141516vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt;res; stack&lt;TreeNode*&gt;sck; TreeNode*cur=root; while(cur || !sck.empty())&#123; while(cur)&#123; sck.push(cur); cur=cur-&gt;left; &#125; cur=sck.top(); res.push_back(cur-&gt;val); sck.pop(); cur=cur-&gt;right; &#125; return res;&#125; 二叉树的前序遍历Leetcode 解题思路 非递归实现需要辅助栈 因为栈是先进后出，而前序遍历顺序是：root =&gt; left =&gt; right 所以right先入栈left后入栈 由于一开始的left和right的地址需要通过root结点获得，所以开始需要先将root入栈123456789101112131415vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if(root == NULL) return &#123;&#125;; stack&lt;TreeNode*&gt; sck; vector&lt;int&gt; res; TreeNode*cur = NULL; sck.push(root); while(!sck.empty())&#123; cur = sck.top(); res.push_back(cur-&gt;val); sck.pop(); if(cur-&gt;right) sck.push(cur-&gt;right); if(cur-&gt;left) sck.push(cur-&gt;left); &#125; return res;&#125; 二叉树的后序遍历Leetcode 解题思路 后序遍历顺序left =&gt; right =&gt; root ,变换的前序遍历顺序root =&gt; right =&gt; left，结果反转则为后序 前序遍历 + 反转结果即可1234567891011121314151617181920212223vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; if(root == NULL) return &#123;&#125;; stack&lt;TreeNode*&gt; sck; vector&lt;int&gt; res; sck.push(root); TreeNode* cur = NULL; while(!sck.empty())&#123; cur = sck.top(); res.push_back(cur-&gt;val); sck.pop(); if(cur-&gt;left) sck.push(cur-&gt;left); if(cur-&gt;right) sck.push(cur-&gt;right); &#125; return reverse(res);&#125;vector&lt;int&gt; reverse(vector&lt;int&gt; arr)&#123; vector&lt;int&gt; res; for(int i=arr.size()-1; i&gt;=0; --i)&#123; res.push_back(arr[i]); &#125; return res;&#125; 验证二叉搜索树leetcode给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 解题思路 二叉搜索树的典型特点：中序遍历就是一个升序的序列，所以验证的方法就显而易见 中序遍历存入数组，验证数组是否是严格单调递增的 看大佬得题解还有更简洁的方法 : 因为是中序遍历，所以只要维护一个记录上一个结点值得变量，每遍历一个点进行一次比较和更新，如果发现小于上个结点值就返回false，注意比较和更新得顺序不能反。12345678910111213141516vector&lt;int&gt; res;bool isValidBST(TreeNode* root) &#123; inorder(root); for (int i = 1; i &lt; res.size(); ++i) &#123; if (res[i - 1] &gt;= res[i]) return false; &#125; return true;&#125;void inorder(TreeNode* root) &#123; if (root == NULL) return; inorder(root-&gt;left); res.push_back(root-&gt;val); inorder(root-&gt;right);&#125; 更简洁得方式：12345678long pre = Long.MIN_VALUE;public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; if (!isValidBST(root.left)) return false; if (root.val &lt;= pre) return false; pre = root.val; return isValidBST(root.right);&#125; 对称二叉树Leetcode给定一个二叉树，检查它是否是镜像对称的。 解题思路 双指针再树中应用。 两个指针分别递归遍历两颗树。 两棵树要想对称，首先他们的子树必须对称，其次他们的根结点必须相等，可以使用后序遍历123456789101112bool isSymmetric(TreeNode* root) &#123; if (root == NULL) return true; return isSymmetric(root-&gt;left, root-&gt;right); &#125; bool isSymmetric(TreeNode* left, TreeNode* right)&#123; if (left == NULL &amp;&amp; right == NULL) return true; if (left == NULL || right == NULL) return false; return isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left) &amp;&amp; left-&gt;val == right-&gt;val; &#125; 二叉树的层序遍历leetcode给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例12345678910113 / \\ 9 20 / \\ 15 7返回其层次遍历结果：[ [3], [9,20], [15,7]] 解题思路 典型的BFS遍历二叉树，使用了队列， 牢记模板，注意：输出的数组是二维数组，并不是简单的遍历，中间需要size变量来记录每一行的个数。123456789101112131415161718192021vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt; &gt; res; queue&lt;TreeNode*&gt; que; if (root) que.push(root); TreeNode* cur = NULL; while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; level; while (size--) &#123; cur = que.front(); que.pop(); level.push_back(cur-&gt;val); if (cur-&gt;left) que.push(cur-&gt;left); if (cur-&gt;right) que.push(cur-&gt;right); &#125; if (!level.empty()) &#123; res.push_back(level); &#125; &#125; return res;&#125; 二叉树的层次遍历IIleetcode给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 解题思路 基本过程与上题的层序遍历一样， 区别在对结果的处理，两种方式：reverse()反转结果，或者插入的时候用头插法，但是因为使用的是vector所以头插法效率极低。123456789101112131415161718192021vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; vector&lt;vector&lt;int&gt; &gt; res; TreeNode* cur = NULL; if (root != NULL) que.push(root); while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; level; while (size--) &#123; cur = que.front(); que.pop(); level.push_back(cur-&gt;val); if (cur-&gt;left !=NULL) que.push(cur-&gt;left); if (cur-&gt;right !=NULL) que.push(cur-&gt;right); &#125; res.push_back(level); //res.insert(res.begin(),level); // 头插法 &#125; reverse(res.begin(),res.end()); return res;&#125; 二叉树的锯齿形层次遍历leetcode给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 解题思路 主题部分与上两题的层序遍历一致，只是多了一个层数的变量，当层数为偶数从左到右插入，层数为奇数头插法实现从右到左。12345678910111213141516171819202122232425vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; vector&lt;vector&lt;int&gt; &gt; res; TreeNode* cur = NULL; if (root != NULL) que.push(root); int levelNum = 0; while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; level; while (size--) &#123; cur = que.front(); que.pop(); if (levelNum % 2 == 0) &#123; level.push_back(cur-&gt;val); &#125; else &#123; level.insert(level.begin(), cur-&gt;val); &#125; if (cur-&gt;left) que.push(cur-&gt;left); if (cur-&gt;right) que.push(cur-&gt;right); &#125; levelNum++; res.push_back(level); &#125; return res;&#125; 二叉树的最大深度Leetcode给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。 解题思路 每个结点得最大深度都需要先知道其两个子结点的最大深度，所以使用后序遍历，先遍历左右子树。 函数意义：返回该结点的最大深度。123456int maxDepth(TreeNode* root) &#123; if (root == NULL) return 0; int left = maxDepth(root-&gt;left); int right = maxDepth(root-&gt;right); return max(left, right) + 1;&#125; 平衡二叉树Leetcode给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 解题思路 先判断左右两个子节点是否平衡，再处理当前结点，所以采用后序遍历 使用哈希表来记录每个结点的最高高度，而每个结点的最高高度也是受其左右子结点的影响，所以可以借着第一条的后序遍历来添加每个结点的高度 1234567891011unordered_map&lt;TreeNode*, int&gt; height;bool isBalanced(TreeNode* root) &#123; if (root == NULL) &#123; height[root] = 0; return true; &#125; if(!isBalanced(root-&gt;left) || !isBalanced(root-&gt;right)) return false; height[root] = max(height[root-&gt;left], height[root-&gt;right]) + 1; if(abs(height[root-&gt;left] - height[root-&gt;right]) &gt; 1) return false; return true;&#125; 二叉树的最小深度leetcode给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 解题思路 与二叉树最大深度类似，要求每个结点的深度都需要先计算其左右子节点的深度，所以采用后序遍历 注意：有些结点只有一个子结点，再比较左右子结点的最小值时，返回值可能会返回最小值0，所以应该避免这种情况，返回非空的那条子结点深度 12345678int minDepth(TreeNode* root) &#123; if (root == NULL) return 0; int left = minDepth(root-&gt;left); int right = minDepth(root-&gt;right); if(root-&gt;left == NULL) return right + 1; if(root-&gt;right == NULL) return left + 1; return min(left, right) + 1;&#125; 路径总和leetcode给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 解题思路 从root结点开始遍历，每经过一个结点，sum 值就减去当前节点的权值，直到sum值为0时表示发现路径，由题意路径结尾必须是叶子，所以还需要判断最后是否是叶子结点 因为每个子结点需要处理的sum值都与母结点有关，所以采用自上而下的先序遍历，先处理母结点，再处理子结点 123456bool hasPathSum(TreeNode* root, int sum) &#123; if (root == NULL) return false; sum-=root-&gt;val; if(sum == 0 &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return true; return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum);&#125; 二叉树中的最大路径和leetcode给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 解题思路 这种可以不经过root结点的路径和，首先想到一条路径一定由三部分构成，左子树路径+中间结点+右子树路径 当前结点的最大路径和与他的左右子树相关，所以先访问子树，是后序遍历。 注意：一个结点返回的不应该是此结点的最大路径和，而应该是单边最大路径给上游 注意：因为路径和可能会有负数出现，可以采用max(0,)的方式去掉负值。 12345678910111213int maxPathSum(TreeNode* root) &#123; int sum = INT_MIN; maxPathSum(root, sum); return sum;&#125;int maxPathSum(TreeNode* root, int&amp; sum) &#123; if (root == NULL) return 0; int left = max(0, maxPathSum(root-&gt;left, sum)); int right = max(0, maxPathSum(root-&gt;right, sum)); sum = max(sum, left + right + root-&gt;val); return root-&gt;val + max(left, right);&#125; 二叉搜索树中第K小的元素Leetcode 对于二叉搜索树中序遍历&#x3D;从小到大排序 需要记录遍历个数的变量 1234567891011int cnt=0,val=0;int kthSmallest(TreeNode* root, int k) &#123; inorder(root,k); return val;&#125;void inorder(TreeNode*root,int k)&#123; if(!root)return; inorder(root-&gt;left,k); if(++cnt==k)val=root-&gt;val; inorder(root-&gt;right,k);&#125; 翻转二叉树Leetcode 反转二叉树并返回根节点，交换当前根结点的左右子树1234567TreeNode* invertTree(TreeNode* root) &#123; if(!root)return NULL; TreeNode*tmp=invertTree(root-&gt;left); root-&gt;left=invertTree(root-&gt;right); root-&gt;right=tmp; return root;&#125; 二叉树的最近公共祖先leetcode给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 解题思路 首先什么样的结点才会是公共祖先：当某个结点，他的左子树中有p点，右子树中有q点，这个结点即为他俩的公共祖先 后序遍历：因为判断一个结点是否是祖先，需要知道他的左右子树有无p或q结点，所以需要先遍历子树。 注意：当发现中间结点的左右两个子树有一个返回为null说明这条路没有找到，而另一颗子树找到了，那么这个中间结点也需要向上游传递（返回）我找到了的信息.12345678910TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == NULL) return 0; TreeNode* left = lowestCommonAncestor(root-&gt;left, p ,q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p ,q); if(root == p || root == q) return root; if (left != NULL &amp;&amp; right != NULL) return root; if (left == NULL) return right; if (right == NULL) return left; return NULL;&#125; 找树左下角的值Leetcode 层序遍历（用队列实现），从右往左，最后一个元素即为所求。 前序中序后续（用栈实现）1234567891011121314151617181920int findBottomLeftValue(TreeNode* root) &#123; if(!root)return 0; queue&lt;TreeNode*&gt; NodeQueue; int res=0; TreeNode*current=new TreeNode(0); //先让根节点入队 NodeQueue.push(root); //弹空队列 while(!NodeQueue.empty())&#123; //每个元素出队时，让其子节点入队 current=NodeQueue.front(); NodeQueue.pop(); //保存每层数值 res=current-&gt;val;* //每层从右往左入队，最后一个元素即为最底层最左边的值 if(current-&gt;right!=NULL)NodeQueue.push(current-&gt;right); if(current-&gt;left!=NULL)NodeQueue.push(current-&gt;left); &#125; return res;&#125; 合并二叉树Leetcode 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 解题思路 函数意义：t2归并到t1里，返回t1 选择t1为主树，更新结点值到t1里。 因为树结构发生变化，所以需要重新链接左右子树 结束条件：当两个都是null结点则返回null，其中一个是null则返回另一个123456789TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; if(!t1 &amp;&amp; !t2) return NULL; if(!t2) return t1; if(!t1) return t2; t1-&gt;val+=t2-&gt;val; t1-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left); t1-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right); return t1;&#125; 最长同值路径Leetcode给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。注意：两个节点之间的路径长度由它们之间的边数表示。 解题思路： 寻找最长路径，即需要一个变量ans记录当前最长值，递归时用于比较。 路径可能穿过某个根结点，所以需要遍历每一个结点，将其左子树最长路径加上右子树最长路径。 设计递归函数：返回当前结点下的左右中其中一条最长路径的长度 注意如果结点值与子树的值不连续，路径即为0 路径&#x3D;结点数-1123456789101112131415int longestUnivaluePath(TreeNode* root) &#123; int ans = 0; height(root, ans); return ans;&#125;int height(TreeNode* node, int &amp;ans) &#123; if (!root) return 0; int left = height(root-&gt;left, ans); int right = height(root-&gt;right, ans); left = (root-&gt;left &amp;&amp; root-&gt;val == root-&gt;left-&gt;val) ? left + 1 : 0; right = (root-&gt;right &amp;&amp; root-&gt;val == root-&gt;right-&gt;val) ? right + 1 : 0; ans = max(ans, left + right); return max(left, right);&#125; 二叉树中第二小的节点Leetcode给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。 解题思路 题干关键信息：节点的值不大于它的子节点的值，即root结点就是整棵树的最小值，因此第二小的值只能是min(root-&gt;left-&gt;val,root-&gt;right-&gt;val)。 但是当root的值与它其中一个子结点刚好相等时，第二小的值才有可能出现在更深层的子节点中，才需要继续递归搜索第二小值。 函数意义：返回第二小的值。 递归结束条件：null结点或者叶子结点（因为叶子结点的左右子结点都是null，无法访问它）。 哪边找到就返回哪边，都找到则返回较小者。1234567891011int findSecondMinimumValue(TreeNode* root) &#123; if(!root) return -1; if(!root-&gt;left &amp;&amp; !root-&gt;right) return -1; int l=root-&gt;left-&gt;val; int r=root-&gt;right-&gt;val; if(root-&gt;val == l) l=findSecondMinimumValue(root-&gt;left); if(root-&gt;val == r) r=findSecondMinimumValue(root-&gt;right); if(l!=-1 &amp;&amp; r!=-1) return min(l,r); if(l==-1) return r; return l;&#125; 修剪二叉搜索树Leetcode给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;&#x3D;L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。 解题思路 函数意义：修剪二叉树并完返回修剪好的二叉树的根结点 递归结束条件：遇到null 如果根结点的值小于给定的左边界L，那么当前结点及其左子树就会被修剪掉，修剪后的树应该是其右子树，所以返回修剪后的右子树。 涉及到改变树的结构，就需要更新链接，如果当前结点值在范围内，那么修建其左右子树，并且更新左右链接。最后 将当前修剪好的子树返回。12345678TreeNode* trimBST(TreeNode* root, int L, int R) &#123; if(!root)return NULL; if(root-&gt;val &lt; L) return trimBST(root-&gt;right,L,R); if(root-&gt;val &gt; R) return trimBST(root-&gt;left,L,R); root-&gt;left=trimBST(root-&gt;left,L,R); root-&gt;right=trimBST(root-&gt;right,L,R); return root;&#125; 二叉搜索树中的插入操作leetcode给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果 解题思路 凡是看到对一个二叉树进行过修改得题，递归得时候一定要对root的左右两个子树重新赋值 若 val &gt; root.val，插入到右子树。 若 val &lt; root.val，插入到左子树。 若 root == null， 即找到了该插入的地方，返回新建的 TreeNode(val)结点。123456TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if (root == nullptr) return new TreeNode(val); if (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val); else root-&gt;right = insertIntoBST(root-&gt;right, val); return root;&#125; 删除二叉搜索树中的节点leetcode给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：首先找到需要删除的节点；如果找到了，删除它。解题思路 必须掌握二叉树的三个性质： 中序遍历&#x3D;递增序列 比当前节点大的最小节点，简称中序遍历序列中的后继节点。先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。 比当前节点小的最大节点，简称中序遍历序列中的前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点 当找到要删除的结点后，该结点有4中状态： 如果是叶子结点，删除它就等于向上返回null结点 如果只有一个子树，删除它就等于向上返回他的那唯一一颗子树 如果两颗子树都存在，应该按照第三条性质，左子树链接到右子树中的最左下角的结点后面，然后向上返回右子树。123456789101112131415161718TreeNode* deleteNode(TreeNode* root, int key) &#123; if (root == NULL) return NULL; if (root-&gt;val &lt; key) root-&gt;right = deleteNode(root-&gt;right, key); else if (root-&gt;val &gt; key) root-&gt;left = deleteNode(root-&gt;left, key); else &#123; // 找到要删除的结点 if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return NULL; // 该节点是叶子 if (root-&gt;left == NULL) return root-&gt;right; if (root-&gt;right == NULL) return root-&gt;left; TreeNode* cur = root-&gt;right; while (cur-&gt;left != NULL) &#123; cur = cur-&gt;left; &#125; cur-&gt;left = root-&gt;left; return root-&gt;right; &#125; return root;&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"树","slug":"树","permalink":"https://www.mingsrc.work/tags/%E6%A0%91/"}]},{"title":"🎨程序员面试金典🎨","slug":"J_LeetCode/LeetCode/程序员面试金典","date":"2022-12-27T03:12:54.073Z","updated":"2022-12-27T03:12:54.074Z","comments":true,"path":"posts/2eef4cb2.html","link":"","permalink":"https://www.mingsrc.work/posts/2eef4cb2","excerpt":"🎨程序员面试金典🎨转自：🔥【github】 ","text":"🎨程序员面试金典🎨转自：🔥【github】 1.判定字符是否唯一 2.判定是否互为字符重排 3.URL化 4.回文排列 5.一次编辑 6.字符串压缩 7.旋转矩阵 8.零矩阵 9.字符串轮转 10.移除重复节点 11.返回倒数第k个节点 12.删除中间节点 13.分割链表 14.链表求和 15.回文链表 16.链表相交 17.环路检测 18.栈的最小值 19.化栈为队 20.栈排序 判定字符是否唯一leetcode实现一个算法，确定一个字符串 s 的所有字符是否全都不同。 解题思路 首先想到哈希表统计各字母出现频率，只遍历一次，频率大于1就返回false。12345678bool isUnique(string astr) &#123; unordered_map&lt;char, int&gt; cnt; for (int i = 0; i &lt; astr.size(); ++i) &#123; cnt[astr[i]]++; if (cnt[astr[i]] &gt; 1) return false; &#125; return true;&#125; 如果面试官不想用哈希表，或者不能用额外的数据结构解题，就用一个整形数组代替来记录26个字母出现次数。123456789bool isUnique(string astr) &#123; int cnt[26]; memset(cnt, 0, sizeof(int) * 26); for (int i = 0; i &lt; astr.size(); ++i) &#123; cnt[astr[i] - &#x27;a&#x27;]++; if (cnt[astr[i] - &#x27;a&#x27;] &gt; 1) return false; &#125; return true;&#125; 但是对于这种统计只出现一次，或者两次的题，都能够给位运算符操作 本题的思路是，把每个字母转换成二进制，例如 a-&gt; 0001 b -&gt; 0010 c-&gt; 0100 d-&gt;1000一次类推剩下所有字母。 还需要维护一个掩码mask，将遍历过的所有字母的二进制数合并起来(|&#x3D;运算)，例如遍历了abcd,mask就等于1111,再次碰到a~d,就能通过&amp;发现重复。12345678910bool isUnique(string astr) &#123; int mask = 0; for (auto c : astr) &#123; int num = 1 &lt;&lt; (c - &#x27;a&#x27;); if (mask &amp; num) return false; else mask |= num; &#125; return true;&#125; 判定是否互为字符重排leetcode给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。 解题思路 不用哈希表的方式，记录26个字母出现的频率，同时遍历两个字符串，一个加次数，一个减次数。最后看是否所有字母的次数为0。12345678910111213bool CheckPermutation(string s1, string s2) &#123; if (s1.size() != s2.size()) return false; int cnt[26]; memset(cnt, 0, sizeof(int) * 26); for (int i = 0; i &lt; s1.size(); ++i) &#123; cnt[s1[i] - &#x27;a&#x27;]++; cnt[s2[i] - &#x27;a&#x27;]--; &#125; for (int i = 0; i &lt; 26; ++i) &#123; if (cnt[i] != 0 ) return false; &#125; return true;&#125; URL化leetcodeURL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。） 示例:12输入：&quot;Mr John Smith &quot;, 13输出：&quot;Mr%20John%20Smith&quot; 解题思路 理解题意很重要，在原数组的基础上进行修改，两种思路：从头开始或从尾部开始，既然原字符串在结尾已经给我预留了足够多的空位，那更方便从尾部开始插入。 维护两个指针，一个指向读入数据的位置（字符串真实长度的尾部），一个指向插入数据的位置（原字符串尾部） 读入数据进行判断，是空格，就在尾部连续插入3个字符’0’’2’’%’,否则正常插入读入的数据。 最后，将修改后的结果从字符串中提取出来，substr()从写入指针最后停止的位置开始提取到尾部。 substr()小技巧：如果没有指定长度或超出了源字符串的长度，则子字符串将延续到源字符串的结尾123456789101112131415161718string replaceSpaces(string S, int length) &#123; int writePos = S.size() - 1; for (int i = 0; i &lt; length; i++) &#123; int readPos = length - 1 - i; if (S[readPos] != &#x27; &#x27;) &#123; S[writePos--] = S[readPos]; &#125; else &#123; S[writePos--] = &#x27;0&#x27;; S[writePos--] = &#x27;2&#x27;; S[writePos--] = &#x27;%&#x27;; &#125; &#125; if (writePos &gt;= 0) &#123; //S = S.substr(writePos + 1, S.size() - writePos - 1); S = S.substr(writePos + 1); &#125; return S;&#125; 回文排列leetcode给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。回文串不一定是字典当中的单词。 解题思路 就是判断一个字符串能否变为一个回文串 统计每个字符出现的次数，偶数次数一定能组成回文，而奇数次数的字符只能有一个。遍历每个字符，如果有2个以上包括2个的字母出现的次数为奇数，则不能变为回文。123456789101112bool canPermutePalindrome(string s) &#123; map&lt;char, int&gt; cnt; for (auto ch : s) &#123; cnt[ch]++; &#125; int res = 0; for (auto m : cnt) &#123; if (m.second % 2) res++; if (res &gt; 1) return false; &#125; return true;&#125; 一次编辑leetcode字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。 示例12345输入: first = &quot;pale&quot;second = &quot;ple&quot;输出: True 解题思路 能够通过增删换一次操作使两个字符相同的前提一定是，两个字符个数绝对差不超过1. 使用两个指针同时遍历两个字符，字幕相同就继续同时往后遍历 如果发现字母不同，cnt++记录需要操作的次数。 删除操作实质上就是指针跳过这个字符。至于是哪个指针进行跳过，就要就比较哪个字符串比较长，就删除哪个字符串的字符。 如果两个字符串长度相等，就只能进行替换操作，替换完，两个指针是要同时前进的12345678910111213141516bool oneEditAway(string first, string second) &#123; int len1 = first.size(), len2 = second.size(); if (abs(len1 - len2) &gt; 1) return false; int p1 = 0, p2 = 0; int cnt = 0; while (p1 &lt;= len2 &amp;&amp; p2 &lt;= len2) &#123; if (first[p1] == second[p2]) &#123; p1++,p2++;continue; &#125; len1 == len2 ? p1++,p2++ : len1 &gt; len2 ? p1++ : p2++; cnt++; if (cnt &gt; 1) return false; &#125; return true;&#125; 字符串压缩leetcode字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。 示例12输入：&quot;aabcccccaaa&quot;输出：&quot;a2b1c5a3&quot; 解题思路 遍历字符串，先取第一个字符作为当前值，从下标1开始遍历，统计与当前字符相等的个数。 当遍历不相等的字符时，更新当前值和个数 注意：因为每次遍历到不同的字符时，指针都会指向下一个字符，因此当遍历到最后一个字符时，需要跟字符串结尾的\\0进行比较，所以遍历边界就不能再是i &lt; s.size()应改为i &lt; size() + 1。让i可以指向\\0。 1234567891011121314string compressString(string S) &#123; if (S.size() &lt;= 1) return S; char cur = S[0]; string res = &quot;&quot;; for (int i = 1; i &lt; S.size() + 1; ++i) &#123; int cnt = 1; res += cur; while (i &lt; S.size() &amp;&amp; S[i] == cur) cnt++, i++; cur = S[i]; res += to_string(cnt); &#125; return S.size() &gt; res.size() ? res : S;&#125; 旋转矩阵leetcode给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。不占用额外内存空间能否做到？ 示例12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 最简单的方式就是使用辅助矩阵，只要找到翻转后位置的对应关系即可，第row行变为第col行，第col列变为第n-1-row列（倒数的row列） matrix[j][n-1-i] = matrix[i][j]1234567891011void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); auto newMat = matrix; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; newMat[j][n - 1 - i] = matrix[i][j]; &#125; &#125; matrix = newMat; return;&#125; 如果面试要求原地进行翻转，首先要知道matrix[j][n-1-i] = matrix[i][j]会覆盖掉第2个点， 第一：因此我们需要先旋转第2个点，但第2点又会覆盖第3个点，所以先旋转第3点，第3点会覆盖第4点，第4个点刚好就是第1个点，形成一个循环，这样我们先记录第1个点，将后面得点依次覆盖，即可完成4个点得同时旋转。 第二：因为一次旋转4个点，所以我们需要知道遍历哪些点才能不重复。偶数边矩阵：最左上角的小矩阵，奇数矩阵：因为多了中间一列，所以选择最左上角的小矩阵 + 中间列。123456789101112void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); for (int i = 0; i &lt; n / 2; ++i) &#123; for (int j = 0; j &lt; (n + 1) / 2; ++j) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[n - j - 1][i]; matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]; matrix[j][n - i - 1] = temp; &#125; &#125;&#125; 用对折翻转代替旋转，这种算法除非做过原题，一般是想不到 先水平翻转，再对角线翻转 注意：翻转需要两个元素：1、翻转前后点得对应关系。2、枚举需要遍历的点。12345678910111213141516void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); // 水平翻转 for (int i = 0; i &lt; n / 2; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; swap(matrix[i][j], matrix[n - 1 - i][j]); &#125; &#125; // 对角线翻转 for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; swap(matrix[i][j], matrix[j][i]); &#125; &#125; return;&#125; 零矩阵leetcode编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。 解题思路 暴力法；先全部遍历，找到并记录全部0的行列坐标。 第二次只遍历这些0的位置，模拟操作：往上下左右四个方向进行置0操作。1234567891011121314151617181920212223242526272829303132333435void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.size() == 0) return; int row = matrix.size(); int col = matrix[0].size(); vector&lt;pair&lt;int,int&gt;&gt; indexs; for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; if (matrix[i][j] == 0) &#123; indexs.push_back(pair&lt;int, int&gt;(i, j)); &#125; &#125; &#125; if (indexs.size() == row * col) return; for (auto it : indexs) &#123; int i = it.first; int j = it.second; int i1 = i; while (++i1 &lt; row) &#123; matrix[i1][j] = 0; &#125; int i2 = i; while (--i2 &gt;= 0) &#123; matrix[i2][j] = 0; &#125; int j1 = j; while (++j1 &lt; col) &#123; matrix[i][j1] = 0; &#125; int j2 = j; while (--j2 &gt;= 0) &#123; matrix[i][j2] = 0; &#125; &#125;&#125; 同样是先记录所以出现0的行和列，然后第二次遍历时，判断当前行或者列是否是需要置0的 需要两个bool数组，记录每个行或列是否是需要置0的行1234567891011121314151617181920212223void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); int m = matrix[0].size(); bool isZeroRow[n], isZeroCol[m]; memset(isZeroRow, 0, sizeof(bool) * n); memset(isZeroCol, 0, sizeof(bool) * m); // 统计哪些行，列需要全置位0 for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (matrix[i][j] == 0) &#123; isZeroRow[i] = true; isZeroCol[j] = true; &#125; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (isZeroRow[i] || isZeroCol[j]) matrix[i][j] = 0; &#125; &#125;&#125; 字符串轮转leetcode字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。 解题思路 两个思路，一种暴力的方式，旋转s2，判断s1 和s2是否相等，不相等继续旋转s2 使用C库int strcmp(const char* s1, const char* s2)字符串需要转换为char*类型，且strcmp是采用逐位相减来判断的，返回0表示相等，大于0表示大于s1 &gt; s2，123456789101112131415bool isFlipedString(string s1, string s2) &#123; if (s1.size() != s2.size()) return false; if (s1.empty()) return true; int n = s1.size(); for (int i = 0; i &lt; n; ++i) &#123; char temp = s2[n - 1]; for (int j = n - 1; j - 1 &gt;= 0; --j) &#123; s2[j] = s2[j - 1]; &#125; s2[0] = temp; if (strcmp(s1.c_str(), s2.c_str()) == 0) return true; &#125; return false;&#125; 思路二：既然是循环字符串，就一定要想到拼接思想，通过s1 + s1 拼接后找是否存在s2子串的方式 找子串有两种方式：1、分割出子串string substr(int index, int count)需要参数位置和个数,返回分割的子串，进行比较1234567891011bool isFlipedString(string s1, string s2) &#123; if (s1.size() != s2.size()) return false; if (s1.empty()) return true; int n = s1.size(); s2 = s2 + s2; for (int i = 0; i &lt; n; ++i) &#123; if (s1[0] == s2[i] &amp;&amp; s1 == s2.substr(i, n)) return true; &#125; return false;&#125; 2、或使用stl库得find函数找子串，找到返回首个字符的下标，否则返回npos12345bool isFlipedString(string s1, string s2) &#123; // slt if (s1.size() != s2.size()) return false; return (s1 + s1).find(s2) != string::npos;&#125; 移除重复节点leetcode编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 示例12输入：[1, 2, 3, 3, 2, 1]输出：[1, 2, 3] 解题思路 本题是对未排序的链表进行删重，所以需要先遍历一遍记录不重复的有哪些值。 第二次遍历针对非记录中的进行删除 链表的删除需要前驱，所以head结点我们也需要新建一个前驱，删除结点的操作最好都是枚举遍历前驱，当前结点通过前驱获得。123456789101112131415ListNode* removeDuplicateNodes(ListNode* head) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* pre = dummy; unordered_set&lt;int&gt; hash; while (pre-&gt;next) &#123; ListNode* cur = pre-&gt;next; // 获取待删除结点 if (hash.find(cur-&gt;val) == hash.end()) &#123; // 没有找到 hash.insert(cur-&gt;val); pre = pre-&gt;next; // 只有遇到新元素才更新 &#125; else pre-&gt;next = pre-&gt;next-&gt;next; &#125; return dummy-&gt;next;&#125; 返回倒数第 k 个节点leetcode实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。注意：本题相对原题稍作改动 示例12输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2输出： 4 解题思路 两个思路，第一快慢指针法，第二翻转链表，但是时间复杂度相对较高123456789101112int kthToLast(ListNode* head, int k) &#123; if (head == NULL) return -1; ListNode* slow = head; ListNode* fast = head; while (k--) fast = fast-&gt;next; while (fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow-&gt;val;&#125; 翻转链表法123456789101112131415int kthToLast(ListNode* head, int k) &#123; ListNode* cur = head; ListNode* pre = NULL; while (cur) &#123; ListNode* temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; &#125; k--; // 第k个元素，跳k-1次就可以 while (k--) &#123; pre = pre-&gt;next; &#125; return pre-&gt;val;&#125; 删除中间节点leetcode实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。 示例12输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f 解题思路 此题题意难以理解，意思是一般我们删除链表的某一个结点都通过遍历到待删除结点的前驱，通过更改前驱指针进行删除本题的目的是，只给你当前待删除的结点指针，完成原地删除操作。 思路是，将当前结点替换为它的后继结点，即更新它的值和next指针1234void deleteNode(ListNode* node) &#123; node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next;&#125; 结点的本质是结构体，通过将后继的内存内容直接覆盖掉当前待删除结点内存空间完成替换。123void deleteNode(ListNode* node) &#123; *node = *(node-&gt;next);&#125; 分割链表leetcode编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。 示例12输入: head = 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1, x = 5输出: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8 解题思路 读懂题意就很难，大致目的是根据x值将一个链表分成两条链表，其中一个是大于等于x的值组成的，另一条是小于x的值，分割完后再进行前后拼接。 用到的技巧就是分割和组装链表 新建链表需要得是头结点和用于遍历的指针，插入时用尾插法 组装链表将其中一条链表尾部next指针指向另一条链表的第一个元素，最后在尾部添加NULL完成组装。1234567891011121314151617181920ListNode* partition(ListNode* head, int x) &#123; ListNode* small = new ListNode(-1); ListNode* big = new ListNode(-1); ListNode* cur = head; ListNode* smallCur = small; ListNode* bigCur = big; while (cur) &#123; if (cur-&gt;val &lt; x) &#123; smallCur-&gt;next = cur; smallCur = smallCur-&gt;next; &#125; else &#123; bigCur-&gt;next = cur; bigCur = bigCur-&gt;next; &#125; cur = cur-&gt;next; &#125; smallCur-&gt;next = big-&gt;next; bigCur-&gt;next = NULL; return small-&gt;next;&#125; 链表求和leetcode给定两个用链表表示的整数，每个节点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。 示例12输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295输出：2 -&gt; 1 -&gt; 9，即912 解题思路 两个指针分别遍历两个链表，将其中的数相加，大于10的部分作为进位参与下一轮的求和，个位数即为新结点的值 关键在于边界条件，当其中一条链表遍历结束后，指向了null，因此将它的值全部赋予0，继续参与之后每轮的求和。 当两链表全部遍历结束后，再次判断还有没有剩余的进位，如果有就最后新建一个结点。 12345678910111213141516171819202122232425262728ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* p1 = l1; ListNode* p2 = l2; int sum = 0; int c = 0; ListNode* preHead = new ListNode(-1); ListNode* cur = preHead; while (p1 || p2) &#123; int val1 = p1 == NULL ? 0 : p1-&gt;val; int val2 = p2 == NULL ? 0 : p2-&gt;val; sum = val1 + val2 + c; c = sum / 10; int val = sum % 10; ListNode* node = new ListNode(val); cur-&gt;next = node; cur = cur-&gt;next; if(p1) p1 = p1-&gt;next; if(p2) p2 = p2-&gt;next; &#125; if (c != 0) &#123; ListNode* node = new ListNode(c); cur-&gt;next = node; &#125; return preHead-&gt;next;&#125; 回文链表leetcode编写一个函数，检查输入的链表是否是回文的。 解题思路 翻转一半的链表进行逐点比较。 先用快慢指针寻找中间点，为了方便奇数偶数链表的统一，我们新建头结点开始遍历。这样当快指针结束时，慢指针正好指向后一半链表的前驱上，无论是否是奇数偶数链表。 翻转链表用了头插法123456789101112131415161718192021222324252627bool isPalindrome(ListNode* head) &#123; if (!head) return true; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* slow = dummy; ListNode* fast = dummy; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode* pre = NULL; ListNode* cur = slow-&gt;next; while (cur) &#123; ListNode* tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; while (head &amp;&amp; pre) &#123; if (head-&gt;val != pre-&gt;val) return false; head = head-&gt;next; pre = pre-&gt;next; &#125; return true;&#125; 链表相交leetcode给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。 解题思路 判断两个链表是否相交，经典做法拼接两个链表，即当第一个链表遍历结束后继续从第二条头部遍历，第二条链表同样如此 这样两个链表相等的长度，当两个指针指向同一块地址时，不是null就是相交点。1234567891011ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if (!headA || !headB) return NULL; ListNode* p1 = headA; ListNode* p2 = headB; while (p1 != p2) &#123; p1 = p1 == NULL ? headB : p1-&gt;next; p2 = p2 == NULL ? headA : p2-&gt;next; &#125; return p1; &#125; 环路检测leetcode给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。 解题思路 题目要我们除了要判断是否是环路，还要返回环路的头部结点 判断是否环路使用快慢指针，当快指针追上慢指针时即为环路 寻找头部就需要数学推导，结论就是当快指针追上慢指针后，让快指针从头开始走，步数和慢指针相同，两指针会在环头部相遇。123456789101112131415161718ListNode *detectCycle(ListNode *head) &#123; if (!head) return NULL; ListNode* slow = head; ListNode* fast = head; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (fast == slow) &#123; // 有环 fast = head; while (fast != slow) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return fast; &#125; &#125; return NULL;&#125; 栈的最小值leetcode请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。 解题思路 维护两个栈，数据栈和扎顶储存当前数据栈中的最小值的最小栈 入栈时判断入栈元素是否比当前数据中的最小值还小，还小就如栈。 出栈时需要判断出栈元素是否刚好就是当前数据中的最小值，是就同步出栈。123456789101112131415161718192021222324252627282930313233class MinStack &#123;public: stack&lt;int&gt; data; stack&lt;int&gt; minSck; MinStack() &#123;&#125; void push(int x) &#123; data.push(x); if (minSck.empty()) &#123; minSck.push(x); &#125; else &#123; if (minSck.top() &gt;= x) minSck.push(x); &#125; &#125; void pop() &#123; if (data.empty()) return; if (data.top() == minSck.top()) &#123; data.pop(); minSck.pop(); &#125; else &#123; data.pop(); &#125; &#125; int top() &#123; return data.top(); &#125; int getMin() &#123; return minSck.top(); &#125; 化栈为队leetcode实现一个MyQueue类，该类用两个栈来实现一个队列。 解题思路 队列是先进先出，栈先进后出，所以通过两个栈反转实现先进先出 出栈的时候先反转栈内的数据，将数据栈全部如辅助栈中，pop的数据就是辅助栈的栈顶元素。 只有当辅助栈弹空时，再继续反转数据栈内的数据进入辅助栈补充12345678910111213141516171819202122int pop() &#123; if (helpSck.empty()) &#123; while (!dataSck.empty()) &#123; helpSck.push(dataSck.top()); dataSck.pop(); &#125; &#125; int res = helpSck.top(); helpSck.pop(); return res;&#125;int peek() &#123; if (helpSck.empty()) &#123; while (!dataSck.empty()) &#123; helpSck.push(dataSck.top()); dataSck.pop(); &#125; &#125; return helpSck.top();&#125; 栈排序leetcode栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。 解题思路 本题相当于对栈内的元素进行排序，维护栈顶到栈底从小到大排序 因此栈顶遇到比它大的数时，先弹出比他小的元素到辅助栈中，直到到他的合适位置后，再将辅助栈内的元素倒入原栈中。1234567891011121314151617181920212223242526void push(int val) &#123; while(!s1.empty() &amp;&amp; s1.top() &lt; val)&#123; s2.push(s1.top()); s1.pop(); &#125; s1.push(val); while(!s2.empty())&#123; s1.push(s2.top()); s2.pop(); &#125;&#125;void pop() &#123; if(!s1.empty()) s1.pop();&#125;int peek() &#123; if(!s1.empty()) return s1.top(); return -1;&#125;bool isEmpty() &#123; return s1.empty();&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/tags/%E9%9D%A2%E8%AF%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"📸排序📸","slug":"J_LeetCode/LeetCode/排序","date":"2022-12-27T03:12:54.072Z","updated":"2022-12-27T03:12:54.072Z","comments":true,"path":"posts/bafd3c38.html","link":"","permalink":"https://www.mingsrc.work/posts/bafd3c38","excerpt":"📸排序📸","text":"📸排序📸 堆排序、快速排序 215.数组中的第K个最大元素 建立哈希表并排序 347.前K个高频元素 451.按照字符出现次数对字符串排序 荷兰国旗问题 75.按颜色进行排序 数组中的第K个最大元素leetcode在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 使用SLT库排序1234int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); return nums[nums.size() - k];&#125; 堆排序解题思路 堆排序会使用到优先队列priority_queue，可以当成一种高级队列，只不过这个队列是已经排好序的。 维护一个个数为k的小顶堆，堆从从上到下按从小到大排序 始终保持堆的大小为k，超出k就pop(),直到遍历结束位置，堆中存放着前k个最大元素，堆顶的元素就是正确答案。12345678int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; queue; for (auto it : nums) &#123; queue.push(it); if (queue.size() &gt; k) queue.pop(); &#125; return queue.top();&#125; 快速排序解题思路 不使用STL库的情况下，手写一个快速排序算法 注意：快速排序使用的是递归，所以记得一定要写个递归结束条件 if (left &gt; right) return ;。 注意：在partition函数中while里处理要判断nums[right] &gt;&#x3D; p，还要判断left &lt; right。1234567891011121314151617181920212223int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; quickSort(nums, 0, nums.size() - 1); return nums[nums.size() - k];&#125;void quickSort(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left &gt; right) return ; int mid = partition(nums, left, right); quickSort(nums, left, mid - 1); quickSort(nums, mid + 1,right);&#125;int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int p = nums[left]; while (left &lt; right) &#123; while (nums[right] &gt;= p &amp;&amp; left &lt; right) right--; nums[left] = nums[right]; while (nums[left] &lt;= p &amp;&amp; left &lt; right) left++; nums[right] = nums[left]; &#125; nums[left] = p; return left;&#125; 前K个高频元素leetcode给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 解题思路 建立哈希表统计数字出现频率， 利用隐式转换，把无序hash转换为pair类型方便按照频率多少进行排序 使用SLT的sort()函数进行排序，大小的比较规则cmp函数需要自己写。 将排好序的前k元素输出12345678910111213141516static bool cmp(pair&lt;int, int&gt; v1, pair&lt;int, int&gt; v2)&#123; return v1.second &gt; v2.second;&#125;vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int,int&gt; hash; for (int i = 0; i &lt; nums.size(); ++i) &#123; hash[nums[i]]++; &#125; vector&lt;pair&lt;int, int&gt; &gt; arr(hash.begin(), hash.end()); sort(arr.begin(), arr.end(), cmp); vector&lt;int&gt; res; for(int i = 0; i &lt; k; ++i)&#123; res.push_back(arr[i].first); &#125; return res;&#125; 按照字符出现次数对字符串排序leetcode给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 解题思路 哈希表建立的频率表是无序的，所以需要转换为其他数据结构，再使用排序算法对其排序 可以使用隐式的类型转换为pair&lt;char,int&gt;，再使用STL里面的sort()函数进行排序，sort的好处是可以自定义排序的规则。 sort()函数自定义的排序规则需要写成静态的函数123456789101112131415161718static bool cmp(pair&lt;char, int&gt; a, pair&lt;char, int&gt; b) &#123; return a.second &gt; b.second;&#125;string frequencySort(string s) &#123; unordered_map&lt;char, int&gt;hash; for (auto it : s) &#123; hash[it]++; &#125; vector&lt;pair&lt;char, int&gt; &gt; arr(hash.begin(), hash.end()); sort(arr.begin(), arr.end(), cmp); string res; for (auto it : arr) &#123; while (it.second--) &#123; res.push_back(it.first); &#125; &#125; return res;&#125; 荷兰国旗Leetcode给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 解题思路 一共三个指针，p0一直指向0的后一位，p2一直指向2的前一位，cur是用于遍历的指针。 本题属于荷兰旗帜问题：思想是遇到0就跟p0所指的数交换位置，遇到2就跟p2所指的数交换位置，遇到1就跳过。 注意：遇到2交换完位置后，cur指针不前进，因为要再次判断交换过来的数是0还是1。 注意2：while结束是 cur &lt; p2而不是cur &lt; nums.size() 123456789void sortColors(vector&lt;int&gt;&amp; nums) &#123; int p0 = 0, p2 = nums.size() - 1; int cur = 0; while (cur &lt; p2) &#123; if (nums[cur] == 1) cur++; else if (nums[cur] == 0) swap(nums[p0++], nums[cur++]); else if (nums[cur] == 2) swap(nums[cur],nums[p2--]); &#125;&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"数组","slug":"J_LeetCode/LeetCode/数组","date":"2022-12-27T03:12:54.072Z","updated":"2022-12-27T03:12:54.072Z","comments":true,"path":"posts/340249a9.html","link":"","permalink":"https://www.mingsrc.work/posts/340249a9","excerpt":"数组\n5460. 好数对的数目\n","text":"数组 5460. 好数对的数目 好数对的数目leetcode给你一个整数数组 nums 。如果一组数字 (i,j) 满足 nums[i] &#x3D;&#x3D; nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。返回好数对的数目。 示例123输入：nums = [1,2,3,1,1,3]输出：4解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始 解题思路 只要想到用一个二维数组的方式来判断就很简单，用到双层for循环暴力解决。12345678910int numIdenticalPairs(vector&lt;int&gt;&amp; nums) &#123; int cnt = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[i] == nums[j]) cnt ++; &#125; &#125; return cnt;&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"数组","slug":"数组","permalink":"https://www.mingsrc.work/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"栈和队列","slug":"J_LeetCode/LeetCode/栈和队列","date":"2022-12-27T03:12:54.072Z","updated":"2022-12-27T03:12:54.073Z","comments":true,"path":"posts/8d66b5f2.html","link":"","permalink":"https://www.mingsrc.work/posts/8d66b5f2","excerpt":"🚑栈和队列🚑转自：🔥【github】 ","text":"🚑栈和队列🚑转自：🔥【github】 7.整数反转 9.回文数 20.有效的括号 232.用栈实现队列 225.用队列实现栈 155.最小栈 150.逆波兰表达式求值 394.字符串解码 133.克隆图 200.岛屿数量 84.柱状图中最大的矩形 542.01矩阵 622.设计循环队列 整数反转Leetcode给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转 解题思路 从低到高位依次加入队列，然后输出 注意反转后的溢出问题123456789int reverse(int x) &#123; int rev=0; while(x!=0)&#123; if(rev&gt;INT_MAX/10 || rev&lt;INT_MIN/10) return 0; rev=rev*10+x%10; x/=10; &#125; return rev;&#125; 回文数Leetcode判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 解题思路 一位数一定是回文数 负数或者个位是0的一定不是回文数。 反转整数，只反转到一半，然后进行比较（对于奇数个数得回文数，去掉中间位再比较）12345678910bool isPalindrome(int x) &#123; if(x&gt;=0 &amp;&amp; x&lt;=9)return true; if(x%10==0 || x&lt;0)return false; int rev=0; while(x&gt;rev)&#123; rev=rev*10+x%10; x/=10; &#125; return rev/10==x || rev==x;&#125; 有效的括号Leetcode给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ &#x3D;&#x3D;&#x3D;的字符串，判断字符串是否有效。有效字符串需满足： 121. 左括号必须用相同类型的右括号闭合。2. 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 解题思路 个数为奇数肯定不对 首字符为右符号肯定不对 遇到左符号入栈 遇到右符号与栈顶元素进行匹配，配对则出栈，否则返回false，最后栈空了则说明是有效的12345678910111213141516 bool isValid(string s) &#123; if(s.size()%2)return false; if(s[0]==&#x27;&#125;&#x27; || s[0]==&#x27;)&#x27; || s[0]==&#x27;]&#x27;) return false; stack&lt;char&gt; sck; for(int i=0;s[i]!=&#x27;\\0&#x27;;++i)&#123; if(s[i]==&#x27;[&#x27; || s[i]==&#x27;&#123;&#x27; || s[i]==&#x27;(&#x27;)&#123; sck.push(s[i]); &#125;else&#123; if(s[i]==&#x27;&#125;&#x27; &amp;&amp; sck.top()!=&#x27;&#123;&#x27;) return false; if(s[i]==&#x27;]&#x27; &amp;&amp; sck.top()!=&#x27;[&#x27;) return false; if(s[i]==&#x27;)&#x27; &amp;&amp; sck.top()!=&#x27;(&#x27;) return false; sck.pop(); &#125; &#125; return sck.empty();&#125; 用栈实现队列Leetcode 栈的顺序为后进先出，而队列的顺序为先进先出。 使用两个栈实现队列，一个元素需要经过两个栈才能出队列123456789101112131415161718192021222324252627282930313233343536class MyQueue &#123;public: void push(int x) &#123; stack1.push(x); &#125; int pop() &#123; if(stack2.empty())&#123; //只有当stack2为空时，才重新加载 while(!stack1.empty())&#123; //stack1装填到stack2 stack2.push(stack1.top()); //c++ pop()函数返回值额为void stack1.pop(); &#125; &#125; int res=stack2.top(); stack2.pop(); return res; &#125; int peek() &#123; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.top()); stack1.pop(); &#125; &#125; return stack2.top(); &#125; bool empty() &#123; return stack1.empty() &amp;&amp; stack2.empty(); &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; 用队列实现栈方法一Leetcode 一个队列 push之前判断当前是否为空 不为空则将元素插入到尾部，前面的全部弹出再去入队 push时间复杂度O(n),而pop的时间复杂度O(1) 12345678910111213141516171819202122232425262728293031323334class MyStack &#123;public: MyStack() &#123;&#125; void push(int x) &#123; if(queue1.empty())&#123; queue1.push(x); &#125;else&#123; int cnt=queue1.size(); queue1.push(x); while(cnt--&gt;0)&#123; queue1.push(queue1.front()); queue1.pop(); &#125; &#125; &#125; int pop() &#123; int res=queue1.front(); queue1.pop(); return res; &#125; int top() &#123; return queue1.front(); &#125; bool empty() &#123; return queue1.empty(); &#125;private: queue&lt;int&gt; queue1;&#125;; 方法二 push时间复杂度O(1),而pop的时间复杂度O(n) 12345678910111213141516171819202122232425262728private: queue&lt;int&gt; q1; void push(int x) &#123; q1.push(x); &#125; int pop() &#123; queue&lt;int&gt;q2; while(q1.size()&gt;1)&#123; q2.push(q1.front()); q1.pop(); &#125; int res=q1.front(); q1=q2; return res; &#125; int top() &#123; queue&lt;int&gt;q2(q1); while(q1.size()&gt;1)&#123; q1.pop(); &#125; int res=q1.front(); q1=q2; return res; &#125; bool empty() &#123; return q1.empty(); &#125;&#125;; 最小栈 Leetcode 维护两个栈：数据栈 最小栈 同步简单，异步节省最小栈空间 异步：当新插入的元素比最小值还小（或相等）时，插入最小栈，出栈时只有当两个栈栈顶元素相同时，两个栈同时pop，否则只有数据栈pop 同步：两个栈的大小始终相同，只是最小栈每次都插入当前最小值，出栈时两栈同时pop 1234567891011121314151617181920212223242526272829303132333435class MinStack &#123;public: void push(int x) &#123; dataStack.push(x); if(miniStack.empty())&#123; miniStack.push(x); &#125;else&#123; int min=miniStack.top(); if(min&gt;=x)&#123; //相等时也要插入 miniStack.push(x); &#125; &#125; &#125; void pop() &#123; if( dataStack.top()==miniStack.top())&#123; //只有相等时才同时弹出否则只弹出dataStack dataStack.pop(); miniStack.pop(); &#125;else&#123; dataStack.pop(); &#125; &#125; int top() &#123; return dataStack.top(); &#125; int getMin() &#123; return miniStack.top(); &#125;private: stack&lt;int&gt; dataStack; stack&lt;int&gt; miniStack;&#125;; 逆波兰表达式求值leetcode根据 逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。说明：整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例123输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 解题思路 典型的后缀表达式，栈得应用场景 遍历字符串数组，遇到字符就弹出栈顶两个元素进行运算，再将结果填入栈。遇到数字就直接入栈 这里使用了c语言stoi()函数直接将字符串转换为数字，也可以使用ASCII值转，atoi(string.c_str())123456789101112131415161718192021222324252627282930313233int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; sck; for (auto it : tokens) &#123; if (it == &quot;+&quot;) &#123; int a = sck.top(); sck.pop(); int b = sck.top(); sck.pop(); sck.push(b + a); &#125; else if (it == &quot;-&quot;) &#123; int a = sck.top(); sck.pop(); int b = sck.top(); sck.pop(); sck.push(b - a); &#125; else if (it == &quot;*&quot;)&#123; int a = sck.top(); sck.pop(); int b = sck.top(); sck.pop(); sck.push(a * b); &#125; else if (it == &quot;/&quot;)&#123; int a = sck.top(); sck.pop(); int b = sck.top(); sck.pop(); sck.push(b / a); &#125; else &#123; sck.push(stoi(it)); &#125; &#125; return sck.top();&#125; 字符串解码leetcode给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例12345输入：s = &quot;3[a]2[bc]&quot;输出：&quot;aaabcbc&quot;输入：s = &quot;3[a2[c]]&quot;输出：&quot;accaccacc&quot; 解题思路 一看到[ ] 匹配得题，首先想到使用栈，既有数字又有字母，想到使用两个栈 这类题基本思路就是找到什么时候入栈，什么时候出栈。 同时涉及了遍历数组，提取数字和提取字符串算法 本题的当遍历到’[‘时同时入栈，遍历到’]’时出栈进行操作,strSck.top()可以理解为到当前为止前面已经展开的字符串，cur为刚刚[ ]中合成的字符串。 讲道理此题过于难以理解🐛123456789101112131415161718192021222324252627string decodeString(string s) &#123; string cur = &quot;&quot;; stack&lt;int&gt; numSck; stack&lt;string&gt; strSck; int val = 0; for (int i = 0; s[i] != &#x27;\\0&#x27;; ++i) &#123; if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;) &#123; val = val * 10 + s[i] - &#x27;0&#x27;; &#125; else if (s[i] == &#x27;[&#x27;) &#123; numSck.push(val); strSck.push(cur); val = 0; cur = &quot;&quot;; &#125; else if ((s[i] &gt;= &#x27;a&#x27; &amp;&amp; s[i] &lt;=&#x27;z&#x27;) || (s[i] &gt;= &#x27;A&#x27; &amp;&amp; s[i] &lt;= &#x27;Z&#x27;)) &#123; cur += s[i]; &#125; else if (s[i] == &#x27;]&#x27;) &#123; int cnt = numSck.top(); numSck.pop(); for (int i = 0; i &lt; cnt; ++i) &#123; strSck.top() += cur; &#125; cur = strSck.top(); strSck.pop(); &#125; &#125; return cur;&#125; 克隆图leetcode给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。图中的每个节点都包含它的值 val int 和其邻居的列表vector[Node]。 示例123456789输入：adjList = [[2,4],[1,3],[2,4],[1,3]]输出：[[2,4],[1,3],[2,4],[1,3]]解释：图中有 4 个节点。节点 1 的值是 1，它有两个邻居：节点 2 和 4 。节点 2 的值是 2，它有两个邻居：节点 1 和 3 。节点 3 的值是 3，它有两个邻居：节点 2 和 4 。节点 4 的值是 4，它有两个邻居：节点 1 和 3 。 解题思路 图得遍历有两种深度DFS和广度BFS 深度优先遍历：使用递归同时还需要记录哪些是已经复制过得，函数得意义是复制并返回复制得结点，如果发现该结点已经复制过，直接返回复制得结点 由于是深拷贝，一定需要new，所以该结点没有复制，就new一个新结点，并标记已经拷贝过。 新得结点还需要链接它得邻接点，遍历它得所以邻接点，并继续复制。1234567891011Node* isClone[101];Node* cloneGraph(Node* node) &#123; if (node == NULL) return NULL; if (isClone[node-&gt;val] != NULL) return isClone[node-&gt;val]; Node* newNode = new Node(node-&gt;val); isClone[node-&gt;val] = newNode; for (auto it : node-&gt;neighbors) &#123; newNode-&gt;neighbors.push_back(cloneGraph(it)); &#125; return newNode;&#125; 使用广度优先遍历就必须使用队列 首先先复制第一个结点并加入到队列中，然后进入循环，注意：队列加入得都是原结点不是新创建得结点，因为新结点还没有链接邻接点 对每个出队列得结点广度遍历，即遍历完它得所有邻接点，没有复制过得就新建并加入队列，最后链接新建的结点和邻接点 1234567891011121314151617181920 Node* isClone[101]; Node* cloneGraph(Node* node) &#123; if (!node) return nullptr; queue&lt;Node*&gt; que; Node* newNode = new Node(node-&gt;val); isClone[node-&gt;val] = newNode; que.push(node); while (!que.empty()) &#123;Node* cur = que.front();que.pop();for (Node* e : cur-&gt;neighbors) &#123; if (isClone[e-&gt;val] == NULL) &#123; que.push(e); isClone[e-&gt;val] = new Node(e-&gt;val); &#125; isClone[cur-&gt;val]-&gt;neighbors.push_back(isClone[e-&gt;val]);&#125; &#125; return newNode; &#125; 岛屿数量leetcode给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。 示例12345678输入:[[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],[&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;]]输出: 1 DFS解题思路 把二维表格当作一个图来处理，每个结点的上下左右都是它的邻接点 两个for循环遍历二维数组，当遇到1时开始深度遍历它的邻接点，凡是dfs遍历途中遇到1的都改为0，直到所有相连的1全部改为0，这就算找到了一个岛，后面继续遍历改后的二维数组。12345678910111213141516171819202122int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int cnt = 0; for (int i = 0; i &lt; grid.size(); ++i) &#123; for (int j = 0; j &lt; grid[0].size(); ++j) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; dfs(grid, i, j); cnt++; &#125; &#125; &#125; return cnt;&#125;void dfs(vector&lt;vector&lt;char&gt; &gt;&amp; grid, int x, int y) &#123; int row = grid.szie() - 1; int col = grid[0].szie() - 1; grid[row][col] = &#x27;0&#x27;; if (x &lt; row &amp;&amp; grid[x + 1][y] == &#x27;1&#x27;) dfs(grid, x + 1, y); if (x &gt; 0 &amp;&amp; grid[x - 1][y] == &#x27;1&#x27;) dfs(grid, x - 1, y); if (y &lt; col &amp;&amp; grid[x][y + 1] == &#x27;1&#x27;) dfs(grid, x, y + 1); if (y &gt; 0 &amp;&amp; grid[x][y - 1] == &#x27;1&#x27;) dfs(grid, x, y - 1);&#125; BFS解题 md，超出时间限制找了一个多小时的原因，一个字一个字对比最后才发现，一个= 写成==，日啊。第二次犯这种错误了12345678910111213141516171819202122232425262728293031323334353637383940414243int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; if (grid.empty()) return 0; int row = grid.size(); int col = grid[0].size(); int cnt = 0; queue&lt;pair&lt;int, int&gt; &gt; que; for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; cnt++; grid[i][j] = &#x27;0&#x27;; que.push(pair(i, j)); while (!que.empty()) &#123; pair&lt;int, int&gt; cur = que.front(); que.pop(); int x = cur.first; int y = cur.second; if (x - 1 &gt;= 0 &amp;&amp; grid[x - 1][y] == &#x27;1&#x27;) &#123; grid[x - 1][y] = &#x27;0&#x27;; que.push(pair&lt;int, int&gt;(x - 1, y)); &#125; if (y - 1 &gt;= 0 &amp;&amp; grid[x][y - 1] == &#x27;1&#x27;) &#123; que.push(pair&lt;int, int&gt;(x, y - 1)); grid[x][y - 1] = &#x27;0&#x27;; &#125; if (x + 1 &lt; row &amp;&amp; grid[x + 1][y] == &#x27;1&#x27;) &#123; que.push(pair&lt;int, int&gt;(x + 1, y)); grid[x + 1][y] = &#x27;0&#x27;; &#125; if (x + 1 &lt; row &amp;&amp; grid[x + 1][y] == &#x27;1&#x27;) &#123; que.push(pair&lt;int, int&gt;(x + 1, y)); grid[x + 1][y] = &#x27;0&#x27;; &#125; if (y + 1 &lt; col &amp;&amp; grid[x][y + 1] == &#x27;1&#x27;) &#123; que.push(pair&lt;int, int&gt;(x, y + 1)); grid[x][y + 1] = &#x27;0&#x27;; &#125; &#125; &#125; &#125; &#125; return cnt;&#125; 柱状图中最大的矩形leetcode给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。 示例dd以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 解题思路 暴力解法可以枚举以每个柱形为高度的最大矩形的面积。具体来说就是：依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。 左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标； 右边看一下，看最多能向右延伸多长；找到大于等于当前柱形高度的最右边元素的下标。 以下题解会超时。123456789101112int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; if (heights.empty()) return 0; int res = INT_MIN; for (int i = 0; i &lt; heights.size(); ++i) &#123; int left = i, right = i; while (left &gt; 0 &amp;&amp; heights[left - 1] &gt;= heights[i]) left--; while (right &lt; heights.size() - 1 &amp;&amp; heights[right + 1] &gt;= heights[i]) right++; int len = right - left + 1; res = max(res, heights[i] * len); &#125; return res;&#125; 01矩阵leetcode给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。两个相邻元素间的距离为 1 。 示例1234567890 0 00 1 01 1 1输出:0 0 00 1 01 2 1 解题思路 理解题意比较难，题意要求我们找到每个1离0最近的距离，正常会想到遍历每个1，最每个1进行DFS或者BFS，但是这样就涉及到对上下左右每个分支的距离最短筛选的操作。时间复杂度也会大大增加。 因此我们可以反过来遍历，先遍历找到所有0的结点，他的4个上下左右分支点一定是1，而1的上下左右4个未访问过的分支点一定是2，依次展开。 BFS解法一般都涉及队列的使用：123456789101112131415161718192021222324252627282930313233343536int off[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int row = matrix.size(); int col = matrix[0].size(); // 初始化 bool isVis[row][col]; for (int i = 0; i &lt; row; ++i) &#123; memset(isVis[i], 0, col); &#125; // 入队列的顺序：所有0的位置，所有离0点距离为1的点，所有离0点距离为2的点.... queue&lt;pair&lt;int, int&gt;&gt; que; for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; if (matrix[i][j] == 0) &#123; que.push(&#123;i, j&#125;); isVis[i][j] = true; &#125; &#125; &#125; while (!que.empty()) &#123; int x = que.front().first; int y = que.front().second; que.pop(); for (int i = 0; i &lt; 4; ++i) &#123; int xi = x + off[i][0]; int yi = y + off[i][1]; if (xi &gt;= 0 &amp;&amp; xi &lt; row &amp;&amp; yi &gt;= 0 &amp;&amp; yi &lt; col &amp;&amp; !isVis[xi][yi]) &#123; isVis[xi][yi] = true; matrix[xi][yi] = matrix[x][y] + 1; que.push(&#123;xi, yi&#125;); &#125; &#125; &#125; return matrix;&#125; 设计循环队列leetcode设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。你的实现应该支持如下操作： 1234567MyCircularQueue(k): 构造器，设置队列长度为 k 。Front: 从队首获取元素。如果队列为空，返回 -1 。Rear: 获取队尾元素。如果队列为空，返回 -1 。enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。isEmpty(): 检查循环队列是否为空。isFull(): 检查循环队列是否已满。 解题思路 两个指针，head和tail，注意满队和空队的条件，满队时：tail就在head的前一格，空队时：tail和head都指向-1。 凡涉及到循环，指针移动后都要对size取模才能保证不超过size大小。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MyCircularQueue &#123;private: vector&lt;int&gt; data; int size; int head; int tail;public: MyCircularQueue(int k) &#123; data.resize(k); size = k; head = -1; tail = -1; &#125; bool enQueue(int value) &#123; if (isFull()) return false; if (isEmpty()) head = 0; tail = (tail + 1) % size; data[tail] = value; return true; &#125; bool deQueue() &#123; if (isEmpty()) return false; if (head == tail) &#123; // 只剩一个元素时 head = -1; tail = -1; return true; &#125; head = (head + 1) % size; return true; &#125; int Front() &#123; if (isEmpty()) return -1; return data[head]; &#125; int Rear() &#123; if (isEmpty()) return -1; return data[tail]; &#125; bool isEmpty() &#123; return head == -1; &#125; bool isFull() &#123; return (tail + 1) % size == head; &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"栈","slug":"栈","permalink":"https://www.mingsrc.work/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://www.mingsrc.work/tags/%E9%98%9F%E5%88%97/"}]},{"title":"双指针","slug":"J_LeetCode/LeetCode/双指针","date":"2022-12-27T03:12:54.071Z","updated":"2022-12-27T03:12:54.071Z","comments":true,"path":"posts/91a7e4d1.html","link":"","permalink":"https://www.mingsrc.work/posts/91a7e4d1","excerpt":"🐛双指针🐛转自：🔥【github】 ","text":"🐛双指针🐛转自：🔥【github】 19. 删除链表的倒数第N个节点 75.颜色分类 88.合并两个有序数组 167.两数之和II-输入有序数组 345.反转字符串中的元音字母 524.通过删除字母匹配到字典里最长单词 633.平方数之和 647.回文子串 680.验证回文字符串Ⅱ 5461.仅含1的子串数 删除链表的倒数第N个节点leetcode给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 解题思路 使用快慢指针，让快指针提前先走n+1步，然后双指针再同时让前走，当快指针指到结尾时，慢指针指向要删除结点得前驱 为了让整个链表得删除操作都统一起来，所以加入了头节点dummy,因为删除某个结点得操作需要它得前驱，而第一个结点没有前驱，所以加入头结点会更方便，删除操作与其他结点统一。 链表所谓删除结点，即前一个结点得next指针越过此结点，指向下一结点12345678910111213141516ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* slow = dummy; ListNode* fast = dummy; n++; while (n--) &#123; fast = fast-&gt;next; &#125; while (fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummy-&gt;next;&#125; 颜色分类Leetcode给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 解题思路 一共三个指针，p0一直指向0的后一位，p2一直指向2的前一位，cur是用于遍历的指针。 本题属于荷兰旗帜问题：思想是遇到0就跟p0所指的数交换位置，遇到2就跟p2所指的数交换位置，遇到1就跳过。 注意：遇到2交换完位置后，cur指针不前进，因为要再次判断交换过来的数是0还是1。 注意2：while结束是 cur &lt; p2而不是cur &lt; nums.size() 123456789void sortColors(vector&lt;int&gt;&amp; nums) &#123; int p0 = 0, p2 = nums.size() - 1; int cur = 0; while (cur &lt; p2) &#123; if (nums[cur] == 1) cur++; else if (nums[cur] == 0) swap(nums[p0++], nums[cur++]); else if (nums[cur] == 2) swap(nums[cur],nums[p2--]); &#125;&#125; 合并两个有序数组leetcode给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 解题思路 合并有两种写法：while结束条件不同可分为写在while里和while外。 注意：数组的边界条件,对于链表指针cur = NULL为结束，而数组是i = -1和i = size()为结束。 思路：从后往前插入num1，两个指针分别从后往前遍历两个数组，较大值插入num1中。用&amp;&amp;与作为结束条件 意思是：当两个数组其中一个遍历结束时，结束while循环，所以还需要将另一个数组的剩余部分依次插入nums1。12345678910void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int p1 = m - 1, p2 = n - 1, cur = m + n - 1; while ( p1 &gt;= 0 &amp;&amp; p2 &gt;= 0)&#123; nums1[cur--] = nums1[p1] &gt; nums2[p2] ? nums1[p1--] : nums2[p2--]; &#125; if (p1 &lt; 0) &#123; while (p2 &gt;= 0) nums1[cur--] = nums2[p2--]; &#125; &#125; 用||或作为结束条件 意思是，只要当两个数组全部遍历完后，才结束while循环，所以再循环体内就要考虑其中一个遍历结束后的操作。12345678void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int p1 = m - 1, p2 = n - 1, cur = n + m - 1; while(cur &gt;= 0)&#123; if (p1 &lt; 0) nums1[cur--] = nums2[p2--]; else if (p2 &lt; 0) nums1[cur--] = nums1[p1--]; else nums1[cur--] = nums1[p1] &gt; nums2[p2] ? nums1[p1--] : nums2[p2--]; &#125;&#125; 两数之和II-输入有序数组Leetcode给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 解题思路 双指针相向遍历， 因为是有序数组，所以left指向小的数，right指向大的数，当两指针所指的数之和大于target，就前移right指针缩小大的数，当和小于target，就后移left指针，增大小的数。12345678910111213vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int left = 0, right = numbers.size() - 1; while (left &lt; right) &#123; if (numbers[left] + numbers[right] == target)&#123; return &#123;left + 1, right + 1&#125;; &#125; else if (numbers[left] + numbers[right] &lt; target) &#123; left++; &#125; else if (numbers[left] + numbers[right] &gt; target) &#123; right--; &#125; &#125; return &#123;&#125;;&#125; 反转字符串中的元音字母leetcode编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 解题思路 首尾各一个指针，当都指向元音字母时，交换字符串12345678910111213141516bool isVolew(char ch)&#123; if(ch==&#x27;a&#x27; || ch==&#x27;e&#x27;||ch==&#x27;i&#x27; || ch==&#x27;o&#x27;||ch==&#x27;u&#x27;) return true; if(ch==&#x27;A&#x27; || ch==&#x27;E&#x27;||ch==&#x27;I&#x27; || ch==&#x27;O&#x27;||ch==&#x27;U&#x27;) return true; return false;&#125;string reverseVowels(string s) &#123; int left=0, right=s.size() - 1; while (left &lt; right) &#123; if (!isVolew(s[left])) ++left; if (!isVolew(s[right])) --right; if (isVolew(s[left]) &amp;&amp; isVolew(s[right])) &#123; swap(s[left++], s[right--]); &#125; &#125; return s;&#125; 通过删除字母匹配到字典里最长单词leetcode给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。 示例12345678输入:s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]输出: &quot;apple&quot;输入:s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]输出: &quot;a&quot; 解题思路 核心时判断一个字符串是不是另一个字符串的子序列，注意这里是子序列而不是子串，子序列是指每个字母在母串中的前后顺序不变。 使用双指针判断子序列，2各指针指向两个串，相同字母时指针后移，不同字母时只有母串指针后移，直到结束，看另一个指针是否指向结尾。 根据题意，要寻找最长的，所以一定要有一个变量储存当前最长值，然后不断进行比较。 compare()函数可以根据字典顺序比较，&lt;0表示字典顺序在前12345678910111213141516171819202122string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; string longest = &quot;&quot;; for(int i = 0; i &lt; d.size(); ++i)&#123; if(d[i].size() &lt; longest.size()) continue; if(d[i].size() == longest.size() &amp;&amp; longest.compare(d[i]) &lt; 0) continue; if(isSub(s, d[i])) longest = d[i]; &#125; return longest;&#125;bool isSub(string s,string d)&#123; int i=0, j=0; while(i &lt; s.size() &amp;&amp; j &lt; d.size())&#123; if(s[i] == d[j])&#123; i++; j++; &#125;else&#123; i++; &#125; &#125; return j == d.size();&#125; 平方数之和Leetcode给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 &#x3D; c。 解题思路 a,b可以为0，所以左指针从0开始而不是1，右指针sqrt(c)开始,效率高。 因为a和b可能是同一个数，所以while里的l可以&#x3D;r。 考虑s可能溢出，所以用r使用long型。为什么防止s溢出要将r设置为long型： 问题在于计算过程中溢出了，计算式完全是以int运算来执行的，并且只有在运算完成之后，其结果才被提升为 long，而此时已经太迟：计算已经溢出。 解决方法使计算表达式的其中一个因子明确为long型，这样可以强制表达式中所有的后续计算都用long运算来完成，防止溢出123456789101112131415bool judgeSquareSum(int c) &#123; int left = 0; long right = sqrt(c); while (left &lt;= right) &#123; int sum = left * left + right * right; if (sum &lt; c) &#123; left++; &#125; else if (sum &gt; c) &#123; right--; &#125; else if (sum == c)&#123; return true; &#125; &#125; return false;&#125; 回文子串Leetcode给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。示例123输入: &quot;aaa&quot;输出: 6说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;. 解题思路 双指针应用：中心扩展 回文串特性：对称相同 回文串：奇数个数和偶数个数，因此有两种扩展：当前字符向两边扩展笔记，当前字符和下一个字符向两边扩展比较。123456789101112131415int countSubstrings(string s) &#123; int cnt = 0; for (int i = 0; s[i] != &#x27;\\0&#x27;; ++i)&#123; expand(s, i, i+1, cnt); expand(s, i, i, cnt); &#125; return cnt; &#125; void expand(string s,int left,int right,int&amp; cnt)&#123; while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right])&#123; left--; right++; cnt++; &#125; &#125; 680.验证回文字符串ⅡLeetcode给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 解题思路 传统思路：遍历每个结点，判断剩余结点能否形成回文，时间复杂度O(n^2) 因为回文对称相等，所以从两头开始遍历，当遇到不相同时，再删除其中一个再进行判断 优化：一开始就是从两头遍历的，所以已经遍历过的地方一定是相等，所以在isPalindrome()函数中不用从两头再重复遍历1234567891011121314151617bool validPalindrome(string s) &#123; int left = 0,right = s.size() - 1; while (left &lt; right) &#123; if (s[left] != s[right]) return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1); left++; right--; &#125; return true;&#125;bool isPalindrome(string s,int left,int right)&#123; while (left &lt; right) &#123; if (s[left] != s[right]) return false; left++; right--; &#125; return true;&#125; 仅含 1 的子串数leetcode给你一个二进制字符串 s（仅由 ‘0’ 和 ‘1’ 组成的字符串）。返回所有字符都为 1 的子字符串的数目。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。 示例1234567输入：s = &quot;0110111&quot;输出：9解释：共有 9 个子字符串仅由 &#x27;1&#x27; 组成&quot;1&quot; -&gt; 5 次&quot;11&quot; -&gt; 3 次&quot;111&quot; -&gt; 1 次 解题思路 刚开始想到用双指针，类似于滑动窗口的思想，每次窗口把连续的1框住，计算窗口中最大子串数。 滑动窗口思想，左右指针从0开始，先移动右指针，当右指针达到要求后，再移动左子针，直到左指针也满足一定要求，最后处理中间的字符，处理完继续移动右指针。 这里右指针的要求指向连续1的最后一位，即当right指向1，而right+1指向0,然后开始移动左子针，直到做指针指向第一个1停，至此形成一个窗口，处理结束后记得更新左指针。12345678910111213141516int numSub(string s) &#123; int left = 0, right = 0; long res = 0; while (right + 1 &lt;= s.size()) &#123; if (s[right] == &#x27;1&#x27; &amp;&amp; s[right + 1] == &#x27;0&#x27; || s[right] == &#x27;1&#x27; &amp;&amp; s[right + 1] == &#x27;\\0&#x27;) &#123; while (s[left] == &#x27;0&#x27;) left++; long len = right - left + 1; res += (1 + len ) * len / 2; res %= 1000000007; left = right + 1; &#125; right++; &#125; return res;&#125; 如果仔细发现当中的规律，1个1有1个子串，2个连续的有3个子串，3个连续的1有6个子串，n个连续的1有1 + 2 + 3+...+n)个子串,即连续1每当增加一个1就会多加len(1)个子串。12345678910111213int numSub(string s) &#123; int res = 0, len = 0; for (auto&amp; ch : s) &#123; if (ch == &#x27;1&#x27;) &#123; len++; res += len; res %= 1000000007; &#125; else &#123; len = 0; &#125; &#125; return res;&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"双指针","slug":"双指针","permalink":"https://www.mingsrc.work/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"哈希表","slug":"J_LeetCode/LeetCode/哈希表","date":"2022-12-27T03:12:54.071Z","updated":"2022-12-27T03:12:54.071Z","comments":true,"path":"posts/850f2080.html","link":"","permalink":"https://www.mingsrc.work/posts/850f2080","excerpt":"⚗哈希表⚗转自：🔥【github】 ","text":"⚗哈希表⚗转自：🔥【github】 1.两数之和 205.同构字符串 217.存在重复元素 242.有效的字母异位词 347.前K个高频元素 409.最长回文串 451.根据字符出现频率排序 594.最长和谐子序列 C++哈希表的基本使用 查找元素是否存在1234若有unordered_map&lt;int, int&gt; mp;查找x是否在map中方法1: 若存在 mp.find(x)!=mp.end()；方法2: 若存在 mp.count(x)!=0； 遍历map12345 unordered_map&lt;key,T&gt;::iterator it; (*it).first; (*it).second for(unordered_map&lt;key,T&gt;::iterator iter=mp.begin();iter!=mp.end();iter++) cout&lt;&lt;&quot;key value is&quot;&lt;&lt;iter-&gt;first&lt;&lt;&quot; the mapped value is &quot;&lt;&lt; iter-&gt;second; 用高级for循环时1234567891011121314151617181920212223 for(auto&amp; it : mp)&#123; cout&lt;&lt; it.first &lt;&lt;it.second;&#125;````两数之和 ============= [Leetcode](https://leetcode-cn.com/problems/two-sum/description/)给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍### 解题思路* 一次遍历法* 如果发现满足条件的key值就return它得值出去，没发现就加入map中```cpp vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (hash.find(target - nums[i]) != hash.end()) &#123; return vector&lt;int&gt;&#123;hash[target - nums[i]], i&#125;; &#125; hash[nums[i]] = i; &#125; return &#123;&#125;; &#125; 同构字符串leetcode给定两个字符串 s 和 t，判断它们是否是同构的。如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 解题思路 哈希交叉映射 比如对于tit和pap，对于tit所有的t对应p，所有的i对应a。对于pap所有的p对应t，所有的a对应i 同时遍历两个字符串，就去map中寻找 该字母是否有对应值（映射）， 如果有就去查该映射的值是否与另一个字符串中对应位字母相同，如果不同就不是同构字符串123456789101112bool isIsomorphic(string s, string t) &#123; if (s.size() != t.size()) return false; unordered_map&lt;char, char&gt; shash; unordered_map&lt;char, char&gt; thash; for (int i = 0; s[i] != &#x27;\\0&#x27;; ++i) &#123; if (shash.find(s[i]) != shash.end() &amp;&amp; shash[s[i]] != t[i]) return false; if (thash.find(t[i]) != thash.end() &amp;&amp; thash[t[i]] != s[i]) return false; shash[s[i]] = t[i]; thash[t[i]] = s[i]; &#125; return true;&#125; 存在重复元素 Leetcode给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 解题思路 哈希表建立每个数字出现的频率 大于1说明重复12345678bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; frequence; for(auto it : nums)&#123; if(++frequence[it] &gt; 1) return true; &#125; return false;&#125; 有效的字母异位词leetcode给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 解题思路 对字符串s建立字母的哈希频率表，再遍历t串，对应的字母频率-1，最后遍历哈希表，如果仍有字母频率不为0，说明有多余的字母。1234567891011121314bool isAnagram(string s, string t) &#123; if (s.size() != t.size()) return false; unordered_map&lt;int, int&gt; hash; for (int i = 0; s[i] != &#x27;\\0&#x27;; ++i) &#123; hash[s[i]]++; &#125; for (int i = 0; t[i] != &#x27;\\0&#x27;; ++i) &#123; hash[t[i]]--; &#125; for (auto it : hash) &#123; if (it.second) return false; &#125; return true;&#125; 前K个高频元素leetcode给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 解题思路 建立哈希表统计数字出现频率， 利用隐式转换，把无序hash转换为pair类型方便按照频率多少进行排序 使用SLT的sort()函数进行排序，大小的比较规则cmp函数需要自己写。 将排好序的前k元素输出12345678910111213141516static bool cmp(pair&lt;int, int&gt; v1, pair&lt;int, int&gt; v2)&#123; return v1.second &gt; v2.second;&#125;vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int,int&gt; hash; for (int i = 0; i &lt; nums.size(); ++i) &#123; hash[nums[i]]++; &#125; vector&lt;pair&lt;int, int&gt; &gt; arr(hash.begin(), hash.end()); sort(arr.begin(), arr.end(), cmp); vector&lt;int&gt; res; for(int i = 0; i &lt; k; ++i)&#123; res.push_back(arr[i].first); &#125; return res;&#125; 最长回文串leetcode给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。 解题思路 根据题意，只需求出最长回文串的长度，而不需要找出最长回文串，所以我们只需利用回文串的特性，统计哪些字母出现了偶数次，哪些出现了奇数次，只需计算他们次数即可。 出现偶数次的字母一定是回文串的一部分，奇数次的字母只需-1次也能组成回文串，最后如果组成的回文串长度小于母串，还可以再再中间加一个字母组成回文串。1234567891011int longestPalindrome(string s) &#123; unordered_map&lt;char,int&gt; hash; for (auto it : s) &#123; hash[it]++; &#125; int res = 0; for (auto it : hash) &#123; res += it.second % 2 == 0 ? it.second : it.second - 1; &#125; return res = res &lt; s.size() ? res + 1 : res ;&#125; 根据字符出现频率排序leetcode给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 解题思路 哈希表建立的频率表是无序的，所以需要转换为其他数据结构，再使用排序算法对其排序 可以使用隐式的类型转换为pair&lt;char,int&gt;，再使用STL里面的sort()函数进行排序，sort的好处是可以自定义排序的规则。 sort()函数自定义的排序规则需要写成静态的函数123456789101112131415161718static bool cmp(pair&lt;char, int&gt; a, pair&lt;char, int&gt; b) &#123; return a.second &gt; b.second;&#125;string frequencySort(string s) &#123; unordered_map&lt;char, int&gt;hash; for (auto it : s) &#123; hash[it]++; &#125; vector&lt;pair&lt;char, int&gt; &gt; arr(hash.begin(), hash.end()); sort(arr.begin(), arr.end(), cmp); string res; for (auto it : arr) &#123; while (it.second--) &#123; res.push_back(it.first); &#125; &#125; return res;&#125; 最长和谐子序列 Leetcode 和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。 示例123输入: [1,3,2,2,5,2,3,7]输出: 5原因: 最长的和谐数组是：[3,2,2,2,3]. 解题思路 找最长的长度，一定需要一个数字去记录当前最长值，并不断跟后面的数进行比较 统计数字出现频率，遍历哈希表的每一个key时，找当前key值大1的数也存不存在哈希表中，如果存在就相加与当前的max变量进行比较。12345678910111213int findLHS(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int,int&gt; hash; int longest = 0; for (int it : nums) &#123; hash[it]++; &#125; for (auto it : hash) &#123; if(hash.find(it.first+1) != hash.end())&#123; longest = max(longest, it.second + hash[it.first+1]); &#125; &#125; return longest;&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"哈希","slug":"哈希","permalink":"https://www.mingsrc.work/tags/%E5%93%88%E5%B8%8C/"}]},{"title":"字符串","slug":"J_LeetCode/LeetCode/字符串","date":"2022-12-27T03:12:54.071Z","updated":"2022-12-27T03:12:54.071Z","comments":true,"path":"posts/fc81fbfd.html","link":"","permalink":"https://www.mingsrc.work/posts/fc81fbfd","excerpt":"转自：🔥【github】 ","text":"转自：🔥【github】 ⚡️字符串⚡️ 242.有效的字母异位词 409.最长回文串 205.同构字符串 647.回文子串 9.回文数 696.计数二进制子串 滑动窗口思想(双指针进阶版） 76.最小覆盖子串 有效的字母异位词 Leetcode 示例：12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 哈希表1234567891011121314151617181920 //构建哈希数组，用索引0~26代表a~z bool isAnagram(string s, string t) &#123; if(s.length()!=t.length())return false; //普通数组必须提前分配空间，或者用动态数组 int hashArr[26]=&#123;0&#125;; for(int i=0;i&lt;s.length();++i)&#123; hashArr[s[i]-&#x27;a&#x27;]++; &#125; for(int i=0;i&lt;t.length();++i)&#123; hashArr[t[i]-&#x27;a&#x27;]--; &#125; //判断个数也可用i&lt;26 for(int i=0;i&lt;sizeof(hashArr)/sizeof(hashArr[0]);++i)&#123; if(hashArr[i]!=0)return false; &#125; return true; &#125;&#125;; 最长回文串 Leetcode给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。 1234567891011121314151617181920 //hash表统计字符出现频率 //偶数加入长度 //奇数-1加入长度 //最后回文长度小于字符集长度说明一定有未使用的字符，回文长度再加1 int longestPalindrome(string s) &#123; int longestLength=0; int hash[127]=&#123;0&#125;; for(int i=0;i&lt;s.length();++i)&#123; hash[s[i]]++; &#125; for(int i=0;i&lt;sizeof(hash)/sizeof(hash[0]);++i)&#123; if(hash[i]%2==0)&#123; longestLength+=hash[i]; &#125;else&#123; longestLength+=hash[i]-1; &#125; &#125; return longestLength&lt;s.length()?++longestLength:longestLength; &#125;&#125;; 同构字符串Leetcode 示例：12输入: s = &quot;egg&quot;, t = &quot;add&quot;输出: true 123456789101112131415161718192021222324 //哈希交叉映射 //比如对于tit和pap， //对于tit所有的t对应p，所有的i对应a //对于pap所有的p对应t，所有的a对应i //同时遍历两个字符串，就去map中寻找 该字母是否有对应值（映射）， //如果有就去查该映射的值是否与另一个字符串中对应位字母相同，如果不同就不是同构字符串 bool isIsomorphic(string s, string t) &#123; unordered_map&lt;char,char&gt; sHash; unordered_map&lt;char,char&gt; tHash; for(int i=0;s[i]!=&#x27;\\0&#x27;;++i)&#123; if(sHash.count(s[i]) &amp;&amp; s[i]!=tHash[t[i]])&#123; return false; &#125; else if(tHash.count(t[i]) &amp;&amp; t[i]!=sHash[s[i]])&#123; return false; &#125; else&#123; tHash[t[i]]=s[i]; sHash[s[i]]=t[i]; &#125; &#125; return true; &#125;&#125;; 回文子串Leetcode 中心扩展思想 12345678910111213141516171819 int cnt=0; //回文字符串：奇数个数和偶数个数两种 //所以有两种中心扩展方式，以当前字符为中心、以当前字符和下一个字符为中心向两边拓展 int countSubstrings(string s) &#123; for(int i=0;s[i]!=&#x27;\\0&#x27;;++i)&#123; expandSubString(s,i,i); expandSubString(s,i,i+1); &#125; return cnt; &#125; //中心扩散，回文字符串对称特点，两端相等 void expandSubString(string s,int start,int end)&#123; while(start&gt;=0 &amp;&amp; end&lt;s.length() &amp;&amp; s[start]==s[end])&#123; start--; end++; cnt++; &#125; &#125;&#125;; 回文数Leetcode 用整数实现队列1234567891011121314 //将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等。 bool isPalindrome(int x) &#123; if(x&gt;=0 &amp;&amp; x&lt;10)return true; if(x&lt;0 || x%10==0)return false; //我们将原始数字除以 10，然后给反转后的数字乘上 10 //当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字 int reverse=0; while(reverse&lt;x)&#123; reverse=reverse*10+x%10; x/=10; &#125; return reverse==x || reverse/10==x?true:false; &#125;&#125;; 计数二进制子串 统计二进制字符串中 连续 1 和连续 0 数量相同的子字符 串个数 对于长字符串会超出时间限制示例：123输入: &quot;00110011&quot;输出: 6解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 123输入: &quot;10101&quot;输出: 4解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。 1234567891011121314151617181920212223242526 int cnt=0; //题目含义：字串必须有0，1，子串的的0和1数量相等，且所有0或1是组合在一起，即一边全是0或者1 //使用中心扩展思想，遇到01，或10时进行扩展 int countBinarySubstrings(string s) &#123; //避免数组越界 for(int i=0;i+1&lt;s.length();i++)&#123; if(s[i]!=s[i+1])&#123; //指针跳过中间部分，指向上个子字符串结尾 int next=expandSubString(s,i,i+1)； i=next; &#125; &#125; return cnt; &#125; int expandSubString(string s,int start,int end)&#123; char f=s[start]; char e=s[end]; while(start&gt;=0 &amp;&amp; end&lt;s.length() &amp;&amp; s[start]==f &amp;&amp; s[end]==e)&#123; start--; end++; cnt++; &#125; return end-1-1; &#125;&#125;; 最小覆盖子串leetcode给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串 示例12输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;输出: &quot;BANC&quot; 说明：字符串T可以有重复的字母，S必须全部包含T（意思是不光要包含字母的种类，相同字母的个数也得相等）。 解题思路 子串问题基本上都是滑动窗口思想 滑动窗口思想:在滑动窗口类型的问题中都会有两个指针。一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口 123456789101112131415161718192021222324252627282930313233343536373839string minWindow(string s, string t) &#123; unordered_map&lt;char, int&gt; window, need; for (auto ch : t) &#123; need[ch]++; &#125; int left = 0, right = 0; // 满足的字母种类个数 int valid = 0; // 最小子串的开始索引和长度 int start = 0, minLen = INT_MAX; while (right &lt; s.size()) &#123; char ch = s[right]; right++; if (need.find(ch) != need.end()) &#123; // 查看ch是否属于t window[ch]++; if (window[ch] == need[ch]) &#123; valid++; &#125; &#125; while (valid == need.size()) &#123; // 能进来都表示已经全覆盖了t // 先判断当前是否事最小子串 if (right - left &lt; minLen) &#123; minLen = right - left ; start = left; &#125; ch = s[left]; left++; if (need.find(ch) != need.end()) &#123; if (window[ch] == need[ch]) valid--; window[ch]--; &#125; &#125; &#125; return minLen == INT_MAX ? &quot;&quot; : s.substr(start, minLen);&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"字符串","slug":"字符串","permalink":"https://www.mingsrc.work/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"力扣周赛","slug":"J_LeetCode/LeetCode/力扣周赛","date":"2022-12-27T03:12:54.070Z","updated":"2022-12-27T03:12:54.070Z","comments":true,"path":"posts/f5327a3.html","link":"","permalink":"https://www.mingsrc.work/posts/f5327a3","excerpt":"力扣周赛","text":"力扣周赛 第200场周赛 5475.统计好三元组 5476.找出数组游戏的赢家 5477.排布二进制网格的最少交换次数 5475.统计好三元组leetcode给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量。如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 。 123450 &lt;= i &lt; j &lt; k &lt; arr.length|arr[i] - arr[j]| &lt;= a|arr[j] - arr[k]| &lt;= b|arr[i] - arr[k]| &lt;= c其中 |x| 表示 x 的绝对值。 返回 好三元组的数量 。 解题思路 暴力就完事了,在i &lt; j &lt; k统计满足条件的次数12345678910111213141516int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) &#123; int n = arr.size(); int cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; for (int k = j + 1; k &lt; n; ++k) &#123; if (abs(arr[i] - arr[j]) &lt;= a &amp;&amp; abs(arr[j] - arr[k]) &lt;= b &amp;&amp; abs(arr[i] - arr[k]) &lt;= c) cnt++; &#125; &#125; &#125; return cnt;&#125; 5476.找出数组游戏的赢家leetcode给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。返回赢得比赛的整数。题目数据 保证 游戏存在赢家。 示例：1234输入：arr = [2,1,3,5,4,6,7], k = 2输出：5解释：一起看一下本场游戏每回合的情况：因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。 解题思路 取第一个数为当前值，统计当前值之后有多少个数小于它，如果正好有k个就返回它 一旦后面有一个数大于当前值，就重新更新次数和当前值。123456789101112131415int getWinner(vector&lt;int&gt;&amp; arr, int k) &#123; int num = arr[0]; int cnt = 0; for (int i = 1; i &lt; arr.size(); ++i) &#123; if (num &gt; arr[i]) &#123; cnt++; &#125; else &#123; num = arr[i]; cnt = 1; &#125; if (cnt == k) break; &#125; return num;&#125; 双向队列模拟操作 先判断如果k值过大，可以直接返回数组中的最大值 定义一个记录每个数连胜次数的cnt数组 每次操作先取出队列的第一个数作为当前值，如果此时的队列头部元素小于当前值就pop出push到尾部当前值得连胜记录cnt++,如果满足k就返回当前值 如果队列头部元素大于当前值，就将当前值push到队尾，同时将头部元素的连胜记录更新为1，更新当前元素。1234567891011121314151617181920212223242526int getWinner(vector&lt;int&gt;&amp; arr, int k) &#123; if (k &gt; arr.size()) &#123; sort(arr.begin(), arr.end()); return arr[arr.size() - 1]; &#125; deque&lt;int&gt; que; que.assign(arr.begin(), arr.end()); int cur = que.front(); int* cnt = (int*)malloc(sizeof(int) * 1000000); memset(cnt, 0, sizeof(int) * 1000000); while (1) &#123; que.pop_front(); while (cur &gt; que.front()) &#123; ++cnt[cur]; if (cnt[cur] == k) return cur; que.push_back(que.front()); que.pop_front(); &#125; que.push_back(cur); cnt[que.front()] = 1; cur = que.front(); if (k == 1) return cur; &#125; return -1;&#125; 5477.排布二进制网格的最少交换次数leetcode给你一个 n x n 的二进制网格 grid，每一次操作中，你可以选择网格的 相邻两行 进行交换。一个符合要求的网格需要满足主对角线以上的格子全部都是 0 。请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 -1 。主对角线指的是从 (1, 1) 到 (n, n) 的这些格子。 示例12输入：grid = [[0,0,1],[1,1,0],[1,0,0]]输出：3 解题思路 统计行末尾连续出现0的次数，然后进行排序，从上到下每行至少应该满足col - 1 - i个0 然后使用贪心思想来模拟交换的过程，统计需要交换行的次数 遍历每行，检查当前行末尾0个数是否满足条件，满足就跳过 如果不满足，就从当前行以下找满足条件的行的下标。如果找到了就开始往上交换，顺便统计次数，如果发现遍历到最后一行都没有发现满足条件的就返回-1没有找到。 12345678910111213141516171819202122232425262728293031int minSwaps(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int row = grid.size(); int col = grid[0].size(); int cnt[row]; memset(cnt, 0, sizeof(int) * row); for (int i = 0; i &lt; row; ++i) &#123; for (int j = col - 1; j &gt;= 0; --j) &#123; if (grid[i][j] == 0) &#123; cnt[i]++; &#125;else break; &#125; &#125; // 贪心 + 模拟 int res = 0; for(int i = 0; i &lt; row - 1; ++i) &#123; if(cnt[i] &gt;= col - i - 1) continue; else &#123; int j = i; while (j &lt; row &amp;&amp; cnt[j] &lt; col - i - 1) j++; if(j == row) return -1; while (j &gt; i) &#123; swap(cnt[j], cnt[j - 1]); res++; j--; &#125; &#125; &#125; return res;&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"动态规划","slug":"J_LeetCode/LeetCode/动态规划","date":"2022-12-27T03:12:54.070Z","updated":"2022-12-27T03:12:54.070Z","comments":true,"path":"posts/a80d0031.html","link":"","permalink":"https://www.mingsrc.work/posts/a80d0031","excerpt":"🙈动态规划🙈转自：🔥【github】 ","text":"🙈动态规划🙈转自：🔥【github】 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 198.打家劫舍 213.打家劫舍II 337.打家劫舍III 矩阵 (10%) 120.三角形最小路径和 64.最小路径和 62.不同路径 63.不同路径II 序列(40%) 70.爬楼梯 55.跳跃游戏 45.跳跃游戏II 132.分割回文串II 300.最长上升子序列 139.单词拆分 322.零钱兑换 双序列(40%) 1143.最长公共子序列 72.编辑距离 5.最长回文子串 爬楼梯 Leetcode 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 解题思路 到达第n阶台阶有两种方式，一个是在第n-1个台阶处+1阶或在n-2个台阶处+2阶 建立一个dp数组，记录到达每一层时的所有方法总数 所以到达第n个台阶的方法与到底第n-1和n-2个台阶相关，dp[n]=dp[n-1]+dp[n-2]123456789int climbStairs(int n) &#123; vector&lt;int&gt; dp; for(int i = 0; i &lt;= n; ++i)&#123; if (i == 0) wayNums.push_back(1); else if (i==1) wayNums.push_back(2); else wayNums.push_back(dp[i - 1] + dp[i - 2]); &#125; return dp.back(); &#125; 跳跃游戏leetcode给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 示例123输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 解题思路 动态规划：建立一个bool类型的dp数组用来记录每个格子是否能够到达 当前格子能否到达与它前面的每个格子都有关系，所以需要遍历它前面的所有格子，只要有一个格子本身能够到达且也能够跳到当前格子，则当前格子就能到达。 本体使用动态规划的时间复杂度比较大,主要用于培养动规的思想。 针对力扣提交的用例，在遍历当前格子之前的格子时，从后往前遍历不容易超时。12345678910111213bool canJump(vector&lt;int&gt;&amp; nums) &#123; vector&lt;bool&gt; dp(nums.size(), false); dp[0] = true; for (int i = 1; i &lt; nums.size(); ++i) &#123; for (int j = i - 1; j &gt;= 0; --j) &#123; if (dp[j] == true &amp;&amp; nums[j] &gt;= i - j) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[nums.size()-1];&#125; 跳跃游戏IIleetcode给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。 解题思路 如果要用动规的思想去解决，那么需要建立一个记录达到每个格子的最小跳跃次数的dp数组， 当前格子的最少次数 &#x3D; 它前面所有能到达当前位置的格子的步数最小值 + 1，所以还是要遍历当前格子之前的所以格子，时间复杂度会相当高，超过时间限制。1234567891011121314int jump(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp(nums.size(),0x3f3f3f3f); dp[0] = 0; for (int i = 1; i &lt; nums.size(); ++i) &#123; int less = 0x3f3f3f3f; for (int j = i-1; j &gt;= 0; --j) &#123; if (j + nums[j] &gt;= i) &#123; less = min(less, dp[j] + 1); &#125; &#125; dp[i] = less; &#125; return dp[nums.size()-1]; &#125; 还可以想办法继续优化，例如加上贪心的算法，因为既然有多个格子可以跳跃到当前格子，从最少跳跃次数的角度考虑，我当然希望是离当前格子最远的地方跳跃过来，也就是我们只需要正向遍历到第一个能够跳跃到当前格子的位置就行了。 当然用c++还是会超时间限制，可以用java12345678910int jump(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp(nums.size(),0x3f3f3f3f); dp[0] = 0; for (int i = 1; i &lt; nums.size(); ++i) &#123; int j = 0; while (j &lt; nums.size() &amp;&amp; j + nums[j] &lt; i) j++; dp[i] = dp[j] + 1; &#125; return dp[nums.size()-1];&#125; 分割回文串 IIleetcode给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回符合要求的最少分割次数。 示例123输入: &quot;aab&quot;输出: 1解释: 进行一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。 解题思路 首先建立dp数组，记录每到一个字母，和它前面所组成的字符串，能使每个子串都是回文串最少分割次数。 动态规划的思路就是，找到当前dp[i]的值与dp[i-1]、dp[i-2].....有怎么的联系 对于本题，通过遍历i之前的所有下标j，找到所有能和i组成回文串的j下标，在这么多能和i组成的回文串的j下标中，通过比较找出最少分割数的dp[j],再+1就是当前位置dp[i]的值. 如果一整个串就是一个回文串，那么最小分割数自然为0 下面的代码会超时，主要学习动规的思路，可以通过优化判断回文串isPalindrome()的方法。这里只用了最简单的方式。12345678910111213141516171819202122232425int minCut(string s) &#123; vector&lt;int&gt; dp(s.size(), 0x3f3f3f3f); dp[0] = 0; for (int i = 1; s[i] != &#x27;\\0&#x27;; ++i) &#123; if (isPalindrome(s, 0, i))&#123; dp[i] = 0; continue; &#125; for (int j = i; j &gt;= 0; --j)&#123; if (isPalindrome(s, j, i))&#123; dp[i] = min(dp[i], dp[j-1] + 1); &#125; &#125; &#125; return dp[s.size()-1];&#125;bool isPalindrome(string s, int left, int right) &#123; if(right == left) return true; while (left &lt; right) &#123; if (s[left] != s[right]) return false; left++, right--; &#125; return true;&#125; 打家劫舍Leetcode 计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 在不触动警报装置的情况下，能够偷窃到的最高金额。 解题思路 dp数组储存抢劫每户时的最大抢劫量，dp[i]表示抢到第i个房间时的最大抢劫量 因为不能相邻抢劫，所以如果抢劫了i-1户，就不能抢劫第i户，或者是i-2户再加上当前户i dp[i]=max(dp[i-1],dp[i-2]+nums[i]); dp数组第一个值和第二个值分别为nums[0]和max(nums[0].nums[1]) 12345678910int rob(vector&lt;int&gt;&amp; nums) &#123; if(!nums.size()) return 0; vector&lt;int&gt; dp; for(int i = 0; i &lt; nums.size(); i++)&#123; if (i == 0) dp.push_back(nums[0]); else if (i == 1) dp.push_back(max(nums[0], nums[1])); else dp.push_back(max(dp[i - 1], dp[i - 2] + nums[i])); &#125; return dp.back();&#125; 打家劫舍II 所有的房屋都围成一圈.Leetcode 打劫问题升级版，因为是环形的，所以多了一个限制条件： 如果从第一户开始偷，那么最后一户就不能偷，下标:0~n-2 如果从第二户开始偷，最后一户就可以偷，下标为:1~n-1 环形问题分解为两条子序列，子序列使用动态规划，比较者最大值12345678910111213141516171819int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return 0; if(nums.size() == 1) return nums[0]; return max(rob(nums, 0, nums.size()-2),rob(nums, 1, nums.size()-1));&#125;int rob(vector&lt;int&gt;&amp;nums, int left, int right)&#123; //根据left和right确定开辟dp数组的大小 int cnt = left - right + 1; vector&lt;int&gt; dp; //cur是dp数组的下标，不是nums的下标，cur从0，即dp的第一元素开始 for(int cur = 0; cur &lt; cnt; cur++)&#123; if (cur == 0) dp.push_back(nums[left]); else if (cur ==1) dp.push_back(max(nums[left], nums[left + 1])); else&#123;//max里比的是dp数组里的值，不是nums数组的 dp.push_back(max(dp[cur - 1], dp[cur - 2] + nums[left + cur])); &#125; &#125; return dp.back();&#125; 打家劫舍IIILeetcode在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 暴力递归解题思路 树形动态规划问题 首先要明确相邻的节点不能偷，也就是’爷爷’选择偷，’儿子’就不能偷了，但是’孙子’可以偷 二叉树只有左右两个孩子，1个’爷爷’最多 2 个’儿子’，4 个’孙子’ 4 个’孙子’偷的钱 + ‘爷爷’的钱 VS 两个’儿子’偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数 1234567int rob(TreeNode* root) &#123; if (root = NULL) return 0; int money = root-&gt;val; if(root-&gt;left) money += rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right); if(root-&gt;right) money += rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right); return max(money, rob(root-&gt;left) + rob(root-&gt;right)); &#125; 建立dp缓存的动态规划解题思路 我们发现’爷爷’在计算自己能偷多少钱的时候，同时计算了 4 个’孙子’能偷多少钱，也计算了 2 个’儿子’能偷多少钱。这样在’儿子’当’爷爷’时，就会产生重复计算一遍’孙子’节点 动态规划的关键优化点 ‘重复子问题’ 使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。 由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value,记录每个计算过得结点值123456789101112131415int rob(TreeNode* root) &#123; unordered_map&lt;TreeNode*, int&gt;dp; return rob(root, dp);&#125;int rob(TreeNode* root, unordered_map&lt;TreeNode*, int&gt; dp)&#123; if (root == NULL) return 0; if (dp.count(root) != 0) return dp[root]; int money=root-&gt;val; if (root-&gt;left) money += rob(root-&gt;left-&gt;left, dp) + rob(root-&gt;left-&gt;right, dp); if (root-&gt;right) money += rob(root-&gt;right-&gt;left, dp) + rob(root-&gt;right-&gt;right, dp); int res = max(money,rob(root-&gt;left,dp) + rob(root-&gt;right, dp)); dp[root] = res; return res;&#125; 终极解法 解题思路 上面两种解法用到了’孙子’节点，计算’爷爷’节点能偷的钱还要同时去计算’孙子’节点投的钱 每个节点储存偷或者不偷两种状态得最大值 我们使用一个大小为 2 的数组来表示,下标0存不偷的值，下标1存偷的值 当前节点选择不偷：当前节点能偷到的最大钱数 &#x3D; 左孩子能偷到的钱 + 右孩子能偷到的钱 当前节点选择偷：当前节点能偷到的最大钱数 &#x3D; 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数 自下而上选择后序遍历123456789101112131415int rob(TreeNode* root) &#123; vector&lt;int&gt; res(2); res = postOrder(root); return max(res[0], res[1]);&#125;vector&lt;int&gt; postOrder(TreeNode* root)&#123; if (root == NULL) return &#123;0,0&#125;; vector&lt;int&gt; res(2); vector&lt;int&gt; left = postOrder(root-&gt;left); vector&lt;int&gt; right = postOrder(root-&gt;right); res[0] = max(left[0], left[1]) + max(right[0], right[1]); res[1] = root-&gt;val + left[0] + right[0]; return res;&#125; 三角形最小路径和leetcode给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 示例123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 解题思路 自顶向下，所以每一行的元素都与上一行的元素有关，第一行除外，所以遍历从第二行开始 建立dp数组，dp[i][j]表示到达此此处的最小路径和，dp数组中最后一行的最小值即为所求。 公式：每一项都与他的上一行有关dp[i][j] = min(dp[i-1][j] + dp[i-1][j]) + triangle[i][j] 需要考虑边界，因为时三角形的，例如每一行的第0个元素，他的上一行没有0-1的元素;还有每一行的最后一个第i元素，他的上一行只有i-1这个元素。1234567891011121314int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int len = triangle.size(); vector&lt;vector&lt;int&gt;&gt; dp(len,vector&lt;int&gt;(len,0x3f3f3f3f)); dp[0][0] = triangle[0][0]; for (int i = 1; i &lt; len; ++i) &#123; for (int j = 0; j &lt; triangle[i].size(); ++j) &#123; if (j == 0) dp[i][j] = dp[i-1][j] + triangle[i][j]; else if (j == i) dp[i][j] = dp[i-1][j-1] + triangle[i][j]; else dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]; &#125; &#125; sort(dp[len-1].begin(), dp[len-1].end()); return dp[len-1][0];&#125; 解题思路 自底向上，所以每一个元素都与下一行的元素有关，最后一行除外，所以遍历从倒数第二行开始 公式：dp[i][j] = min(dp[i+i][j], dp[i+1][j]) + triangle[i][j] 因为是三角形，边界的元素在下一行必有相邻的元素存在，所以免去了边界检测。12345678910int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; // 自底向上 // 从倒数第二行开始 for (int i = triangle.size() - 2; i &gt;= 0; --i) &#123; for (int j = 0; j &lt; triangle[i].size(); ++j) &#123; triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]); &#125; &#125; return triangle[0][0];&#125; 最小路径和leetcode给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。 示例12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 解题思路 上一题是三角形，这一题变矩形，首先考虑自左上角到右下角，那么每个元素的最小路径和都与他的上一个元素或者左边的元素有关，但是考虑到边界，第一列和第一行的元素并没有左或者上面的于元素，所以需要单独考虑，同时第一个元素左和上都没有，也需要单独考虑。 剩下的元素公式为：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];1234567891011121314int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int row = grid.size(); int col = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(col, 0x3f3f3f3f)); for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; if (i == 0 &amp;&amp; j &gt; 0) dp[i][j] = dp[i][j-1] + grid[i][j]; else if (j == 0 &amp;&amp; i &gt; 0) dp[i][j] = dp[i-1][j] + grid[i][j]; else if (i == 0 &amp;&amp; j == 0) dp[i][j] = grid[0][0]; else dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]; &#125; &#125; return dp[row-1][col -1];&#125; 解题思路 如果是自右下至左上，对于本题仍然有边界需要考虑，每个元素的最小路径和都与他的右边和下边的值有关，但是对于最后一行和最后一列并没有下或者右边的值，需要单独考虑，最右下角的值右和下都没有，更需要单独考虑 对于其他元素,可以不用建立dp数组的方式实现，取他的右和下最小值相加：grid[i][j] += min(grid[i+1][j], grid[i][j+1]);12345678910111213int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int row = grid.size(); int col = grid[0].size(); for (int i = row-1; i &gt;= 0; --i) &#123; for (int j = col-1; j &gt;= 0; --j) &#123; if (i == row-1 &amp;&amp; j == col-1) continue; else if (i == row-1) grid[i][j] += grid[i][j+1]; else if (j == col-1) grid[i][j] += grid[i+1][j]; else grid[i][j] += min(grid[i+1][j], grid[i][j+1]); &#125; &#125; return grid[0][0];&#125; 不同路径leetcode一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？ 解题思路 此题是上一题最小路径和的简易版,这里就只写了一种自右下至左上的思路 需要一个dp数组来记录到某个格子的所有路径个数，因为是自右下往左上，所以每个格子都可以从他的右边或者下面到达，所以这个格子的路径数就等于他下面和右边格子路径数之和。 大部分格子的公式:dp[i][j] &#x3D; dp[i+1][j] + dp[i][j+1];但是又边界的考虑，例如最后一列和最后一行的格子没有右或者下面的格子，就必须单独考虑。最右下角的格子右边和下面都没有，更需要拎出来单独考虑了。123456789101112int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,0x3f3f3f3f)); for (int i = m-1; i &gt;=0; --i) &#123; for (int j = n-1; j &gt;= 0; --j) &#123; if (i == m-1 &amp;&amp; j == n-1) dp[i][j] = 1; else if (i == m-1) dp[i][j] = dp[i][j+1]; else if (j == n-1) dp[i][j] = dp[i+1][j]; else dp[i][j] = dp[i+1][j] + dp[i][j+1]; &#125; &#125; return dp[0][0];&#125; 不同路径 IIleetcode一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 示例123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 解题思路 此题就体现出了从右下往左上建立dp表的优势，因为障碍物的出现只会影响上面和左边的格子，但是因为遍历的顺序是从右下往左上，所以一定是先遍历到障碍物的格子，之后才会遍历到被它所影响到的格子。 既然是先遍历到障碍物，那直接将其在dp数组中的路径数设为0，对于被他影响的格子就相当于此路不通，不走这个障碍物格子。 其他正常的格子路径还是：dp[i][j] = dp[i+1][j] + dp[i][j+1]; 对于两个边界：最后一列的格子:dp[i][j] = dp[i+1][j];,最后一行的格子dp[i][j] = dp[i][j+1];123456789101112131415int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int row = obstacleGrid.size(); int col = obstacleGrid[0].size(); vector&lt;vector&lt;long&gt;&gt; dp(row,vector&lt;long&gt;(col,0x3f3f3f3f)); for (int i = row-1; i &gt;=0; --i) &#123; for (int j = col-1; j &gt;= 0; --j) &#123; if (obstacleGrid[i][j] == 1) &#123;dp[i][j] = 0; continue;&#125; if (i == row-1 &amp;&amp; j == col-1) dp[i][j] = 1; else if (i == row-1) dp[i][j] = dp[i][j+1]; else if (j == col-1) dp[i][j] = dp[i+1][j]; else dp[i][j] = dp[i+1][j] + dp[i][j+1]; &#125; &#125; return dp[0][0];&#125; 最长上升子序列leetcode给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 解题思路 使用暴力法动态规划：定义dp[i] 为考虑前 i 个元素，必须以第 i个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取为最长上升子序列之中。 所以状态转移方程为: dp[i] = max(dp[j], dp[j-1].......） + 1 其中j表示i之前的所以元素。 因为是升序序列，j在i之前，所以一定nums[j] &lt; nums[i] 才行。 注意返回值不在是dp[nums.size()-1]，而是dp数组中的最大值，因为dp[i]代表的是以nums[i]为序列结尾的最长个数。实际最长的序列不一定是以最后一个数字nums[size()-1]为结尾的。 max_element()在头文件 #include &lt;algorithm&gt; 中，返回的是迭代器，所以输出值的话要在前面加 *,默认是从小到大排列.123456789101112int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; vector&lt;int&gt; dp(nums.size() , 1); for (int i = 1; i &lt; nums.size(); ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[j] &lt; nums[i])&#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; &#125; return *max_element(dp.begin(), dp.end());&#125; 单词拆分leetcode给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。 示例12345678输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 最长公共子序列leetcode给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。 示例123输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3 解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。 解题思路 动规面试题高频题型，最长公共子序列（Longest Common Subsequence，简称 LCS） 对于子序列类型的问题，暴力点就是穷举问题，而动态规划算法做的就是穷举 + 剪枝，所以可以说只要涉及子序列问题，基本上就是动规解决 因为两个字符串就要建立一个dp table来解决，首先明白dp数组的含义是dp[i][j]表示：对于 s1[1..i] 和 s2[1..j]，它们的 LCS 长度是 dp[i][j]。 由于两个字符串有可能其中一个是空串，所以dp数组还需要多加一列和一行，他们的dp[i][j]永远是0，因为是空串，永远不会有lcs。所以之后i和j的遍历时从1开始.szie()结束。 状态转移方程，二维的dp table，每个状态值都是由前面的三个状态影响：dp[i][j] = (dp[i-1][j], dp[i][j-1], dp[i-1][j-1) 还要明白，如果一个字母，两个串都有，那么他一定属于LCS，LCS长度就要+1。 i和j指针所指的如果不相等，那么就取前面两个状态的最大值即可。 超详细原理请参考其他大佬的：动态规划之最长公共子序列123456789101112131415int longestCommonSubsequence(string text1, string text2) &#123; int len1 = text1.size(); int len2 = text2.size(); vector&lt;vector&lt;int&gt; &gt; dp(len1 + 1, vector&lt;int&gt;(len2 + 1, 0)); for (int i = 1; i &lt; len1 + 1; ++i) &#123; for (int j = 1; j &lt; len2 + 1; ++j) &#123; if (text1[i-1] == text2[j-1]) &#123; dp[i][j] = dp[i-1][j-1] + 1; &#125; else &#123; dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[len1][len2];&#125; 编辑距离leetcode给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符删除一个字符替换一个字符 示例1234567输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)rorse -&gt; rose (删除 &#x27;r&#x27;)rose -&gt; ros (删除 &#x27;e&#x27;) 解题思路 参考大佬的解题思路：powcai dp[i][j] 代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数 当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]； 当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 因为我们要将word1变为word2,也就是用删除，增加，替换操作将word1的每个字母变成word2的字母 说明 更容易理解些： dp[i-1][j-1]到dp[i][j]需要进行替换操作，dp[i-1][j]到d[i][j]需要进行删除操作，dp[i][j-1] 到d[i][j]需要进行添加操作。 dp table第一行，是 word1 为空变成 word2 最少步数，就是插入操作 第一列，是 word2 为空，需要的最少步数，就是删除操作 123456789101112131415161718192021int minDistance(string word1, string word2) &#123; int len1 = word1.size(); int len2 = word2.size(); vector&lt;vector&lt;int&gt; &gt; dp(len1 + 1, vector&lt;int&gt;(len2 + 1, 0)); for (int i = 0; i &lt; len1 + 1; ++i) &#123; dp[i][0] = i; &#125; for (int i = 0; i &lt; len2 + 1; ++i) &#123; dp[0][i] = i; &#125; for (int i = 1; i &lt; len1 + 1; ++i) &#123; for (int j = 1; j &lt; len2 + 1; ++j) &#123; if (word1[i-1] == word2[j-1]) &#123; dp[i][j] = dp[i-1][j-1]; &#125; else &#123; dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1; &#125; &#125; &#125; return dp.back().back();&#125; 零钱兑换leetcode给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 解题思路1234567891011int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount + 1, 0x3f3f3f3f); dp[0] = 0; for (int i = 1; i &lt;= amount; ++i) &#123; for (auto coin : coins) &#123; if (i &lt; coin) continue; dp[i] = min(dp[i], dp[i-coin] + 1); &#125; &#125; return dp[amount] == 0x3f3f3f3f ? -1 : dp[amount];&#125; 最长回文子串leetcode给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 解题思路 动态规划，要想知道长度为n的字符串是否是回文，需要先了解长度n-2的字符串是否是回文，同时首尾的字符也必须相等才行。 dp[i][j] = dp[i + 1][j - 1] &amp;&amp; s[i] == s[j] 表示从第i个字符开始到第j个字符结束 判断长得字符串是否回文需要先判断短得字符串是否成立，所以必须从长度 len = 0 开始遍历建立dp数组。 边界条件1，长度为1即len &#x3D; 0时，一个字母一定是回文串，所以为true 边界条件2，长度为2即len &#x3D; 1时，两个字母只有相等时才是true12345678910111213141516171819string longestPalindrome(string s) &#123; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n ,false)); string res; int MAX = INT_MIN; for (int len = 0; len &lt; n; ++len) &#123; for (int i = 0; i + len &lt; n; ++i) &#123; int j = i + len; if (len == 0) dp[i][j] = true; else if (len == 1) dp[i][j] = (s[i] == s[j]); else dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]); if (dp[i][j] &amp;&amp; len + 1 &gt; MAX) &#123; MAX = len + 1; res = s.substr(i, len + 1); &#125; &#125; &#125; return res;&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.mingsrc.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"🎨剑指offer🎨","slug":"J_LeetCode/LeetCode/剑指offer","date":"2022-12-27T03:12:54.069Z","updated":"2022-12-27T03:12:54.070Z","comments":true,"path":"posts/234402f4.html","link":"","permalink":"https://www.mingsrc.work/posts/234402f4","excerpt":"🎨剑指offer🎨","text":"🎨剑指offer🎨 1.数组中重复的数字 2.二维数组中的查找 3.替换空格 4.从尾到头打印链表 5.重建二叉树 6.用两个栈实现队列 7.斐波那契数列 8.青蛙跳台阶问题 9.旋转数组的最小数字 10.矩阵中的路径 11.机器人的运动范围 12.剪绳子 13.剪绳子II 14.二进制中1的个数 15.数值的整数次方 16.打印从1到最大的n位数 17.删除链表的节点 18.调整数组顺序使奇数位于偶数前面 19.链表中倒数第k个节点 20.反转链表 21.合并两个排序的链表 22.树的子结构 23.二叉树的镜像 24.对称的二叉树 25.顺时针打印矩阵 26.包含min函数的栈 27.栈的压入、弹出序列 28.从上到下打印二叉树 29.从上到下打印二叉树II 30.从上到下打印二叉树III 31.二叉搜索树的后序遍历序列 32.二叉树中和为某一值的路径 33.复杂链表的复制 34.二叉搜索树与双向链表 35.序列化二叉树 36.字符串的排列 37.数组中出现次数超过一半的数字 38.最小的k个数 39.连续子数组的最大和 40.连续子数组的最大和 41.1～n整数中1出现的次数 42.把数组排成最小的数 43.把数字翻译成字符串 44.礼物的最大价值 45.最长不含重复字符的子字符串 46.丑数 47.第一个只出现一次的字符 48.两个链表的第一个公共节点 49.在排序数组中查找数字I 50.二叉搜索树的第k大节点 51.0～n-1中缺失的数字 52.二叉树的深度 53.平衡二叉树 54.数组中数字出现的次数 55.数组中数字出现的次数II 56.和为s的两个数字 57.和为s的连续正数序列 58.翻转单词顺序 59.左旋转字符串 60.滑动窗口的最大值 61.队列的最大值 62.n个骰子的点数 63.扑克牌中的顺子 64.圆圈中最后剩下的数字 65.股票的最大利润 66.求1+2+…+n 67.不用加减乘除做加法 68.构建乘积数组 69.把字符串转换成整数 70.二叉搜索树的最近公共祖先 71.二叉树的最近公共祖先 72.数字序列中某一位的数字 数组中重复的数字leetcode 找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 解题思路1 建立哈希表或者数组记录数字出现次数，大于1就返回12345678int cnt[100000];int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0; i &lt; nums.size(); ++i) &#123; cnt[nums[i]]++; if (cnt[nums[i]] &gt; 1) return nums[i]; &#125; return -1;&#125; 解题思路2 先排序，遍历发现前后两个值一样，就是重复的数1234567int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); for (int i = 1; i &lt; nums.size(); ++i) &#123; if (nums[i] == nums[i -1 ]) return nums[i]; &#125; return -1;&#125; 二维数组中的查找leetcode在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 解题思路 一般规律性很强的矩阵，数列，一定要找一个关键位置的数字，作为比较，用这个数字能够完成一部分筛选 例如本题的左下角，因为他是本行的最小值，所以如果target比他还要小，说明target一定不在此行。他又是本列的最大值，如果target比他还要大，那target一定不在这一列。通过这样可以筛选掉一行或者一列。 直到左下角的值等于target时结束。12345678910bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int row = matrix.size() - 1; int col = 0; while (row &gt;= 0 &amp;&amp; col &lt; matrix[0].size()) &#123; if (matrix[row][col] == target) return true; else if (matrix[row][col] &gt; target) row--; else col++; &#125; return false;&#125; 方法二：因为是有序数组，就想到二分查找，每一行都使用二分法找target,但是此方法没有利用列得有序性 1234567891011121314151617181920bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty()) return false; int row = matrix.size(); for (int i = 0; i &lt; row; ++i) &#123; if (find(matrix, i, target)) return true; &#125; return false;&#125;bool find(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int row, int target) &#123; if (matrix[row].empty()) return false; int left = 0, right = matrix[0].size() - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (matrix[row][mid] &lt; target) left = mid + 1; else if (matrix[row][mid] &gt; target) right = mid; else if (matrix[row][mid] == target) return true; &#125; return matrix[row][left] == target;&#125; 替换空格leetcode请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1：12输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 限制：0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000 解题思路 方法1：遍历找到空格，删除空格，插入新字符 123456789string replaceSpace(string s) &#123; for (int i = 0; s[i] != &#x27;\\0&#x27;; ++i) &#123; if (s[i] == &#x27; &#x27;) &#123; s.erase(i, 1); s.insert(i, string(&quot;%20&quot;)); &#125; &#125; return s;&#125; 方法2：使用额外空间，创建空字符，遇到空格就push新字符，非空格push正常字符。 注意 ？a ：b运算符中a和b必须属于同一类型，“%20”是const char*类型，而ch属于char类型，只能用以下形式来写。123456string replaceSpace(string s) &#123; string ans = &quot;&quot;; for (char ch : s) ans = (ch == &#x27; &#x27;) ? ans + &quot;%20&quot; : ans + ch ; return ans;&#125; 123456789101112string replaceSpace(string s) &#123; int len = s.size(); string res; for (int i = 0; i &lt; len; ++i) &#123; if (s[i] == &#x27; &#x27;) &#123; res += &quot;%20&quot;; &#125; else &#123; res += s[i]; &#125; &#125; return res;&#125; 如果面试官要求不能使用额外得空间，实现原地修改，可以先统计空格数量，再原字符串后添加足够长得空间123456789101112131415161718192021string replaceSpace(string s) &#123; int len = s.size(); int cnt = 0; for (int i = 0; i &lt; len; ++i) &#123; if (s[i] == &#x27; &#x27;) cnt++; &#125; s += string(cnt * 2, &#x27; &#x27;); int p1 = s.size() - 1; int p2 = len - 1; while (p2 &gt;= 0) &#123; if (s[p2] == &#x27; &#x27;) &#123; s[p1--] = &#x27;0&#x27;; s[p1--] = &#x27;2&#x27;; s[p1--] = &#x27;%&#x27;; &#125; else &#123; s[p1--] = s[p2]; &#125; p2--; &#125; return s;&#125; 从尾到头打印链表leetcode输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 解题思路 反转一般想到头插法或者栈实现12345678910111213141516vector&lt;int&gt; reversePrint(ListNode* head) &#123; ListNode* pre = NULL; ListNode* cur = head; while (cur != NULL) &#123; ListNode * tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; vector&lt;int&gt; res; while (pre != NULL) &#123; res.push_back(pre-&gt;val); pre = pre-&gt;next; &#125; return res; &#125; 用栈反转12345678910111213vector&lt;int&gt; reversePrint(ListNode* head) &#123; stack&lt;int&gt; sck; while (head) &#123; sck.push(head-&gt;val); head = head-&gt;next; &#125; vector&lt;int&gt; res; while (!sck.empty()) &#123; res.push_back(sck.top()); sck.pop(); &#125; return res;&#125; 最low 的方法是用遍历链表，输出每个结点的值到数组中，然后用reverse()进行反转。 重建二叉树leetcode输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \\9 20 / \\ 15 7 解题思路 新建&#x2F;改变树结构的，在递归函数中一定要新建root结点并给root-&gt;left和root-&gt;right赋值。 用两个指针在树中遍历时：结束条件就是left &gt; right,left=right是最后一个结点或者说叶子节点。 新建树一定是先序遍历，先建立根再建立左右子树，递归函数的参数表示，pre_root根结点再先序列中的索引，in_left中序列中左子树左边界 in_right 中序列中右子树右边界。 根节点都是从先序中找，第一个结点一定是根，根后一个结点一定是左子树的根节点，根后+左子树大小+1就是右子树的根结点。 左子树的大小则通过中序遍历得到，因为在中序列中根节点左边全是左子树的结点。 因为涉及根据值取他得索引，所以事先要建立id映射表idHash。12345678910111213141516171819 unordered_map&lt;int, int&gt; idHash; vector&lt;int&gt; pre; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; pre = preorder; for (int i = 0; i &lt; inorder.size(); ++i) &#123; idHash[inorder[i]] = i; &#125; return buildTree(0, 0, inorder.size() - 1); &#125; TreeNode* buildTree(int pre_root, int in_left, int in_right) &#123; if (in_left &gt; in_right) return NULL; TreeNode* root = new TreeNode(pre[pre_root]); int in_root = idHash[pre[pre_root]]; root-&gt;left = buildTree(pre_root + 1, in_left, in_root - 1);// 左节点个数是：in_root - in_left + 1 经常容易写错 root-&gt;right = buildTree(pre_root + in_root - in_left + 1, in_root + 1, in_right); return root; &#125; 用两个栈实现队列leetcode用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 解题思路 插入时，按正常入栈，但弹出时需要从最先入栈的即栈底开始，所以要用到辅助栈，将栈底元素倒出来到辅助栈的栈顶 只有当辅助栈的元素全部弹空后，再开始新一轮从数据栈往辅助栈倒 两个栈都为空时，才是真的空了。1234567891011121314151617181920stack&lt;int&gt; sck1;stack&lt;int&gt; sck2;CQueue() &#123; &#125; void appendTail(int value) &#123; sck1.push(value);&#125;int deleteHead() &#123; if (sck2.empty() &amp;&amp; sck1.empty()) return -1; if (sck2.empty()) &#123; while (!sck1.empty()) &#123; sck2.push(sck1.top()); sck1.pop(); &#125; &#125; int front = sck2.top(); sck2.pop(); return front;&#125; 斐波那契数列leetcode写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下,斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 解题思路 经典的动规问题，出了前两个元素，其他任意一个元素值都与他的前两个元素相关，所以状态方程为：dp[i] = dp[i -1] + dp[i -2] 注意答案要取模123456789int fib(int n) &#123; int dp[n + 1]; for (int i = 0; i &lt;= n; ++i) &#123; if (i == 0) dp[0] = 0; else if (i == 1) dp[1] = 1; else dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007; &#125; return dp[n];&#125; 如果面试管要求较少的空间，可以只需要三个变量，实时记录当前值，他的前一个值和前二个值，每次遍历都进行一个更新。12345678910int fib(int n) &#123; int first = 0, second = 1; int ans = n == 0 ? 0 : 1; for (int i = 2; i &lt;= n; ++i) &#123; ans = (first + second) % 1000000007; first = second; second = ans; &#125; return ans;&#125; 青蛙跳台阶问题leetcode一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 解题思路 PS:为什么要模1000000007（跟我念，一，八个零，七）,int64位的最大值为2^63-1，用最大值模1000000007的结果求平方，不会在int64中溢出。所以在大数相乘问题中,相乘时两边都对1000000007取模，保存在int64里面不会溢出. 建立dp数组建立跳到当前台阶的方法数，那么对于任意台阶，可以从他前一个台阶或者前两个台阶跳到，状态方程为：’dp[i] &#x3D; dp[i - 1] + dp[i - 2]’ 12345678910int numWays(int n) &#123; int dp[n + 1]; for (int i = 0; i &lt;= n; ++i) &#123; if (i == 0) dp[0] = 1; else if (i == 1) dp[1] = 1; else if (i == 2) dp[2] = 2; else dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007; &#125; return dp[n];&#125; 节省空间的做法：12345678910111213int numWays(int n) &#123; if (n == 0 || n == 1) return 1; if (n == 2) return 2; int first = 1; int second = 2; int res = 0; for (int i = 2; i &lt; n; ++i) &#123; res = (first + second) % 1000000007; first = second; second = res; &#125; return res;&#125; 旋转数组的最小数字leetcode把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 解题思路 典型的二分查找，要查找的数左右两边的特点，他的左边都是大于数组的最后一个数，他的右边都是小于数组最后一个数。 本题的不同之处在于存在重复数字，所以会出现mid所指与right所指之数相等，导致无法判断最小值出现在mid左边还是右边，因此需要删除一个重复值，暴力的缩小范围。right--1234567891011int minArray(vector&lt;int&gt;&amp; nums) &#123; int left = 0; int right = nums.size() - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) left = mid + 1; else if (nums[mid] &lt; nums[right]) right = mid; else if (nums[mid] == nums[right]) right--; &#125; return nums[left];&#125; 暴力法：遍历整个数组，如果发现后面一个数小于前面一个数，说明找到了分界点。 如果没有找到分界点，说明整个数组都是一个数重复，就返回第一个数即可。1234567int minArray(vector&lt;int&gt;&amp; numbers) &#123; for (int i = 0; i + 1 &lt; numbers.size(); ++i) &#123; if (numbers[i] &gt; numbers[i + 1]) return numbers[i + 1]; &#125; return numbers[0];&#125; 矩阵中的路径leetcode请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。[[“a”,”b”,”c”,”e”],[“s”,”f”,”c”,”s”],[“a”,”d”,”e”,”e”]]但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 解题思路 本题第一想到DFS或BFS 使用DFS时应该注意递归结束条件有哪些：坐标越界、已经访问过、递归的深度超过word长度、字符不等于word对应位置的字符。 这里介绍另一种标记已访问过的方法：就是访问时将数组中的数字提取出来，原位置用其他不常用字符代替，因为递归时只访问word中字符，所以访问过的一定不会再访问，递归结束后记得回复原样（不恢复也行）1234567891011121314151617181920212223242526public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; for (int i = 0; i &lt; board.size(); i++) &#123; for (int j = 0; j &lt; board[0].size(); j++) &#123; if (dfs(board, word, i, j, 0)) return true; &#125; &#125; return false; &#125;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; b, string&amp; w, int i, int j, int k) &#123; if (i &gt;= b.size() || i &lt; 0 || j &gt;= b[0].size() || j &lt; 0 || b[i][j] != w[k]) return false; if (k == w.length() - 1) return true; char temp = b[i][j]; b[i][j] = &#x27;/&#x27;; int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; for (int q = 0; q &lt; 4; q ++ ) &#123; int m = i + dx[q], n = j + dy[q]; if (dfs(b, w, m, n, k + 1)) return true; &#125; b[i][j] = temp; return false; &#125; 第二版解题思路，类似此类问题：通过dfs在多条路径中寻找其中一条满足条件的路径。 注意：第一次通过遍历先发现头节点，再根据次节点展开深度递归，记录路径长度或者储存路径信息的变量都要再每次dfs前重新定义。 注意：每次递归完要恢复isVis标志位。只有一种情况不需要恢复就是，只从一个节点开始dfs，只需要找到一条满足的路径即可，不需要回溯。 dfs模板：先判断是否已经访问，再写递归结束的条件，最后只有满足一定条件的子节点才进行dfs。1234567891011121314151617181920212223242526272829303132333435363738int off[4][2] = &#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;vector&lt;vector&lt;bool&gt;&gt; isVis;string word;vector&lt;vector&lt;char&gt;&gt; board;int row;int col;bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; row = board.size(); col = board[0].size(); this-&gt;isVis.resize(row, vector&lt;bool&gt;(col, false)); this-&gt;board = board; this-&gt;word = word; for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; if (board[i][j] == word[0]) &#123; int depth = 0; if(dfs(i, j, depth)) return true; &#125; &#125; &#125; return false;&#125;bool dfs(int x, int y, int depth) &#123; if (isVis[x][y]) return false; isVis[x][y] = true; cout &lt;&lt; board[x][y]; if (depth == word.size() - 1) return true; for (int i = 0; i &lt; 4; ++i) &#123; int m = x + off[i][0]; int n = y + off[i][1]; if (m &lt; row &amp;&amp; m &gt;= 0 &amp;&amp; n &lt; col &amp;&amp; n &gt;= 0 &amp;&amp; board[m][n] == word[depth + 1]) if (dfs(m, n, depth + 1)) return true; &#125; isVis[x][y] = false; return false;&#125; 机器人的运动范围leetcode地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？ 解题思路 此题的难度在于理解上面，并不是暴力的遍历全部结点，判断哪个符合条件，因为题目时运动范围即，所以符合要求的结点都时连接在一起的。 因为数组中的值仅仅为两位数，因此’ x &#x2F; 10 + x %10’就是个位与十位的数位和 这里用了一个二维数组记录访问过的结点，一定要初始化二维数组。 因为本题求得是机器人得运动范围，不是求某一最长得路径，因此再dfs结束后不需要回复isVis数组。1234567891011121314151617181920212223242526272829303132int cnt = 0;int m, n, k;int off[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;bool** isVis;int movingCount(int m, int n, int k) &#123; this-&gt;m = m; this-&gt;n = n; this-&gt;k = k; isVis = new bool*[m]; for (int i = 0; i &lt; m; ++i) &#123; isVis[i] = new bool[n]; memset(isVis[i], 0, n * sizeof(bool)); &#125; dfs(0, 0, isVis); return cnt;&#125;void dfs(int i, int j, bool** isVis) &#123; if (isVis[i][j]) return; isVis[i][j] = true; cnt++; for (int z = 0; z &lt; 4; ++z) &#123; int x = i + off[z][0]; int y = j + off[z][1]; if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp; (x / 10 + x % 10 + y / 10 + y % 10 &lt;= k)) dfs(x, y, isVis); &#125; return;&#125; 剪绳子leetcode给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例1234567输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 解题思路 贪心+暴力解决 要想积最大，每段长度都尽量相等或接近就行，首先想到用平均值avg，如果平均下来有剩余值，就降剩余值再平均前面每个值上，就变avg + 1，所以最终分段完每段的长度不是avg就是avg + 1 设分了m段,那么余数有多少，就有多少个avg + 1,剩下的就是avg pow(int num, int exp);求乘方函数。123456789int cuttingRope(int n) &#123; int res = 0; for (int m = 2; m &lt;=n; ++m) &#123; int avg = n / m; int sum = n % m ? pow(avg, m - n % m) * pow(avg + 1, n % m) : pow(avg, m); res = max(res, sum); &#125; return res;&#125; 剪绳子IIleetcode给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]k[1]…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 解题思路 本题与上一题得区别在于存在大数操作，2 &lt;= n &lt;= 1000 对于本题需要了解数学知识，要想使成绩最大化，就需要将绳子尽可能的多分段，因此每段长度有，1，2，3中长度考虑，1显然不行，2或3中，3更合适，因此此题就变为求3的幂操作。 幂操作因为指数级别的增加，很容易溢出int32甚至int64，所以为了不让溢出，就需要对幂结果求余，采用分割后分别求余。 循环求幂：大数取余满足分配律，(xy)⊙p=[(x⊙p)(y⊙p)]⊙p123456789int cuttingRope(int n) &#123; if (n == 2 || n == 3) return n -1; long res = 1; while (n &gt; 4) &#123; res = res * 3 % 1000000007; n -= 3; &#125; return res * n % 1000000007;&#125; 方法二，用贪心+快速幂指法12345678910111213141516171819int cuttingRope(int n) &#123; if (n == 2 || n == 3) return n - 1; int a = n / 3; int b = n % 3; if (b == 2) return quickPow(3, a) * 2 % 1000000007; else return quickPow(3, a - 1) * (b + 3) % 1000000007; &#125;long quickPow(int x, int n) &#123; long res = 1; long t = x; while (n) &#123; if (n &amp; 1) res = res * t % 1000000007; t = t * t % 1000000007; n /= 2; &#125; return res;&#125; 二进制中1的个数请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 解题思路 三种方法：1、掩码为1，让数子(num &amp; 1) 判断num二进制形式的最后一位是否是1，num &gt;&gt;= 1让num二进制数右移一位，就可以实现逐位判断。 2、方法一通过不断右移num，还可以不断左移掩码1来判断 3、 反转num的最后一位，记录反转次数 反转’n &amp;&#x3D; n -1’12345678int hammingWeight(uint32_t n) &#123; int cnt = 0; while (n) &#123; if (n &amp; 1) cnt++; n &gt;&gt;= 1; &#125; return cnt;&#125; 12345678910int hammingWeight(uint32_t n) &#123; uint32_t mask = 1; int i = 32; int cnt = 0; while (i--) &#123; if (n &amp; mask) cnt++; mask &lt;&lt;= 1; &#125; return cnt;&#125; 12345678int hammingWeight(uint32_t n) &#123; int cnt = 0; while (n) &#123; n &amp;= n - 1; cnt++; &#125; return cnt;&#125; 数值的整数次方leetcode实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 解题思路 如果采用whie(exp–)根据指数个数不断求积的方式计算，对于指数很大的数可能会超时，因此使用快速求幂算法 核心就是通过指数的二进制形式，将指数进行的分解，例如（x^9 指数为9，二进制是:1001, 那么9 = 2^3 + 2^0, 所以x^9 = x^8 * x^1 ) 1234567891011121314double myPow(double x, int n) &#123; if (n == 0) return 1; bool isPositive = true; long t = n; if (t &lt; 0) t = -t, isPositive = false; double res = 1; while (t) &#123; if (t &amp; 1) res *= x; x *= x; t &gt;&gt;= 1; &#125; return isPositive ? res : (1 / res);&#125; 其中用到了用移位t &gt;&gt;= 1, 注意能够使用的前提是t不能是负数（因为负数用的是补码），因此之前现做绝对化处理,但是力扣的用例中使用了n = -2147483648这个数，int的取值范围是-2147483648到2147483647，但-2147483648取绝对值2147483648超出int范围，所以需要long去接他。 可以用除法 n &#x2F;&#x3D; 2来代替，就不会有如上问题,也不同考虑符数问题 12345678910double myPow(double x, int n) &#123; double res = 1; int t = n; while (n) &#123; if (n &amp; 1) res *= x; x *= x; n /= 2; &#125; return t &gt; 0 ? res : 1 / res;&#125; 使用递归思想，易理解,因为只有n在递归中发送变化，因此结束条件只考虑n的情况。 12345678double myPow(double x, int n) &#123; if (n == 0) return 1; if (n == 1) return x; if (n == -1) return 1 / x; double half = myPow(x, n / 2); double mod = myPow(x, n % 2); return half * half * mod;&#125; 打印从1到最大的n位数leetcode输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例12输入: n = 1输出: [1,2,3,4,5,6,7,8,9] 解题思路 此题相对书上的做了简化，因为已经给出返回值是int型，所以用例中不会有大数，就简单很多 关键在于找到最大值，然后遍历打印即可 可以用pow(10, n)来确定最大边界。 我这里提供另一种算法：例如3位数，那么最大值就是999，4位数最大9999。1234567891011vector&lt;int&gt; printNumbers(int n) &#123; int cnt = 0; vector&lt;int&gt; res; while (n--) &#123; cnt = cnt * 10 + 9; &#125; for (int i = 1; i &lt;= cnt; ++i) &#123; res.push_back(i); &#125; return res;&#125; 删除链表的节点leetcode给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。 删除某个结点的前提一定是找到他的前驱和要删除的结点，因此需要两个指针。 改变链表的操作，有可能会删除第一个结点，因此需要一个头节点作为第一个结点的前驱，来统一化操作。12345678910111213ListNode* deleteNode(ListNode* head, int val) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = head; ListNode* pre = dummy; while (cur-&gt;val != val) &#123; cur = cur-&gt;next; pre = pre-&gt;next; &#125; pre-&gt;next = cur-&gt;next; return dummy-&gt;next;&#125; 调整数组顺序使奇数位于偶数前面leetcode输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 解题思路 思路来自于快排的挖坑法，定义两个头尾指针，把最后一个数挖走，然后left指针遍历直到发现一个偶数，就把这个偶数挖走放到最后的坑里，再用right往前遍历，直到发现一个奇数，挖走放到前面那个坑里，直到俩个指针相遇，把坑不上即可。 注意：如果将第一个数挖走，一开始就要从末尾开始遍历，如果挖走最后一个数，就要从左先开始遍历。 1234567891011121314vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return &#123;&#125;; int left = 0; int right = nums.size() - 1; int temp = nums[right]; while (left &lt; right) &#123; while ((nums[left] &amp; 1) == 1 &amp;&amp; left &lt; right) left++; nums[right] = nums[left]; while ((nums[right] &amp; 1) == 0 &amp;&amp; left &lt; right) right--; nums[left] = nums[right]; &#125; nums[left] = temp; return nums;&#125; 改进版,不需要挖坑了，而且只交换一次。 12345678910vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return &#123;&#125;; int left = 0 ,right = nums.size() - 1; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; (nums[right] &amp; 1) == 0) right--; while (left &lt; right &amp;&amp; (nums[left] &amp; 1) == 1) left++; swap(nums[left++], nums[right--]); &#125; return nums;&#125; 链表中倒数第k个节点leetcode输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 解题思路 快慢指针法，让快指针遍历到结尾null时，慢指针正好指向倒数第k个结点。 因为要删出结点必须要前驱，所以添加一个头结点dummy，方便删第一个结点。 注意此题返回的是删除后剩余的链，1234567891011121314ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* fast = dummy; ListNode* slow = dummy; while (k--) &#123; fast = fast-&gt;next; &#125; while (fast) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow;&#125; 反转链表leetcode定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 解题思路 方法1：头插法反转1234567891011ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL; ListNode* cur = head; while (cur) &#123; ListNode* tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre;&#125; 方法2：用栈反转:首先遍历链表，1、把每个结点入栈，2、然后再循环出栈链接到上一个结点，3、更新当前指针。1234567891011121314151617181920ListNode* reverseList(ListNode* head) &#123; if (!head) return NULL; stack&lt;ListNode*&gt; sck; ListNode* cur = head; while (cur) &#123; sck.push(cur); cur = cur-&gt;next; &#125; ListNode* pre = sck.top(); ListNode* curr = sck.top(); sck.pop(); while (!sck.empty()) &#123; curr-&gt;next = sck.top(); sck.pop(); curr = curr-&gt;next; &#125; curr-&gt;next = NULL; return pre;&#125; 合并两个排序的链表leetcode输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路 合并需要三个指针，一个指向l1的p1,指向l2的p2，遍历合并后链表的cur指针,新链表的头指针pre。 同时遍历两个链表，当有一个链表遍历结束时退出循环，将另一个链表剩下的直接接上新链表。 123456789101112131415161718ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* p1 = l1; ListNode* p2 = l2; ListNode* pre = new ListNode(-1); ListNode* cur = pre; while (p1 != NULL &amp;&amp; p2 != NULL) &#123; if (p1-&gt;val &lt;= p2-&gt;val)&#123; cur-&gt;next = p1; p1 = p1-&gt;next; &#125; else &#123; cur-&gt;next = p2; p2 = p2-&gt;next; &#125; cur = cur-&gt;next; &#125; cur-&gt;next = p1 == NULL ? p2 : p1; return pre-&gt;next;&#125; 一样的思路另一种写法，区别在于while循环大判断是||或. 123456789101112131415161718192021222324ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* p1 = l1, p2 = l2; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while (p1 || p2) &#123; if (p1 == NULL) &#123; cur-&gt;next = p2; break; &#125; if (p2 == NULL) &#123; cur-&gt;next = p1; break; &#125; if (p1-&gt;val &lt;= p2-&gt;val) &#123; cur-&gt;next = p1; p1 = p1-&gt;next; &#125; else &#123; cur-&gt;next = p2; p2 = p2-&gt;next; &#125; cur = cur-&gt;next; &#125; return dummy-&gt;next;&#125; 递归思想:先了解函数的意义是合并两个链表并返回合并后的头部节点，其次返回条件，函数的两个参数都会在递归过程中发生变化，因此结束条件有两个，其中一个为null表示其中一条遍历结束，直接返回另一条链表。 123456789101112ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) return l2; if (l2 == NULL) return l1; if (l1-&gt;val &lt;= l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125;&#125; 树的子结构leetcode输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)B是A的子结构， 即 A中有出现和B相同的结构和节点值。 示例123456789101112131415例如:给定的树 A: 3 / \\ 4 5 / \\ 1 2给定的树 B： 4 / 1返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 解题思路 首先需要遍历整个A树每个结点，来跟跟B进行对比，所以需要两个递归，第一个递归用于遍历整个A树，第二个递归用于对比两个树。 第一个递归结束条件，如果A树的结点遍历到结尾null说明还没发现子树，因此返回false，再根据题意空树B == null不属于任何子树 第二个递归判断两个树是否相等或者B是否属于A，当同时遍历两个树的结点，如果有不相等的结点一定不是，结束条件：当(A == NULL &amp;&amp; B == NULL)即两个树同时遍历结束 ，说明A和B完全相等，如果A先结束，说明A属于B，返回false，B先结束说吧B属于A，B是A的子树，返回true12345678910111213bool isSubStructure(TreeNode* A, TreeNode* B) &#123; if (A == NULL || B == NULL) return false; // 空树不算任何子树 if (isEqual(A, B)) return true; return isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B);&#125;bool isEqual(TreeNode* A, TreeNode* B) &#123; if (A == NULL &amp;&amp; B == NULL) return true; // 都刚好遍历完 if (B == NULL) return true; // B遍历到尾部，A下面还有 if (A == NULL) return false; // B还没有遍历完， A下面就没了 if (A-&gt;val != B-&gt;val) return false; return isEqual(A-&gt;left, B-&gt;left) &amp;&amp; isEqual(A-&gt;right, B-&gt;right); &#125; 二叉树的镜像leetcode请完成一个函数，输入一个二叉树，该函数输出它的镜像。 解题思路 对于改变树结构的递归，其中一定有root-&gt;left = 和root-&gt;right = 左右子树重新赋值的操作。 函数意义是返回反转后的根结点。 1234567TreeNode* mirrorTree(TreeNode* root) &#123; if (root == NULL) return NULL; TreeNode* tmp = mirrorTree(root-&gt;left); root-&gt;left = mirrorTree(root-&gt;right); root-&gt;right = tmp; return root;&#125; 能用递归就能用迭代法，对于深度递归一般使用栈，又由于翻转操作，我们需要先得到根节点，才能反转他的左右子树，因此采用栈数据结构的前序遍历的迭代法，先右节点入栈。交换操作也可以使用swap()代替。 1234567891011121314151617TreeNode* mirrorTree(TreeNode* root) &#123; if (!root) return NULL; stack&lt;TreeNode*&gt; sck; sck.push(root); TreeNode* cur = NULL; while (!sck.empty()) &#123; cur = sck.top(); sck.pop(); // swap(cur-&gt;left, cur-&gt;right) TreeNode* tmp = cur-&gt;left; cur-&gt;left = cur-&gt;right; cur-&gt;right = tmp; if (cur-&gt;right) sck.push(cur-&gt;right); if (cur-&gt;left) sck.push(cur-&gt;left); &#125; return root;&#125; 对称的二叉树leetcode请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \\ 2 2 / \\ / \\3 4 4 3 解题思路 一定需要两个指针，一个递归遍历左子树，一个遍历右子树，再进行左右子树交叉结点值的对比，当发现结点不相等时返回false 注意遍历到结尾null时的处理，都是null也属于对称。12345678910bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return isSymmetric(root-&gt;left, root-&gt;right);&#125;bool isSymmetric(TreeNode* left, TreeNode* right) &#123; if (left == NULL &amp;&amp; right == NULL) return true; if (left == NULL || right == NULL || left-&gt;val != right-&gt;val) return false; return isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left) ;&#125; 顺时针打印矩阵leetcode输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 解题思路 定义四个边界，上下左右，每打印一圈四个边界就向里面缩小一个单位，同时为了保证每次打印都是从0下标开始的，所以一行n个元素只打印前n个，一列n个元素也只打印前n个。 循环的结束条件：当上下边界重合，或者左右边界重合时，说明就剩中间一行或者一列或者一个元素三种情况未遍历打印，需要单独考虑。 上下左右边界都重合说明就剩一个元素。1234567891011121314151617181920vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return &#123;&#125;; vector&lt;int&gt; res; int top = 0, bottom = matrix.size() - 1; int left = 0, right = matrix[0].size() - 1; while (left &lt; right &amp;&amp; top &lt; bottom) &#123; for (int i = left; i &lt; right; ++i) res.push_back(matrix[top][i]); for (int i = top; i &lt; bottom; ++i) res.push_back(matrix[i][right]); for (int i = right; i &gt; left; --i) res.push_back(matrix[bottom][i]); for (int i = bottom; i &gt; top; --i) res.push_back(matrix[i][left]); left++, right--; top++, bottom--; &#125; if (left == right)&#123; // 还剩一列 或者一个 for (int i = top; i &lt;= bottom; ++i) res.push_back(matrix[i][left]); &#125; else if (top == bottom) &#123; // 还剩一行 for (int i = left; i &lt;= right; ++i) res.push_back(matrix[top][i]); &#125; return res;&#125; 包含min函数的栈leetcode定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 解题思路 入栈时比较当前元素与最小栈栈顶元素，更小则加入最小栈中。 出栈时需要考虑当前栈顶的元素是不是最小值，如果是，则最小栈也需要弹出，不是则只弹出数据栈栈顶的元素。12345678910111213141516171819202122232425262728293031stack&lt;int&gt; dataSck;stack&lt;int&gt; minSck;MinStack() &#123;&#125;void push(int x) &#123; dataSck.push(x); if (minSck.empty()) &#123; minSck.push(x); &#125; else &#123; if (x &lt;= minSck.top()) minSck.push(x); &#125;&#125;void pop() &#123; if (dataSck.empty()) return; if (dataSck.top() == minSck.top()) &#123; dataSck.pop(); minSck.pop(); &#125; else &#123; dataSck.pop(); &#125;&#125;int top() &#123; return dataSck.top();&#125;int min() &#123; return minSck.top();&#125; 栈的压入、弹出序列leetcode输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 解题思路 根据弹出数组来模拟整个入栈和出栈的操作。 因为入栈的顺序是固定的，因此根据push数组来遍历入栈，但是出栈可能发生再任意一个结点当中，但是一定按照pop数组进行的。 因此只要当入栈的元素即栈顶与pop数组第一个元素相等时，代表这个刚入栈的元素要出栈了，出栈后pop数组也要往后遍历一位。 用while循环是因为模拟连续出栈的操作，因为有可能一次入栈后，出现连续多次出栈操作。 后面只要入栈的元素即栈顶元素与pop数组相等时，就代表该出栈了。 最后如果栈空代表pop数组满足栈的操作。123456789101112bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; stack&lt;int&gt; sck; int j = 0; for (auto num : pushed) &#123; sck.push(num); while (!sck.empty() &amp;&amp; sck.top() == popped[j]) &#123; sck.pop(); j++; &#125; &#125; return sck.empty();&#125; 从上到下打印二叉树leetcode从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 解题思路 典型的层序遍历，使用到了队列,遍历一个结点就把他的子结点加入队列即可。123456789101112131415vector&lt;int&gt; levelOrder(TreeNode* root) &#123; if (root == NULL) return &#123;&#125;; queue&lt;TreeNode*&gt; que; que.push(root); TreeNode* cur = NULL; vector&lt;int&gt; res; while (!que.empty()) &#123; cur = que.front(); que.pop(); res.push_back(cur-&gt;val); if (cur-&gt;left) que.push(cur-&gt;left); if (cur-&gt;right) que.push(cur-&gt;right); &#125; return res;&#125; 队列可以实现先进先出，同样用链表也可以代替队列123456789101112131415vector&lt;int&gt; levelOrder(TreeNode* root) &#123; if (root == NULL) return &#123;&#125;; vector&lt;int&gt; res; list&lt;TreeNode*&gt; List; List.push_back(root); TreeNode* cur = NULL; while (!List.empty()) &#123; cur = List.front(); List.pop_front(); res.push_back(cur-&gt;val); if (cur-&gt;left) List.push_back(cur-&gt;left); if (cur-&gt;right) List.push_back(cur-&gt;right); &#125; return res;&#125; 从上到下打印二叉树IIleetcode从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 1234567891011 3 / \\ 9 20 / \\ 15 7输出：[ [3], [9,20], [15,7]] 解题思路 再上题层序遍历的基础上，多了个按层打印的效果，因此每层都需要一个数组level来记录当前层的所以结点。 只需要知道，每次加入队列的所有结点，即为一层的所有结点。队列的长度就是一层的个数。根据这个个数来遍历一层结点。 1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if (root == NULL) return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; que; que.push(root); TreeNode* cur = NULL; while (!que.empty()) &#123; vector&lt;int&gt; level; int len = que.size(); while (len--) &#123; cur = que.front(); que.pop(); level.push_back(cur-&gt;val); if (cur-&gt;left) que.push(cur-&gt;left); if (cur-&gt;right) que.push(cur-&gt;right); &#125; res.push_back(level); &#125; return res;&#125; DFS递归法.前序遍历总体来看是从左到右的遍历，因此遍历到某个节点时将其插入到对应高度的结果数组中。 因为无法提前知道层高，就需要再遍历的过程中，先判断当前层数在结果数组中是否已经开辟了空间。如果没有就再新建一行数组空间。 12345678910111213vector&lt;vector&lt;int&gt;&gt; res;vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; dfs(root, 0); return res;&#125;void dfs(TreeNode* root, int depth) &#123; if (!root) return; if(depth == res.size()) res.emplace_back(vector&lt;int&gt;()); // 新建一行 res[depth].emplace_back(root-&gt;val); dfs(root-&gt;left, depth + 1); dfs(root-&gt;right, depth + 1);&#125; 从上到下打印二叉树IIIleetcode请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 1234567891011 3 / \\ 9 20 / \\ 15 7输出：[ [3], [20,9], [15,7]] 解题思路 再上体的基础上又多了一个条件，就是对于奇数层和偶数层，他的结点输出循环不同 因此还需要一个变量cnt来记录当前层数，当前为偶数层时，level数组进行反转操作。 123456789101112131415161718192021222324vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if (root == NULL) return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; que; que.push(root); TreeNode* cur = NULL; int layer = 0; while (!que.empty()) &#123; vector&lt;int&gt; level; int len = que.size(); while (len--) &#123; cur = que.front(); que.pop(); level.push_back(cur-&gt;val); if (cur-&gt;left) que.push(cur-&gt;left); if (cur-&gt;right) que.push(cur-&gt;right); &#125; if (layer % 2 != 0) reverse(level.begin(), level.end()); res.push_back(level); layer++; &#125; return res;&#125; dfs递归思想，每层使用list链表的数据结构，这样可以头插法，相当反转一个数组。 最后将链表转为为数组再输出 123456789101112131415161718vector&lt;list&lt;int&gt;&gt; res;vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; dfs(root, 0); ans.resize(res.size()); for (int i = 0; i &lt; res.size(); ++i) for (auto it : res[i]) ans[i].emplace_back(it); return ans;&#125;void dfs(TreeNode* root, int depth) &#123; if (!root) return; if (depth == res.size()) res.emplace_back(list&lt;int&gt;()); if (depth &amp; 1) res[depth].emplace_front(root-&gt;val); else res[depth].emplace_back(root-&gt;val); dfs(root-&gt;left, depth + 1); dfs(root-&gt;right, depth + 1);&#125; 二叉搜索树的后序遍历序列leetcode输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同 示例12345678910 5 / \\ 2 6 / \\ 1 3输入: [1,6,3,2,5]输出: false输入: [1,3,2,6,5]输出: true 解题思路 只要是根据一个序列来判断是否是某个树得某种遍历,一定都需要两个参数left和right,因为要框出左子树和右子树。 因为后序遍历，所以最后一位即right所指一定是这个树得根结点root 找完root结点，还需要找到左子树和右子树得分界点，因为是二叉搜索树，左子树得所有结点值一定小于右子树，利用while遍历序列发现第一个大于root得结点即为右子树得结点，记为mid。 这样一个序列分配完成，right所指为root结点，[left, mid-1] 为左子树结点，[mid, right-1]为右子树 判断：如果右子树中发现一个小于root结点，就不满足二叉搜索树了。12345678910111213141516bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123; int left = 0, right = postorder.size() - 1; return dfs(postorder, left, right);&#125;bool dfs(vector&lt;int&gt;&amp; postorder, int left, int right) &#123; if (left &gt;= right) return true; int root = postorder[right]; int mid = 0; while (postorder[mid] &lt; root) mid++; // mid左为left，&lt; root; mid右为right &gt; root for (int i = mid; i &lt; right; ++i) &#123; if (postorder[i] &lt; root) return false; &#125; return dfs(postorder, left , mid - 1) &amp;&amp; dfs(postorder, mid, right - 1);&#125; 二叉树中和为某一值的路径leetcode输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 示例:给定如下二叉树，以及目标和 sum &#x3D; 22， 12345678910111213 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1返回:[ [5,4,11,2], [5,8,4,5]] 解题思路 通过深度递归,每经过一个结点sum就减去当前结点值，数组path记录路径经过得点，并继续往下递归 当sum减至刚好为0时，且当前结点没有后继，属于叶子结点，说明这是一条路径。加入结果数组中即可。1234567891011121314151617vector&lt;vector&lt;int&gt;&gt; res;vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;int&gt; path; dfs(root, sum, path); return res;&#125;void dfs (TreeNode* root, int sum, vector&lt;int&gt;&amp; path) &#123; if (root == NULL) return; path.push_back(root-&gt;val); sum -= root-&gt;val; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL &amp;&amp; sum == 0) res.push_back(path); dfs(root-&gt;left, sum, path); dfs(root-&gt;right, sum, path); path.pop_back(); return; &#125; 复杂链表的复制leetcode请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 解题思路 因为是深拷贝链表，所以每遍历一个结点就new一个新结点，并赋值 链表得链接，只能链接当前结点与上一个结点，只要遍历过得结点才能链接，不能往后链接，因此需要维护一个last指针，指向当前结点得前驱 由于本题每个结点还有一个随机链接，所以我们需要两个表，第一个表记录原链表得随机指针指向了那个结点得下标。第二表需要记录，新链表每个结点得地址。 链接随机指针时：先查原表当前结点随机指针指得是第几个结点，再根据下标查新表获取新结点地址，再链接。12345678910111213141516171819202122232425262728293031Node* copyRandomList(Node* head) &#123; unordered_map&lt;Node*, int&gt; idx; unordered_map&lt;int, Node*&gt; addr; Node* cur = head; Node* dummy = new Node(-1); Node* pre = dummy; int i = 0; while (cur) &#123; idx[cur] = i; Node* node = new Node(cur-&gt;val); addr[i] = node; pre-&gt;next = node; pre = pre-&gt;next; cur = cur-&gt;next; i++; &#125; pre-&gt;next = NULL; cur = head; Node* curr = dummy-&gt;next; while (cur) &#123; if (cur-&gt;random) curr-&gt;random = addr[idx[cur-&gt;random]]; else curr-&gt;random = NULL; cur = cur-&gt;next; curr = curr-&gt;next; &#125; return dummy-&gt;next;&#125; 二叉搜索树与双向链表leetcode输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 解题思路 链表得链接一定是往前链接，所以需要维护一个指向上一个结点得指针pre 因为是一个搜索树，所以选择中序遍历,就是从小到大排好序得。 当遍历完后，pre指针正好指向最后一个结点，将其与第一个结点进行链接。 注意：用一个全局变量来记录遍历过程中的上一个节点。 注意：root节点不是第一个链表的第一节点，head-&gt;right才是.12345678910111213141516171819Node* pre = NULL; //上一个结点Node* treeToDoublyList(Node* root) &#123; if (!root) return NULL; Node* head = new Node(-1); pre = head; inorder(root); pre-&gt;right = head-&gt;right; head-&gt;right-&gt;left = pre; return head-&gt;right;&#125;void inorder(Node* root) &#123; if (!root) return; inorder(root-&gt;left); pre-&gt;right = root; root-&gt;left = pre; pre = root; inorder(root-&gt;right);&#125; 序列化二叉树leetcode 请实现两个函数，分别用来序列化和反序列化二叉树。 12345678910你可以将以下二叉树： 1 / \\ 2 3 / \\ 4 5序列化为 &quot;[1,2,3,null,null,4,5]&quot; 解题思路 对于根据序列来建树得题一般都不简单。本题属于困难 本题涉及得技巧：层序遍历、数字转字符串、字符串转数字 删除字符串最后一位三种方法： 迭代器：str.erase(str.end() - 1); 提取子串：str.substr(0, str.size() - 1); 数组：str.pop_back(); 数字转字符串；我用的是从个位开始往前添加每位数字，再reverse()反转字符串。效率很低。 本代码写的不好123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104string serialize(TreeNode* root) &#123; if (!root) return &quot;&quot;; queue&lt;TreeNode*&gt; que; que.push(root); TreeNode* cur = NULL; string res; while (!que.empty()) &#123; cur = que.front(); que.pop(); if (cur) &#123; res += toString(cur-&gt;val); res += &#x27;,&#x27;; que.push(cur-&gt;left); que.push(cur-&gt;right); &#125; else &#123; res += &quot;null,&quot;; &#125; &#125; //res.erase(res.end() - 1); // 迭代器/三种用法 //res.substr(0, res.size() - 1); // 子串 res.pop_back(); //cout &lt;&lt; &quot;[&quot; + res + &quot;]&quot;&lt;&lt;endl; return &quot;[&quot; + res + &quot;]&quot;;&#125;string toString(int val) &#123; string res = &quot;&quot;; if (val &lt; 0) &#123; // val &lt; 10 res += &#x27;-&#x27;; res += abs(val) + &#x27;0&#x27;; &#125; else &#123; // val &gt;= 0 while (val) &#123; res += val % 10 + &#x27;0&#x27;; val /= 10; &#125; reverse(res.begin(), res.end()); &#125; return res;&#125;TreeNode* deserialize(string data) &#123; if (data.size() == 0) return NULL; vector&lt;int&gt; data_int; int left = 1; int right = 1; while (left &lt; data.size()) &#123; while (data[right] != &#x27;,&#x27; &amp;&amp; data[right] != &#x27;]&#x27;) right++; int val = toInt(data, left, right - 1); data_int.push_back(val); left = right + 1; right++; &#125; TreeNode* root = new TreeNode(data_int[0]); queue&lt;TreeNode*&gt; que; que.push(root); double start = 0; // 子结点起始坐标 double end = 0; double n = 1; // 层数 TreeNode* cur = NULL; while (!que.empty()) &#123; double cnt = pow(2, n++); start = cnt - 1; end = start + cnt - 1; while (start &lt;= end) &#123; if (start &gt;= data_int.size()) break; cur = que.front(); que.pop(); TreeNode* leftNode = NULL; TreeNode* rightNode = NULL; if (data_int[start] != INT_MIN) leftNode = new TreeNode(data_int[start]); if (data_int[start + 1] != INT_MIN) rightNode = new TreeNode(data_int[start + 1]); if (leftNode) que.push(leftNode); if (rightNode) que.push(rightNode); cur-&gt;right = rightNode; cur-&gt;left = leftNode; start += 2; &#125; &#125; return root;&#125;int toInt(string str, int left, int right) &#123; if (str[left] == &#x27;n&#x27;) return INT_MIN; int res = 0; bool isNeg = false; if (str[left] == &#x27;-&#x27;) left++, isNeg = true; while (left &lt;= right) &#123; res = res * 10 + str[left] - &#x27;0&#x27;; left++; &#125; return isNeg ? -res : res;&#125; 字符串的排列leetcode输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例12输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] 解题思路 回溯递归，从第一个字符开始，其他所有字符都属于他的下一结点，所有需要一个for循环遍历全部，为了防止重复遍历需要一个vis数组，同时还需要一个path记录遍历经过的结果 回溯递归结束后还需去重，2种方法：1、使用集合set 2、排序去重unique 12345678910111213141516171819202122232425262728vector&lt;string&gt; permutation(string s) &#123; vector&lt;string&gt; res; string path; vector&lt;bool&gt; isVis(s.size(), false); dfs(s, path, isVis, res); //unordered_set&lt;string&gt; set(res.begin(), res.end()); //使用集合去重。 //res.assign(set.begin(), set.end()); sort(res.begin(), res.end()); // 排序去重 auto end = unique(res.begin(),res.end()); // 返回最后一位 res.erase(end, res.end()); // 剪掉 return res;&#125;void dfs (string s, string&amp; path, vector&lt;bool&gt;&amp; isVis, vector&lt;string&gt;&amp; res) &#123; if (path.size() == s.size()) &#123; res.push_back(path); return; &#125; // 在所有得选择列表中继续选择 for (int i = 0; i &lt; s.size(); ++i) &#123; if (isVis[i]) continue; isVis[i] = true; path += s[i]; dfs(s, path, isVis, res); isVis[i] = false; path.pop_back(); &#125;&#125; 修改版。12345678910111213141516171819202122232425262728vector&lt;bool&gt; isVis;string s;vector&lt;string&gt; res;vector&lt;string&gt; permutation(string s) &#123; this-&gt;s = s; isVis.resize(s.size(), false); string path; for (int i = 0; i &lt; s.size(); ++i) &#123; dfs(i, path); &#125; unordered_set set(res.begin(), res.end()); res.assign(set.begin(), set.end()); return res;&#125;void dfs(int root, string&amp; path) &#123; if (isVis[root]) return; isVis[root] = true; path += s[root]; if (path.size() == s.size()) &#123; res.push_back(path); &#125; for (int i = 0; i &lt; s.size(); ++i) &#123; dfs(i, path); &#125; isVis[root] = false; path.pop_back();&#125; 数组中出现次数超过一半的数字leetcode数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。 解题思路 哈希表记录次数123456789int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); unordered_map&lt;int, int&gt; cnt; for (auto&amp; num : nums) &#123; cnt[num]++; if (cnt[num] &gt; len / 2) return num; &#125; return -1;&#125; 先排序，因为至少一半都是一个数字，所以中间值一定是他1234int majorityElement(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); return nums[nums.size() / 2];&#125; 摩尔投票法： 有同意和反对票。多数值当作同意票，其他所有值都当做反对票, 正负票正好抵消， 需要一个last值记录上衣结点的数值，用于比较，vato票数一旦为0就重新更新last值。，由于 因为最后一定都是一个数值，所以last保存的就是那个值。123456789101112int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int last = 0, vote = 0; // 记录投票数 for (int i = 0; i &lt; nums.size(); ++i) &#123; if (vote == 0) &#123; // 正负票正好抵消， last = nums[i]; vote++; &#125; else &#123; // 当前票与上一票进行比较，相同就++，不同就抵消了 last == nums[i] ? vote++ : vote--; &#125; &#125; return last; // 最后就剩多数票了&#125; 最小的k个数leetcode输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 解题思路 经典的topK问题 求topK最小就用大顶堆。求topK最大就用小顶堆。 C++用优先队列来实现堆，priority_queue需要三个参数：三个参数：元素类型，容器类型，func类型 小顶堆升序排列，大顶堆降序排列。顶top就是队列第一个元素。 维护大小为k的大顶堆，当堆满时判断，新插入元素只要小于堆顶（即最大值），就入堆，队顶的最大值弹出。 12345678910111213141516171819vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; if (k == 0 || arr.size() == 0) return &#123;&#125;; priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; que; vector&lt;int&gt; res; for (auto&amp; num : arr) &#123; if (que.size() == k) &#123; if (num &lt;= que.top()) que.pop(); else continue; &#125; que.push(num); &#125; while (k--) &#123; res.push_back(que.top()); que.pop(); &#125; return res;&#125; 计数排序解决topK问题 1234567891011121314vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; int cnt[10001]; memset(cnt, 0, sizeof(int) * 10001); for (auto num : arr) &#123; cnt[num]++; &#125; vector&lt;int&gt; res; for (int i = 0; i &lt; 10001; ++i) &#123; while (cnt[i]-- &amp;&amp; res.size() &lt; k) res.push_back(i); if (res.size() == k) break; &#125; return res;&#125; 连续子数组的最大和{leetcode](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。 解题思路 首先想到动态规划 dp[i]代表到当前i位置时，连续的子数组和得最大值。他与dp[i-1]有关，如果dp[i-1]+num[i]更大，那设为dp[i]，但是如果dp[i-1]+nums[i]还没有本身nums[i]大的话说明前面的dp[i-1]还是个负值，产生负影响，所以前面的i-1个子串都该舍弃。 难点在于状态转移方程：因为题意要求必须是连续，所以如果+nums[i]后，还没有本身nums[i]大时，就断开前面得重新开始。1234567891011int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; dp(len); int maxSum = nums[0]; for (int i = 0; i &lt; len; ++i) &#123; if (i == 0) dp[0] = nums[0]; else dp[i] = max(dp[i - 1] + nums[i], nums[i]); maxSum = max(maxSum, dp[i]); &#125; return maxSum;&#125; 如果面试要求空间复杂度O(1)时 该使用一个变量pre来记录dp[i-1] 可以使用技巧：cur += max(pre, 0);来代替if else操作。123456789101112int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int maxSum = nums[0]; int pre = nums[0]; int cur = 0; for (int i = 1; i &lt; nums.size(); i++) &#123; cur = nums[i]; cur += max(pre, 0); pre = cur; maxSum = max(maxSum, cur); &#125; return maxSum;&#125; 正常不用技巧12345678910111213int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int cur = 0; int pre = nums[0]; int MAX = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; cur = nums[i]; cur = max(cur + pre, cur); MAX = max(MAX, cur); pre = cur; &#125; return MAX;&#125; 1～n整数中1出现的次数leetcode输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。 解题思路 正常思路,对每个数循环取余计算1出现的个数，但是会超时。123456789101112131415int countDigitOne(int n) &#123; int res = 0; for (int i = 1; i &lt;= n; ++i) res += count(i); return res;&#125;int count(int num) &#123; int cnt = 0; while (num) &#123; cnt += (num % 10 == 1); num /= 10; &#125; return cnt;&#125; 快速的方法是，直接根据n，统计十进制n中每个位出现1的次数，这样这需遍历n的位数次就能求出结果。 需要找到每位出现次数的规律：对于个位只有09,1只出现1次，十位099会出现10次，百位0~999会出现100次，因此每位出现1的次数与他的位数digit有关 如果当前位是0的话，例如2304的十位出现1的次数为：因为十位数有0~99,十位会出现10次1，而0~99出现的次数又是23次,因此1出现的总次数为：23 * 10 = 230，公式:high * dight 如果当前位是1的话，例如2314，在2304的基础上，在加上 10，11，12，13，14 5 个，即 23 * 10 + 4 + 1 公式:high * digit + low + 1 如果当前位是2的话，例如2324, 在2304的基础上，在加上完整的10的是个数10,12,13,14,15,16,17,18,19即23 * 10 + 10 公式：high + digit + dight 结束条件：cur遍历完所有的位后。 注意更新low cur high digit的先后顺序不能错123456789101112131415int countDigitOne(int n) &#123; int high = n / 10, cur = n % 10, low = 0; long digit = 1; int cnt = 0; while (high || cur) &#123; // 只有同时为0时才结束 if (cur == 0) cnt += high * digit; else if (cur == 1) cnt += high * digit + low + 1; else cnt += (high + 1) * digit; low += cur * digit; cur = high % 10; high /= 10; digit *= 10; &#125; return cnt;&#125; 数字序列中某一位的数字leetcode数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。 解题思路 先确定n所指的数字是几位数，通过循环相减确定所在哪个区间。 再确定n所指的数字是什么，通过起始值加偏移量确定数子 最后确定n所指的位于数字的第几位，通过取余确定 最后为了方便取出数字的第几位，先转换为字符串，取出后再转换为整型。1234567891011int findNthDigit(int n) &#123; long digit = 1, start = 1, cnt = 9; while (n &gt; cnt) &#123; n -= cnt; digit += 1; start *= 10; cnt = digit * start * 9; &#125; int num = start + (n - 1) / digit; // 括号不能省 n-1 是因为从0开始不是从1开始，减去0 return to_string(num)[(n - 1) % digit] - &#x27;0&#x27;;&#125; 把数组排成最小的数leetcode输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 解题思路 本质是一个排序问题，需要设计一定得规则将字串排序并输出 将所有得数字转换为字符串添加到vector数组中，方便使用sort()函数进行排序 [](type parm, type parm)&#123;return ;&#125; 使用lamada表达式建立得匿名函数，作为sort函数得比较cmp函数 比较原则：如意两个数字例如：3和30， 如果拼接得字符串330 &gt; 303，就认为3 &gt; 30 12345678string minNumber(vector&lt;int&gt;&amp; nums) &#123; vector&lt;string&gt; res; for (auto it : nums) res.push_back(to_string(it)); sort(res.begin(), res.end(), [](string str1, string str2)&#123;return str1 + str2 &lt; str2 + str1;&#125;); string ans; for (auto it : res) ans += it; return ans;&#125; python3 join()：用一个字符去拼接一个字符列表 append()：列表得追加 functools.cmp_to_key：将老式得cmp函数转换为关键词函数，（python3取消了cmp函数使用关键字函数）123456789101112class Solution: def minNumber(self, nums: List[int]) -&gt; str: def sort_rule(x, y): a, b = x + y, y + x if a &gt; b: return 1 elif a &lt; b: return -1 else: return 0 strs = [] for num in nums: strs.append(str(num)) strs.sort(key = functools.cmp_to_key(sort_rule)) return &#x27;&#x27;.join(strs) 把数字翻译成字符串leetcode给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 123输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot; 解题思路 首先想到用动态规划的思路，想想每新增加一个字符对方法数量改变所做的贡献。例如1，只有一种翻译方式，而2加入后可以分两种情况，2翻译成b时，是一种，12一起翻译又是一种方式， 注意所谓的贡献指，新增2对方法数量的贡献，新增2之前的方法数是n，新增2后还是n，贡献值为0。 状态转移方程：先判断新增的数字与前一个数字合并，是否在1~26之间，如果是则dp[i] &#x3D; d[i -1] + dp[i - 2],否则还是dp[i-1] 题目中还设置了限制，前导0的情况下不算。即01不属于1~26之间。 12345678910111213141516171819202122232425262728// 判断与前一个数组能否形成一个字母bool helper(int num1, int num2) &#123; if (num1 == 0)return false; return num1 * 10 + num2 &gt;= 0 &amp;&amp; num1 * 10 + num2 &lt;= 25; &#125;// 将一个数，按位填入数组中vector&lt;int&gt; toVector(int num) &#123; vector&lt;int&gt; res; if (num == 0) return &#123;0&#125;; while (num) &#123; res.push_back(num % 10); num /= 10; &#125; reverse(res.begin(), res.end()); return res;&#125;int translateNum(int num) &#123; if (num &lt; 10) return 1; vector&lt;int&gt; nums = toVector(num); vector&lt;int&gt; dp(nums.size()); dp[0] = 1; dp[1] = helper(nums[0], nums[1]) ? 2 : 1; for (int i = 2; i &lt; nums.size(); ++i) dp[i] = helper(nums[i - 1], nums[i]) ? dp[i - 1] + dp[i - 2] : dp[i - 1]; return dp.back();&#125; 改进版：用string替换数组数据结构 12345678910111213141516bool help(string num, int i) &#123; if (num[i - 1] == &#x27;1&#x27; || (num[i - 1] == &#x27;2&#x27; &amp;&amp; num[i] &lt; &#x27;6&#x27;)) return true; return false;&#125;int translateNum(int num) &#123; if (num &lt; 10) return 1; string n = to_string(num); vector&lt;int&gt; dp(n.size()); dp[0] = 1; dp[1] = help(n, 1) ? 2 : 1; for (int i = 2; i &lt; n.size(); ++i) &#123; dp[i] = help(n, i) ? dp[i - 1] + dp[i - 2] : dp[i - 1]; &#125; return dp.back();&#125; 礼物的最大价值leetcode在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例12345678输入: [ [1,3,1], [1,5,1], [4,2,1]]输出: 12解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 解题思路 矩阵的动态规划问题，要求到矩阵中的任意一格的值，都与当前格子上和左格子值有关。因此状态转移方程为：dp[i[j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] 注意边界问题，在第一行和第一列得状态转移方程稍微有所不同，第一个点可以直接跳过比方便遍历123456789101112131415int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int row = grid.size(); int col = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(row, vector&lt;int&gt;(col, 0)); dp[0][0] = grid[0][0]; for (int i = 0; i &lt; row; ++i) &#123; for (int j = 0; j &lt; col; ++j) &#123; if (i == 0 &amp;&amp; j == 0) continue; if (i == 0) dp[0][j] = dp[0][j - 1] + grid[0][j]; else if (j == 0) dp[i][0] = dp[i - 1][0] + grid[i][0]; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; &#125; &#125; return dp[row-1][col-1];&#125; 最长不含重复字符的子字符串leetcode请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 示例1234567输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路 子串指连续的，子序列可以不连续 一看到子串问题大部分都是用滑动窗口思想解决 首先移动右指针，当发现有重复的字符出现时，开始移动左指针，直到没有重复字符出现，记录长度个数。 判断有无重复字母可用map记录当前窗口中每个字符出现频率。 12345678910111213141516int lengthOfLongestSubstring(string s) &#123; int left = 0, right = 0; int n = s.size(); map&lt;char, int&gt; cnt; int res = 0; while (right &lt; n) &#123; while (cnt[s[right]] == 0 &amp;&amp; right &lt; n) &#123; cnt[s[right]]++; res = max(res, right - left + 1); right++; &#125; cnt[s[left]]--; left++; &#125; return res;&#125; 或者使用set来判断是否出现重复数字，记住set的常用操作，emplace(), erase(), find() 12345678910111213141516int lengthOfLongestSubstring(string s) &#123; int left = 0, right = 0; int longest = 0; int n = s.size(); unordered_set&lt;char&gt; ch; while (right &lt; n) &#123; while (ch.find(s[right]) == ch.end() &amp;&amp; right &lt; n ) &#123; longest = max(longest, right - left + 1); ch.emplace(s[right]); right++; &#125; ch.erase(s[left]); // 此处容易写成right 必须在left++前 left++; &#125; return longest;&#125; 丑数leetcode我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 示例123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 解题思路 此题本质上可以看做是合并三个有序序列，因为丑数序列就是合并后去重而已。 因为丑数是前面的丑数乘以2或3或5形成的，因此最终的丑数序列一定是丑数序列 * 2 丑数序列 * 3 丑数序列 * 5合并去重后得到的。 要无重复的合并三个有序序列，每个序列都需要一个指针，比较三指针所指取最小值加入到丑数序列中，最小值的那个指针后移一位 当2个序列指针所指都是最小的。那么这2个序列指针同时后移12345678910111213int nthUglyNumber(int n) &#123; vector&lt;int&gt; ugly(n, 0); int p1 = 0, p2 = 0, p3 = 0; ugly[0] = 1; for (int i = 1; i &lt; n; ++i) &#123; int minVal = min(ugly[p1] * 2, min(ugly[p2] * 3, ugly[p3] * 5)); if (minVal == ugly[p1] * 2) p1++; if (minVal == ugly[p2] * 3) p2++; if (minVal == ugly[p3] * 5) p3++; ugly[i] = minVal; &#125; return ugly.back();&#125; 第一个只出现一次的字符leetcode在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 解题思路 建立哈希表记录所有字符出现次数，第二次在遍历s字符串找到出现次数为1的字母 12345678char firstUniqChar(string s) &#123; unordered_map&lt;char,int&gt; cnt; for (char ch : s) cnt[ch]++; for (auto ch : s) if (cnt[ch] == 1) return ch; return &#x27; &#x27;;&#125; 两个链表的第一个公共节点leetcode输入两个链表，找出它们的第一个公共节点。 解题思路 太浪漫了 两个结点不断的去对方的轨迹中寻找对方的身影，只要二人有交集，就终会相遇❤ 123456789ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* p1 = headA; ListNode* p2 = headB; while (p1 != p2) &#123; p1 = p1 == NULL ? headB : p1-&gt;next; p2 = p2 == NULL ? headA : p2-&gt;next; &#125; return p1 == NULL ? NULL: p1;&#125; 在排序数组中查找数字Ileetcode统计一个数字在排序数组中出现的次数。 解题思路 既然题目中提到了是排序数组就要利用这个条件，主要还是考二分法 因为排好序了，所以目标数字一定都是连续得，只要找到最左边得数字，再往后遍历统计数量即可。 12345678910111213int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) right = mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid; &#125; int cnt = 0; while (left &lt; nums.size() &amp;&amp; nums[left++] == target) cnt++; return cnt;&#125; 0～n-1中缺失的数字leetcode一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 解题思路 排序数组找某个数首先想到二分法，其次找缺失数字两头数组得不同点，加以区分，发现他们与下标得关系不同 左边数字与下标相同，而右边数组与下标不同，通过二分法找到缺失的位置 边界的判断，如果left指针指向最后一个元素，且当前元素与下标是相等的，说明数组中间并没有缺，缺的是最后一位的数字。123456789int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int left = 0, right = nums.size() - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] != mid) right = mid; else left = mid + 1; &#125; return left == nums.size() - 1 &amp;&amp; nums[left] == left ? left + 1 : left;&#125; 二叉搜索树的第k大节点leetcode给定一棵二叉搜索树，请找出其中第k大的节点。 示例1234567输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2输出: 4 解题思路 BST的特点是中序遍历是排好序的，稍作调整，让中序遍历的时候先遍历右子树，最后再遍历左子树，可以实现从大到小的顺序123456789101112131415int res = 0;int cnt = 0;int kthLargest(TreeNode* root, int k) &#123; dfs(root, k); return res;&#125;void dfs(TreeNode* root, int&amp; k) &#123; if (!root) return; dfs(root-&gt;right, k); if (--k == 0) &#123; res = root-&gt;val; return ; &#125; dfs(root-&gt;left, k);&#125; 二叉树的深度leetcode输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 解题思路 因为要求每个节点得高度必须先知道其左右子节点高度信息，所以用后序遍历得到左右子书高度 当前节点得高度为左右子树高度最大值 + 1 为了防止重复计算某个子树节点高度可以使用哈希表对遍历过得节点高度进行储存。计算得时候直接进行取值 123456789101112unordered_map&lt;TreeNode*, int&gt; height;int maxDepth(TreeNode* root) &#123; if (!root) &#123; height[root] = 0; return 0; &#125; int left = maxDepth(root-&gt;left); int right = maxDepth(root-&gt;right); height[root] = max(height[root-&gt;left], height[root-&gt;right]) + 1; return height[root];&#125; 平衡二叉树leetcode输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 解题思路 要判断当前节点是否满足平衡二叉树条件需要先知道左右子树得高度差，因此需要先遍历左右子树，因此使用后序遍历 如果左右子节点有任一不满足，直接返回false 如果当前节点不满足也直接返回false 因为计算节点得高度也是后序遍历，因此可以同时用哈希表记录遍历过得节点高度 1234567891011unordered_map&lt;TreeNode*, int&gt; height;bool isBalanced(TreeNode* root) &#123; if (!root) &#123; height[root] = 0; return true; &#125; if (!isBalanced(root-&gt;left) || !isBalanced(root-&gt;right)) return false; if (abs(height[root-&gt;left] - height[root-&gt;right]) &gt; 1) return false; height[root] = max(height[root-&gt;left], height[root-&gt;right]) + 1; return true;&#125; 数组中数字出现的次数leetcode一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 解题思路 普通思路使用哈希表，但一定不是面试官想要得答案 主要考点还是位运算： ^异或：x ^ x &#x3D; 0; ^异或其他常用用法： i ^ 0 &#x3D; i; i ^ 1 &#x3D; ~i; (i表示某一位) 全部数字进行异或后，凡是出现两次得数都会抵消掉，因此最后剩下得数就是只出现一次得两个数异或。 加入A ^ B &#x3D; C 数组c得二进制形式下，某一个位出现的1一定来自与A或B中的其中一个。通过这一位来区别A和B int mask = A &amp; (-A) 可以得A二进制最右边位的1，用这个数mask来做为掩码。 通过mask掩码与运算，所以数字都区分为两类，一类是有掩码位为1的数，另一类是掩码位为0的数 再次分别异或，最终得到只出现一次的两个数。 1234567891011121314vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for (auto num: nums) sum ^= num; int res1 = 0, res2 = 0; int mask = sum &amp; (-sum); for (auto num : nums) &#123; if (mask &amp; num) res1 ^= num; else res2 ^= num; &#125; return &#123;res1, res2&#125;;&#125; 数组中数字出现的次数IIleetcode在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 解题思路 统计所有数字二进制形式下，各个位1出现的次数和，保存再cnt[32] 出现3次数字的位，1的个数一定是3的倍数，因此对cnt[32]各位进行3的取模运算。 最终再将cnt[32]转换为整型数字，即为所求 1234567891011121314151617int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int cnt[32]; memset(cnt, 0, sizeof(int) * 32); for (auto num : nums) &#123; unsigned int mask = 1; // 每个数都要重新复位一下, 不用无符号会报错 for (int i = 31; i &gt;= 0; --i) &#123; if (num &amp; mask) cnt[i]++; mask &lt;&lt;= 1; &#125; &#125; int res = 0; for (int i = 0; i &lt; 32; ++i) &#123; res &lt;&lt;= 1; // 必须先左移，否则结果最后会多移一位，变成2倍的值 res += cnt[i] % 3; &#125; return res;&#125; 还有一种更为玄学的操作，了解一下即可 12345678int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int once = 0, twice = 0; for (auto num : nums) &#123; once = once ^ num &amp; ~twice; twice = twice ^ num &amp; ~once; &#125; return once;&#125; 和为s的两个数字leetcode输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 解题思路 既然题目中已经给出了增序数列，一般考的就是二分搜索123456789101112131415161718vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (auto num : nums) &#123; int res = qsort(nums, target - num); if (res &gt; 0) return &#123;num , res&#125;; &#125; return &#123;&#125;;&#125;int qsort(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return target; else if (nums[mid] &gt; target) right = mid; else left = mid + 1; &#125; return -1;&#125; 或者两头使用双指针法遍历 123456789vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right =nums.size() - 1; while (left &lt; right) &#123; if (nums[left] + nums[right] &gt; target) right--; else if (nums[left] + nums[right] == target) return &#123;nums[left],nums[right]&#125;; else left++; &#125; return &#123;&#125;;&#125; 和为s的连续正数序列leetcode输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 解题思路 类似与找连续字串的问题，都要想到滑动窗口思想 右指针一直往后移动，知道窗口内的和大于等于target,如果等于target就存入结果中，如果大于就移动左指针。123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123; int left = 1, right = 1; vector&lt;vector&lt;int&gt;&gt; res; while (right &lt; target) &#123; while ((left + right) * (right - left + 1) / 2 &lt; target) &#123; right++; &#125; if ((left + right) * (right - left + 1) / 2 == target) &#123; vector&lt;int&gt; ret; for (int i = left; i &lt;= right; ++i) &#123; ret.push_back(i); &#125; res.push_back(ret); &#125; left++; &#125; return res; &#125; 翻转单词顺序leetcode输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 示例12输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot; 解题思路 反转类型的题，首先想到用栈 遍历字符串，分割字符串并生成字符串模板，字符串入栈。123456789101112131415161718string reverseWords(string s) &#123; stack&lt;string&gt; sck; for (int i = 0; i &lt; s.size(); ++i) &#123; string str; while (i &lt; s.size() &amp;&amp; !isblank(s[i])) &#123; str += s[i]; ++i; &#125; if (!str.empty()) sck.push(str); // 防止空串入栈 &#125; string res = &quot;&quot;; while (!sck.empty()) &#123; res = res + sck.top() + &#x27; &#x27;; sck.pop(); &#125; if(!res.empty()) res.pop_back(); // 防止弹出空字符串 return res;&#125; 左旋转字符串leetcode字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 示例12输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot; 解题思路 因为只是互换位置，字串的长度没有变化，从位置k开始遍历，如果超过len就对len取模，形成从头循环。12345678string reverseLeftWords(string s, int n) &#123; int len = s.size(); string res = &quot;&quot;; for (int i = 0; i &lt; len; ++i) &#123; res += s[(n + i) % len]; &#125; return res;&#125; 偷懒的方式直接使用库函数strstr()提取子串 strstr(int begin, int end) 注意end指最后一位字母的后一位索引。123string reverseLeftWords(string s, int n) &#123; return s.substr(n, s.size()) + s.substr(0, n);&#125; 滑动窗口的最大值leetcode给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 示例12345678910111213输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 解题思路 维护一个单调队列，队列头部一直保存窗口里的最大值，如果窗口右移时，窗口左边界正好丢弃的是最大值，那么单调队列头部出列。 正常窗口右边界加入的数字都要依次与队列队尾部比较，进加入的数更大，就不断让它往前走，保持队列一直是单调递减的。 注意窗口左右边界的运动范围，1 - k &lt; left &lt; n - k + 1 和 0 &lt; right &lt; n 两个指针同时运动。1234567891011121314vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; if (nums.size() == 0 || k == 0) return &#123;&#125;; deque&lt;int&gt; que; vector&lt;int&gt; res; for (int left = 1 - k, right = 0; right &lt; nums.size(); ++left, ++right) &#123; // 删除得元素等于队首元素时，弹出队首 因为left - 1为弹出的元素，所以left指针不能 = 0. if (left &gt; 0 &amp;&amp; que.front() == nums[left - 1]) que.pop_front(); // 保持队列单调递减 while (!que.empty() &amp;&amp; nums[right] &gt; que.back()) que.pop_back(); que.push_back(nums[right]); if (left &gt;= 0) res.push_back(que.front()); // left = 0以后才形成窗口，才有最大值出现。 &#125; return res;&#125; 队列的最大值leetcode请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1 解题思路 维护两个队列，一个存储正常的数据，一个维护当前最大值的队列 单调队列：新加入的数组必须不断与队尾比较，直到找到他合适的位置，队列一直时单调递减的 删除元素时，相等时同时弹出两个队列头部。12345678910111213141516171819202122232425class MaxQueue &#123;public: queue&lt;int&gt; data; deque&lt;int&gt; maxque; MaxQueue() &#123;&#125; int max_value() &#123; if(!maxque.empty()) return maxque.front(); return -1; &#125; void push_back(int value) &#123; while (!maxque.empty() &amp;&amp; value &gt; maxque.back()) maxque.pop_back(); data.push(value); maxque.push_back(value); &#125; int pop_front() &#123; if (data.empty()) return -1; int res = data.front(); if (res == maxque.front()) maxque.pop_front(); data.pop(); return res; &#125;&#125;; n个骰子的点数leetcode把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 示例12输入: 2输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] 解题思路 二维的动态规划问题 首先了解概率问题都是统计次数，最后除以总次数，所以问题转化为，投掷n个骰子，所有点数出现的总次数是6^n，因为每个骰子点数都有6种可能 我们的目的就是 计算出投掷完 n 枚骰子后每个点数出现的次数。 单单看第 n 枚骰子，它的点数可能为 1~6因此投掷完 n 枚骰子后点数 j 出现的次数，可以由投掷完 n-1枚骰子后，对应点数 j-1, j-2, j-3, … , j-6 出现的次数之和转化过来。 状态转移方程：dp[n][j]= dp[n-1][j-1] + dp[n-1][j-2] + dp[n-1][j-3] + dp[n-1][j-4] + dp[n-1][j-5] + dp[n-1][j-6] 边界处理:投掷完 1枚骰子后，它的可能点数分别为 1, 2, 3, … , 6并且每个点数出现的次数都是 11234567891011121314151617181920vector&lt;double&gt; twoSum(int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(6 * n + 1, 0)); for (int i = 1; i &lt;= 6; ++i) dp[1][i] = 1; for (int i = 2; i &lt;= n; ++i) &#123; // i: 投掷i个骰子 for (int j = i; j &lt;= 6 * i ; ++j) &#123; // j: 点数和的范围 for (int k = 1; k &lt;= 6; ++k) &#123; // k: 1~6点数 if (j &gt; k) dp[i][j] += dp[i - 1][j - k]; &#125; &#125; &#125; int total = pow(6, n); vector&lt;double&gt; res; for (int j = n; j &lt;= 6 * n; ++j) &#123; res.push_back(dp[n][j] * 1.0 / total); &#125; return res;&#125; 扑克牌中的顺子leetcode从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 示例12输入: [0,0,1,2,5]输出: True 解题思路 因为0代表所有牌，所以只要找到数组中不连续的牌，看他们之间能允许插入几张牌才能使他们连续，最后与0牌的数量进行比较即可 先递增排序，0会出现在前面，统计0出现的次数 因为是递增排序，所以当前数字与后面的数字差大于1说明出现了不连续，如果需要插入0的个数大于已有的0个数，说明不能组成顺子 off等于0说明重复数字，不算顺子 off代表前后的偏差123456789101112131415bool isStraight(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int cnt = 0; int off = 0; for (int i = 0; i &lt; nums.size() - 1; ++i) &#123; if (nums[i] == 0) &#123; cnt++; continue; &#125; off = abs(nums[i] - nums[i + 1]); if (off == 1) continue; if (off == 0 || off - 1 &gt; cnt ) return false; &#125; return true;&#125; 圆圈中最后剩下的数字leetcode0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例12输入: n = 5, m = 3输出: 3 解题思路 普通人思路：通过新建一个链表来模拟操作，但是对于大数会出现超时 模拟一个循环链表,n个数字，需要删除n - 1次 注意list的erase删除操作，参数必须是迭代器，返回值也是迭代器，而且是删除元素后一个位置的迭代器。 移动迭代器只能通过++自增操作。12345678910111213141516int lastRemaining(int n, int m) &#123; list&lt;int&gt; myList; for (int i = 0; i &lt; n; ++i) myList.push_back(i); n--; auto it = myList.begin(); while (n--) &#123; for (int i = 0; i &lt; m - 1; ++i) &#123; it++; if (it == myList.end()) it = myList.begin(); &#125; it = myList.erase(it); if (it == myList.end()) it = myList.begin(); &#125; return myList.front();&#125; 股票的最大利润leetcode假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 示例1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 解题思路 动态规划问题，建立dp数组，则dp[i]代表前i天能获得的最大利润，结果返回dp[n-1] dp[i] 的值与前一天的最大利润dp[i-1]有关，如果前一天的利润比当天卖掉股票的最大利润还要大，那就继续用前一天的利润。 如果当天卖股票，就需要知道前面i天当中的最小值，所以可以边遍历边记录最小值。1234567891011int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if (n == 0) return 0; vector&lt;int&gt; dp(n); int minVal = prices[0]; for (int i = 1; i &lt; n; ++i) &#123; minVal = min(minVal, prices[i]); dp[i] = max(dp[i -1], prices[i] - minVal); &#125; return dp.back();&#125; 求1+2+…+nleetcode求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 解题思路 高斯就和法需要用到四则运算,也可以这样抖个机灵。1return (int)(pow(n, 2) + n) &gt;&gt; 1; 迭代法需要用到循环操作12for (int i = 0; i &lt;= n; ++i) res += i; 只能用递归法，不过递归一般需要if()来结束跳出递归， 可以使用逻辑运算符的特性，&amp;&amp;的短路效果来代替跳出操作。也因此&amp;&amp; ||这种运算符无法重载 当n = 1的时候，对于&amp;&amp;运算已经判断为false，就不会执行后面的语句，因此直接return n; 此时n=11234int sumNums(int n) &#123; n &gt; 1 &amp;&amp; (n += sumNums(n - 1)); return n; &#125; 不用加减乘除做加法leetcode写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。 解题思路 此题主要想考的是二进制形式下的加法运算，一般会用到位运算符 先从一个位考虑123456不考虑进位时：0 + 0 = 00 + 1 = 11 + 0 = 11 + 1 = 0正好是异或运算 123456只考虑进位c00 + 00 = 00 c = 001 + 00 = 01 c = 000 + 01 = 01 c = 001 + 01 = 10 c = 1 正好是&amp;运算，但是需要左移一位 所以两个数之和a + b 就转换位二进制形式下的s + c , s代表a ^ b,c代表a &amp; b &lt;&lt; 1 但是由于题目要求不能使用加号，所以s + c 通过继续循环的方式相加，把s赋值给a,c赋值给b，继续循环计算a + b,直到第二个加数为0结束。 注意c++里，左移不能作用在负数，因此左移前需要格式转换为无符号类型。 &lt;&lt; 的优先级高于 &amp;记得加括号。12345678int add(int a, int b) &#123; while (b != 0) &#123; int c = (unsigned int)(a &amp; b) &lt;&lt; 1; a ^= b; b = c; &#125; return a;&#125; 构建乘积数组leetcode给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]&#x3D;A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 示例12输入: [1,2,3,4,5]输出: [120,60,40,30,24] 解题思路 本质上是一道动态规划，维护两个dp数组 B数组中的每第i数都是由A数组中A[i]左边的所有数之积和A[i]右边的所有数之积相乘得到的。 因此一个dp数组用来记录i以左的乘积，另一个记录i以右的乘积 状态转移方程分别为leftDP[i] = leftDP[i - 1] * a[i - 1]和rightDP[i] = rightDP[i + 1] * a[i + 1] 注意边界：左边从第二个数字开始建立dp，右边从倒数第二个数字开始建立dp。123456789101112131415161718192021vector&lt;int&gt; constructArr(vector&lt;int&gt;&amp; a) &#123; int n = a.size(); if (n == 0) return &#123;&#125;; vector&lt;int&gt; leftDP(n, 0); vector&lt;int&gt; rightDP(n, 0); leftDP[0] = 1; for (int i = 1; i &lt; n; ++i) &#123; leftDP[i] = leftDP[i - 1] * a[i - 1]; &#125; rightDP[n - 1] = 1; for (int i = n - 2; i &gt;= 0; --i) &#123; rightDP[i] = rightDP[i + 1] * a[i + 1]; &#125; vector&lt;int&gt; res(n, 0); for (int i = 0; i &lt; n; ++i) &#123; res[i] = leftDP[i] * rightDP[i]; &#125; return res;&#125; 把字符串转换成整数leetcode写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例112输入: &quot;42&quot;输出: 42 示例21234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 示例3:123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。 示例4:1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。 因此无法执行有效的转换。 ###示例5: 1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解题思路 用一个指针i从头到尾遍历 忽略空格，遍历到第一个非空格字符为止，判断+-正负号, 继续往后遍历，如果是数字字符就进行转换，如果不是数字就停止转换将之前的转换的结果输出。 注意1：输出数字之前都要先判断正负，再输出。 注意2：如果不允许使用long只能用int作为转换数字的容器时，需要在 res * 10之前先判断当前res是否已经大于INT_MAX / 10,或者当前res已经等于INT_MAX / 10,但是最右边新加入的位大于7说明这个字符已经超过了32位整数的最大值，需要直接输出INT_MAX。12345678910111213141516171819202122232425int strToInt(string str) &#123; if(str.empty()) return 0; int i = 0; // 跳过空格 while(str[i] == &#x27; &#x27;) i++; // 判断符号 bool isNeg = false; if (str[i] == &#x27;-&#x27;) &#123; isNeg = true; i++; &#125; else if(str[i] == &#x27;+&#x27;) i++; // 转换数字 int res = 0; while(i &lt; str.size()) &#123; if (str[i] &gt;= &#x27;0&#x27; &amp;&amp; str[i] &lt;= &#x27;9&#x27;) &#123; if (res &gt; INT_MAX / 10 || (res == INT_MAX / 10 &amp;&amp; str[i] &gt; &#x27;7&#x27;)) return isNeg == true ? INT_MIN : INT_MAX; // 数字边界处理 res = res * 10 + (str[i] - &#x27;0&#x27;); // 括号不能省，因为可能会溢出 &#125; else return isNeg == true ? -res : res; // 不是数字直接返回前面转换得数字结果 i++; &#125; return isNeg == true ? -res : res;&#125; 如果用能用long，比较麻烦，因为res可以超过int的界限，所以再返回答案之前都需要先判断res是否越界。12345678910111213....前面都一样 long res = 0; for (; i &lt; str.size(); ++i) &#123; if (res &gt; INT_MAX || res &lt; INT_MIN) return isNeg ? INT_MIN : INT_MAX; if (str[i] &gt;= &#x27;0&#x27; &amp;&amp; str[i] &lt;= &#x27;9&#x27;) &#123; res = res * 10 + (str[i] - &#x27;0&#x27;); continue; &#125; return isNeg ? -res : res; &#125; if (res &gt; INT_MAX || res &lt; INT_MIN) return isNeg ? INT_MIN : INT_MAX; return isNeg ? -res : res; &#125; 二叉搜索树的最近公共祖先leetcode给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5] 示例123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 解题思路 根据BST特性，当前值大于qp，说明p，q都在左子树，就往左子树继续递归，当前值小于qp，说明p，q都在右子树。 p，q各在一边，说明当前的根就是最近共同祖先。123456TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == NULL) return NULL; if (root-&gt;val &gt; q-&gt;val &amp;&amp; root-&gt;val &gt; p-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q); return root; &#125; 二叉树的最近公共祖先leetcode给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉树: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4] 示例123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 解题思路 pq得公共结点就意味着p和q分别出现在当前节点的左右子树。 因此，当递归遍历到pq结点的时候，直接返回该结点，如果没发现就继续往下遍历。 当左右子树返回的不是null就说明这棵树下面发现了qp节点。 如果只有一棵树返回了null说明另一棵树发现了qp节点，就继续往上返回它，告诉上游此也树发现了pq节点。12345678910TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == NULL) return NULL; if (root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if (left &amp;&amp; right) return root; if (left) return left; if (right) return right; return NULL;&#125; 另一种思路：前序遍历记录从根节点到qp结点的两条路径，然后路径逐个比较，最后一个相同的结点即为最近公共结点。123456789101112131415161718192021222324252627vector&lt;vector&lt;TreeNode*&gt;&gt; path;TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; vector&lt;TreeNode*&gt; path1; vector&lt;TreeNode*&gt; path2; getPath(root, p, path1); getPath(root, q, path2); int n = min(path[0].size(), path[1].size()); // 按最短的路径长度比较 TreeNode* res = NULL; for (int i = 0; i &lt; n; ++i) &#123; if (path[0][i] == path[1][i]) res = path[0][i]; &#125; return res;&#125;void getPath(TreeNode* root, TreeNode* tar, vector&lt;TreeNode*&gt;&amp; path) &#123; if (!root) return; path.push_back(root); if (root == tar) &#123; this-&gt;path.push_back(path); return; &#125; getPath(root-&gt;left, tar, path); getPath(root-&gt;right, tar, path); path.pop_back();&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"位运算","slug":"J_LeetCode/LeetCode/位运算","date":"2022-12-27T03:12:54.068Z","updated":"2022-12-27T03:12:54.068Z","comments":true,"path":"posts/2633a26.html","link":"","permalink":"https://www.mingsrc.work/posts/2633a26","excerpt":"🍻位运算🍻转自：🔥【github】 ","text":"🍻位运算🍻转自：🔥【github】 136.只出现一次的数字 137.只出现一次的数字II 260.只出现一次的数字III 191.位1的个数 338.比特位计数 190.颠倒二进制位 只出现一次的数字leetcode给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 解题思路 一种方法是先排序，因为两个相同的数一定在一起，两个数一起遍历，当发现不同的时候便找到结果 当遍历到结尾时还没有发现则说明那一个数就出现在最后一位。123456789int singleNumber(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); for (int i = 0; i + 2 &lt; nums.size(); i+=2) &#123; if (nums[i] != nums[i + 1]) &#123; return nums[i]; &#125; &#125; return nums[nums.size()-1];&#125; 异或的性质： 任何数和 0做异或运算，结果仍然是原来的数 任何数和其自身做异或运算，结果是 0 异或运算满足交换律和结合律，本题就是应用这一性质1234567int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for (auto it : nums) &#123; res ^= it; &#125; return res;&#125; 只出现一次的数字IIleetcode给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 解题思路 位运算实在烧脑参考题解 用哈希表还是香 基本思想是，由于数字都是出现3次，所以这个数它的二进制任意位1的个数和都是3，当把所有的数字全部相加的和的二进制任意位1的个数一定是3的倍数，那么可以设计一种状态转换公式，使所有数字以二进制形式相加，各个位的1当出现第3次时变为0，这样最后剩下仍为1的位，就是只出现1次的数的二进制。 但是二进制只能表达2中状态，所以需要2位二进制 00-&gt; 01-&gt; 10 来表达任意位三种不同的状态。int数字有32位组成，所以需要两个整型变量one和two来状态转换。one表示1出现0次和1次，two表示1出现2次，因为出现第三次会变为0，所以最终的结果就是返回one 异或运算：x ^ 0 &#x3D; x​ ， x ^ 1 &#x3D; ~x与运算：x &amp; 0 &#x3D; 0 ， x &amp; 1 &#x3D; x 推导one的计算方式1234567if two == 0: if n == 0: one = one if n == 1: one = ~oneif two == 1: one = 0 通过异或运算简化1234if two == 0: one = one ^ nif two == 1: one = 0 与运算简化1one = one ^ n &amp; ~two 代码12345678int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int one = 0, two = 0; for (int num : nums) &#123; one = ~two &amp; one ^ num); two = ~one &amp; two ^ num); &#125; return one &#125; 只出现一次的数字IIIleetcode给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。 示例12输入: [1,2,1,3,2,5]输出: [3,5] 解题思路 全部异或就能得到只出现1次的数x和y的异或。然后想办法分离他俩。他俩异或的结果，任意位出现的1，这个1只属于是他俩的其中一个。所以在异或结果中，随便找一个为1的位就能区分他俩。 所以通过 int diff = mask &amp; (-mask);找到最右边的1那个位来区分他俩, 依然对所有数字异或,但加了条件n &amp; diff，这次只有那一位为1的数字才加入异或，通过这样就一定可以剔除掉另一个数字，12345678910111213141516vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int mask = 0; for (auto n : nums) &#123; mask ^= n; &#125; int diff = mask &amp; (-mask); int x = 0; for (auto n : nums) &#123; if (n &amp; diff) &#123; x ^= n; &#125; &#125; int y = mask ^ x; return &#123;x, y&#125;;&#125; 位1的个数leetcode编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 解题思路 方法一：定义掩码，逐位比较，掩码每次左移一位， mask &lt;&lt;= 1注意掩码必须使用无符号类型。 方法二：或者原码每次右移一位，与1进行比较。 方法三：每次反转原码的最后一位1，n &amp;= (n - 1)，直到原码变为0，最后统计反转的次数 123456789int hammingWeight(uint32_t n) &#123; uint32_t mask = 1; int cnt = 0; for (int i = 0; i &lt; 32; ++i) &#123; if (n &amp; mask) cnt++; mask &lt;&lt;= 1; &#125; return cnt;&#125; 12345678int hammingWeight(uint32_t n) &#123; int cnt = 0; while (n) &#123; if (n &amp; 1) cnt++; n &gt;&gt;= 1; &#125; return cnt;&#125; 12345678int hammingWeight(uint32_t n) &#123; int cnt = 0; while (n) &#123; n &amp;= n - 1; cnt++; &#125; return cnt;&#125; 比特位计数leetcode给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例112输入: 2输出: [0,1,1] 示例212输入: 5输出: [0,1,1,2,1,2] 解题思路 首先理解题意，返回的数组表示每个数字 i 的二进制数1的个数，数组大小一定是num+1,因为包含了数字0。 奇数二进制表示最低位是1，偶数是0。 奇数：二进制表示中，奇数一定比前面那个偶数多一个 1 偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多，因为偶数最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。 奇数偶数判断出了用 i % 2 == 0 还可以用i &amp; 1 ==0 来判断偶数。123456789vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; dp(num + 1); dp[0] = 0; for (int i = 1; i &lt;= num; i++) &#123; if((i &amp; 1) == 0) dp[i] = dp[i / 2]; else dp[i] = dp[i - 1] + 1; &#125; return dp;&#125; 颠倒二进制位leetcode颠倒给定的 32 位无符号整数的二进制位。 解题思路 如果做过反转一个十进制数的题，这道题基本与之相似，反转十进制使用的算法是: 类似栈从后往前不断弹出数字，12345int rev = 0;while (n) &#123; rev = rev * 10 + n % 10; n /=10;&#125; 而对于二进制数，实际上也可以,只是系数变为了212345int rev = 0;while (n) &#123; rev = rev * 2 + n % 2; n /=2;&#125; 但是需要考虑到整型溢出问题，还有二进制要考虑前导零的问题。所以我们可以替换为位操作。12345678uint32_t reverseBits(uint32_t n) &#123; uint32_t rev = 0; for (int i = 0; i &lt; 32; ++i) &#123; rev = (rev &lt;&lt; 1) + (n &amp; 1); n &gt;&gt;= 1; &#125; return rev;&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"位运算","slug":"位运算","permalink":"https://www.mingsrc.work/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"hexo特殊符号使用","slug":"I_Hexo配置/hexo特殊符号","date":"2022-12-27T03:12:54.067Z","updated":"2022-12-27T06:55:59.181Z","comments":true,"path":"posts/c8319666.html","link":"","permalink":"https://www.mingsrc.work/posts/c8319666","excerpt":"","text":"hexo特殊符号@## note modern red ‘fa fa-bell’ ##@有些特殊符号不能使用所以只能使用替换的字符：@## endnote##@ @## tabs 特殊符号对照 ##@ 有些特殊符号不能使用所以只能使用替换的字符： ! ! — 惊叹号 Exclamation mark” “ “ 双引号 Quotation mark# # — 数字标志 Number sign$ $ — 美元标志 Dollar sign% % — 百分号 Percent sign&amp; &amp; &amp; Ampersand‘ ‘ — 单引号 Apostrophe( ( — 小括号左边部分 Left parenthesis) ) — 小括号右边部分 Right parenthesis — 星号 Asterisk+ + — 加号 Plus sign&lt; &lt; &lt; 小于号 Less than= = — 等于符号 Equals sign- - − — 减号&gt; &gt; &gt; 大于号 Greater than? ? — 问号 Question mark@ @ — Commercial at[ [ —- 中括号左边部分 Left square bracket\\ \\ —- 反斜杠 Reverse solidus (backslash)] ] — 中括号右边部分 Right square bracket{ { — 大括号左边部分 Left curly brace| | — 竖线Vertical bar} } — 大括号右边部分 Right curly brace 1234567891011121314151617181920212223! &amp;#33; — 惊叹号 Exclamation mark” &amp;#34; &amp;quot; 双引号 Quotation mark# &amp;#35; — 数字标志 Number sign$ &amp;#36; — 美元标志 Dollar sign% &amp;#37; — 百分号 Percent sign&amp; &amp;#38; &amp;amp; Ampersand‘ &amp;#39; — 单引号 Apostrophe( &amp;#40; — 小括号左边部分 Left parenthesis) &amp;#41; — 小括号右边部分 Right parenthesis* &amp;#42; — 星号 Asterisk+ &amp;#43; — 加号 Plus sign&lt; &amp;#60; &amp;lt; 小于号 Less than= &amp;#61; — 等于符号 Equals sign- &amp;#45; &amp;minus; — 减号&gt; &amp;#62; &amp;gt; 大于号 Greater than? &amp;#63; — 问号 Question mark@ &amp;#64; — Commercial at[ &amp;#91; --- 中括号左边部分 Left square bracket\\ &amp;#92; --- 反斜杠 Reverse solidus (backslash)] &amp;#93; — 中括号右边部分 Right square bracket&#123; &amp;#123; — 大括号左边部分 Left curly brace| &amp;#124; — 竖线Vertical bar&#125; &amp;#125; — 大括号右边部分 Right curly brace @##endtabs##@","raw":null,"content":null,"categories":[{"name":"hexo","slug":"hexo","permalink":"https://www.mingsrc.work/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.mingsrc.work/tags/hexo/"}]},{"title":"二分法","slug":"J_LeetCode/LeetCode/二分法","date":"2022-12-27T03:12:54.067Z","updated":"2022-12-27T03:12:54.067Z","comments":true,"path":"posts/649c2087.html","link":"","permalink":"https://www.mingsrc.work/posts/649c2087","excerpt":"🐧二分法🐧转自：🔥【github】 ","text":"🐧二分法🐧转自：🔥【github】 ps:二分法一定要牢记3个经常用的模板，注意边界检测。 34.在排序数组中查找元素的第一个和最后一个位置 69.x的平方根 153.寻找旋转排序数组中的最小值 167.两数之和II-输入有序数组 278.第一个错误的版本 744.寻找比目标字母大的最小字母 二分法的3个模板必须记住 3个模板代码区别很小，主要在于找到target之后指针的处理，建议比较target时的大于小于等于三种情况都写出来进行讨论，不易搞混淆，还要牢记左右指针的越界时的处理。while循环里时&lt;&#x3D;符号，while循环结束后right指针在前，left指针在后。 寻找一个数（基本的二分搜索） 寻找左侧边界的二分搜索（检查 left 越界的情况） 寻找右侧边界的二分搜索（检查 right越界的情况) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int binary_search(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; //直接返回 right = mid - 1; &#125; else if(nums[mid] == target) &#123; return mid; &#125; &#125; return -1;&#125;int left_bound(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if (nums[mid] == target) &#123; //此处注意区别 // 别返回，收缩左侧边界 right = mid - 1; &#125; &#125; // 最后要检查 left 越界的情况 if (left &gt;= nums.length || nums[left] != target) return -1; return left;&#125;int right_bound(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if (nums[mid] == target) &#123; //此处注意区别 // 别返回，收缩右侧边界 left = mid + 1; &#125; &#125; // 最后要检查 right 越界的情况 if (right &lt; 0 || nums[right] != target) return -1; return right;&#125; 在排序数组中查找元素的第一个和最后一个位置leetcode给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。 解题思路 用二分法找左右边界，直接套用上面的模板 找左右边界的函数唯一不同点在于当nums[mid] == target时对指针的操作不同:找左边界就要不断往左压缩即右指针不断往左走right = mid - 1;，函数最后返回左指针，找右边界不断往右压缩即左指针不断往右走left = mid + 1，函数返回右指针 注意:要防止左右指针的溢出，和确定所指的数是否是目标值（可能目标值并不存在于数组中）123456789101112131415161718192021222324252627282930313233343536373839vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int left = findLeft(nums, target); int right = findRight(nums, target); return &#123;left, right&#125;;&#125;int findLeft(vector&lt;int&gt;&amp; nums, int target)&#123; int left = 0; int right = nums.size()-1; while (left &lt;=right) &#123; int mid = left + (right - left)/2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; right = mid - 1; &#125; &#125; if (left &gt;= nums.size() || nums[left] != target) return -1; return left;&#125;int findRight(vector&lt;int&gt;&amp; nums, int target)&#123; int left = 0; int right = nums.size()-1; while (left &lt;=right) &#123; int mid = left + (right - left)/2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; if (right &lt; 0 || nums[right] != target) return -1; return right;&#125; x的平方根leetcode实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去解题思路 二分法，从比x小的数中找平方等于x的值。 注意:结尾返回right而不是left是因为，while循环结束时，right &lt; left，如果x平方根不是整数，那么将会处于(r, l)指针区间内，所以只保留整数意味着返回r所指的数。 因为两数相乘可能涉及到溢出问题，所以可以将乘法转换为除法代替mid * mid == x 改为 mid == x / mid。1234567891011121314 int mySqrt(int x) &#123; int left = 1, right = x; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (mid == x / mid) &#123; return mid; &#125; else if (mid &lt; x / mid)&#123; left = mid + 1; &#125; else if (mid &gt; x / mid) &#123; right = mid -1 ; &#125; &#125; return right;&#125; 寻找旋转排序数组中的最小值leetcode假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。你可以假设数组中不存在重复元素。 解题思路 使用二分法解决问题的关键是先发现要查找元素的两边数据的特性，左边的数据一定大于数组的最后一位，右边的数据一定小于数组的最后一位，所以选择最后一位作为target进行比较。 123456789101112131415 int findMin(vector&lt;int&gt;&amp; nums) &#123; int left = 0, right = nums.size() - 1; int target = nums[right]; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; right = mid - 1; &#125; else if (nums[mid] &gt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return nums[left];&#125; 两数之和II-输入有序数组leetcode给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明:返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 解题思路 本题推荐哈希表解答，但这里提供一个二分法思路，在看到升序排列的有序数组时，要先想到二分法。 基本思路：遍历数组，对于每个数都用二分法来查找第二个数target - nums[i]即可 注意：不可以重复使用相同的元素，即第二个数不能和第一个数重复，所以函数参数记录了第一个数的下标。123456789101112131415161718192021222324252627vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; for (int i = 0; i &lt; numbers.size(); ++i) &#123; int num2 = target - numbers[i]; int index2 = binarySearch(numbers, i, num2); if (index2 != -1) return &#123;i + 1 , index2 + 1&#125;; &#125; return &#123;&#125;;&#125;int binarySearch(vector&lt;int&gt;&amp; numbers, int index1, int target) &#123; int left = 0, right = numbers.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (numbers[mid] == target) &#123; if (mid != index1)&#123; return mid; &#125; else &#123; left = mid + 1; &#125; &#125; else if (numbers[mid] &lt; target) &#123; left = mid + 1; &#125; else if (numbers[mid] &gt; target) &#123; right = mid - 1; &#125; &#125; return -1;&#125; 第一个错误的版本leetcode你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 解题思路 升序数组 且 第一个错误版本之前是好的，之后都是坏的，很容易想到二分搜索查找最左边界的错误版本。123456789101112int firstBadVersion(int n) &#123; int left = 1, right = n; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (!isBadVersion(mid)) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return left;&#125; 寻找比目标字母大的最小字母leetcode给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。在比较时，字母是依序循环出现的。举个例子： 如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’ 示例12345678910111213141516171819202122232425输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;c&quot;输出: &quot;f&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;d&quot;输出: &quot;f&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;g&quot;输出: &quot;j&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;j&quot;输出: &quot;c&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;k&quot;输出: &quot;c&quot; 解题思路 代码比较简单，主要是理解函数最后应该返回left还是right的问题 题意知，我们要在一个有序数组中找比目标字母大的最小字母，首先需要先找到目标字母的最后一位，也就是右边界，然后再往后一位即为所求。 二分法找右边界，左指针不断往右压缩 while循环结束后，无论有没有找到，目标字母一定在[right, left)区间内，因为是往右压缩，所以如果数组中存在目标字母，那就是right所指的字母，如果不存在，目标字母一定在right和left所指的字母之间。但题目要求找比目标字母稍大的字母，所以left所指正好满足。所以返回值要返回left指针。 根据上一条分析，函数应该返回left指针，就要考虑left指针的溢出问题，当left超出数组边界时，返回数组首字母。1234567891011121314char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123; int left = 0, right = letters.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (letters[mid] == target) &#123; left = mid + 1; &#125; else if (letters[mid] &lt; target) &#123; left = mid + 1; &#125; else if (letters[mid] &gt; target) &#123; right = mid - 1; &#125; &#125; return left &gt;= letters.size() ? letters[0] : letters[left]&#125;","raw":null,"content":null,"categories":[{"name":"大神们の笔记","slug":"大神们の笔记","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"大神们の笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/"},{"name":"github","slug":"github","permalink":"https://www.mingsrc.work/categories/github/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"二分法","slug":"二分法","permalink":"https://www.mingsrc.work/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"}]},{"title":"Butterfly内置标签","slug":"I_Hexo配置/Butterfly内置标签使用","date":"2022-12-27T03:12:54.066Z","updated":"2022-12-27T06:51:34.629Z","comments":true,"path":"posts/d21884bc.html","link":"","permalink":"https://www.mingsrc.work/posts/d21884bc","excerpt":"Butterfly主题内置标签@ note modern blue no-icon @ 本篇为hexo Butterfly主题内置标签的一些使用样例，供参考使用\n@ endnote @","text":"Butterfly主题内置标签@ note modern blue no-icon @ 本篇为hexo Butterfly主题内置标签的一些使用样例，供参考使用 @ endnote @ 1,Block Quote2,Code Block3,Backtick Code Block4,Pull Quote5,tag-hide@ tabs tag-hide @ 1##@ hideInline content,display,bg,color @## content: 文本内容 display: 按钮显示的文字(可选) bg: 按钮的背景颜色(可选) color: 按钮文字的颜色(可选) Demo: 123哪个英文字母最酷？ ##@ hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff @##门里站着一个人? ##@ hideInline 闪 @## 哪个英文字母最酷？ ##@ hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff @## 门里站着一个人? ##@ hideInline 闪 @## Block独立的block隐藏内容，可以隐藏很多内容，包括图片，代码块等等 ( display 不能包含英文逗号，可用&amp;sbquo;) 123##@ hideBlock display,bg,color @##content##@ endhideBlock @## content: 文本内容 display: 按钮显示的文字(可选) bg: 按钮的背景颜色(可选) color: 按钮文字的颜色(可选) Demo: 1234查看答案##@ hideBlock 1+1=？ @##2##@ endhideBlock @## 查看答案 @ hideBlock 1+1= @2 @ endhideBlock @ 如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。 ( display 不能包含英文逗号，可用&amp;sbquo;) 123##@ hideToggle display,bg,color @##content##@ endhideToggle @## Demo: 123456##@ hideToggle Butterfly安装方法 @##在你的博客根目录里git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly如果想要安装比较新的dev分支，可以git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly##@ endhideToggle @## @ hideToggle Butterfly安装方法 @在你的博客根目录里git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly如果想要安装比较新的dev分支，可以git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly @ endhideToggle @ @ endtabs @6,Gist7,iframe 1&lt;iframe src=&quot;https://mingsrc.work&quot; cols=&quot;50%,50%&quot; heigth=500px width=100% style=&quot;width:100%;height:500px;scroll-x:auto;&quot;&gt;&lt;/iframe&gt; 8,Image插入具有指定尺寸的图像。 [classname]可选 123##@ img [class names] /path/to/image [width] [height] &#x27;&quot;title text&quot; &quot;alt text&quot;&#x27; @##example:##@ img https://tvax3.sinaimg.cn/large/0072YHp3ly1gjlriqpyayj30hs0hswf6.jpg 100 100 &#x27;&quot;博客头像&quot; &quot;头像&quot;&#x27; @## @ img https://tvax3.sinaimg.cn/large/0072YHp3ly1gjlriqpyayj30hs0hswf6.jpg 100 100 ‘“博客头像” “头像”‘ @9,Link插入具有target =“ _ blank”属性的链接。 123##@ link text url [external] [title] @##example:##@ link 博客首页,https://fole-del.github.io , https://tva1.sinaimg.cn/large/0072YHp3ly1gjtb4cmbnjj31s516lav7.jpg @## @ link 博客首页,https://fole-del.github.io , https://tva1.sinaimg.cn/large/0072YHp3ly1gjtb4cmbnjj31s516lav7.jpg@10,Include Code将代码段插入到source / downloads / code文件夹中。可以通过配置中的code_dir选项指定文件夹位置。 11,Checkbox@ checkbox 纯文本测试 @@ checkbox checked, 支持简单的 markdown 语法 @@ checkbox red, 支持自定义颜色 @@ checkbox green checked, 绿色 + 默认选中 @@ checkbox yellow checked, 黄色 + 默认选中 @@ checkbox cyan checked, 青色 + 默认选中 @@ checkbox blue checked, 蓝色 + 默认选中 @@ checkbox plus green checked, 增加 @@ checkbox minus yellow checked, 减少 @@ checkbox times red checked, 叉 @@ radio 纯文本测试 @@ radio checked, 支持简单的 markdown 语法 @@ radio red, 支持自定义颜色 @@ radio green, 绿色 @@ radio yellow, 黄色 @@ radio cyan, 青色 @@ radio blue, 蓝色 @12,Vimeo插入自适应或指定大小的Vimeo视频。 13,Include Posts14,Include Assets15,Raw","raw":null,"content":null,"categories":[{"name":"hexo","slug":"hexo","permalink":"https://www.mingsrc.work/categories/hexo/"},{"name":"butterfly","slug":"hexo/butterfly","permalink":"https://www.mingsrc.work/categories/hexo/butterfly/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.mingsrc.work/tags/hexo/"}]},{"title":"Butterfly主题使用帮助","slug":"I_Hexo配置/Butterfly主题使用帮助","date":"2022-12-27T03:12:54.066Z","updated":"2022-12-27T03:12:54.066Z","comments":true,"path":"posts/d9efe45d.html","link":"","permalink":"https://www.mingsrc.work/posts/d9efe45d","excerpt":"","text":"Butterfly 常用操作 详细配置参考： 作者: Jerry連結: https://demo.jerryc.me/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A來源: Butterfly 12345678910111213141516171819202122title:date:updated:tags:categories:keywords:description:top_img:comments:cover:toc:toc_number:auto_open:copyright:copyright_author:copyright_author_href:copyright_url:copyright_info:mathjax:katex:aplayer:highlight_shrink: 静态页面的一些属性： 写法 解释 title 【必需】文章标题 date 【必需】文章创建日期 updated 【可选】文章更新日期 tags 【可选】文章标签 categories 【可选】文章分类 keywords 【可选】文章关键字 description 【可选】文章描述 top_img 【可选】文章顶部图片 cover 【可选】文章缩略图(如果没有设置top_img,文章页顶部将展示缩略图，可设置为false/图片地址/留空) comments 【可选】显示文章评论模块(默认 true) toc 【可选】显示文章TOC(默认设置为toc的enable配置) toc_number 【可选】显示toc_number(默认设置为toc的number配置) auto_open 【可选】是否自动打开TOC(默认设置为toc的auto_open配置) copyright 【可选】显示文章版权(默认设置为post_copyright的enable配置) copyright_author 【可选】文章版的文章作者 copyright_author_href 【可选】文章版权模块的文章作者链接 copyright_url 【可选】文章版权模块的文章連結链接 copyright_info 【可选】文章版版权模块的版权声明文字 mathjax 【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false) katex 【可选】显示katex(当设置katex的per_page: false時，才需要配置，默认 false) aplayer 【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐配置 highlight_shrink 【可选】配置代码块是否展开(true/false)(默认值为highlight_shrink的配置) 1 标签用法：123&#123;% note [class] [no-icon] [style] %&#125;Any content (support inline tags too.io).&#123;% endnote %&#125; Demo：Any content (support inline tags too.io). 名称 用法 class 【可选】标识，不同的标识有不同的配色（ default / primary / success / info / warning / danger ） no-icon 【可选】不显示 icon style 【可选】可以覆盖配置中的 style（simple/modern/flat/disabled） 用法二： 1234567&#123;% note [color] [icon] [style] %&#125;Any content (support inline tags too.io).&#123;% endnote %&#125;Demo：&#123;% note orange &#x27;fas fa-lab&#x27; green %&#125;Any content (support inline tags too.io).&#123;% endnote %&#125; Any content (support inline tags too.io). 名称 用法 color 【可选】顔色(default / blue / pink / red / purple / orange / green) icon 【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon ) style 【可选】可以覆盖配置中的 style（simple/modern/flat/disabled） 样例第一种格式第二种格式第三种格式对比123456789101112131415161718192021222324252627&#123;% note simple %&#125;默认 提示块标籤&#123;% endnote %&#125;&#123;% note default simple %&#125;default 提示块标籤&#123;% endnote %&#125;&#123;% note primary simple %&#125;primary 提示块标籤&#123;% endnote %&#125;&#123;% note success simple %&#125;success 提示块标籤&#123;% endnote %&#125;&#123;% note info simple %&#125;info 提示块标籤&#123;% endnote %&#125;&#123;% note warning simple %&#125;warning 提示块标籤&#123;% endnote %&#125;&#123;% note danger simple %&#125;danger 提示块标籤&#123;% endnote %&#125; 默认 提示块标籤 default 提示块标籤 primary 提示块标籤 success 提示块标籤 info 提示块标籤 warning 提示块标籤 danger 提示块标籤 123456789101112131415161718192021&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 還是 UnionPay&#123;% endnote %&#125;&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心開車 安全至上&#123;% endnote %&#125;&#123;% note red &#x27;fas fa-fan&#x27; modern %&#125;這是三片呢？還是四片？&#123;% endnote %&#125;&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 還是 UnionPay&#123;% endnote %&#125;&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石頭布&#123;% endnote %&#125;&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最討厭的瀏覽器&#123;% endnote %&#125; 你是刷 Visa 還是 UnionPay 2021年快到了…. 小心開車 安全至上 這是三片呢？還是四片？ 你是刷 Visa 還是 UnionPay 剪刀石頭布 前端最討厭的瀏覽器 123456789101112131415161718192021&#123;% note no-icon flat %&#125;你是刷 Visa 還是 UnionPay&#123;% endnote %&#125;&#123;% note blue no-icon flat %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fa fa-bicycle flat %&#125;小心開車 安全至上&#123;% endnote %&#125;&#123;% note red no-icon flat %&#125;這是三片呢？還是四片？&#123;% endnote %&#125;&#123;% note orange no-icon flat %&#125;你是刷 Visa 還是 UnionPay&#123;% endnote %&#125;&#123;% note purple no-icon flat %&#125;剪刀石頭布&#123;% endnote %&#125;&#123;% note green no-icon flat %&#125;前端最討厭的瀏覽器&#123;% endnote %&#125; 你是刷 Visa 還是 UnionPay 2021年快到了…. 小心開車 安全至上 這是三片呢？還是四片？ 你是刷 Visa 還是 UnionPay 剪刀石頭布 前端最討厭的瀏覽器 123456789101112&#123;% note no-icon flat %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note blue no-icon modern %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fa fa-bicycle&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note red no-icon disabled %&#125;2021年快到了....&#123;% endnote %&#125; flat 提示块标籤 modern提示块标籤 simple 提示块标籤 disabled 提示块标籤 2 butterfly内置标签 标签名 语法 参数 行内文本 span 样式参数, 文本内容 logo, code，red, yellow, green, cyan, blue, gray，small, h4, h3, h2, h1, large, huge, ultra，left, center, right 独立文本 p 样式参数, 文本内容 同上 普通标签 note 样式参数, 文本内容 quote, info, warning, done/success, error/danger， quote（蓝色引号）info（蓝色叹号）warning(黄色叹号),done（绿色打钩）success（绿色打钩）,error(红色禁止),danger(红色打叉) 块状标签 noteblock 样式参数 文本段落 同上 上标式标签 tip 样式参数, 文本内容 空(蓝色叹号上标),success (绿色打钩上标),error(红色叉上标),warning(黄色叹号上标) 动画标签 tip 标签图标样式 动画效果 文本内容 标签图标样式参考普通标签； 动画效果： faa-horizontal【摇晃】faa-flash【若隐若现】,faa-spin【360度旋转】,faa-shake【小幅度摆动】 复选框 checkbox 样式参数（可选）, 文本 颜色：red, yellow, green, cyan, blue； 样式：plus, minus, times； 选中状态：checked 按钮 btn [url],[text],[icon],[color] [style] [layout] [position] [size] url:链接, text:按钮文字, icon:可选图标, color:可选-按钮背景顔色(默认style时）按钮字体和边框顔色(outline时default/blue/pink/red/purple/orange/green), style:可选按钮样式默认实心outline/留空, layout:可选按钮布局默认为lineblock/留空, position:可选按钮位置前提是设置了layout为block默认为左边center/right/留空, size:可选按钮大小larger/留空 隐藏按钮 hideInline content,display,bg,color content: 文本内容， display: 按钮显示的文字(可选)， bg: 按钮的背景颜色(可选)， color: 按钮文字的颜色(可选) 隐藏款按钮 hideBlock display,bg,color content 同上 选项卡容器 tab-id：必填，如果一个页面有多个 tabs 时，tab-id 不能重复。tab-name：标签文本。 折叠容器 颜色：blue, cyan, green, yellow, red；状态：状态填写 open 代表默认打开 fancybox容器 fancybox 参数, 列数 图片 endfancybox 对齐方向：left, center, right；缩放：stretch；列数：逗号后面直接写列数，支持 2 ～ 8 列。设定列列数之后就是「多行多图」布局，此时图片默认左对齐。为了避免图片大小不一，建议搭配 stretch 来时图片放大填充。 音频容器 audio 音频链接 无 食品容器 video 视频链接 对齐方向：left, center,right； 列数：逗号后面直接写列数，支持 1 ～ 4 列。 latex公式 latex公式内容latex公式内容 无 出现&#123;&#123;&#125;&#125;解决办法 123&#123;% raw %&#125; 含有双大括号的内容&#123;% endraw %&#125; 3 按钮按钮具体用法 12345678910111213141516&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;[url] : 链接[text] : 按钮文字[icon] : [可选] 图标[color] : [可选] 按钮背景顔色(默认style时） 按钮字体和边框顔色(outline时) default/blue/pink/red/purple/orange/green[style] : [可选] 按钮样式 默认实心 outline/留空[layout] : [可选] 按钮佈局 默认为line block/留空[position] : [可选] 按钮位置 前提是设置了layout为block 默认为左边 center/right/留空[size] : [可选] 按钮大小 larger/留空 12345This is my website, click the button &#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC %&#125;This is my website, click the button &#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right %&#125;This is my website, click the button &#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,,outline %&#125;This is my website, click the button &#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,outline %&#125;This is my website, click the button &#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,larger %&#125; This is my website, click the button JerryCThis is my website, click the button JerryCThis is my website, click the button JerryCThis is my website, click the button JerryCThis is my website, click the button JerryC 123&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,block %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,block center larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,block right outline larger %&#125; JerryC JerryC JerryC 1234567&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,blue larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,pink larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,red larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,purple larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,orange larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,green larger %&#125; JerryC JerryC JerryC JerryC JerryC JerryC JerryC 123456789&lt;div class=&quot;btn-center&quot;&gt;&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry1,far fa-hand-point-right,outline larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry2,far fa-hand-point-right,outline blue larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry3,far fa-hand-point-right,outline pink larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry4,far fa-hand-point-right,outline red larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry5,far fa-hand-point-right,outline purple larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry6,far fa-hand-point-right,outline orange larger %&#125;&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry7,far fa-hand-point-right,outline green larger %&#125;&lt;/div&gt; Jerry1 Jerry2 Jerry3 Jerry4 Jerry5 Jerry6 Jerry7 4 引用块123&#123;% blockquote %&#125;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. 5 引用书上的句子1234567&#123;% blockquote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endblockquote %&#125;example:&#123;% blockquote 艾米莉·狄金森 &#x27;句读&#x27;%&#125;我想你了，可是我不能对你说，怕只怕，说了对你也是一种折磨。&#123;% endblockquote %&#125; 我想你了，可是我不能对你说，怕只怕，说了对你也是一种折磨。 艾米莉·狄金森 6 饼图12345678&#123;% mermaid %&#125;pie title Key elements in Product X &quot;Calcium&quot; : 42.96 &quot;Potassium&quot; : 50.05 &quot;Magnesium&quot; : 10.01 &quot;Iron&quot; : 5&#123;% endmermaid %&#125; pie title Key elements in Product X &quot;Calcium&quot; : 42.96 &quot;Potassium&quot; : 50.05 &quot;Magnesium&quot; : 10.01 &quot;Iron&quot; : 5 7 选项卡内容 Demo 1 - 预设选择第一个【默认】 12345678910111213&#123;% tabs 选项卡一 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 选项卡一 1选项卡一 2选项卡一 3This is Tab 1.This is Tab 2.This is Tab 3. Demo 2 - 预设选择tabs 12345678910111213&#123;% tabs 选项卡二(默认为2), 2 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 选项卡二(默认为2) 1选项卡二(默认为2) 2选项卡二(默认为2) 3This is Tab 1.This is Tab 2.This is Tab 3. Demo 3 - 没有预设值 12345678910111213&#123;% tabs 选项卡三（无预设值）, -1 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 选项卡三（无预设值） 1选项卡三（无预设值） 2选项卡三（无预设值） 3This is Tab 1. This is Tab 2.This is Tab 3. Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名 123456789101112&#123;% tabs 选项卡四（自定义标签） %&#125;&lt;!-- tab 第一个Tab@fa fa-arrow-circle-left --&gt;**tab名字为第一个Tab**&lt;!-- endtab --&gt;&lt;!-- tab @fa fa-arrow-right --&gt;**只有图标 没有Tab名字**`&lt;i class=&quot;fa fa-podcast&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;`&lt;i class=&quot;fa fa-podcast&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;!-- endtab --&gt;&lt;!-- tab grav@fa fa-grav --&gt;**名字+icon**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 第一个Tabgravtab名字为第一个Tab只有图标 没有Tab名字名字+icon 哪个英文字母最酷？ 查看答案 因为西装裤(C装酷) 门里站着一个人? 查看答案 闪 8 图片格式（演示用）12345&#123;% gallery %&#125;插入图片链接即可![]()仅支持markdown格式&#123;% endgallery %&#125; 9 隐藏块隐藏块 123&#123;% hideToggle 分割线 %&#125;&#123;% endhideToggle %&#125;","raw":null,"content":null,"categories":[{"name":"hexo","slug":"hexo","permalink":"https://www.mingsrc.work/categories/hexo/"},{"name":"butterfly","slug":"hexo/butterfly","permalink":"https://www.mingsrc.work/categories/hexo/butterfly/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.mingsrc.work/tags/hexo/"}]},{"title":"每日一题☀️","slug":"H_Coding/力扣自刷/每日一题","date":"2022-12-27T03:12:54.065Z","updated":"2022-12-27T03:12:54.065Z","comments":true,"path":"posts/4e0bd4b0.html","link":"","permalink":"https://www.mingsrc.work/posts/4e0bd4b0","excerpt":"","text":"题目 最接近原点的的K个点 最接近原点的的K个点 973. 最接近原点的 K 个点我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。 （这里，平面上两点之间的距离是欧几里德距离。） 你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。 示例 1： 1234567输入：points = [[1,3],[-2,2]], K = 1输出：[[-2,2]]解释： (1, 3) 和原点之间的距离为 sqrt(10)，(-2, 2) 和原点之间的距离为 sqrt(8)，由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。 示例 2： 123输入：points = [[3,3],[5,-1],[-2,4]], K = 2输出：[[3,3],[-2,4]]（答案 [[-2,4],[3,3]] 也会被接受。） 代码123456789class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int K) &#123; sort(points.begin(),points.end(),[](const vector&lt;int&gt;&amp; u, const vector&lt;int&gt;&amp; v)&#123; return u[0] * u[0] + u[1] * u[1] &lt; v[0] * v[0] + v[1] * v[1]; &#125;); return &#123;points.begin(), points.begin() + K&#125;; &#125;&#125;; 下一个排列31. 下一个排列实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路：注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地： 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。 以排列 [4,5,2,6,3,1][4,5,2,6,3,1] 为例： 我们能找到的符合条件的一对「较小数」与「较大数」的组合为 22 与 33，满足「较小数」尽量靠右，而「较大数」尽可能小。 当我们完成交换后排列变为 [4,5,3,6,2,1][4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6][4,5,3,1,2,6]。 代码：12345678910111213141516class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 2; while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i+1]) i--; if (i &gt;= 0) &#123; int j = nums.size() - 1; while(j &gt;= 0 &amp;&amp; nums[i] &gt;= nums [j]) j--; swap(nums[i],nums[j]); &#125; reverse(nums.begin() + i + 1, nums.end()); &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://www.mingsrc.work/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"OJ在线编程常见输入输出练习","slug":"H_Coding/牛客/OJ在线编程常见输入输出","date":"2022-12-27T03:12:54.065Z","updated":"2022-12-27T03:12:54.065Z","comments":true,"path":"posts/2ead30ec.html","link":"","permalink":"https://www.mingsrc.work/posts/2ead30ec","excerpt":"","text":"OJ在线编程常见输入输出练习 ACM的时候才知道自己连基本的输入都难以搞定！！！耻辱柱定死了~~~😭😭😭 如果大家有更好的方法一定给我分享一下，我太菜了👤 题目A+B(1)||A+B(2)||A+B(3)||A+B(4)||A+B(5)||A+B(6)||A+B(7)||字符串排序(1)||字符串排序(2)||字符串排序(3) A+B(1)链接：https://ac.nowcoder.com/acm/contest/5650/A来源：牛客网 题目描述 计算a+b 输入描述: 1输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据包括多组。 输出描述: 1输出a+b的结果 示例1 输入 121 510 20 输出 12630 代码123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;int&gt; a; int ta; cin &gt;&gt; ta; while (cin) &#123; a.push_back(ta); cin &gt;&gt; ta; &#125; for (int i = 0; i &lt; a.size(); i+=2) cout &lt;&lt; a[i] + a[i+1] &lt;&lt; endl; return 0;&#125; A+B(2)链接：https://ac.nowcoder.com/acm/contest/5650/B来源：牛客网 题目描述 计算a+b 输入描述: 12输入第一行包括一个数据组数t(1 &lt;= t &lt;= 100)接下来每行包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9) 输出描述: 1输出a+b的结果 示例1 输入 12321 510 20 输出 12630 代码123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; vector&lt;int&gt; nums; while (t-- &amp;&amp; cin) &#123; int a,b; cin &gt;&gt; a &gt;&gt; b; nums.push_back(a+b); &#125; for (auto it : nums) cout &lt;&lt; it &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; A+B(3)链接：https://ac.nowcoder.com/acm/contest/5650/C来源：牛客网 题目描述 计算a+b 输入描述: 1输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据有多组, 如果输入为0 0则结束输入 输出描述: 1输出a+b的结果 示例1 输入 1231 510 200 0 输出 12630 代码1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; nums; while (cin &amp;&amp; a != 0 &amp;&amp; b != 0) &#123; nums.push_back(a + b); cin &gt;&gt; a &gt;&gt; b; &#125; for (auto it : nums) cout &lt;&lt; it &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; A+B(4)链接：https://ac.nowcoder.com/acm/contest/5650/D来源：牛客网 题目描述 计算一系列数的和 输入描述: 123输入数据包括多组。每组数据一行,每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100), n为0的时候结束输入。接下来n个正整数,即需要求和的每个正整数。 输出描述: 1每组数据输出求和的结果 示例1 输入 1234 1 2 3 45 1 2 3 4 50 输出 121015 代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; nums; int length; cin &gt;&gt; length; while (length != 0) &#123; int ans = 0; for (int i = 0; i &lt; length; ++i) &#123; int temp; cin &gt;&gt; temp; ans += temp; &#125; nums.push_back(ans); cin &gt;&gt; length; &#125; for (auto it : nums) cout &lt;&lt; it &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; A+b(5)链接：https://ac.nowcoder.com/acm/contest/5650/E来源：牛客网 题目描述 计算一系列数的和 输入描述:1234输入的第一行包括一个正整数t(1 &lt;= t &lt;= 100), 表示数据组数。接下来t行, 每行一组数据。每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。接下来n个正整数, 即需要求和的每个正整数。 输出描述: 1每组数据输出求和的结果 示例1 输入 12324 1 2 3 45 1 2 3 4 5 输出 121015 代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int row; cin &gt;&gt; row; vector&lt;int&gt; res; while (row--) &#123; int length = 0, ans = 0; cin &gt;&gt; length; for (int i = 0; i &lt; length; ++i) &#123; int temp = 0; cin &gt;&gt; temp; ans += temp; &#125; res.push_back(ans); &#125; for (auto i : res) cout &lt;&lt; i &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; A+B(6)链接：https://ac.nowcoder.com/acm/contest/5650/F来源：牛客网 题目描述 计算一系列数的和 输入描述: 123输入数据有多组, 每行表示一组输入数据。每行的第一个整数为整数的个数n(1 &lt;= n &lt;= 100)。接下来n个正整数, 即需要求和的每个正整数。 输出描述: 1每组数据输出求和的结果 示例1 输入 124 1 2 3 45 1 2 3 4 5 输出 121015 代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; nums; int length; cin &gt;&gt; length; while (cin) &#123; int ans = 0; for (int i = 0; i &lt; length; ++i) &#123; int temp; cin &gt;&gt; temp; ans += temp; &#125; nums.push_back(ans); cin &gt;&gt; length; &#125; for (auto it : nums) cout &lt;&lt; it &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; A+B(7)链接：https://ac.nowcoder.com/acm/contest/5650/G来源：牛客网 题目描述计算一系列数的和 输入描述: 123输入数据有多组, 每行表示一组输入数据。每行不定有n个整数，空格隔开。(1 &lt;= n &lt;= 100)。 输出描述: 1每组数据输出求和的结果 示例1 输入 1231 2 34 50 0 0 0 0 输出 123690 代码12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; sum; vector&lt;vector&lt;int&gt;&gt; res; while (!cin.eof()) &#123; vector&lt;int&gt; nums; int ans = 0; int temp = 0; while(cin)&#123; cin &gt;&gt; temp; ans += temp; // nums.push_back(temp); //把结果保存在nums中 if (getchar() == &#x27;\\n&#x27;) break; &#125; // res.push_back(nums); //把nums保存在res中 sum.push_back(ans); &#125; for (int i = 0; i &lt; sum.size()-1; ++i) cout &lt;&lt; sum[i] &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 字符串排序(1)链接：https://ac.nowcoder.com/acm/contest/5650/H来源：牛客网 题目描述对输入的字符串进行排序后输出 输入描述: 123输入有两行，第一行n第二行是n个空格隔开的字符串 输出描述: 1输出一行排序后的字符串，空格隔开，无结尾空格 示例1 输入 125c d a bb e 输出 1a bb c d e 代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;string&gt; vstr; int length; cin &gt;&gt; length; for (int i = 0; i &lt; length; ++i) &#123; string str; cin &gt;&gt; str; vstr.push_back(str); &#125; sort(vstr.begin(), vstr.end()); for (auto it : vstr) cout &lt;&lt; it &lt;&lt; &quot; &quot;; system(&quot;pause&quot;); return 0;&#125; 字符串排序(2)链接：https://ac.nowcoder.com/acm/contest/5650/I来源：牛客网 题目描述对输入的字符串进行排序后输出 输入描述: 123多个测试用例，每个测试用例一行。每行通过空格隔开，有n个字符，n＜100 输出描述: 1对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开 示例1 输入 123a c bbf ddddnowcoder 输出 123a bb cdddd fnowcode 代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;vector&lt;string&gt; &gt; res; while (!cin.eof()) &#123; vector&lt;string&gt; vstr; while (cin) &#123; string str; cin &gt;&gt; str; vstr.push_back(str); if (getchar() == &#x27;\\n&#x27;) &#123; sort(vstr.begin(), vstr.end()); break; &#125; &#125; res.push_back(vstr); &#125; //输出 for (int i = 0; i &lt; res.size(); ++i) &#123; cout &lt;&lt; res[i][0]; for (auto j = 1;j &lt; res[i].size(); ++j) cout &lt;&lt; &quot; &quot; &lt;&lt; res[i][j]; cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; 字符串排序(3)链接：https://ac.nowcoder.com/acm/contest/5650/J来源：牛客网 题目描述对输入的字符串进行排序后输出 输入描述: 12多个测试用例，每个测试用例一行。每行通过,隔开，有n个字符，n＜100 输出描述: 1对于每组用例输出一行排序后的字符串，用&#x27;,&#x27;隔开，无结尾空格 示例1 输入 123a,c,bbf,ddddnowcoder 输出 123a,bb,cdddd,fnowcoder 代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include &lt;sstream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; string s; vector&lt;string&gt; vec; while (cin &gt;&gt; s) &#123; istringstream input(s); string t; while (getline(input, t, &#x27;,&#x27;)) vec.push_back(t); if (cin.get() == &#x27;\\n&#x27;) &#123; sort(vec.begin(), vec.end()); for (int i = 0; i &lt; vec.size(); i++) &#123; if (i) cout &lt;&lt; &quot;,&quot; &lt;&lt; vec[i]; else cout &lt;&lt; vec[i]; &#125; cout &lt;&lt; endl; vec.clear(); &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;sstream&gt;using namespace std;int main()&#123; string str; vector&lt;string&gt;array; while(getline(cin,str)) &#123; istringstream strs(str); string strt; while(getline(strs,strt,&#x27;,&#x27;)) array.push_back(strt); sort(array.begin(),array.end()); for(auto iter=array.begin();iter!=array.end()-1;iter++) cout&lt;&lt;*iter&lt;&lt;&#x27;,&#x27;; cout&lt;&lt;array.back()&lt;&lt;endl; array.clear(); &#125; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"https://www.mingsrc.work/tags/%E7%89%9B%E5%AE%A2/"},{"name":"输入输出","slug":"输入输出","permalink":"https://www.mingsrc.work/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"}]},{"title":"贪心算法(自刷)","slug":"H_Coding/力扣自刷/TX贪心算法","date":"2022-12-27T03:12:54.064Z","updated":"2022-12-27T03:12:54.064Z","comments":true,"path":"posts/45042f99.html","link":"","permalink":"https://www.mingsrc.work/posts/45042f99","excerpt":"贪心算法（自刷）53.最大子序和","text":"贪心算法（自刷）53.最大子序和 53最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 思路： 初始化 定义一个当前和curSum，为负数的时候就清零从新累计，初始值为0; 定义一个最大和maxSum，每当curSum求出之后都要拿来比较一下，进行更新,初始值为Integer.MIN_VALUE，保证计算第一 元素的时候maxSum就更新为curSum； 遍历，对每一个元素进行如下操作： 计算当前和curSum; 更新最大和maxSum; 更新当前和curSum，若为负数则清零 返回 代码：1234567891011121314151617181920212223class Solution&#123;public: int maxSubArray(vector&lt;int&gt; &amp;nums) &#123; //类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值 int result = INT_MIN; int numsSize = int(nums.size()); int sum = 0; for (int i = 0; i &lt; numsSize; i++) &#123; sum += nums[i]; result = max(result, sum); //如果sum &lt; 0，重新开始找子序串 if (sum &lt; 0) &#123; sum = 0; &#125; &#125; return result; &#125;&#125;; 122.买卖股票的最佳时机122. 买卖股票的最佳时机 II 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路如果i+1天比i天大，就累加 代码123456789class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int profit = 0; for(int i = 0; i + 1 &lt; prices.size(); i++) profit += max(prices[i+1] - prices[i], 0); return profit; &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://www.mingsrc.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"栈(自刷)","slug":"H_Coding/力扣自刷/Z栈","date":"2022-12-27T03:12:54.064Z","updated":"2022-12-27T03:12:54.064Z","comments":true,"path":"posts/149d196b.html","link":"","permalink":"https://www.mingsrc.work/posts/149d196b","excerpt":"栈题目一\n剑指 Offer 09. 用两个栈实现队列","text":"栈题目一 剑指 Offer 09. 用两个栈实现队列 用两个栈实现队列剑指 Offer 09. 用两个栈实现队列 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1：1234输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1]示例 2：1234输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2]提示： 1 &lt;= values &lt;= 10000最多会对 appendTail、deleteHead 进行 10000 次调用 123456789101112131415161718192021222324252627282930class CQueue &#123;public: CQueue() &#123; &#125; void appendTail(int value) &#123; one.push(value); &#125; int deleteHead() &#123; if(two.empty()) &#123; if(one.empty()) return -1; while(!one.empty()) &#123; two.push(one.top()); one.pop(); &#125; int top = two.top(); two.pop(); return top; &#125; else &#123; int top = two.top(); two.pop(); return top; &#125; &#125;private: stack&lt;int&gt; one,two; &#125;; 找出右边第一个比其大的数1234567891011121314151617181920212223242526272829vector&lt;int&gt; findMax2(vector&lt;int&gt;num)&#123; if (num.size() == 0)return num; vector&lt;int&gt;res(num.size()); int i = 0; stack&lt;int&gt;s; while (i &lt; num.size()) &#123; if (s.empty() || num[s.top()] &gt;= num[i])//如果堆栈里面有的top元素比即将到来的元素大，则入栈，直到右边找到比top元素大的， &#123; s.push(i++);//i增加，遍历下个元素 &#125; else//栈里面有元素，且满足num[i] 比栈里面的元素大，则找到s.top()位置对应值，右边第一个元素其大的元素 &#123; res[s.top()] = num[i]; s.pop();//此处仅仅弹出top元素，因为其找到了右边第一个元素比其大的值，而i不变化，是因为num[i]也有可能比pop之后top元素大 &#125; &#125; while (!s.empty())//如果不为空，说明这些元素没有找到 &#123; res[s.top()] = INT_MAX;//直接用INT_MAX标记 s.pop(); &#125; for (int i = 0; i &lt; res.size(); i++) cout &lt;&lt; res[i] &lt;&lt; endl; return res; &#125;","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"栈","slug":"栈","permalink":"https://www.mingsrc.work/tags/%E6%A0%88/"}]},{"title":"哈希表","slug":"H_Coding/力扣自刷/HX哈希","date":"2022-12-27T03:12:54.063Z","updated":"2022-12-27T03:12:54.063Z","comments":true,"path":"posts/850f2080.html","link":"","permalink":"https://www.mingsrc.work/posts/850f2080","excerpt":"哈希表哈希映射\n面试题10.02变位词组\n最长回文串","text":"哈希表哈希映射 面试题10.02变位词组 最长回文串 哈希映射不使用任何内建的哈希表库设计一个哈希映射 具体地说，你的设计应该包含以下的功能 put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。remove(key)：如果映射中存在这个键，删除这个数值对。 示例： MyHashMap hashMap &#x3D; new MyHashMap();hashMap.put(1, 1);hashMap.put(2, 2);hashMap.get(1); &#x2F;&#x2F; 返回 1hashMap.get(3); &#x2F;&#x2F; 返回 -1 (未找到)hashMap.put(2, 1); &#x2F;&#x2F; 更新已有的值hashMap.get(2); &#x2F;&#x2F; 返回 1hashMap.remove(2); &#x2F;&#x2F; 删除键为2的数据hashMap.get(2); &#x2F;&#x2F; 返回 -1 (未找到) 实现一个hash类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct Node&#123; int nkey; int nval; Node* next; Node(int key, int val): nkey(key), nval(val), next(nullptr)&#123;&#125;&#125;;int len = 1000;class MyHashMap &#123;public: vector &lt;Node*&gt; arr; /** Initialize your data structure here. */ MyHashMap() &#123; arr = vector&lt;Node*&gt; (len, new Node(-1,-1)); &#125; /** value will always be non-negative. */ void put(int key, int value) &#123; int temp = key % len; Node* h = arr[temp]; Node* prev; while(h)&#123; if(h -&gt; nkey == key)&#123; h -&gt; nval = value; return; &#125; prev = h; h = h -&gt; next; &#125; Node* node = new Node(key,value); prev -&gt; next = node; &#125; /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) &#123; int temp = key % len; Node* h = arr[temp]; while(h)&#123; if(h -&gt; nkey == key) return h -&gt; nval; h = h -&gt; next; &#125; return -1; &#125; /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) &#123; int temp = key % len; Node* h = arr[temp]; while(h)&#123; if(h -&gt; nkey == key)&#123; h -&gt; nval = -1; &#125; h = h -&gt; next; &#125; &#125;&#125;; C++链地址法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;vector&gt;class Node&#123;public: int key; int value; Node * next;public: Node(int key_, int value_):key(key_),value(value_),next(nullptr)&#123;&#125;; ~Node();&#125;;const int len = 100;class MyHashMap &#123; public: vector&lt;Node*&gt; arr;public: /** Initialize your data structure here. */ MyHashMap():arr(vector&lt;Node*&gt;(len, nullptr))&#123; for (int i = 0; i &lt; len; ++i) arr[i] = new Node(-1,0); &#125; /** value will always be non-negative. */ void put(int key, int value) &#123; int index = key % len; Node *tmp = arr[index]; while (tmp) &#123; if (tmp-&gt;key == -1) &#123; tmp-&gt;key = key; tmp-&gt;value = value; return ; &#125; if (tmp-&gt;key == key) &#123; tmp-&gt;value = value; return ; &#125; if (tmp-&gt;next == nullptr) &#123; tmp-&gt;next = new Node(key, value); return ; &#125; tmp = tmp-&gt;next; &#125; return ; &#125; /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ int get(int key) &#123; int index = key % len; Node *tmp = arr[index]; while (tmp) &#123; if (tmp-&gt;key == key) return tmp-&gt;value; tmp = tmp-&gt;next; &#125; return -1; &#125; /** Removes the mapping of the specified value key if this map contains a mapping for the key */ void remove(int key) &#123; int index = key % len; Node *tmp = arr[index]; while (tmp) &#123; if (tmp-&gt;key == key) &#123; tmp-&gt;value = 0; tmp-&gt;key = -1; return ; &#125; tmp = tmp-&gt;next; &#125; return ; &#125;&#125;;/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap* obj = new MyHashMap(); * obj-&gt;put(key,value); * int param_2 = obj-&gt;get(key); * obj-&gt;remove(key); */作者：lie-wen-hu-ke-de-xian-wei-jing链接：https://leetcode-cn.com/problems/design-hashmap/solution/c-lian-di-zhi-fa-by-lie-wen-hu-ke-de-xian-wei-jing/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 变位词组编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。 注意：本题相对原题稍作修改 示例: 输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],输出:[ [“ate”,”eat”,”tea”], [“nat”,”tan”], [“bat”]]说明： 所有输入均为小写字母。不考虑答案输出的顺序。 解题思路 变位词利用sort后和相同。哈希表添加次下标即可，之后便利哈希表根据下标添加变位词 12345678910111213141516171819202122vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string,vector&lt;int&gt; &gt; map; vector&lt;vector&lt;string&gt; &gt; res; for(int i =0; i &lt; strs.size() ; i++) &#123; string str = strs[i]; sort(str.begin(),str.end()); map[str].push_back(i); &#125; for(auto i : map ) &#123; auto index = i.second; //vector&lt;int&gt; index vector&lt;string&gt; tmp; for(auto it : index) &#123; tmp.push_back(strs[it]); &#125; res.push_back(tmp); &#125; return res;&#125; 最长回文串给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。 示例 1: 输入:“abccccdd” 输出:7 解释:我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。 思路 先用哈希统计出现的每一个字母个数 for(auto it : s) hash[it]++; 统计字母个数为偶数的和，字母个数为奇数时，减一也能满足回文串要求 length += it.second % 2 ? it.second : it.second - 1 此时res % 2 = 0，如果 res &lt; size,则回文串中间还可以加一个 代码12345678910111213class Solution &#123;public: int longestPalindrome(string s) &#123; unordered_map&lt;char,int&gt; hash; for(auto it : s) hash[it]++; int res = 0; for(auto it : hash) res += it.second % 2 == 0 ? it.second : it.second-1; //res % 2 = 0 如果res = size,则原字符串出现的字母均是偶数个 return res = res &lt; s.size() ? res + 1 : res; &#125;&#125;; 独一无二的出现次数1207. 独一无二的出现次数给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例 1： 123输入：arr = [1,2,2,1,1,3]输出：true解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2： 12输入：arr = [1,2]输出：false 示例 3： 12输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]输出：true 12345678910111213141516class Solution &#123;public: bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) &#123; unordered_map&lt;int,int&gt; hash; for(int i =0; i &lt; arr.size(); ++i) &#123; hash[arr[i]]++; &#125; unordered_set&lt;int&gt; times; for (const auto&amp; x: hash) &#123; times.insert(x.second); &#125; return times.size() == hash.size(); &#125;&#125;; 前 K 个高频元素（哈希排序）347. 前 K 个高频元素给定一个非空的整数数组，返回其中出现频率前 k 高的元素。示例 1: 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 12输入: nums = [1], k = 1输出: [1] 1234567891011121314151617181920212223class Solution &#123;public: static bool cmp(pair&lt;int,int&gt;v1,pair&lt;int,int&gt;v2) &#123; return v1.second &gt; v2.second; &#125; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int,int&gt; hash; for(int i = 0; i &lt; nums.size(); i++) &#123; hash[nums[i]]++; &#125; vector&lt;pair&lt;int,int&gt; &gt; arr(hash.begin(),hash.end()); sort(arr.begin(),arr.end(),cmp); vector&lt;int&gt; res; for(int i = 0; i &lt; k; i++) &#123; res.push_back(arr[i].first); &#125; return res; &#125;&#125;; 二倍数对数组954. 二倍数对数组 给定一个长度为偶数的整数数组 A，只有对 A 进行重组后可以满足 “对于每个 0 &lt;&#x3D; i &lt; len(A) &#x2F; 2，都有 A[2 * i + 1] &#x3D; 2 * A[2 * i]” 时，返回 true；否则，返回 false。 示例 1： 12输入：[3,1,3,6]输出：false 示例 2： 12输入：[2,1,2,6]输出：false 示例 3： 123输入：[4,-2,2,-4]输出：true解释：我们可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4] 示例 4： 12输入：[1,2,4,16,8,4]输出：false 代码 1234567891011121314151617181920212223242526class Solution &#123;public: bool canReorderDoubled(vector&lt;int&gt;&amp; A) &#123; map&lt;int,int&gt; hash; int match; for(int i : A) hash[i]++; for(auto it = hash.begin(); it != hash.end(); ++it) &#123; if(it-&gt;second &gt; 0) &#123; if(it-&gt;first &gt; 0) match = it-&gt;first *2; else &#123; if(it-&gt;first % 2) return false; match = it-&gt;first / 2; &#125; hash[match] -= it-&gt;second; if(hash[match] &lt; 0) return false; &#125; &#125; return true; &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"程序员内功","slug":"程序员内功","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/"},{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"},{"name":"算法数据结构","slug":"程序员内功/算法数据结构","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"哈希","slug":"哈希","permalink":"https://www.mingsrc.work/tags/%E5%93%88%E5%B8%8C/"}]},{"title":"链表(自刷)","slug":"H_Coding/力扣自刷/LB链表","date":"2022-12-27T03:12:54.063Z","updated":"2022-12-27T03:12:54.063Z","comments":true,"path":"posts/464e9a9.html","link":"","permalink":"https://www.mingsrc.work/posts/464e9a9","excerpt":"链表两两交换链表中的节点\n合并两个有序链表\n","text":"链表两两交换链表中的节点 合并两个有序链表 两两交换链表中的节点 24. 两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1：12输入：head = [1,2,3,4]输出：[2,1,4,3]示例 2：12输入：head = []输出：[]示例 3：12输入：head = [1]输出：[1]提示：链表中节点的数目在范围 [0, 100] 内0 &lt;= Node.val &lt;= 100 思路定义一个虚拟头结点dummylisty，如果存在可以交换的节点，则按照题目要求把相应位置的节点插入到相应位置。 123456789101112131415161718192021222324class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *dummyList =new ListNode(-1,head); dummyList-&gt;next = head; if(dummyList-&gt;next == nullptr) return nullptr; if(head-&gt;next == nullptr) return head; ListNode *top = dummyList; while(top-&gt;next!= nullptr &amp;&amp; top-&gt;next-&gt;next != nullptr) &#123; ListNode* tmp = top-&gt;next; // 记录临时节点 ListNode* tmp1 = top-&gt;next-&gt;next-&gt;next; // 记录临时节点 top-&gt;next = top-&gt;next-&gt;next; top-&gt;next-&gt;next = tmp; top-&gt;next-&gt;next-&gt;next = tmp1; top = top-&gt;next-&gt;next; &#125; return dummyList-&gt;next; &#125;&#125;; 合并两个有序链表 21. 合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 12345678910111213141516171819class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* retList = new ListNode(0); ListNode* dummy = retList; while(l1 != nullptr &amp;&amp; l2 != nullptr) &#123; if(l1-&gt;val &lt; l2-&gt;val) &#123; dummy-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; dummy-&gt;next = l2; l2 = l2-&gt;next; &#125; dummy = dummy-&gt;next; &#125; dummy-&gt;next = l1 == NULL ? l2 : l1; return retList-&gt;next; &#125;&#125;; 反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 示例1 输入 1&#123;1,2,3&#125; 返回值 1&#123;3,2,1&#125; 代码1234567891011121314151617181920212223/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; ListNode *pre = nullptr; ListNode *cur = pHead; ListNode *nex = nullptr; while(cur) &#123; nex = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = nex; &#125; return pre; &#125;&#125;; 奇偶链表 328. 奇偶链表给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例： 12&gt;输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL&gt;输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 代码123456789101112131415161718class Solution &#123;public: ListNode* oddEvenList(ListNode* head) &#123; if (head == NULL) return head; ListNode* evenHead = head-&gt;next; ListNode* odd = head; ListNode* even = evenHead; while(even != nullptr &amp;&amp; even-&gt;next != nullptr) &#123; odd-&gt;next = even-&gt;next; odd = odd-&gt;next; even-&gt;next = odd-&gt;next; even = even-&gt;next; &#125; odd-&gt;next = evenHead; return head; &#125;&#125;; 复杂度分析时间复杂度：O(n)O(n)，其中 nn 是链表的节点数。需要遍历链表中的每个节点，并更新指针。 空间复杂度：O(1)O(1)。只需要维护有限的指针。","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://www.mingsrc.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"数组(自刷)","slug":"H_Coding/力扣自刷/SZ数组","date":"2022-12-27T03:12:54.063Z","updated":"2022-12-27T03:12:54.063Z","comments":true,"path":"posts/dc95c5cc.html","link":"","permalink":"https://www.mingsrc.work/posts/dc95c5cc","excerpt":"数组杨辉三角\n加一\n删除排序数组中的重复项\n四数之和\n","text":"数组杨辉三角 加一 删除排序数组中的重复项 四数之和 杨辉三角118. 杨辉三角 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 代码123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; res; for(int i = 0; i &lt; numRows; i++) &#123; vector&lt;int&gt; row; row.resize(i+1); row[0] = 1; row[i] = 1; for(int j = 1; j &lt;= i-1; j++) &#123; row[j] = res[i-1][j-1]+res[i-1][j]; &#125; res.push_back(row); &#125; return res; &#125;&#125;; 加一66. 加一 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2:123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。代码 12345678910111213class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; for(int i = digits.size()-1;i&gt;=0;i--) &#123; digits[i]++; if(digits[i]==10) digits[i]=0; else return digits; &#125; digits.insert(digits.begin(),1); return digits; &#125;&#125;; 删除排序数组中的重复项26. 删除排序数组中的重复项给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。123456789101112131415class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; int i = 0; for (int j = 1; j &lt; nums.size(); j++) &#123; if (nums[j] != nums[i]) &#123; i++; nums[i] = nums[j]; &#125; &#125; return i + 1; &#125;&#125;; 四树之和18. 四数之和 题目给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。注意：答案中不可以包含重复的四元组。 示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ret; int length = nums.size(); for (int i = 0; i &lt; length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; for (int first = i + 1; first &lt; length - 2; first++) &#123; if (first &gt; i + 1 &amp;&amp; nums[first] == nums[first - 1]) continue; int second = first + 1; int third = length - 1; while (second &lt; third) &#123; int sum = nums[first] + nums[second] + nums[third] + nums[i]; cout &lt;&lt; &quot;sum:&quot; &lt;&lt; sum &lt;&lt; &#x27;:&#x27;; cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot; &lt;&lt; nums[first] &lt;&lt; &quot; &quot; &lt;&lt; nums[second] &lt;&lt; &quot; &quot; &lt;&lt; nums[third] &lt;&lt; endl; if (sum == target) &#123; ret.push_back(&#123; nums[i] , nums[first] , nums[second] , nums[third] &#125;); while (second &lt; third &amp;&amp; nums[second] == nums[second + 1]) ++second; //注意去重 while (second &lt; third &amp;&amp; nums[third] == nums[third - 1]) --third; third--; second++; &#125; else if (sum &lt; target) second++; else third--; &#125; &#125; &#125; return ret; &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"数组","slug":"数组","permalink":"https://www.mingsrc.work/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"二分法(自刷)","slug":"H_Coding/力扣自刷/EF二分法","date":"2022-12-27T03:12:54.062Z","updated":"2022-12-27T03:12:54.062Z","comments":true,"path":"posts/31380466.html","link":"","permalink":"https://www.mingsrc.work/posts/31380466","excerpt":"二分法\n\n二分法代码1234567891011121314151617181920212223242526272829303132333435363738// 二分查找（折半查找）：对于已排序，若无序，需要先排序// 非递归int BinarySearch(vector&lt;int&gt; v, int value , int low, int high) &#123;\tif (v.size() &lt;= 0) &#123;\t\treturn -1;\t&#125;\twhile (low &lt;= high) &#123;\t\tint mid = low + (high - low) / 2;\t\tif (v[mid] == value) &#123;\t\t\treturn mid;\t\t&#125;\t\telse if (v[mid] &gt; value) &#123;\t\t\thigh = mid - 1;\t\t&#125;\t\telse &#123;\t\t\tlow = mid + 1;\t\t&#125;\t&#125;\treturn -1;&#125;// 递归int BinarySearch2(vector&lt;int&gt; v, int value, int low, int high)&#123;\tif (low &gt; high)\t\treturn -1;\tint mid = low + (high - low) / 2;\tif (v[mid] == value)\t\treturn mid;\telse if (v[mid] &gt; value)\t\treturn BinarySearch2(v, value, low, mid - 1);\telse\t\treturn BinarySearch2(v, value, mid + 1, high);&#125;\n\n题目：[34. 在排序数组中查找元素的第一个和最后一个位置](###34. 在排序数组中查找元素的第一个和最后一个位置)\n[69.x的平方根](###69. x 的平方根)\n[153. 寻找旋转排序数组中的最小值](###153. 寻找旋转排序数组中的最小值)\n[167. 两数之和 II - 输入有序数组](###167. 两数之和 II - 输入有序数组)","text":"二分法 二分法代码1234567891011121314151617181920212223242526272829303132333435363738// 二分查找（折半查找）：对于已排序，若无序，需要先排序// 非递归int BinarySearch(vector&lt;int&gt; v, int value , int low, int high) &#123; if (v.size() &lt;= 0) &#123; return -1; &#125; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (v[mid] == value) &#123; return mid; &#125; else if (v[mid] &gt; value) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return -1;&#125;// 递归int BinarySearch2(vector&lt;int&gt; v, int value, int low, int high)&#123; if (low &gt; high) return -1; int mid = low + (high - low) / 2; if (v[mid] == value) return mid; else if (v[mid] &gt; value) return BinarySearch2(v, value, low, mid - 1); else return BinarySearch2(v, value, mid + 1, high);&#125; 题目：[34. 在排序数组中查找元素的第一个和最后一个位置](###34. 在排序数组中查找元素的第一个和最后一个位置) [69.x的平方根](###69. x 的平方根) [153. 寻找旋转排序数组中的最小值](###153. 寻找旋转排序数组中的最小值) [167. 两数之和 II - 输入有序数组](###167. 两数之和 II - 输入有序数组) 34. 在排序数组中查找元素的第一个和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 解法一code-banner12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; // 搜索右边界 right int i = 0, j = nums.size() - 1; while(i &lt;= j) &#123; int m = (i + j) / 2; if(nums[m] &lt;= target) i = m + 1; else j = m - 1; &#125; int right = i; // 若数组中无 target ，则提前返回 if(j &gt;= 0 &amp;&amp; nums[j] != target) return &#123;-1, -1&#125;; if(j &lt; 0) return &#123;-1, -1&#125;; // 搜索左边界 right i = 0; j = nums.size() - 1; while(i &lt;= j) &#123; int m = (i + j) / 2; if(nums[m] &lt; target) i = m + 1; else j = m - 1; &#125; int left = j; return &#123;left + 1, right - 1&#125;; &#125;&#125;; 解法二(还是二分法)123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() -1,mid; while (left &lt;= right) &#123; mid = (left + right) / 2; if(nums[mid] &gt; target) right = mid - 1; else if(nums[mid] &lt; target) left = mid + 1; else if(nums[mid] == target) &#123; if(nums[right] &gt; target) right--; else if(nums[left] &lt; target) left++; else if(nums[left] == target &amp;&amp; nums[right] == target) return &#123;left , right&#125;; &#125; &#125; return &#123;-1,-1&#125;; &#125;&#125;; 69. x 的平方根实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4输出: 2 示例 2: 12345输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 代码（一看就会）123456789101112131415161718192021class Solution &#123;public: int mySqrt(int x) &#123; long l = 1; long r = x; if (x == 0) return 0; if (x == 1) return 1; while(l&lt;r) &#123; int mid = (l+r)/2; if (x/mid == mid) &#123; return mid; &#125; else if (x/mid &gt; mid) &#123; l = mid+1; &#125; else &#123; r = mid; &#125; &#125; return l-1; &#125; &#125;; 153. 寻找旋转排序数组中的最小值假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 12输入: [3,4,5,1,2]输出: 1 示例 1: 12输入: [3,4,5,1,2]输出: 1 解题思路： 指针最终指向数组最大和最小的位置 左右两边不断靠近到整个数组最大值与最小值的分界点 代码：12345678910111213141516171819class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int left=0,right=nums.size()-1; int min = nums[0]; if(nums[left] &lt; nums[right]) return nums[left]; while(left &lt; right) &#123; int mid = (left + right) / 2; if(right - left == 1) return nums[left]&gt;nums[right]?nums[right]:nums[left]; else if(nums[mid] &gt; nums[right]) left = mid; else if(nums[mid] &lt; nums[right]) right = mid; &#125; return min; &#125;&#125;; 167. 两数之和 II - 输入有序数组给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例： 123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int left=0,right = numbers.size() -1; int sum = numbers[left] + numbers[right]; while ( sum != target) &#123; sum = numbers[left] + numbers[right]; if( sum &lt; target) left++; else if (sum &gt; target)&#123; right--; &#125; else if ( sum == target)&#123; return &#123;left+1,right+1&#125;; &#125; &#125; return &#123;left+1,right+1&#125;; &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"二分法","slug":"二分法","permalink":"https://www.mingsrc.work/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"}]},{"title":"分治算法(自刷)","slug":"H_Coding/力扣自刷/FZ分治算法","date":"2022-12-27T03:12:54.062Z","updated":"2022-12-27T03:12:54.062Z","comments":true,"path":"posts/3e1bc1fc.html","link":"","permalink":"https://www.mingsrc.work/posts/3e1bc1fc","excerpt":"分治算法自刷","text":"分治算法自刷 分治算法的核心思想分治算法的核心思想就是四个字,分而治之,也就是将原来的问题划分成n个规模较小,并且结构与原问题相似的子问题,递归地解决这些子问题,然后再合并其结果,就得到原问题的解. 看起来有点像递归,不过要知道分治算法是一种处理问题的思想,递归是一种编程技巧.看起来像是因为分治算法一般都比较适合用递归去实现 分治算法递归实现步骤1. 分解：​ 将原问题分解为一系列的子问题 2. 解决：递归地求解各个子问题，若子问题足够小，则直接求解。 3. 合并：将子问题的结果合并为原问题 53.最大子序和 53.最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。`进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路1. Post not found: 力扣自刷/动态规划2. Post not found: 力扣自刷/贪心算法3. 分治算法 123456789101112131415161718192021222324252627int findmax(vector&lt;int&gt; nums, int x, int y)&#123; int v, L, R, midMaxs; if (y - x == 0) &#123; return nums[x]; &#125; int m = ( x + y ) / 2; //分治第一步，划分成[x,m)和[m,y)两部分 midMaxs = max(findmax(nums, x, m), findmax(nums, m + 1, y)); v = 0; L = nums[m]; R = nums[m+1]; for (int i = m ; i &gt;= x; i--) &#123; L = max(L, v += nums[i]); &#125; v = 0; for (int i = m + 1 ; i &lt;= y; i++) &#123; R = max(R, v += nums[i]); &#125; return max(L + R, midMaxs);&#125;int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int length = nums.size(); int result = findmax(nums, 0, length-1); return result;&#125;","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"分治算法","slug":"分治算法","permalink":"https://www.mingsrc.work/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"}]},{"title":"词根","slug":"G_CET6/词根","date":"2022-12-27T03:12:54.061Z","updated":"2022-12-27T03:12:54.061Z","comments":true,"path":"posts/1744453e.html","link":"","permalink":"https://www.mingsrc.work/posts/1744453e","excerpt":"","text":"词根、词缀表Word List 1 词根词缀 含义 Exapmle Translation abs- 离去 abstract n.摘要 adj.抽象的 con- 共同 consensus n.意见等一致 inter- 在……之前，相互 internal adj.国内的；内心的 pro- 向前 propel vt.推进，激励 re- 又，再；重新 repression n.压抑；镇压 bio 生命 biography n.传记 ceed 行走，前进 proceedings n.进程；议程 cogn 知道 congnitive adj.认知的，认知能力的 fin 范围 define vt.给……下定义，限定 ign 燃 ignite vt.点燃；引发 vi.着火 luxur 富，精美 luxury n. 奢侈，奢侈品 pel 推 propel vt.推进，激励 pli 倍，重 compliment n.赞美的话 vt. 赞美，恭维 pond 重量 ponder v. 思索，考虑，沉思 press 压 repression n. 压抑；镇压 rog 要求 arrangant adj. 傲慢的，自大的 -ine ……的 genuine adj. 真的；真诚的 -ion 表性质 repression n. 压抑；镇压 -y ……的 hasty adj. 草率的；急速的；匆忙的 Word List 2 词根词缀 含义 Exapmle Translation ac-,ap-,as- 加强 appendix n. 阑尾；附录 con-，cor- 共同，加强 contest n. 竞赛，争夺 em-，en- 使… embody vt. 使具体化；包括 in- 不 innumerable adj. 无数的，数不清的 intel- 中间 intellectual n. 知识分子 adj. 智力的 pre- 预先 presume vt. 推测，假定 circ 环绕 circus n. 马戏团；环形广场 cumul 堆积 accumulate v. 积累，堆积 fic 做 proficiency n. 熟练，精通 fract 打破 fracture n. 裂缝 v. 使断裂 guis 伪装 disguise vt. 假扮，伪装；掩盖 lect 选择 intellectual n. 知识分子 adj. 智力的 liter 文字 literacy n. 识字，有文化，读写能力 nutri 营养 nutrition n. 营养，营养学 pos 放 compose vt. 组成，是镇静 sent 感觉 sentiment n. 意见，感情 vi 道路 deviate vi. 背离，偏离 -ee 表人 referee n. 裁判员；证明人 -ic …的 gigantic adj. 巨大的，庞大的 -ish 使 nourish vt. 养育，喂养 -ive …性质的 progressive adj. 前进的；渐进的 -ure 行为，行为的加过 fracture n. 裂缝 v. 使断裂 Word List 3 词根词缀 含义 Exapmle Translation con- 共同；加强 conversion n. 转变；皈依 en- 使…… endurance n. 忍耐力，持久（力） ex 出 expose vt. 使暴露，揭露 cens 评估 census n. 人口普查，统计 clud，clus 关闭 inclusive adj. 包括一切的 crim 罪行 criminal n. 犯人 adj. 犯罪的 dict 说 predict vt.预言，预告， 预测 init 开始 initial adj. 最初的，开始的 loqu 说 eloquent adj. 雄辩的，口才流利的 miss 送，放出 dismiss vt. 不再考虑，解雇 norm 规则 abnormal adj. 反常的，异常的 radi 光线 radical adj. 基本的，激进的 serv 保持 conserve vt. 保护，保藏 -ence essence n. 本质；精髓，精华 -ial ……的 initial adj. 最初的，开始的 -ous ……的 previous adj. 先的，以前的","raw":null,"content":null,"categories":[],"tags":[{"name":"CET6","slug":"CET6","permalink":"https://www.mingsrc.work/tags/CET6/"}]},{"title":"动态规划(自刷)","slug":"H_Coding/力扣自刷/DP动态规划","date":"2022-12-27T03:12:54.061Z","updated":"2022-12-27T03:12:54.061Z","comments":true,"path":"posts/14c322e6.html","link":"","permalink":"https://www.mingsrc.work/posts/14c322e6","excerpt":"题目列表最大上升子序和\n最大子序和\n最长回文子串\n不同路径\n最长回文子序列\n正则表达式匹配","text":"题目列表最大上升子序和 最大子序和 最长回文子串 不同路径 最长回文子序列 正则表达式匹配 最大上升子序列和题目描述一个数的序列bi，当b1 &lt; b2 &lt; … &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …,aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 &lt;&#x3D; i1 &lt; i2 &lt; … &lt; iK &lt;&#x3D; N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和. 你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)。 输入描述:12输入包含多组测试数据。每组测试数据由两行组成。第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。 输出描述:1对于每组测试数据，输出其最大上升子序列和。 输入1271 7 3 5 9 4 8 输出118 解题思路从前往后依次计算当前位置的最大子序列和： ​ sum[当前位置] &#x3D; max( arr[当前位置] , sum[之前] + arr[当前位置]) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt; arr; vector&lt;int&gt; sum; sum.resize(1000); int length, resMax = 0; cin &gt;&gt; length; while (!cin.eof() &amp;&amp; length--) &#123; int temp; cin &gt;&gt; temp; arr.push_back(temp); &#125; for (int end = 0; end &lt; arr.size() - 1; end++) &#123; sum[end] = arr[end]; for (int first = 0; first &lt; end; first++) &#123; if (arr[first] &lt; arr[end]) &#123; sum[end] = max(sum[end] , arr[end]+sum[first]); &#125; &#125; resMax = max(resMax, sum[end]); &#125; for (auto it : sum) cout &lt;&lt; it &lt;&lt; &quot; &quot;; cout &lt;&lt; resMax &lt;&lt; endl; return 0;&#125; 最大子序和最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。`进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; sonSum(nums.size()); sonSum[0] = nums[0]; int res = sonSum[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; sonSum[i] = max(nums[i], sonSum[i - 1] + nums[i]); res = max(res, sonSum[i]); &#125; return res; &#125;&#125;; 最长回文子串5. 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 代码（时间复杂度高）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: string longestPalindrome(string str) &#123; //空字符串直接返回0 if (str.length() == 0) &#123; return str; &#125; //记录下manacher字符串的长度，方便后面使用 int len = (int)(str.length() * 2 + 1); //开辟动态数组chaArr记录manacher化的字符串 //开辟动态数组pArr记录每个位置的回文半径 char *chaArr = new char[len]; int* pArr = new int[len]; int index = 0; for (int i = 0; i &lt; len;i++) &#123; chaArr[i] = (i &amp; 1) == 0 ? &#x27;#&#x27; : str[index++]; &#125; //到此完成对原字符串的manacher化 //R是最右回文边界，C是R对应的最左回文中心，maxn是记录的最大回文半径 int R = -1; int C = -1; int maxn = 0; int start=0; //开始从左到右遍历 for (int i = 0; i &lt; len; i++) &#123; //第一步直接取得可能的最短的回文半径，当i&gt;R时，最短的回文半径是1，反之，最短的回文半径可能是i对应的i&#x27;的回文半径或者i到R的距离 pArr[i] = R &gt; i ? min(R - i, pArr[2 * C - i]) : 1; //取最小值后开始从边界暴力匹配，匹配失败就直接退出 while (i + pArr[i]&lt;len &amp;&amp; i - pArr[i]&gt;-1) &#123; if (chaArr[i + pArr[i]] == chaArr[i - pArr[i]]) &#123; pArr[i]++; &#125; else &#123; break; &#125; &#125; //观察此时R和C是否能够更新 if (i + pArr[i] &gt; R) &#123; R = i + pArr[i]; C = i; &#125; //更新最大回文半径的值 if(maxn&lt;pArr[i])&#123; maxn = pArr[i]; start=(i-maxn+1)/2; &#125; &#125; //记得清空动态数组哦 delete[] chaArr; delete[] pArr; return str.substr(start,maxn-1); &#125;&#125;; 解法二（动态规划） 建立dp[i][j]数组存入s[i:j]这个区间的字符是否是回文串 判断当前区间s[i:j]是否是回文串只需要判断当前s[i]==s[j] &amp;&amp; dp[i+1][j-1] 12345678910111213141516171819202122232425262728class Solution &#123;public:string longestPalindrome(string s) &#123; int n = s.size(); //建立dp数组 vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n)); string ans; for(int l = 0 ; l &lt; n; ++l) &#123; for (int i =0;i + l &lt; n; ++i) &#123; int j = i + l; if(l == 0) &#123; dp[i][j] = 1; &#125; else if(l == 1) &#123; dp[i][j] = (s[i] == s[j]); &#125; else &#123; dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i+1][j-1]); &#125; //如果发现长度更长的，则更新ans if(dp[i][j] &amp;&amp; l + 1 &gt; ans.size())&#123; ans = s.substr(i , l + 1); &#125; &#125; &#125; return ans;&#125;&#125;; 不同路径62不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 示例 1: 12345678输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例2： 12输入: m = 7, n = 3输出: 28 解法一：动态规划1234567891011121314151617181920212223class Solution &#123;public: int uniquePaths(int m, int n) &#123; //动态创建一个二维路径答案表 int **dp = (int **)malloc(sizeof(int *) * n); for (int i = 0; i &lt; n; i++) &#123; dp[i] = (int *)malloc(sizeof(int) * m); &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (i == 0 || j == 0) &#123; //最上一行或者最左一列 dp[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; &#125; return dp[n-1][m-1]; &#125;&#125;; 解法二：递归123456789101112131415161718192021static int a[101][101] = &#123; 0 &#125;;//静态变量放在class外面（类似全局变量），并初始化。class Solution &#123;public:int uniquePaths(int m, int n) &#123; if (m == 1 || n == 1) return 1; if (m == 2) return n; if (n == 2) return m; if (a[m][n] &gt; 0)//计算过就直接返回。 return a[m][n]; a[m - 1][n] = uniquePaths(m - 1, n); a[n][m - 1] = a[m - 1][n];//由于本题的对称性，可以直接复制到对称位置 a[m][n-1] = uniquePaths(m, n - 1); a[n - 1][m] = a[m][n - 1];//由于本题的对称性，可以直接复制到对称位置 a[m][n] = a[m - 1][n] + a[m][n-1]; return a[m][n];//递归法 &#125;&#125;; 最长回文子序列516. 最长回文子序列 给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。 示例 1: 12345输入:&quot;bbbab&quot;输出:4一个可能的最长回文子序列为 &quot;bbbb&quot;。 示例 2: 12345输入:&quot;cbbd&quot;输出:2一个可能的最长回文子序列为 &quot;bb&quot;。 状态转移123456if (s[i] == s[j]) // 它俩一定在最长回文子序列中 dp[i][j] = dp[i + 1][j - 1] + 2;else // s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？ dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); 代码12345678910111213141516171819class Solution &#123;public: int longestPalindromeSubseq(string s) &#123; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n,0)); for (int i = 0 ; i &lt; n; i++) dp[i][i] = 1; for (int i = n - 1; i &gt;= 0; i--)&#123; for (int j = i + 1; j &lt; n; j++)&#123; //状态转移方程 if (s[i] == s[j]) dp[i][j] = dp[i + 1][j-1]+2; else dp[i][j] = max(dp[i+1][j],dp[i][j-1]); &#125; &#125; return dp[0][n-1]; &#125;&#125;; 正则表达式匹配 10. 正则表达式匹配 强烈推荐大佬的讲解↓！！！ 作者：labuladong链接：https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: map&lt;string,bool&gt; memo; bool dp(string&amp; s, int i,string&amp; p,int j)&#123; int m = s.size(), n = p.size(); // base case if (j == n) &#123; return i == m; &#125; if (i == m) &#123; if ((n - j) % 2 == 1) &#123; return false; &#125; for (; j + 1 &lt; n; j += 2) &#123; if (p[j + 1] != &#x27;*&#x27;) &#123; return false; &#125; &#125; return true; &#125; // 记录状态 (i, j)，消除重叠子问题 string key = to_string(i) + &quot;,&quot; + to_string(j); if (memo.count(key)) return memo[key]; bool res = false; if (s[i] == p[j] || p[j] == &#x27;.&#x27;) &#123; if (j &lt; n - 1 &amp;&amp; p[j + 1] == &#x27;*&#x27;) &#123; res = dp(s, i, p, j + 2) || dp(s, i + 1, p, j); &#125; else &#123; res = dp(s, i + 1, p, j + 1); &#125; &#125; else &#123; if (j &lt; n - 1 &amp;&amp; p[j + 1] == &#x27;*&#x27;) &#123; res = dp(s, i, p, j + 2); &#125; else &#123; res = false; &#125; &#125; // 将当前结果记入备忘录 memo[key] = res; return res; &#125; bool isMatch(string s, string p) &#123; return dp(s,0,p,0); &#125;&#125;; 一和零 474. 一和零 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例 1： 1234输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3输出：4解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2： 123输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1输出：2解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。 代码123456789101112131415161718192021class Solution &#123;public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; int S = strs.size(); vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); for (int l = 0; l &lt; S; ++l) &#123; int zero = 0; int one = 0; for (int i = 0; i &lt; strs[l].size(); ++i) &#123; if (strs[l][i] == &#x27;0&#x27;) ++zero; else ++one; &#125; for (int i = m; i &gt;= zero; --i) &#123; for (int j = n; j &gt;= one; --j) &#123; dp[i][j] = max(dp[i][j], 1 + dp[i - zero][j - one]); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 思路 计算爬上n-1阶楼梯的方法数量。因为再爬1阶就到第n阶 计算爬上n-2阶楼梯体方法数量。因为再爬2阶就到第n阶 那么f(n)&#x3D;f(n-1)+f(n-2); 代码123456789101112int climbStairs(int n) &#123; if(n==0||n==1) return n; vector&lt;int&gt; dp(n); dp[0] = 1; dp[1] = 2; for(int i = 2;i &lt; n; i++) &#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n-1];&#125;","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.mingsrc.work/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"ipad访问🐾电脑文件","slug":"F_杂记/技巧/ipad访问电脑文件","date":"2022-12-27T03:12:54.060Z","updated":"2022-12-27T03:12:54.060Z","comments":true,"path":"posts/cdc0a7f6.html","link":"","permalink":"https://www.mingsrc.work/posts/cdc0a7f6","excerpt":"","text":"ipad访问电脑文件夹最终目标：ipad上可以访问电脑共享的文件夹 一、前提条件 ipad与电脑是在同一个局域网内 当然，你还得有一个pad 你还得知道你电脑账户名以及账户密码 二、设置共享文件夹 本文以share-folders文件夹为例 1. 设置共享文件夹(跟着步骤来) 右击文件夹 点击共享 选择被共享的用户，这里我选择ming Ming，选择用户之后点击右下角🀄共享(H)按钮即可 到这一步，共享文件夹就设置完毕了，如图所示 2. 查看windows的IP地址 按Win+R输入cmd，打开命令提示符（或者右击左下角按钮，点击运行) 输入ipconfig查看本机IP地址 如下图所示为我本人电脑的IP地址 3. 在ipad连接 打开文件，没有的可以去app store下载 点击文件右上角菜单栏··· 输入IP地址，然后点击连接 也就是2-3得到的地址 1smb://192.168.1.113 输入名称和密码（也就是你的windows用户和密码），点击下一步 注1：如果你电脑是中文名，那你就输入中文名即可 注2：用户名带空格的如果登录失败，可以删除空格再尝试一遍 三、连接成功如图所示，ipad文件已共享出现了我们刚才连接的网络位置，打开share-folders文件夹也能看到仅有的一张图片。同样的，在电脑的网络位置，点进去也能看到我们已经共享的文件夹。","raw":null,"content":null,"categories":[],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://www.mingsrc.work/tags/%E6%8A%80%E5%B7%A7/"},{"name":"杂记","slug":"杂记","permalink":"https://www.mingsrc.work/tags/%E6%9D%82%E8%AE%B0/"},{"name":"分享","slug":"分享","permalink":"https://www.mingsrc.work/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"软件分享","slug":"F_杂记/软件/AllOFSW","date":"2022-12-27T03:12:54.060Z","updated":"2022-12-27T03:12:54.060Z","comments":true,"path":"posts/a80b6d86.html","link":"","permalink":"https://www.mingsrc.work/posts/a80b6d86","excerpt":"","text":"Utools可能是Windows里边最好的快捷方式呼出工具了，个人使用非常顺手。具体看官网介绍吧！我只能说确实好用，也是把这个软件放在第一位的原因。 Everything全局搜索工具 TrayS绿色版任务栏透明居中软件 语雀多端协同笔记短剑 Mouse Without Borders局域网内多台主机键鼠共享 SpaceDesk局域网内多台主机屏幕共享 浏览器插件类油猴可以下载和使用各种脚本，目前已经有大量的脚本可以直接去下载使用，非常方便 微博图床可以建一个免费的专属于你个人的图床 infinity Pro一个极简风格的标签页 笔记类软件一款好用的markdown软件（可以配合百度云实现同步功能） https://typora.io/# 博客框架Hexo https://hexo.io/zh-cn/ 在线图片处理 https://www.yasuotu.com/ 快用工具（文档、视频、图片、文件解压缩、数据分析） https://www.fastools.cn/doc 奶牛快传（文件快传） https://cowtransfer.com/?utm_source=nicelinks.site PPT网站资源整合 https://www.hippter.com/?utm_source=nicelinks.site 标签生成器（shields.io） 语雀（在线笔记平台-阿里开发） https://www.yuque.com/dashboard","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Markdown用法","slug":"F_杂记/所见即所得","date":"2022-12-27T03:12:54.059Z","updated":"2022-12-27T06:48:26.897Z","comments":true,"path":"posts/2c291b4d.html","link":"","permalink":"https://www.mingsrc.work/posts/2c291b4d","excerpt":"","text":"Markdown介绍Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown语法的目标是：成为一种适用于网络的书写语言「易读易写」。并且Markdown兼容HTML。你可以使用HTML语言编写Markdown，如果你要部署你的个人博客，那这更是你必不可少的技能之一！！！ 强烈推荐typora这款markdown软件，谁用谁说好！ 一款优质的Markdown编辑器,不仅仅是Markdown 除此之外，如果你愿意花一点点时间来了解{ post_link } 简述Markdown常见用法在下面，我将简单介绍几个常用的markdown写法。希望大家写出更好的观看效果的文章。本文一些内容是属于Hexo下buttrerfly主题的内置标签。 大家可以自己下载Typora尝试一下markdown。 为什么推荐Typora,我归纳了以下几点： 一 “所见即所得”（即时渲染） 二 支持图床功能，配合PicGO可以实现图片的随用随传 ![Markdown](https://tva3.sinaimg.cn/large/0072YHp3ly1gk9x8gmzdlj30v904ddg1.jpg) 如下所示，右击图片就可以上传到PicGo指定的图床。真的很好用！！！ 三 Typora还支持将`md文件`导出为多种格式的文件，目前支持以下文件: 四 如果你还会一点CSS,那你甚至可以自定义界面样式 ![Markdown](https://tva4.sinaimg.cn/large/0072YHp3ly1gk9xloodttj306i0d1gls.jpg) 下面我将从以下这几个方面介绍一下Typora的一些使用方法： - [字体](#字体) ` （小 大）` - [斜体](#斜体) ` *斜体*` - [粗体](#加粗) ` **粗体**` - [斜体 + 粗体](#斜体加粗) ` ***斜体+粗体\\***` - [删除](#删除) `~~原价：99.9元~~` - [链接](#链接) `[http://www.jianshu.com](https://www.jianshu.com)` - [分割线](#分割线) - [下划线](#下划线) - [标题](#标题) - [任务列表](#任务列表) - [图片](#图片) - [区块引用](#区块引用) - [行内代码](#行内代码) \\`markdown\\` - [列表](#列表) - [表格](#表格) - [脚注](#脚注) - [高亮](#高亮) - [目录](#目录) ## 字体 123&lt;small&gt;小号字体&lt;/small&gt;&lt;big&gt;大号字体&lt;/big&gt;&lt;div style=&quot;text-align:center;&quot;&gt;&lt;font color=rgb(25,26,35) face=&quot;华文彩云&quot; size=100px style=&quot;text-align:center&quot;&gt;其他快捷方式&lt;/font&gt;&lt;/div&gt; | 属性 | 值 | 描述 | | ----- | ------------------------------ | ----------------------------------- | | color | rgb();#XXXXXXcolorname | 规定文本的颜色，可以使用`style`代替 | | face | font_family | 规定文本的字体 | | size | number | 规定文本的大小 | 小号字体 大号字体 其他快捷方式 ## 斜体 西方斜体这一习惯看个人喜好吧。在文字前后各加一个`*`就👌了 1*斜体* 效果如下： *斜体* ## 加粗 在文字前后各加两个`**`就👌了 1**加粗** 效果如下： **加粗** ## 斜体加粗 斜体文字前后各加`*`，加粗文字前后各加`**`，斜体加粗在文字前后加`***`。没毛病... 1***斜体加粗*** 效果如下: ***斜体加粗*** ## 删除 1~~content~~ 效果如下： ~~content~~ ## 链接 链接应该是使用最多的场景了。他人有好的文字或者自己摘自哪里、都可以传送门直接过去。 12[网站名](地址)地址 效果如下： [example@163.com](mailto:example@163.com) http://www.baidu.com ## 分割线 12341 ****2 *****3 ---以上三种写法都可以，效果一样，看个人心情使用。 **** ***** --- ## 下划线 1&lt;u&gt;内容&lt;/u&gt; 内容 ## 标题 123# 一级标题···###### 六级标题 //最多支持六级标题 效果如下： 一级标题 六级标题 任务列表格式： 12 - [] 待完成- [X] 已完成 效果如下： [ ] 待完成 [X] 已完成 图片格式为![]() 其中图片名称可以为空。直接输入[]就可以。下面我的url输入的直接就文字url。所以肯定是空图片啦。Typora也可以直接把电脑本地的图片拖进来，自动生成图片链接。 1![图片名](URL) 区块引用代码块，使用’`‘和~都可以 123```代码``` 效果如下： 1代码 行内代码程序猿引用代码，或者是文章中有一些关键性的名词啊，或者为了突出醒目。效果不错。 1`printf(&quot;test&quot;)` 效果如下： printf(&quot;test”); 列表 1234567- 无序项目1* 无序项目2+ 无序项目3 - 无序二级1 - 无序二级21. 有序标题 1. 无序二级标题 无序项目1 无序项目2 无序项目3 无序二级1 无序二级2 有序标题 无序二级标题 表格ctrl+t更方便 1234| 第一格表头 | 第二格表头 || -------------------------------- | ---------------------- || 内容单元格 第一列第一格 | 内容单元格第二列第一格 || 内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 | 效果如下: 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 脚注H~2~o效果预览—&gt;H~2~o 高亮1&lt;mark&gt;content&lt;/mark&gt; &lt;mark&gt;标签支持全局属性，因此可以通过自定义style修改mark的样式。 参考这个↓： HTML参考手册|编程字典 12&lt;mark&gt;原始样式&lt;/mark&gt;&lt;mark style=&quot;font:&#x27;微软雅黑&#x27;;color:red;font-weight:900&quot;&gt;CSS样式&lt;/mark&gt; 原始样式CSS样式 目录代码 1[toc] 在typora输入[toc]即可生成内容目录","raw":null,"content":null,"categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.mingsrc.work/tags/Markdown/"}]},{"title":"windows Terminal 打开 Git Bash","slug":"F_杂记/工作方式/Windows Terminal & GitBase","date":"2022-12-27T03:12:54.059Z","updated":"2022-12-27T03:12:54.059Z","comments":true,"path":"posts/352e7838.html","link":"","permalink":"https://www.mingsrc.work/posts/352e7838","excerpt":"","text":"添加Bash到环境变量中1. 添加git到环境变量这一步的目的是方便使用系统命令调用git bash。 ① 操作右击我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;Path-&gt;添加Git/bin路径即可 如图所示：找到bin目录后，将其添加到path目录 ② 验证Win+R输入Bash能打开Git则说明添加到环境变量成功。 2. 修改Windows Terminal配置打开Windows Terminal进入到设置界面，然后点击左下角打开Json文件，在Json文件中找到Profile对象，然后在其子对象list中添加下述代码即可。 12345678910111213141516&#123; &quot;acrylicOpacity&quot; : 0.75, &quot;closeOnExit&quot; : true, &quot;colorScheme&quot; : &quot;Campbell&quot;, &quot;commandline&quot; : &quot;bash.exe&quot;, &quot;cursorColor&quot; : &quot;#FFFFFF&quot;, &quot;cursorShape&quot; : &quot;bar&quot;, &quot;fontFace&quot; : &quot;Consolas&quot;, &quot;fontSize&quot; : 12, &quot;historySize&quot; : 9001, &quot;name&quot; : &quot;git-bash&quot;, &quot;padding&quot; : &quot;0, 0, 0, 0&quot;, &quot;snapOnInput&quot; : true, &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot;, &quot;useAcrylic&quot; : true&#125; 关于Icon，可以邮件下载下边这张图，下载后修改后缀名为ico,在上述代码中添加Icon字段即可： 1&quot;icon&quot;: &quot;图片路径\\\\git-for-windows.ico&quot; 补充 添加主题代码直接复制替换Json配置文件中的schemes字段即可。 Windows Terminal 主题相关配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233&quot;schemes&quot;: [ &#123; &quot;background&quot;: &quot;#0C0C0C&quot;, &quot;black&quot;: &quot;#0C0C0C&quot;, &quot;blue&quot;: &quot;#0037DA&quot;, &quot;brightBlack&quot;: &quot;#767676&quot;, &quot;brightBlue&quot;: &quot;#3B78FF&quot;, &quot;brightCyan&quot;: &quot;#61D6D6&quot;, &quot;brightGreen&quot;: &quot;#16C60C&quot;, &quot;brightPurple&quot;: &quot;#B4009E&quot;, &quot;brightRed&quot;: &quot;#E74856&quot;, &quot;brightWhite&quot;: &quot;#F2F2F2&quot;, &quot;brightYellow&quot;: &quot;#F9F1A5&quot;, &quot;cursorColor&quot;: &quot;#FFFFFF&quot;, &quot;cyan&quot;: &quot;#3A96DD&quot;, &quot;foreground&quot;: &quot;#CCCCCC&quot;, &quot;green&quot;: &quot;#13A10E&quot;, &quot;name&quot;: &quot;Campbell&quot;, &quot;purple&quot;: &quot;#881798&quot;, &quot;red&quot;: &quot;#C50F1F&quot;, &quot;selectionBackground&quot;: &quot;#FFFFFF&quot;, &quot;white&quot;: &quot;#CCCCCC&quot;, &quot;yellow&quot;: &quot;#C19C00&quot; &#125;, &#123; &quot;background&quot;: &quot;#012456&quot;, &quot;black&quot;: &quot;#0C0C0C&quot;, &quot;blue&quot;: &quot;#0037DA&quot;, &quot;brightBlack&quot;: &quot;#767676&quot;, &quot;brightBlue&quot;: &quot;#3B78FF&quot;, &quot;brightCyan&quot;: &quot;#61D6D6&quot;, &quot;brightGreen&quot;: &quot;#16C60C&quot;, &quot;brightPurple&quot;: &quot;#B4009E&quot;, &quot;brightRed&quot;: &quot;#E74856&quot;, &quot;brightWhite&quot;: &quot;#F2F2F2&quot;, &quot;brightYellow&quot;: &quot;#F9F1A5&quot;, &quot;cursorColor&quot;: &quot;#FFFFFF&quot;, &quot;cyan&quot;: &quot;#3A96DD&quot;, &quot;foreground&quot;: &quot;#CCCCCC&quot;, &quot;green&quot;: &quot;#13A10E&quot;, &quot;name&quot;: &quot;Campbell Powershell&quot;, &quot;purple&quot;: &quot;#881798&quot;, &quot;red&quot;: &quot;#C50F1F&quot;, &quot;selectionBackground&quot;: &quot;#FFFFFF&quot;, &quot;white&quot;: &quot;#CCCCCC&quot;, &quot;yellow&quot;: &quot;#C19C00&quot; &#125;, &#123; &quot;background&quot;: &quot;#282C34&quot;, &quot;black&quot;: &quot;#282C34&quot;, &quot;blue&quot;: &quot;#61AFEF&quot;, &quot;brightBlack&quot;: &quot;#5A6374&quot;, &quot;brightBlue&quot;: &quot;#61AFEF&quot;, &quot;brightCyan&quot;: &quot;#56B6C2&quot;, &quot;brightGreen&quot;: &quot;#98C379&quot;, &quot;brightPurple&quot;: &quot;#C678DD&quot;, &quot;brightRed&quot;: &quot;#E06C75&quot;, &quot;brightWhite&quot;: &quot;#DCDFE4&quot;, &quot;brightYellow&quot;: &quot;#E5C07B&quot;, &quot;cursorColor&quot;: &quot;#FFFFFF&quot;, &quot;cyan&quot;: &quot;#56B6C2&quot;, &quot;foreground&quot;: &quot;#DCDFE4&quot;, &quot;green&quot;: &quot;#98C379&quot;, &quot;name&quot;: &quot;One Half Dark&quot;, &quot;purple&quot;: &quot;#C678DD&quot;, &quot;red&quot;: &quot;#E06C75&quot;, &quot;selectionBackground&quot;: &quot;#FFFFFF&quot;, &quot;white&quot;: &quot;#DCDFE4&quot;, &quot;yellow&quot;: &quot;#E5C07B&quot; &#125;, &#123; &quot;background&quot;: &quot;#FAFAFA&quot;, &quot;black&quot;: &quot;#383A42&quot;, &quot;blue&quot;: &quot;#0184BC&quot;, &quot;brightBlack&quot;: &quot;#4F525D&quot;, &quot;brightBlue&quot;: &quot;#61AFEF&quot;, &quot;brightCyan&quot;: &quot;#56B5C1&quot;, &quot;brightGreen&quot;: &quot;#98C379&quot;, &quot;brightPurple&quot;: &quot;#C577DD&quot;, &quot;brightRed&quot;: &quot;#DF6C75&quot;, &quot;brightWhite&quot;: &quot;#FFFFFF&quot;, &quot;brightYellow&quot;: &quot;#E4C07A&quot;, &quot;cursorColor&quot;: &quot;#4F525D&quot;, &quot;cyan&quot;: &quot;#0997B3&quot;, &quot;foreground&quot;: &quot;#383A42&quot;, &quot;green&quot;: &quot;#50A14F&quot;, &quot;name&quot;: &quot;One Half Light&quot;, &quot;purple&quot;: &quot;#A626A4&quot;, &quot;red&quot;: &quot;#E45649&quot;, &quot;selectionBackground&quot;: &quot;#FFFFFF&quot;, &quot;white&quot;: &quot;#FAFAFA&quot;, &quot;yellow&quot;: &quot;#C18301&quot; &#125;, &#123; &quot;background&quot;: &quot;#002B36&quot;, &quot;black&quot;: &quot;#002B36&quot;, &quot;blue&quot;: &quot;#268BD2&quot;, &quot;brightBlack&quot;: &quot;#073642&quot;, &quot;brightBlue&quot;: &quot;#839496&quot;, &quot;brightCyan&quot;: &quot;#93A1A1&quot;, &quot;brightGreen&quot;: &quot;#586E75&quot;, &quot;brightPurple&quot;: &quot;#6C71C4&quot;, &quot;brightRed&quot;: &quot;#CB4B16&quot;, &quot;brightWhite&quot;: &quot;#FDF6E3&quot;, &quot;brightYellow&quot;: &quot;#657B83&quot;, &quot;cursorColor&quot;: &quot;#FFFFFF&quot;, &quot;cyan&quot;: &quot;#2AA198&quot;, &quot;foreground&quot;: &quot;#839496&quot;, &quot;green&quot;: &quot;#859900&quot;, &quot;name&quot;: &quot;Solarized Dark&quot;, &quot;purple&quot;: &quot;#D33682&quot;, &quot;red&quot;: &quot;#DC322F&quot;, &quot;selectionBackground&quot;: &quot;#FFFFFF&quot;, &quot;white&quot;: &quot;#EEE8D5&quot;, &quot;yellow&quot;: &quot;#B58900&quot; &#125;, &#123; &quot;background&quot;: &quot;#FDF6E3&quot;, &quot;black&quot;: &quot;#002B36&quot;, &quot;blue&quot;: &quot;#268BD2&quot;, &quot;brightBlack&quot;: &quot;#073642&quot;, &quot;brightBlue&quot;: &quot;#839496&quot;, &quot;brightCyan&quot;: &quot;#93A1A1&quot;, &quot;brightGreen&quot;: &quot;#586E75&quot;, &quot;brightPurple&quot;: &quot;#6C71C4&quot;, &quot;brightRed&quot;: &quot;#CB4B16&quot;, &quot;brightWhite&quot;: &quot;#FDF6E3&quot;, &quot;brightYellow&quot;: &quot;#657B83&quot;, &quot;cursorColor&quot;: &quot;#002B36&quot;, &quot;cyan&quot;: &quot;#2AA198&quot;, &quot;foreground&quot;: &quot;#657B83&quot;, &quot;green&quot;: &quot;#859900&quot;, &quot;name&quot;: &quot;Solarized Light&quot;, &quot;purple&quot;: &quot;#D33682&quot;, &quot;red&quot;: &quot;#DC322F&quot;, &quot;selectionBackground&quot;: &quot;#FFFFFF&quot;, &quot;white&quot;: &quot;#EEE8D5&quot;, &quot;yellow&quot;: &quot;#B58900&quot; &#125;, &#123; &quot;background&quot;: &quot;#000000&quot;, &quot;black&quot;: &quot;#000000&quot;, &quot;blue&quot;: &quot;#3465A4&quot;, &quot;brightBlack&quot;: &quot;#555753&quot;, &quot;brightBlue&quot;: &quot;#729FCF&quot;, &quot;brightCyan&quot;: &quot;#34E2E2&quot;, &quot;brightGreen&quot;: &quot;#8AE234&quot;, &quot;brightPurple&quot;: &quot;#AD7FA8&quot;, &quot;brightRed&quot;: &quot;#EF2929&quot;, &quot;brightWhite&quot;: &quot;#EEEEEC&quot;, &quot;brightYellow&quot;: &quot;#FCE94F&quot;, &quot;cursorColor&quot;: &quot;#FFFFFF&quot;, &quot;cyan&quot;: &quot;#06989A&quot;, &quot;foreground&quot;: &quot;#D3D7CF&quot;, &quot;green&quot;: &quot;#4E9A06&quot;, &quot;name&quot;: &quot;Tango Dark&quot;, &quot;purple&quot;: &quot;#75507B&quot;, &quot;red&quot;: &quot;#CC0000&quot;, &quot;selectionBackground&quot;: &quot;#FFFFFF&quot;, &quot;white&quot;: &quot;#D3D7CF&quot;, &quot;yellow&quot;: &quot;#C4A000&quot; &#125;, &#123; &quot;background&quot;: &quot;#FFFFFF&quot;, &quot;black&quot;: &quot;#000000&quot;, &quot;blue&quot;: &quot;#3465A4&quot;, &quot;brightBlack&quot;: &quot;#555753&quot;, &quot;brightBlue&quot;: &quot;#729FCF&quot;, &quot;brightCyan&quot;: &quot;#34E2E2&quot;, &quot;brightGreen&quot;: &quot;#8AE234&quot;, &quot;brightPurple&quot;: &quot;#AD7FA8&quot;, &quot;brightRed&quot;: &quot;#EF2929&quot;, &quot;brightWhite&quot;: &quot;#EEEEEC&quot;, &quot;brightYellow&quot;: &quot;#FCE94F&quot;, &quot;cursorColor&quot;: &quot;#000000&quot;, &quot;cyan&quot;: &quot;#06989A&quot;, &quot;foreground&quot;: &quot;#555753&quot;, &quot;green&quot;: &quot;#4E9A06&quot;, &quot;name&quot;: &quot;Tango Light&quot;, &quot;purple&quot;: &quot;#75507B&quot;, &quot;red&quot;: &quot;#CC0000&quot;, &quot;selectionBackground&quot;: &quot;#FFFFFF&quot;, &quot;white&quot;: &quot;#D3D7CF&quot;, &quot;yellow&quot;: &quot;#C4A000&quot; &#125;, &#123; &quot;background&quot;: &quot;#000000&quot;, &quot;black&quot;: &quot;#000000&quot;, &quot;blue&quot;: &quot;#000080&quot;, &quot;brightBlack&quot;: &quot;#808080&quot;, &quot;brightBlue&quot;: &quot;#0000FF&quot;, &quot;brightCyan&quot;: &quot;#00FFFF&quot;, &quot;brightGreen&quot;: &quot;#00FF00&quot;, &quot;brightPurple&quot;: &quot;#FF00FF&quot;, &quot;brightRed&quot;: &quot;#FF0000&quot;, &quot;brightWhite&quot;: &quot;#FFFFFF&quot;, &quot;brightYellow&quot;: &quot;#FFFF00&quot;, &quot;cursorColor&quot;: &quot;#FFFFFF&quot;, &quot;cyan&quot;: &quot;#008080&quot;, &quot;foreground&quot;: &quot;#C0C0C0&quot;, &quot;green&quot;: &quot;#008000&quot;, &quot;name&quot;: &quot;Vintage&quot;, &quot;purple&quot;: &quot;#800080&quot;, &quot;red&quot;: &quot;#800000&quot;, &quot;selectionBackground&quot;: &quot;#FFFFFF&quot;, &quot;white&quot;: &quot;#C0C0C0&quot;, &quot;yellow&quot;: &quot;#808000&quot; &#125;, &#123; &quot;background&quot;: &quot;#FFFFFF&quot;, &quot;black&quot;: &quot;#073642&quot;, &quot;blue&quot;: &quot;#268BD2&quot;, &quot;brightBlack&quot;: &quot;#002B36&quot;, &quot;brightBlue&quot;: &quot;#949800&quot;, &quot;brightCyan&quot;: &quot;#93A1A1&quot;, &quot;brightGreen&quot;: &quot;#00BC00&quot;, &quot;brightPurple&quot;: &quot;#6C71C4&quot;, &quot;brightRed&quot;: &quot;#CB4B16&quot;, &quot;brightWhite&quot;: &quot;#FDF6E3&quot;, &quot;brightYellow&quot;: &quot;#657B83&quot;, &quot;cursorColor&quot;: &quot;#FFFFFF&quot;, &quot;cyan&quot;: &quot;#2AA198&quot;, &quot;foreground&quot;: &quot;#000000&quot;, &quot;green&quot;: &quot;#FFE79E&quot;, &quot;name&quot;: &quot;lwz_solarized_light&quot;, &quot;purple&quot;: &quot;#D33682&quot;, &quot;red&quot;: &quot;#DC322F&quot;, &quot;selectionBackground&quot;: &quot;#BFBFBF&quot;, &quot;white&quot;: &quot;#EEE8D5&quot;, &quot;yellow&quot;: &quot;#B58900&quot; &#125;]","raw":null,"content":null,"categories":[],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://www.mingsrc.work/tags/%E6%8A%80%E5%B7%A7/"},{"name":"杂记","slug":"杂记","permalink":"https://www.mingsrc.work/tags/%E6%9D%82%E8%AE%B0/"},{"name":"分享","slug":"分享","permalink":"https://www.mingsrc.work/tags/%E5%88%86%E4%BA%AB/"}]},{"title":"有书读 NO.1","slug":"F_杂记/分享/推荐一本书/《半小时漫画中国哲学史》","date":"2022-12-27T03:12:54.058Z","updated":"2022-12-27T03:12:54.058Z","comments":true,"path":"posts/2d110b49.html","link":"","permalink":"https://www.mingsrc.work/posts/2d110b49","excerpt":"","text":"《半小时漫画中国哲学史》虽然书名说的就是半个小时，但我是间隔这用了三天时间读了一下，从另一个角度来讲，我既是来陶冶一下最近烦躁的情绪；同时，也是因为在上党课时对哲学、批判思维的一种兴趣，发现这本书纯属意外。但确实值得推荐： ​ 1. 作者通过漫画的形式讲了中国哲学的一些内容； ​ 2. 诙谐幽默的讲述为本就枯燥的内容平添色彩，内容方面图一乐，毕竟好多知识课本里边都学过，但值得学习的是作者叙述的风格和语言的组织，以及文中不间断的插画内容，思维确实有趣 .card--11 .card__img1, .card--11 .card__img--hover1 { background-image: url(\"https://cdn.jsdelivr.net/gh/fole-del/img/imgservice.suning.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg\"); } .card__clock1 { vertical-align: middle; fill: #FFFFFF; } .card__time1 { color: #FFFFFF; vertical-align: text-bottom; } .card__clock-info1 { float: right; } .card__img1 { visibility: hidden; background-size: cover; background-position: center; background-repeat: no-repeat; width: 100%; height: 200px; border-top-left-radius: 12px; border-top-right-radius: 12px; } .card__info-hover1 { position: absolute; padding: 16px; width: 100%; opacity: 0; top: 0; } .card__img--hover1 { transition: 0.2s all ease-out; background-size: cover; background-position: center; background-repeat: no-repeat;width: 100%; position: absolute; height: 235px; border-top-left-radius: 12px; border-top-right-radius: 12px; top: 0; } .card1 { transition: all 0.4s cubic-bezier(0.175, 0.885, 0, 1); background-color: #fff; position: relative; border-radius: 12px; overflow: hidden; box-shadow: 0px 13px 10px -7px rgba(0, 0, 0, 0.1); transform: scale(0.9, 0.9); } .card1:hover { box-shadow: 0px 30px 18px -8px rgba(0, 0, 0, 0.1); transform: scale(1, 1); } .card__info1 { z-index: 2; background-color: #fff; border-bottom-left-radius: 12px; border-bottom-right-radius: 12px; } .card__category1 { text-transform: uppercase; font-size: 13px; letter-spacing: 2px; font-weight: 500; color: #868686; } .card__title1 { margin-top: 5px; margin-bottom: 10px; } .card__by1 { font-size: 12px; font-weight: 500; } .card__author1 { font-weight: 600; text-decoration: none; color: #ad7d52; } .card1:hover .card__img--hover1 { height: 100%; opacity: 0.1; } .card1:hover .card__info1 { background-color: transparent; position: relative; } .card:hover .card__info-hover1 { opacity: 1; } /** * CSS Locks * min viewport 576px * max viewport 1400px **/ .card1 { /* * min width = 300 * max width = 600 */ width: calc(300px + (600 - 300) * ((100vw - 576px) / (1400 - 576))); } .card__like1 { /* * min width = 18 * max width = 36 */ width: calc(36px + (36 - 18) * ((100vw - 576px) / (1400 - 576))); } .card__clock1 { /* * min width = 20 * max width = 40 */ width: calc(20px + (40 - 20) * ((100vw - 576px) / (1400 - 576))); } .card__time1 { /* * min font-size = 12 * max font-size = 24 */ font-size: calc(24px + (24 - 12) * ((100vw - 576px) / (1400 - 576))); margin-left: calc(5px + (10 - 5) * ((100vw - 576px) / (1400 - 576))); } .card__info1 { padding: calc(16px + (32 - 16) * ((100vw - 576px) / (1400 - 576))) calc(24px + (48 - 24) * ((100vw - 576px) / (1400 - 576))) calc(24px + (48 - 24) * ((100vw - 576px) / (1400 - 576))) calc(24px + (48 - 24) * ((100vw - 576px) / (1400 - 576))); } 链接直达 《半小时漫画中国哲学史》 古人都在思考些什么？ by 《半小时漫画中国哲学史》 一些文中的插画","raw":null,"content":null,"categories":[{"name":"杂记","slug":"杂记","permalink":"https://www.mingsrc.work/categories/%E6%9D%82%E8%AE%B0/"},{"name":"分享","slug":"杂记/分享","permalink":"https://www.mingsrc.work/categories/%E6%9D%82%E8%AE%B0/%E5%88%86%E4%BA%AB/"},{"name":"书籍","slug":"杂记/分享/书籍","permalink":"https://www.mingsrc.work/categories/%E6%9D%82%E8%AE%B0/%E5%88%86%E4%BA%AB/%E4%B9%A6%E7%B1%8D/"}],"tags":[{"name":"分享","slug":"分享","permalink":"https://www.mingsrc.work/tags/%E5%88%86%E4%BA%AB/"},{"name":"书单","slug":"书单","permalink":"https://www.mingsrc.work/tags/%E4%B9%A6%E5%8D%95/"},{"name":"好书","slug":"好书","permalink":"https://www.mingsrc.work/tags/%E5%A5%BD%E4%B9%A6/"}]},{"title":"《我的团长我的团》","slug":"F_杂记/分享/推荐一部剧/《我的团长我的团》","date":"2022-12-27T03:12:54.058Z","updated":"2022-12-27T03:12:54.059Z","comments":true,"path":"posts/f5df8c81.html","link":"","permalink":"https://www.mingsrc.work/posts/f5df8c81","excerpt":"","text":"我有眼泪给别人，但不愿 为自己痛哭；我没有使自己 适合于这世界，也没有美丽的 自辟的国土，就只好永远 渴望：为希望而生；在希望里 死去，终于承认了不知道 生命；接受了它又挥霍掉， 只是历史的工具，长路上的 一粒沙，所以拼命摆脱 那黑影，而他们因此讥笑我； 这就选择了寂寞，热闹的寂寞， 用笑声骗自己，漂浮在庸俗 生活的涡流里，而渐渐，我就说， 我是个庸俗主义者，无心痛哭。 ——杜运燮《赠友》 剧情简介1942年，中缅边境有座叫禅达的小镇。时不时受到炮火袭击的地方，聚集着一群来自五湖四海的溃兵。他们是小太爷孟烦了（张译 饰）、军医郝兽医（罗京民 饰）、东北佬迷龙（张国强 饰）、阿译长官（王往 饰）、湖南人不辣（王大治 饰）等。他们只求有吃的死不了，如同活死尸。这时，师 长虞啸卿（邢佳栋 饰）出现了，他想利用这群散兵重组川军团，空降缅甸参加战争。但到达战场的小分队面对的却是已成定局的溃败。最后剩下的孟烦了一行人被逼退到四面楚歌的小屋里。外面是不断靠近的日本兵，危机的最高点，拯救他们的是自称团长的龙文章（段奕宏 饰）。 龙文章其人，由来不明，不按常理出牌，却奇迹地带领着孟烦了一行人渡过怒江，回到了禅达。等待他们的不是嘉奖，而是看守。而龙文章则被发现根本不是什么团长，而是摘了军衔自己挂帅的中尉。就在大家都猜测龙文章凶多吉少时，龙文章不仅没死还被虞啸卿任命为川军团团长，但等待他们的是更深的漩涡…… 主演： 段奕宏 / 张译 / 张国强 / 邢佳栋 / 李晨 / 曹海涛 / 刘威葳 / 高峰 / 罗京民 / 王往 / 王大治 / 范雷 / 王迅 / 王东栋 / 刘天佐 / 谢孟伟 / 左腾云 / 赵志君 / 王大奇 / 袁菲 / 江奇翰 / 李泓良 / 杜建桥 / 张衡平 / 宿宇杰 / 马云 / 何杰 / 白恩 / 柯志凌 / 曹操 / 吴有才 / 哈斯其其格 / 史航 / 邓宝 / 陈思诚 / 张衍 / 李京 / 杨在景 / 李博 / 刁海明 / 兰晓龙 夸一夸&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🎉实在惊叹于演员演技的扎实和剧情的波澜起伏。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 看的过程中实在是有太多的感慨。既是军人，也是逃兵，也是英雄，对角色的塑立实在犹如神来之笔。但这还仅仅只是个开始，文中人物谈吐皆具深意，随性一首便是对处境、遭遇、生死的感慨，借用网友一句来形容，那就是： “拍摄如电影，表演似话剧，以远征军历史为背景，探讨鲁迅式的国民性以及哈姆莱特式的生存命题。” @抛书人 就像剧中有句话说的那样，这世上，没有哪个人经得起挑剔 豆瓣评价 剧照","raw":null,"content":null,"categories":[],"tags":[{"name":"分享","slug":"分享","permalink":"https://www.mingsrc.work/tags/%E5%88%86%E4%BA%AB/"},{"name":"好剧","slug":"好剧","permalink":"https://www.mingsrc.work/tags/%E5%A5%BD%E5%89%A7/"}]},{"title":"用MarkDown画图,你敢想？","slug":"F_杂记/分享/typora画图","date":"2022-12-27T03:12:54.057Z","updated":"2022-12-27T03:12:54.057Z","comments":true,"path":"posts/227fcf6f.html","link":"","permalink":"https://www.mingsrc.work/posts/227fcf6f","excerpt":"","text":"很早以前我就了解到了使用typora可以画图这件事，应该说是当我知道typora这个软件时，很大一部分程序上，typora这款软件极大的方便了我记录自己的学习笔记，发博客等，通过picGo，我可以方便快捷的使用github的免费存储空间。同时，我可以更快捷方便的通过hexo来发布我编辑的文章到我的博客。而当我了解到typora画图之后，似乎我又发现了新大陆，借此记录了自己学习typora画图的一些语法以及技巧，使用体验真的很好的画图软件——typora 1.流程图 2.时序图 3.状态图 4.类图 5.甘特图 流程图语法解释：graph 关键字就是声明一张流程图，TD 表示的是方向，这里的含义是 Top-Down 由上至下。 123456789graph LR; a[&quot;起点!&quot;]==粗线带文字==&gt;b; b&#123;菱形节点&#125;--&gt;c; a-.-虚线带文字-.-&gt;d((具有圆边的节点)); b---|不带箭头的线|e; e--带箭头的线--&gt;f; c&gt;非对称形状]--&gt;e; d--实现特殊字符--&gt;g[&quot;特殊字符:#9829;&quot;]; style a fill:lightblue,stroke:black,stroke-width:4px graph LR; a[&quot;起点!&quot;]&#x3D;&#x3D;粗线带文字&#x3D;&#x3D;&gt;b; b{菱形节点}--&gt;c; a-.-虚线带文字-.-&gt;d((具有圆边的节点)); b---|不带箭头的线|e; e--带箭头的线--&gt;f; c&gt;非对称形状]--&gt;e; d--实现特殊字符--&gt;g[&quot;特殊字符:#9829;&quot;]; style a fill:lightblue,stroke:black,stroke-width:4px 子图的语法规范123456789101112graph TB c1--&gt;a2 b1 --&gt; a subgraph one a1--&gt;a2 end subgraph two b1--&gt;b2 end subgraph three c1--&gt;c2 end graph TB c1--&gt;a2 subgraph one a1--&gt;a2 end subgraph two b1--&gt;b2 end subgraph three c1--&gt;c2 end 样式链接1234graph LR id1(Start)--&gt;id2(Stop) style id1 fill:#f9f,stroke:#333,stroke-width:4px style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5 graph LR id1(Start)--&gt;id2(Stop) style id1 fill:#f9f,stroke:#333,stroke-width:4px style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5 fontawesome12345graph TD B[&quot;fa:fa-twitter 和平&quot;] B--&gt;C[fa:fa-ban 禁止] B--&gt;D(fa:fa-spinner); B--&gt;E(A fa:fa-camera-retro 也许?); 时序图语法解释：-&gt;&gt; 代表实线箭头，--&gt;&gt; 则代表虚线。 1234567891011121314sequenceDiagram Alice-&gt;&gt;Jhon: 你好啊！ activate Jhon Jhon--&gt;&gt;+Alice: 你好，最近怎么样！ deactivate Jhon Alice-&gt;&gt;-Jhon: 挺好的，学了Typora画图，你呢？ loop every minute note over Alice,Jhon:数秒之后~~~ end par Jhon思考时间 rect rgb(100,215,180) Jhon--&gt;&gt;Jhon: 心理活动，我要不要也学一学#9829; end end 一些比较复杂的时序图： 123456789sequenceDiagram Alice -&gt;&gt; Bob: Hello Bob, how are you? Bob--&gt;&gt;John: How about you John? Bob--x Alice: I am good thanks! Bob-x John: I am good thanks! Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row. Note left of Alice: what does he think about? Bob--&gt;Alice: Checking with John... Alice-&gt;John: Yes... John, how are you? 状态图语法解释：[*] 表示开始或者结束，如果在箭头右边则表示结束。 1234stateDiagram [*]--&gt; s1 s1--&gt;s2 s2--&gt;[*] 类图语法解释：&lt;|-- 表示继承，+ 表示 public，- 表示 private，学过 Java 的应该都知道。 123456789101112131415161718192021classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck&#123; +String beakColor +swim() +quack() &#125; class Fish&#123; -int sizeInFeet -canEat() &#125; class Zebra&#123; +bool is_wild +run() &#125; 甘特图甘特图一般用来表示项目的计划排期，目前在工作中经常会用到。 语法也非常简单，从上到下依次是图片标题、日期格式、项目、项目细分的任务。 1234567891011121314151617gantt title 工作计划 3.8~3.12 dateFormat YYYY-MM-DD excludes weekends section 运控项目 Completed task :done, des1, 2021-03-06,2021-03-09 Active task :active, des2, 2021-03-09, 3d Future task :crit, des3, after des2, 5d Future task2 : des4, after des3, 5d section 站控项目 实现弹出式消息框 :a1, 2021-03-01, 2d 继续下一项目 :after a1, 2d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h 甘特图简单用法： 12345gantt apple :a, 2017-07-20, 30d banana :crit, b, 2017-07-23, 1d cherry :active, c, after b a, 1d 关于甘特图的input和output的format 在甘特图中有两个属性一个为dateFormat，用以控制甘特图时间的输入；另一个为axisFormat，用以控制甘特图输出时间的格式，两者均可以根据下边两个表来实现自定义的时间格式。 以下为input的dateFormat： 1234567891011121314151617181920Input Example Description:YYYY 2014 4 digit yearYY 14 2 digit yearQ 1..4 Quarter of year. Sets month to first month in quarter.M MM 1..12 Month numberMMM MMMM January..Dec Month name in locale set by moment.locale()D DD 1..31 Day of monthDo 1st..31st Day of month with ordinalDDD DDDD 1..365 Day of yearX 1410715640.579 Unix timestampx 1410715640579 Unix ms timestampH HH 0..23 24 hour timeh hh 1..12 12 hour time used with a A.a A am pm Post or ante meridiemm mm 0..59 Minutess ss 0..59 SecondsS 0..9 Tenths of a secondSS 0..99 Hundreds of a secondSSS 0..999 Thousandths of a secondZ ZZ +12:00 Offset from UTC as +-HH:mm, +-HHmm, or Z Example： 1dateFormat YYYY-MM-DD 这个是output的axisFormat： 123456789101112131415161718192021222324%a - abbreviated weekday name.%A - full weekday name.%b - abbreviated month name.%B - full month name.%c - date and time, as &quot;%a %b %e %H:%M:%S %Y&quot;.%d - zero-padded day of the month as a decimal number [01,31].%e - space-padded day of the month as a decimal number [ 1,31]; equivalent to %_d.%H - hour (24-hour clock) as a decimal number [00,23].%I - hour (12-hour clock) as a decimal number [01,12].%j - day of the year as a decimal number [001,366].%m - month as a decimal number [01,12].%M - minute as a decimal number [00,59].%L - milliseconds as a decimal number [000, 999].%p - either AM or PM.%S - second as a decimal number [00,61].%U - week number of the year (Sunday as the first day of the week) as a decimal number [00,53].%w - weekday as a decimal number [0(Sunday),6].%W - week number of the year (Monday as the first day of the week) as a decimal number [00,53].%x - date, as &quot;%m/%d/%Y&quot;.%X - time, as &quot;%H:%M:%S&quot;.%y - year without century as a decimal number [00,99].%Y - year with century as a decimal number.%Z - time zone offset, such as &quot;-0700&quot;.%% - a literal &quot;%&quot; character. Example: 1axisFormat %Y-%m-%d","raw":null,"content":null,"categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.mingsrc.work/tags/Markdown/"},{"name":"画图","slug":"画图","permalink":"https://www.mingsrc.work/tags/%E7%94%BB%E5%9B%BE/"}]},{"title":"Hexo 搭建博客","slug":"F_杂记/Hexo搭建博客","date":"2022-12-27T03:12:54.056Z","updated":"2022-12-27T03:12:54.056Z","comments":true,"path":"posts/b6159bfb.html","link":"","permalink":"https://www.mingsrc.work/posts/b6159bfb","excerpt":"","text":"使用hexo搭建博客首先安装 Node.js Mirror Node.js安装教程 Git - Downloading Package","raw":null,"content":null,"categories":[],"tags":[]},{"title":"git 测试文档","slug":"E_学习笔记/闲来无事/log","date":"2022-12-27T03:12:54.056Z","updated":"2022-12-27T03:12:54.056Z","comments":true,"path":"posts/3f6965b2.html","link":"","permalink":"https://www.mingsrc.work/posts/3f6965b2","excerpt":"","text":"本文档用于记录git命令及其结果期间每执行一步就会在本文档记录，通过编写本文档以及使用git+show log tag status命令可以帮你更快了解git的工作原理。 初始化仓库1234567mkdir git_repost_testcd git_repost_testgit init # 初始化文件git remote add origin git@gitee.com:fole-del/git-command-test-project.git #与远程仓库连接git pull --allow-unrelated-histories origin master # 从远程仓库拉文件初始化本地仓，本地仓=本地仓+远程仓git commit -m &quot;fix(fole-del):添加了log记录文档&quot;git tag V1.0 # 添加标签V1.0 自动化部署12345678910111213141516171819202122232425262728293031323334353637383940mkdir setting #添加setting文件夹cd setting #切换到setting文件夹touch autoHooks.bat #添加批处理文件，可以使用vim编辑vi autoHooks.bat---------------------------- # 添加框内代码到autoHooks.bat@echo offset &quot;curDir=%cd%&quot;echo -------------------------------set &quot;curDir=%curDir:setting=%&quot;set source=%cd%\\commit-msg.sampleset dest=%curDir%.git\\hooks\\commit-msgecho %source%echo %dest%copy &quot;%source%&quot; &quot;%dest%&quot;echo -----------------------------------------------------------touch commit-msg #创建commit-msg文件----------------------------- # 添加框内文件到commit-msg#!/bin/bash#!/bin/bashMSG=`awk &#x27;&#123;printf(&quot;%s&quot;,$0)&#125;&#x27; $1`if [[ $MSG =~ ^(feat|fix|test|refactor|docs|style|chroe)\\(.*\\):.*$ ]]then echo -e &quot;\\033[32m commit success! \\033[0m&quot;else echo -e &quot;\\033[31m Error: the commit message is irregular \\033[m&quot; echo -e &quot;\\033[31m Error: type must be one of [feat,fix,docs,style,refactor,test,chore] \\033[m&quot; echo -e &quot;\\033[31m eg: feat(文件): add the user login \\033[m&quot; exit 1fi-----------------------------./autoHooks.bat # 执行批处理命令git tag V1.01 # 因为配置了部署，加一个标签 使用develop分支开发Git分支管理策略 develop分支_黄昏的大树-CSDN博客 关于develop分支的介绍可以看上述链接的博客。 123456789101112git checkout -b develop master # 从master分支创建develop分支并切换到develop分支cd .. # 退到上一级git add * # 把刚才创建的setting文件夹以及随时更改的本文档（log.md）添加到缓存区git status # 查看本地仓库 该命令用于查看在你上次提交之后是否有对文件进行再次修改git tags &quot;setting&quot; # 添加setting标签git commit -m &quot;fix(setting):自动化部署&quot;---------------------------------------------------# 接下里合并develop分支到mastter分支git checkout master #切换到master分支，此时文档变为创建develop分支时的状态git merge --no-ff develop #此时应该会看到提示，并且log.md文档内容修改为你刚才在develop分支最后保存的状态git push # 提交到远程仓库git push origin --tags # 将本地的所有标签一次性提交到远程仓库 使用feature分支关于feature分支不明白的可以看这篇文章柳暗花明又一村 之后的命令就会减少注释了，不懂得可以自己查阅 12345678910git checkout developgit checkout -b feature-sayHello developtouch main.cppvi main.cpp # 随便写点什么都行git add main.ppgit tag V1.02# 删除分支git branch -D develop# 删除远程分支git branch --delete develop git merge在feat分支的main.cpp文件中添加一段代码： 1234int intConflit()&#123; cout &lt;&lt; &quot;conflict testing&quot;; return 1;&#125; 写完保存，然后执行git命令提交本次修改： 123git add *git commit -m &quot;merge test --conflit&quot;git checkout master 切换到master分支后也修改main.cpp文件，随便增加一个函数 1234void testConflict()&#123; cout &lt;&lt; &quot;测试conflict&quot; &lt;&lt; endl; cout &lt;&lt; &quot;这里是增加了一行代码&quot; &lt;&lt; endl;&#125; 然后也提交本次修改，再执行merge，来看一下main.cpp发生了什么变化： feat分支与master分支的修改合并了HEAD下之后等号之前显示当前分支代码的改变，feat之前等号之后显示的分支改变合并到当前分支的内容。 这里推荐一个vscode的插件GitLens，借助插件可以选择保留current change|incoming change|both change|compare change，方便你分支的合并 Current change Incoming change Both change compare change 提交标签 123git push origin v1.02# 提交所有标签👇git push origin tags","raw":null,"content":null,"categories":[],"tags":[]},{"title":"自动化部署项目hook","slug":"E_学习笔记/闲来无事/自动化部署项目hooks","date":"2022-12-27T03:12:54.056Z","updated":"2022-12-27T03:12:54.056Z","comments":true,"path":"posts/7b9b5177.html","link":"","permalink":"https://www.mingsrc.work/posts/7b9b5177","excerpt":"","text":"在研究如何更好使用git log的过程中，学习了很多非常强有力的技能，这些技能极大地方便了我们对项目的管理，更好、更加规范、更加流程的帮助我们管理一个项目从开发到维护的过程。😛 看到一篇文章，讲了关于git commit的信息填写的格式进行规范。git 的 hook 操作强大到难以置信，效率为王！ 文章中还讲到了如何使用自动化部署对项目团队中每个人的git commit进行规范，闲来无事玩两下，借着这篇文章，我就开始了并不是自动化的“自动化”，简单的几句代码，却是几个小时的尝试，从sample到批处理命令的编写，都是泪啊~~~ 其中关于如何获取文件路径的尝试也是耗费不少时间，尝试几次之后才得以成功。 前言首先列出期间我用到的几个网站，以便你操作的时候查阅相关的资料 批处理入门手册_w3cschool，w3c对于批处理的各个命令的解说挺详细的，但是排版太难看，实在是不忍下眼，但是作为手册，还是有参考的价值，“环境变量延迟扩展”一节对文件路径的修改与获取相对重要一点，可以先看一下。 批处理获取路径_weixin_30952103的博客-CSDN博客，这篇博客对批处理中文你的bat文件在e:/mybat/test.bat,则%0就是e:/mybat/test.bat, %~dp0是e:/mybat/。 关于钩子（hooks）钩子都被存储在 Git 目录下的 hooks 子目录中。 也即绝大部分项目中的 .git/hooks 。 当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。 这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。 所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或任何你熟悉的语言编写它们。 这些示例的名字都是以 .sample 结尾，如果你想启用它们，得先移除这个后缀。 sample文件在开头提及的那篇文章中关于commit-msg的代码已经有说明，感兴趣的同学可以自己去研究怎么写这个脚本。当然，除了commit-msg还有其他几个脚本用来规范你的项目部署。git hooks即git 钩子，都是以sample结尾的脚文件，存放在.git/hooks目录下。最终要做的事情也是将写好的脚本文件存放到hooks目录下。 如下图所示的smaple文件都可以通过自定义的形式实现相应的功能。 这里添加一个我从不知名博客找到的一段commit-msg的代码行： 1234567891011#!/bin/bashMSG=`awk &#x27;&#123;printf(&quot;%s&quot;,$0)&#125;&#x27; $1`if [[ $MSG =~ ^(feat|fix|test|refactor|docs|style|chroe)\\(.*\\):.*$ ]]then echo -e &quot;\\033[32m commit success! \\033[0m&quot;else echo -e &quot;\\033[31m Error: the commit message is irregular \\033[m&quot; echo -e &quot;\\033[31m Error: type must be one of [feat,fix,docs,style,refactor,test,chore] \\033[m&quot; echo -e &quot;\\033[31m eg: feat(user): add the user login \\033[m&quot; exit 1fi 批处理命令献上代码： 1234567rem autoSetHooks.bat@echo offset &quot;curDir=%cd%&quot;set &quot;curDir=%curDir:setting=%&quot;set source=%cd%\\commit-msg.sampleset dest=%curDir%.git\\hooks\\commit-msgcopy &quot;%source%&quot; &quot;%dest%&quot; 虽然只有短短几行代码，但却费了我不少时间。唯一的功能也很简单，主要就是copy命令，将同路径下的commit-msg.sample拷贝到.git\\hooks\\路径下。 如果你看懂了批处理链接中关于环境变量延迟扩展，那么上述代码就是一个简单的Hello World~ 如果你没看也无妨，关键的几句代码我会说明一下： set &quot;curDir=%cd%&quot; 打开终端执行cd命令，屏幕输出和这里的%cd%是一致的，这句话的意思就是获取当前批处理程序的的路径保存到curDir变量中。 比较重要的一个操作就是:（冒号），在这里可以将:A=B理解为replace(A,B)，就是用B替换A。注：替换为空的话等号=后边就和第4行一样就行 确定source文件和destination之后执行copy命令就行。 最后，在clone项目到本地之后，找到上述批处理运行即可在.git/hooks/目录下生成commit-msg.sample文件。 感觉我的做法不是很标准，应该是在程序编译期间自动执行bat命令最好，这样就不用去特意运行一下批处理命令。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"杂记","slug":"学习笔记/杂记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.mingsrc.work/tags/git/"},{"name":"bat","slug":"bat","permalink":"https://www.mingsrc.work/tags/bat/"}]},{"title":"git命令手册💪_从新建项目开始","slug":"E_学习笔记/闲来无事/Git最全手册","date":"2022-12-27T03:12:54.055Z","updated":"2022-12-27T03:12:54.055Z","comments":true,"path":"posts/5487447e.html","link":"","permalink":"https://www.mingsrc.work/posts/5487447e","excerpt":"","text":"在写这篇文章期间发现了这么几个网站Git参考手册、Git教程™ (yiibai.com)，希望对你的学习有所帮助 git_新建项目并提交远程仓库💪先从最简单的说起，新手如何快速的新建项目并提交到仓库，以及当你本地有项目时，如何与远程空仓链接。 在本地项目所在文件夹执行git init 命令--&gt;会生成一个.git的隐藏文件夹 使用git add file命令将改变添加到暂存区，git add *是添加所有文件。 添加完毕后可以使用git commit -m &quot;注释&quot;将暂存区内容提交到仓库。如果已经关联了远程仓库，就可以执行push命令就行。如果是第一次为关联的情况，则需要绑定仓库。 登录仓库并创建仓库，这一步的目的是为了获取一个仓库的URL或者SSH，用来和本地关联； 获取SSH之后就可以继续绑定了。执行git remote add origin(远程仓库的别名，可以自己命名) ‘URL\\SSH’，就可以将本地与远程仓关联起来。 但是这时候如果你在新建仓库时选择了初始化文件，就会导致本地和远程仓文件不一致，实际上尽管已经关联，但是还是两个单独的仓库，因此需要一些初始化操作让本地和远程同步。建议就是把远程仓的东西拉到本地。 执行git pull origin master --allow-unrelated-histories就可以把远程仓的东西拉到本地。 将本地文件推送到远程仓库，使用git push origin master开始推送。 git push将当前分支推送至远程同名分支 git push origin [branch]:[branch]推送本地某分支至远程某分支 git push -u origin [branch]:[branch]推送本地某分支至远程某分支，并跟踪 当你查不多已经提交了几个项目之后，我想你就需要更多的一些使用方法帮助你更快的管理你的项目。以下是我在实际使用过程中的一些记录。仅供参考 git log最强命令合集git log可以说是你在提交或者查看项目时比较常用的一个命令，方便你快速的查看日志，配合参数使用更强大。 1. git log、2. git log -n、3. git log –start -n、4. 指定日期、关键字、作者、5. 查看某次commit做了哪些修改、 最强推荐版 1. git log - 查看历史提交记录 不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 2. git log -n 如果不想向上面那样全部显示，可以选择显示前N条。 3. git log -start -n 显示简要的增改行数统计,每次提交文件的变更统计，-n 同上，前n条，可省略。 4. 指定日志、关键字、作者 12345如两天前的提交历史：git log --since=2.days如指定作者为&quot;BeginMan&quot;的所有提交:$ git log --author=BeginMan如指定关键字为“init”的所有提交：$ git log --grep=init如指定提交者为&quot;Jack&quot;的所有提交：$ git log --committer=Jack注意作者与提交者的关系：作者是程序的修改者，提交者是代码提交人。 如指定2天前，作者为“BeginMan”的提交含有关键字’init’的前2条记录： 1git log --since=2.days --author=BeginMan --grep=init -2 5. 查看某次commit做了哪些修改 12git log #查看commit的历史git show &lt;commit-hash-id&gt; #查看某次commit的修改内容 最强推荐版 1git log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative 参考的stormZhang的教程： 效果炫酷，但是命令较长。但是，可以通过设置别名来使用： 1git config --global alias.lg &quot;log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit --date=relative&quot; 设置别名之后就可以通过git lg来调用上述自定义语句了，感兴趣的猿猿可以自己了解一下。 当然还有其他一些命令方便日志查询： git log --oneline git log --stat git log -p git shortlog git log --graph --oneline --decorate git branch常用命令 git branch 查看本地所有分支 git branch -r 查看远程所有分支 git branch -a 查看本地和远程的所有分支 git branch &lt;branchname&gt; 新建分支 git branch -d &lt;branchname&gt; 删除本地分支 git branch -d -r &lt;branchname&gt; 删除远程分支，删除后还需推送到服务器 git push origin:&lt;branchname&gt; 删除后推送至服务器 git branch -m &lt;oldbranch&gt; &lt;newbranch&gt; 重命名本地分支 分支补充 git checkout命令用于切换分支或恢复工作树文件。git checkout是git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。示例 1234git checkout master #(1)git checkout master~2 Makefile #(2)rm -f hello.cgit checkout hello.c #(3) （1）切换分支、（2）从另一个提交中取出文件、（3）从索引中回复hello.c git 常用命令 一 git show 命令用于显示各种类型的对象 git push -u origin master -f 强制推送 git 查看远程仓1git remote -v git commit emojiexample: 1git commit -m &quot;:tada: Initial commit&quot; | emoji | emoji 代码 | commit 说明 || :——————: | :—————————: | :————————–: | :–: || 🎨 (调色板) | :art: | 改进代码结构 &#x2F; 代码格式 || ⚡️ (闪电) 🐎 (赛马) | :zap: :racehorse: | 提升性能 || 🔥 (火焰) | :fire: | 移除代码或文件 || 🐛 (bug) | :bug: | 修复 bug || 🚑 (急救车) | :ambulance: | 重要补丁 || ✨ (火花) | :sparkles: | 引入新功能 || 📝 (备忘录) | :memo: | 撰写文档 || 🚀 (火箭) | :rocket: | 部署功能 || 💄 (口红) | :lipstick: | 更新 UI 和样式文件 || 🎉 (庆祝) | :tada: | 初次提交 || ✅ (白色复选框) | :white_check_mark: | 更新测试 || 🔒 (锁) | :lock: | 修复安全问题 || 🍎 (苹果) | :apple: | 修复 macOS 下的问题 || 🐧 (企鹅) | :penguin: | 修复 Linux 下的问题 || 🏁 (旗帜) | :checkered_flag: | 修复 Windows 下的问题 || 🤖（机器人） | :robot: | 修复 Android 下的问题 || 🍏 (绿苹果) | :green_apple: | 修复 iOS 下的问题 || 🔖 (书签) | :bookmark: | 发行 &#x2F; 版本标签 || 🚨 (警车灯) | :rotating_light: | 移除 linter 警告 || 🚧 (施工) | :construction: | 工作进行中 || 👷 (工人) | :construction_worker: | 添加 CI 构建系统 || 💚 (绿心) | :green_heart: | 修复 CI 构建问题 || ⬆️ (上升箭头) | :arrow_up: | 升级依赖 || ⬇️ (下降箭头) | :arrow_down: | 降级依赖 || 📌 (图钉) | :pushpin: | 将依赖项固定到特定版本 || 📈 (上升趋势图) | :chart_with_upwards_trend: | 添加分析或跟踪代码 || ♻️ （回收） | :recycle: | 重构代码 || 🐳 (鲸鱼) | :whale: | Docker 相关工作 || 🌐 (带子午线的地球仪) | :globe_with_meridians: | 国际化与本地化 || ➕ (加号) | :heavy_plus_sign: | 增加一个依赖 || ➖ (减号) | :heavy_minus_sign: | 减少一个依赖 || 🔧 (扳手) | :wrench: | 修改配置文件 || 🔨 (锤子) | :hammer: | 重大重构 || ✏️ (铅笔) | :pencil2: | 修复 typo || 💩 (粑粑…) | :hankey: | 写了辣鸡代码需要优化 || ⏪ (倒带) | :rewind: | 恢复更改 || 🔀 (交叉向右的箭头) | :twisted_rightwards_arrows: | 合并分支 || 📦 (包裹) | :package: | 更新编译的文件或包 || 👽 (外星人) | :alien: | 由于外部 API 更改而更新代码 || 🚚 (货车) | :truck: | 移动或者重命名文件 || 📄 (正面朝上的页面) | :page_facing_up: | 增加或更新许可证书 || 💥 (爆炸) | :boom: | 引入突破性的变化 || 🍱 (铅笔) | :bento: | 增加或更新资源 || 👌 (OK 手势) | :ok_hand: | 由于代码审查更改而更新代码 || ♿️ (轮椅) | :wheelchair: | 改善无障碍交互 || 💡 (灯泡) | :bulb: | 给代码添加注释 || 🍻 (啤酒) | :beers: | 醉醺醺地写代码… || 💬 (消息气泡) | :speech_balloon: | 更新文本文档 || 🗃 (卡片文件盒) | :card_file_box: | 执行与数据库相关的更改 || 🔊 (音量大) | :loud_sound: | 增加日志 || 🔇 (静音) | :mute: | 移除日志 || 👥 (轮廓中的半身像) | :busts_in_silhouette: | 增加贡献者 || 🚸 (孩童通行) | :children_crossing: | 优化用户体验、可用性 || 🏗 (建筑建造) | :building_construction: | 结构变动 || 📱 (iPhone) | :iphone: | 做响应式设计 || 🤡 (小丑脸) | :clown_face: | 嘲弄事物（直译，这个没明白） || 🥚 (鸡蛋) | :egg: | 增加彩蛋 || 🙈 (看不见邪恶) | :see_no_evil: | 增加或更改 gitignore || 📸 (照相机闪光灯) | :camera_flash: | 增加或更新截图 || ⚗️ (蒸馏器) | :alembic: | 尝试新东西 || 🔍 (放大镜) | :mag: | SEO 优化 || ☸️ (船的方向盘) | :wheel_of_dharma: | 关于 Kubernetes 的工作 || 🏷 (标签) | :label: | 增加类型（FLow、Typescript） |","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"杂记","slug":"学习笔记/杂记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.mingsrc.work/tags/git/"}]},{"title":"SVN学习笔记","slug":"E_学习笔记/闲来无事/SVN","date":"2022-12-27T03:12:54.055Z","updated":"2022-12-27T03:12:54.055Z","comments":true,"path":"posts/a7642b15.html","link":"","permalink":"https://www.mingsrc.work/posts/a7642b15","excerpt":"","text":"SVN版本控制系统（SubVersion）一、概述为什么要使用SVN系统控制软件？ 在遇到多版本时如何解决？SCM：软件配置管理 所谓的软件配置管理实际就是对软件源代码进行控制与管理 1. CVS：元老级产品 2. VSS：入门级产品 3. ClearCase：IBM公司提供技术支持 4. SVN：主流产品 什么是SVN SVN是近年来鹊起的版本管理工具，是CVS的接班人。目前，绝大多数软件公司都适用SVN作为代码版本管理软件。 ​ 特点： - 操作简单，入门容易 - 支持跨平台操作 - 支持版本回退功能（时间机器） 获取SVN软件属于C&#x2F;S结构软件（客户端与服务端） - 服务端软件网址 www.visualsvn.com - 客户端软件网址 www.tortoisesvn.com [下载网址](http://tortoisesvn.net/downloads) 二、SVN服务端安装SVN的工作流程 1、Checkout（检出）2、Update（更新）3、Commit（提交）服务器端安装（visualSVN)1、双击安装2、下一步选择带有可视化界面的，第二种情况只有Dos界面 3、仓库与端口设置location字符不要出现空格 SVN服务器项目配置1、创建一个项目​ 1. 首先在SVN服务端创建一个公有目录WebApp作为项目目录 在WebApp目录下创建Shop文件夹，作为Shop（版本仓库） 在SVN文件夹下创建WebApp文件夹 在WebApp文件夹下创建Shop文件夹 创建版本仓库，Dos环境基本语法 svnadmin create Shop 文件夹路径（Shop路径） 创建成功之后Shop文件目录下的文件结构 2、进行服务端监管Apache -&gt; http://loaclhost或（IP地址）访问到hedocs目录下的相关文件（监管） SVN -&gt; svn:&#x2F;&#x2F;localhost或（IP地址）访问到相关数据仓库（如Shop仓库） 基本语法：svnserve -d（后台运行） -r（监管目录） 版本仓库路径 如下图所示： 通过以上指令，我们的svn:&#x2F;&#x2F;loaclhost或者IP地址就可以直接指向Shop版本仓库。 3、权限控制默认情况下，SVN服务器是不允许匿名用户，上传文件到服务端的，所以必须更改项目的相关配置文件。 打开Shop/conf/svnserve.conf文件，修改第19行aanon-access字段的值为write。 三、SVN客户端安装1、获取安装包客户端有两个版本：32位和64位 2、确认操作系统位数右击电脑-&gt;属性就可以看到如下界面，确定自己的电脑是32位还是64位； 3、安装 双击安装包（TortoiseSVN） 同意许可，点击下一步 选择安装路径 下一步，install，系统将会自动安装SVN软件，单机Finish即可 注：安装完成之后，一定要重启计算机，否则SVN图标无法正常出现 安装成功之后，鼠标右键就会出现如下两个图标，代表我们已经成功安装 如果需要汉化包，安装完成之后只需要双击汉化包即可。 安装完成之后，在Setting之中选择设置语言即可： 使用客户端软件连接配置服务器 首先在你的项目目录鼠标右键 –&gt; TortoiseSVN –&gt; 版本库浏览器 –&gt; svn:&#x2F;&#x2F;localhost(输入svn服务器地址) svn:&#x2F;&#x2F;SVN服务器地址 –&gt; Shop项目（仓库） 打开隐藏功能，显示隐藏文件，就可以看到.svn文件，此时就已经与服务端建立了联系 四、SVN使用详解Checkout检出操作 连接到SVN服务器端 更新服务端数据到本地 注意：Checkout只在第一次链接时操作一次，以后如果进行更新操作使用Update（更新指令） Commit提交操作 提交本地数据到服务端 在Dos窗口使用svn -d -r 文件路径，鼠标右击出现上图，点击提交或者更新即可。 出现下图，说明项目上传完毕。 项目成员如何加入项目 检出 先创建自己的文件夹 –&gt; 在项目目录里边 –&gt; 鼠标右键 –&gt; Tortoise –&gt; 输入URL –&gt; 右键项目 –&gt; 检出即可 提交 当该项目成员需要上交文件时，执行Commit操作即可。 Update更新操作用于在别的项目组成员提交了文件或者数据之后更新到本地项目 五、SVN图标详解图标及含义 常规 当客户端文件与服务器端文件完全同步时，系统显示以上图标。 冲突 当客户端提交的文件与服务器端数据有冲突时，系统会显示以上图标。 已删除 当服务端数据已删除，那么客户端该文件将显示以上图标。 增加 当我们编写文件已添加到提交队列，那么系统将自动显示该图标。 无版本控制 当我们编写的文件没有添加到队列，那么系统将自动显示以上图标。 修改 当客户端文件有修改但未提交，此时将自动显示以上图标。 只读 当客户端文件以只读形式存在时，将自动显示以上图标。 锁定 当服务端数据已锁定，那么客户端文件将自动显示锁定图标。 忽略 客户端文件易忽略，不需要进行提交上传，那么将自动显示该图标。 忽略功能当你不需要将一些文件上传时，右击文件选择Tortoise中的忽略菜单即可忽略。 六、SVN使用详解三版本回退 什么是版本回退有些时候，软件的运行可能是开发者或使用者不满意，这时我们需要把当前版本退回到以前的某个版本。 传统的版本功能每一个版本都需要占用一定的内存空间。 v1.0 v2.0 v3.0 总计 100M 150M 200M 450M 但是SVN的存储机制只需要在原来的版本基础上添加即可 v1.0 v2.0 v3.0 总计 100M +50M +50M 200M 如何回到某个版本？在项目文件鼠标右击，选择Tortoise然后选择更新至二级菜单即可进行下一步如何更新的操作。 通过日志的形式 通过版本号的形式 七、版本冲突 通过安排不同开发时间解决 通过分配不同项目开发模块 通过SVN解决版本冲突问题 八、配置多仓库与权限控制1、配置多仓库在实际项目开发中，我么可能会同时开发多个项目，那么我们如何进行多项目监管呢？ 通过svnserver进项仓库监管，但是监管指令只能监管某一个文件夹，不能同时监管多个仓库。但是可以通过监管总目录达到监管所有仓库的目的。svnserver -d -r 文件路径 Shop项目：svn:&#x2F;&#x2F;loaclhost&#x2F;Shop Wechat项目：svn:&#x2F;&#x2F;localhost&#x2F;Wechat 2、权限控制如果要使用权限控制功能，必须先开启权限功能。 在每一个仓库中都有一个conf文件夹，里面有三个文件： authz文件：授权文件 告诉哪些用户具有哪些权限 passwd文件：认证文件 标识当前svn系统中某个仓库具有哪些用户以及 相应的密码 默认情况下，以上两个文件都是禁用的，如需要使用，首先要开启以上两个文件。 在svnserver.conf 配置文件中： 注释匿名用户的可读写权限# anon-access = write 开启认证文件与授权选线27行与36行 27行password-db = passwd 36行auth-db = authz","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"杂记","slug":"学习笔记/杂记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%82%E8%AE%B0/"}],"tags":[]},{"title":"hash冲突的四种解决办法","slug":"E_学习笔记/闲来无事/hash冲突的解决办法","date":"2022-12-27T03:12:54.055Z","updated":"2022-12-27T03:12:54.055Z","comments":true,"path":"posts/92bebae7.html","link":"","permalink":"https://www.mingsrc.work/posts/92bebae7","excerpt":"","text":"通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。下面以创建哈希表为例，说明解决冲突的方法。 hash冲突的四种解决办法哈希冲突 就是根据key即经过一个函数f(key)得到的结果的作为地址去存放当前的key value键值对(这个是hashmap的存值方式)，但是却发现算出来的地址上已经有人先来了。造成当前值无法存储的情况 一、开放定址法1Hi = (H(key) + di) MOD m，其中i=1,2,…,k(k&lt;=m-1) H(key)为哈希函数，m为哈希表表长，di为增量序列，i为已发生冲突的次数。其中，开放定址法根据步长不同可以分为3种： 1. 线性探查法简单地说，就是以当前冲突位置为起点，步长为1循环查找，直到找到一个空的位置，如果循环完了都占不到位置，就说明容器已经满了。举个栗子，就像你在饭点去街上吃饭，挨家去看是否有位置一样。 2. 平方探测法相对于线性探查法，这就相当于的步长为di &#x3D; i2来循环查找，直到找到空的位置。以上面那个例子来看，现在你不是挨家去看有没有位置了，而是拿手机算去第i2家店，然后去问这家店有没有位置。 3. 伪随机探测法：di&#x3D;伪随机序列这个就是取随机数来作为步长。还是用上面的例子，这次就是完全按心情去选一家店问有没有位置了。 但开放定址法有这些缺点： 这种方法建立起来的哈希表，当冲突多的时候数据容易堆集在一起，这时候对查找不友好； 删除结点的时候不能简单将结点的空间置空，否则将截断在它填入散列表之后的同义词结点查找路径。因此如果要删除结点，只能在被删结点上添加删除标记，而不能真正删除结点； 如果哈希表的空间已经满了，还需要建立一个溢出表，来存入多出来的元素。 二、链地址法将冲突位置的元素构造成链表。在添加数据的时候，如果哈希地址与哈希表上的元素冲突，就放在这个位置的链表上。 拉链法的优点： 处理冲突的方式简单，且无堆集现象，非同义词绝不会发生冲突，因此平均查找长度较短； 由于拉链法中各链表上的结点空间是动态申请的，所以它更适合造表前无法确定表长的情况； 删除结点操作易于实现，只要简单地删除链表上的相应的结点即可。 拉链法的缺点：需要额外的存储空间。 从HashMap的底层结构中我们可以看到，HashMap采用是数组+链表&#x2F;红黑树的组合来作为底层结构，也就是开放地址法+链地址法的方式来实现HashMap。 三、再哈希法1Hi = RHi(key), 其中i=1,2,…,k RHi()函数是不同于H()的哈希函数，用于同义词发生地址冲突时，计算出另一个哈希函数地址，直到不发生冲突位置。这种方法不容易产生堆集，但是会增加计算时间。 所以再哈希法的缺点是：增加了计算时间。 四、建立一个公共溢出区","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"杂记","slug":"学习笔记/杂记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"hash","slug":"hash","permalink":"https://www.mingsrc.work/tags/hash/"}]},{"title":"proto 学习记录（闲了再写）","slug":"E_学习笔记/网络通信/proto学习记录","date":"2022-12-27T03:12:54.054Z","updated":"2022-12-27T03:12:54.054Z","comments":true,"path":"posts/3d271314.html","link":"","permalink":"https://www.mingsrc.work/posts/3d271314","excerpt":"","text":"使用命令行生成proto文件 1proto -I ./ --cpp_out=./ proto文件","raw":null,"content":null,"categories":[],"tags":[]},{"title":"线程demo","slug":"E_学习笔记/线程/线程demo","date":"2022-12-27T03:12:54.053Z","updated":"2022-12-27T03:12:54.053Z","comments":true,"path":"posts/e6507a53.html","link":"","permalink":"https://www.mingsrc.work/posts/e6507a53","excerpt":"","text":"Demo of Thread苦于每次写就忘的经历，我又写了一个简单的没有质量的Demo，因为太闲了，写完这篇就开始刷题吧 三个文件，People.h,People.cpp,main.cpp。三个文件，两样东西，一个是People的类，一个是main函数调用线程。 People头文件及cpp文件 1234567891011121314151617181920212223242526272829// profile: People头文件#pragma once#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;Windows.h&gt;#include &lt;stdlib.h&gt;using namespace std;static int constructTimes = 0;static int copyTimes = 0;class People &#123;public: People(string str); People(const People &amp;mt); ~People(); void setName(string str); void startWork(int s); void endWork(int e); void calcWorkTime();private: string m_name; int m_start; int m_end;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// profile: people.cpp文件#include &quot;People.h&quot;People::People(string str) :m_name(str)&#123; constructTimes++; cout &lt;&lt; &quot;构造次数:&quot; &lt;&lt; constructTimes &lt;&lt; endl;&#125;People::People(const People &amp;mt) : m_name(mt.m_name)&#123; copyTimes++; cout &lt;&lt; &quot;构造次数:&quot; &lt;&lt; copyTimes &lt;&lt; endl;&#125;People::~People()&#123; cout &lt;&lt; this-&gt;m_name &lt;&lt; &quot; 调用了析构函数&quot; &lt;&lt; endl;&#125;void People::setName(string str)&#123; cout &lt;&lt; &quot;更换岗位开始,需等待片刻&quot; &lt;&lt; endl; int i; for (i = 0; i &lt; 3; i++) &#123; Sleep(1000); cout &lt;&lt; &quot;更换岗位ing……&quot; &lt;&lt; endl; &#125; this-&gt;m_name = str; cout &lt;&lt; str &lt;&lt; &quot; 设置工作成功,耗时&quot;&lt;&lt; i &lt;&lt;&quot;S&quot; &lt;&lt; endl;&#125;void People::startWork(int s)&#123; cout &lt;&lt; m_name &lt;&lt; &quot; 开始工作,开始时间：&quot; &lt;&lt; s &lt;&lt; endl; m_start = s;&#125;void People::endWork(int e)&#123; cout &lt;&lt; m_name &lt;&lt; &quot; 结束工作,开始时间：&quot; &lt;&lt; e &lt;&lt; endl; m_end = e;&#125;void People::calcWorkTime()&#123; cout &lt;&lt; m_name &lt;&lt; &quot; 的工作时长为：&quot;; cout &lt;&lt; m_end - m_start &lt;&lt; endl;&#125; 主函数文件 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;thread&gt;#include &quot;People.h&quot;class People;using namespace std;int main(int argc, const char * argv[])&#123; People p1(&quot;aaa&quot;); cout &lt;&lt; &quot;线程:&quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;开始&quot; &lt;&lt; endl; int startTime = 1,endTime; People *p1ptr = &amp;p1; // 这里如果使用的是p1,则允许setName函数内部修改值，但不会对外部影响 // 使用std::ref()不会调用拷贝构造函数，因为std::ref是引用传递，函数内部的修改影响外面，这里传的必须是指针 // 使用 std::cref() 相当于 std::const ref(),const 引用传递，函数内部不能修改 std::thread w1(&amp;People::setName, std::ref(p1ptr), &quot;bbb&quot;); std::thread w2(std::move(w1)); // 线程为w2开始运行setName,w1不再作为一个线程对象 bool w1Joinable = w1.joinable(); cout &lt;&lt; &quot;w1的joinable：&quot; &lt;&lt; w1Joinable &lt;&lt; endl; w2.detach(); // detach 是脱离主线程，单独在一个线程中进行，屏幕输出就会乱序 // w1.join() 是加入到线程 cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl; p1.startWork(1); for (auto i = 0; i &lt; 5; i++) &#123; Sleep(1000); cout &lt;&lt; &quot;工作ing……&quot; &lt;&lt; endl; endTime = i; &#125; p1.endWork(endTime); p1.calcWorkTime(); system(&quot;pause&quot;); return 0;&#125; 输出： 构造次数:1 线程:17668开始 更换岗位开始,需等待片刻w1的joinable： 0 ----------- aaa 开始工作,开始时间：1 工作ing…… 更换岗位ing…… 更换岗位ing…… 工作ing…… 更换岗位ing…… bbb 设置工作成功,耗时3S 工作ing…… 工作ing…… 工作ing…… bbb 结束工作,开始时间：4 bbb 的工作时长为：3 因为是detach()的方式，因此更换岗位与工作是异步进行的。也就是这是两个单独的线程在进行。","raw":null,"content":null,"categories":[],"tags":[{"name":"线程","slug":"线程","permalink":"https://www.mingsrc.work/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"线程相关概念","slug":"E_学习笔记/线程/线程相关基础概念","date":"2022-12-27T03:12:54.053Z","updated":"2022-12-27T03:12:54.053Z","comments":true,"path":"posts/de3574a2.html","link":"","permalink":"https://www.mingsrc.work/posts/de3574a2","excerpt":"","text":"进程与线程的概念进程：是表示资源分配的基本单位，又是调度运行的基本单位。 例如：用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I&#x2F;O设备等。然后。把该进程放入进程的就绪队列。进程调度程序选中它，为它分配CPU以及其它有关资源，该进程才真正运行。所以进程是系统中的并发执行的单位。 线程：是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。如果把线程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能的子任务之一。 例如：假设用户启动了一个窗口中的数据库应用程序，操作系统就将对数据库的调用表示为一个进程。假设用户要从数据库中产生一份工资单报表，并传到一个文件中，这是一个子任务；在产生工资单报表的过程中，用户又可以输入数据库查询请求，这又是一个子任务。这样，操作系统则把每一个请求——工资单报表和新输入的数据查询表示为数据库进程中的独立的线程。线程可以在处理器上独立调度执行，这样，在多处理器环境下就允许几个线程各自在单独处理器上进行。操作系统提供线程就是为了方便而有效地实现这种并发性。 多进程与多线程的区别 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复杂，需要用IPC；数据是分开的，同步简单 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 各有优势 内存、CPU 占用内存多，切换复杂，CPU利用率低 占用内存少，切换简单，CPU利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 适应于多核分布式 进程占优 优劣对比 优劣 多进程 多线程 优点 编程、调试简单，可靠性较高 创建、销毁、切换速度快，内存、资源占用小 缺点 创建、销毁、切换速度慢，内存、资源占用大 编程、调试复杂，可靠性较差 如何选择 需要频繁创建销毁的优先用线程 需要进行大量计算的优先使用线程 强相关的处理用线程，弱相关的处理用进程 可能要扩展到多机分布的用进程，多核分布的用线程 都满足需求的情况下，用你最熟悉、最拿手的方式","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"线程","slug":"学习笔记/线程","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://www.mingsrc.work/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"","slug":"E_学习笔记/数据库/Redis/redis","date":"2022-12-27T03:12:54.052Z","updated":"2022-12-27T03:12:54.052Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://www.mingsrc.work/posts/0","excerpt":"","text":"redis 3V+3高 大数据时代的3V：主是描述问题的 海量volume 多样variety 实时velocity 大数据时代的3高：主要是面向程序的 高并发 高扩展 高性能 de1","raw":null,"content":null,"categories":[],"tags":[]},{"title":"","slug":"E_学习笔记/数据库/Redis/数据架构层","date":"2022-12-27T03:12:54.052Z","updated":"2022-12-27T03:12:54.052Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://www.mingsrc.work/posts/0","excerpt":"","text":"数据架构层&#x3D;&#x3D;如果你未来是一个架构师，没有什么是加一层解决不了的！&#x3D;&#x3D; 1.商品的基本信息​ 王坚：推荐文章：&#x3D;&#x3D;阿里云的这群疯子&#x3D;&#x3D;-40分钟重要！ 2.商品的描述、评论​ 文档型数据库，mongoDB 3. 图片​ 分布式文件系统 FastDFS 淘宝自己的 TFS Google 的 GFS Hadoop HDFS 阿里云的 oss 4.商品的关键字（搜索） 搜索引擎 solr elasticsearch ISerach：多隆 所有牛逼的人都有一段苦逼的岁月！ 5.热门的波段信息 内存数据库 redis tair 、Memache 6. 商品的交易，外部的支付借口 三方应用 大型互联网应用问题： 数据类型太多了 数据源繁多，经常重构 数据要改造，大面积改革 $\\ LaTeX$ f = \\frac&#123;2 \\pi&#125;&#123;T&#125;$. 算大 1$\\ce&#123;CH4 + 2 $\\left( \\ce&#123;O2 + 79/21 N2&#125; \\right)$&#125;$","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Oracle重做日志文件","slug":"E_学习笔记/数据库/Oracle/重做日志文件","date":"2022-12-27T03:12:54.051Z","updated":"2022-12-27T03:12:54.051Z","comments":true,"path":"posts/30a326fd.html","link":"","permalink":"https://www.mingsrc.work/posts/30a326fd","excerpt":"","text":"重做日志文件重做日志文件时为了数据库恢复的物理文件，其中保存了数据库的变更操作信息。 一、概述重做日志文件(Redo Logfile)又被称为事务日志文件(Transaction Logfile)。 它对ORACLE数据库来说至关重要。ORACLE中每执行一条更新操作时，都会引起数据库的变化，因此都会生成一定数量的重做日志，他们将被记录到重做日志文件中。以便在数据库出现例程失败或介质故障时，可以利用重做日志文件来恢复数据库 重做日志文件是ORACLE三类文件中最为复杂的一类。在ORACLE 10G安装完毕后，会自动创建3个重做日志文件。 重做日志文件主要以重做记录的形式记录、保存对数据库所作的修改(或事务)。 如果在一段时间内只对数据库进行了查询操作，则不产生重做日志记录信息。 如果对一个表的数据进行了修改，并完成了事务的提交，这时数据文件只存储修改后的数据，但重做日志文件中要记录两类数据: 一类是修改前的数据； 一类是修改后的数据。 所以重做日志文件的管理方式与数据文件的管理方式有所不同。 二、作用与目的 重做日志文件在数据库的恢复过程中起着非常重要的作用，可以用来进行例程和介质恢复（其中介质恢复需要借助于归档日志文件），以及事务的撤销。 重做日志文件是为了数据库恢复的物理文件，其中保存了数据库的变更操作信息。 通过重做日志文件通常是通过重做（REDO）或者是回退（UNDO）实现的。 重做（REDO）就是有些原因到导致事务对数据库的操作的修改在写入数据文件之前丢失了，此时就可以利用重做日志文件做该事务对数据库的变更。 回退（UNDO）如果用户在事务提交之前想回滚事务，那么可以利用重做日志文件撤销事务对数据库所做的变更。 三、工作原理重做日志文件记录所有对数据的改变，并提供由系统或媒体失败带来的恢复机制。 每个数据库至少有两个重做日志文件，采用循环写的方式进行工作。这样就能保证当一个重做日志文件在进行归档时，还有另一个重做日志文件可用。当一个重做日志文件被写满后，后台进行就开始写下一个重做日志文件。当所有的重做日志文件都写满后，LGWR进程再重新开始写入第一个重做日志文件，开始新的循环。 通常LGWR进程再开始下一个重做日志之前要确定： 该重做日志文件中的所有重做记录所对应的变更操作结果必须全部写入数据文件中。如果数据库处于“归档模式”，要确定对该重做日志文件进行了归档。 重做日志写进程（LGWR）在任意时刻只能写一组重做日志组，LGWR后台进程正在写的重做日志组叫做当前重做日志组。 LGWR将完全相同的信息从重做日志缓冲区复制到改组的每个重做日志文件中。 LGWR是以循环的方式写重做日志组的，当写满一个重做日志组时，就会开始写下一组重做日志，这称为日志切换，当写满最后一组时，LGWR又开始写第一组重做日志。 这被称为日志切换 检查点操作也产生 信息被写入控制文件 如果数据库运行在归档模式下（oracle默认为非归档模式）,当LGWR的写操作从一个重做日志组切换到下一个重做日志组后，归档写进程（ARCH&#x2F;ARCH0）就会将原来的重做日志文件中的信息复制到归档日志文件中。 oracle服务器保证在归档写进程没有将重做日志文件中的信息复制到归档日志文件中之前，LGWR进程不能再写这组重做日志。 1. 重做日志文件的写入 为保证数据库是可以恢复的，写入重做日志文件时必须遵守如下两个原则： 写入的次序要严格按并发事务的执行次序； 必须先写入重做日志文件再写入数据文件。 循环写入 日志切换或日志序列号 检查点 2. 强迫日志切换和启动检查点 日志切换 可以使用ALTERSYSTEM SWITCH LOGFILE命令来启动 启动检查点 设置fast_start_mttr_target参数 ALTER SYSTEM CHECKPOINT命令 ALTER SYSTEM CHECKPOINT； 3. 启动检查点进程的时机 重做日志切换 即当一组重做日志写满时切换到下一组重做日志时。 关闭数据库 使用NORMAL，TRANSACTIONAL,IMMEDIATTE选项关闭数据库时，启动检查点。 表空间脱机或被设置成BACKUP模式 手动检查点 可以使用ALTER SYSTEM CHRCKPOINT手动设置一个检查点 时间检查点 每隔多长时间执行一次检查点。可以通过调整LOG_CHECKPOINT_TOMEOUT和LOG_CHECKPOINT_INTERVAL参数来改变检查点执行的间隔。调整时小心，不要让间隔时间太长，也不要添加不必要的检查点。 初始化参数LOG_CHECKPOINT_TO_ALTER 如果将设置成TRUE，则关于每个检查点的信息都将被记录到预警日志文件中。该参数默认值是FALSE，表示不记录检查点的信息。如果在预警日志文件中看到关于检查点没有完成的信息，就应该给数据库添加新的重做日志文件，这样会给检查点的完成提供更多的时间，也保证了检查点产生的不是很频繁。 四、概述重做日志文件的结构当写满一个重做日志组时，就会开始写下一组重做日志。当写满最后一组时，LGWR又开始写第一组重做日志。 重做记录 重做日志文件是由一条一条重做记录组成的，重做记录(REDO RECORD)是有一个个修改向量(CHANGE VECTOR)组成的。每个修改向量记录了对数据库中的某个数据块所作的修改。重做记录记录了可以用来对数据可进行恢复的所有修改的数据，包括回退段。因此，重做日志文件同样也会保护回退数据。当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。在ORACLE中，对数据库所作的修改实际上都是先在内存中进行的。当满足一定条件时先将修改操作产生的在SGA区的重做日志高速缓存中的修改结果，以重做记录的形式成批的写入重做日志文件中（此时就认为该事务已成功提交，因为此时可以进行事务的回退了，这种机制被称为“快速提交”，然后才将内存中的在SGA区的数据告诉缓存中的修改结构成批的写入数据文件进行永久保存。因此，只要某项修改操作的重做记录没有丢失，就可以通过重做记录来恢复该项的修改操作。在相应的数据提交之前，重做记录也可以被写入到重做日志文件中。如当SGA区的重做日志告诉缓存已经填满，或者提交了另一个事务，那么即使某些重做记录还没有提交，LGWR也会将重做日志缓存区中的所有重做记录全部写入到某个重做日志文件中，以便获得更多的空闲空间。这样，如果需要，ORACLE就可以回退这些修改了。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Oracle数据库","slug":"学习笔记/Oracle数据库","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]},{"title":"","slug":"E_学习笔记/数据库/Redis/NoSQL的四大分类","date":"2022-12-27T03:12:54.051Z","updated":"2022-12-27T03:12:54.052Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://www.mingsrc.work/posts/0","excerpt":"","text":"NoSQL的四大分类KV键值对：- 新浪：Redis - 美团：Redis + Tair - 阿里、百度：Redis + memecache 文档型数据库（bson格式和json一样）： MongoDB（一般必须要掌握） MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档！ MongoDB是一个介于关系型数据库和非关系型数据库中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的 ConthDB 列存数据库 HBase 分布式文件系统 图关系数据库","raw":null,"content":null,"categories":[],"tags":[]},{"title":"控制文件与重做日志文件","slug":"E_学习笔记/数据库/Oracle/实验三、控制文件和重做日志文件","date":"2022-12-27T03:12:54.050Z","updated":"2022-12-27T03:12:54.050Z","comments":true,"path":"posts/d6644a62.html","link":"","permalink":"https://www.mingsrc.work/posts/d6644a62","excerpt":"","text":"控制文件和重做日志文件主要是数字字典 控制文件 和重做日志文件的内容 1.启动SQL*Plus工具：确保iSQL*Plus应用服务器已经启动（一般默认安装都是自动启动），isqlplustcl start为启动iSQLPlus应用服务器的命令； 2.使用SQL*Plus的步骤 a.在浏览器中输入：http:localhost:5560&#x2F;isqlplus b.输入用户名密码 c.在iSQLPlus的工作区输入SQL语句，就像在SQLPlus中一样 3.Oracle实例的管理 3.1 初始化参数文件（Oracle数据库的最重要文件之一） 文件在本机的路径 G:\\oracle\\product\\10.1.0\\admin\\orcl\\pfile 4.格式化某字段的长度命令 ：col name for a15; 5.数据字典 查看表空间信息 dba_tablespaces 查看表空间存储位置及文件的名字等信息 dba_data_files 查看数据库系统上有多少用户和什么时候创建数据库的 dba_users 6.控制文件，重做日志，表空间文件的存储路径：本机G:\\oracle\\product\\10.1.0\\oradata\\orcl 7.控制文件及其引入目的：控制文件是数据库极其重要的文件，是一个比较小的二进制文件，它记载了物理数据库的当前状态 每一个控制文件只属于一个数据库，但为了防止控制文件的丢失，一个数据库不止一个控制文件。这些控制文件的内容完全 一样，我当前的数据库就有三个控制文件。实际的商用数据库至少两个一般三个控制文件，为了防止磁盘的物理故障，这些 文件最后放在不同的物理磁盘控制器上 在数据库装载或打开之前，Oracle服务器必须能够访问控制文件，当数据库在打开的状态下Oracle服务器会随时地修改控制 文件中的内容。任何用户，包括数据库管理员都不能修改控制文件中的数据 8.怎么查看控制文件的配置 SELECT type,record_size,records_total,records_used FROM v$controlfile_record_section; SELECT type,record_size,records_total,records_used FROM v$controlfile_record_section where type IN(&#39;DATAFILE&#39;,&#39;TABLESPACE&#39;,&#39;REDO LOG&#39;); 9.通过使用数据字典获取属性使用v\\$parameter来获取控制文件的名字 SELECT value FROM v\\$parameter WHERE name=&#39;control_files&#39;; 然后格式化显示 col name for a45; SELECT * FROM v$controlfile; 10.控制文件的备份 alter database backup controlfile to &#39;D:\\backup\\control.bak&#39;; 也可将控制文件备份到一个追踪文件中，改追踪文件已含重建控制文件的SQL语句 alter database backup controlfile to trace; 11.移动控制文件的实例 以下操作假定数据库没有使用服务器参数化文件（SPFLILE） 参看控制文件现有的配置 col name for a50 ; SELECT * FROM v$controlfile; 正常关闭数据库 shutdown immediate 拷贝文件 host copy G:\\oracle\\product\\10.1.0\\oradata\\orcl D:\\Disk3\\CONTROL01.CTL host copy G:\\oracle\\product\\10.1.0\\oradata\\orcl D:\\Disk6\\CONTROL02.CTL host copy G:\\oracle\\product\\10.1.0\\oradata\\orcl D:\\Disk9\\CONTROL03.CTL 启动数据库 startup 12.获取重做日志的信息 2个获取重做日志的信息的数据字典 v\\$log和v\\$logfile SELECT group#,sequence#,members,bytes,status,archived FROM v$log; col member for a50; SELECT * FROM v$logfile; 13.强制性产生重做日志切换的命令 ALTER SYSTEM SWITCH LOGFILE 14.强制性产生检查点的命令ALTER SYSTEM CHECKPIONT","raw":null,"content":null,"categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.mingsrc.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"数据库/Oracle","permalink":"https://www.mingsrc.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]},{"title":"创建数据库","slug":"E_学习笔记/数据库/Oracle/实验五、手动创建一个数据库","date":"2022-12-27T03:12:54.050Z","updated":"2022-12-27T03:12:54.050Z","comments":true,"path":"posts/6cc82a18.html","link":"","permalink":"https://www.mingsrc.work/posts/6cc82a18","excerpt":"","text":"手动创建一个数据库 1 要创建一个新的数据库，必须：（1）创建一个特权用户（超越数据库），用以下两种方式之一： a. 操作系统 b. 使用口令文件（2）启动实例所需的充足内存（3）有足够的磁盘空间 可以使用使用口令文件： 1&gt; orapwd 2 创建口令文件并设值SID12345&gt; orawpd file=d:\\oracle\\ora92\\database\\[fileName].ora password=admin entries=10;&gt; set oracle_sid=[userSid]example:&gt; orawpd file=d:\\oracle\\ora92\\database\\pwdming.ora password=admin entries=10;&gt; set oracle_sid=ming ming，按照自己的文件名和SID设置即可\" width=\"565\" data-width=\"565\" data-height=\"83\"> 3 配置相关文件 把 d:\\oracle\\ora92\\admin 中的sample文件中复制到 d：\\oracle\\admin下面，改名为 [fileName]，建议filename = [userSid],示例中的文件名是ming 编辑 ming文件夹下pfile\\initsmple.ora,改名为 init.ora,并修改以下参数： 1234567db_name=[username] #username为上一步配置的[UserSid]control_file=(“c:\\oracle\\oradate\\[fileName]\\control01.ctl”,”c:\\oracle\\oradata\\[fileName]\\contraol02.ctl”)db_block_size = 8192example:db_name=[username] #username为上一步配置的[UserSid]control_file=(“c:\\oracle\\oradate\\ming\\control01.ctl”,”c:\\oracle\\oradata\\ming\\contraol02.ctl”)db_block_size = 8192 之后再注释掉以下几个属性 ​ - text_enable ​ - job_queue_interval ​ - distributed_transactions. 到此属性修改完毕，保存之后复制当前文件~init.ora~。 在 c:\\oracle\\database 创建文件夹[fileName]^我的文件名是“ming”^ 把第二步复制的init.ora粘贴到 d:\\oracle\\ora92\\database中，改名为 initming.ora 文件名自定义，下一步会用到。 4 创建实例1234# [fileName]为3.4中的自定义文件名&gt; oradim –NEW-SID [userSid] -INTPWD admin -pfile c:\\oracle\\ora92\\database\\[fileName].ora example:&gt; oradim –NEW-SID ming -INTPWD admin -pfile c:\\oracle\\ora92\\database\\initdyf.ora. 5 创建spfile(必须先启动实例)以win7为例启动实例在开始-&gt;控制面板-&gt;管理工具-&gt;服务,然后找到你创建的实例点击启动或重新启动即可。 123&gt; conn sys/password as sysbdba&gt; shutdown immediate&gt; startup nomount pfile=&#x27;c:\\oracle\\ora92\\database\\initming.ora&#x27; 1&gt; create spfile=&#x27;c:\\oracle\\ora92\\database\\spfileming.ora&#x27; from pfile=&#x27;c:\\oracle\\ora92\\database\\initming.ora&#x27;; 1234567891011121314151617&gt; create database [databaseName] Maxlogfiles 10 Maxdatafiles 1024 Maxinstances 2 Datafile ‘c:\\oracle\\oradata\\ming\\system01.dbf’size 50m Logfile Group 1 ’c:\\oracle\\oradata\\ming\\red001.ora’ size 10m, Group 2 ’c:\\oracle\\oradata\\ming\\red002.ora’ size 10m;example:&gt; create database ming Maxlogfiles 10 Maxdatafiles 1024 Maxinstances 2 Datafile &#x27;c:\\oracle\\oradata\\ming\\system01.dbf&#x27; size 50m Logfile Group 1 (&#x27;c:\\oracle\\oradata\\ming\\red001.ora&#x27;) size 10m, Group 2 (&#x27;c:\\oracle\\oradata\\ming\\red002.ora&#x27;) size 10m; spfile创建语句建议手打~~~直接复制很可能会报错 在创建数据库时尝试好几次会出现这个错误： 此时如果再继续创建的话，又会报如下错误： 如果是上图错误（错误二），则可以尝试删除C:\\oracle\\oradta\\ming\\中创建的文件再次尝试是否可以成功创建。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Oracle数据库","slug":"学习笔记/Oracle数据库","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.mingsrc.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]},{"title":"C++连接oracle","slug":"E_学习笔记/数据库/Oracle/实验八、用C++连接数据库","date":"2022-12-27T03:12:54.050Z","updated":"2022-12-27T03:12:54.050Z","comments":true,"path":"posts/da132b8a.html","link":"","permalink":"https://www.mingsrc.work/posts/da132b8a","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Oracle数据库","slug":"学习笔记/Oracle数据库","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.mingsrc.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]},{"title":"Oracle数据类型","slug":"E_学习笔记/数据库/Oracle/Oracle数据类型","date":"2022-12-27T03:12:54.049Z","updated":"2022-12-27T03:12:54.049Z","comments":true,"path":"posts/2b739d38.html","link":"","permalink":"https://www.mingsrc.work/posts/2b739d38","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Oracle数据库","slug":"学习笔记/Oracle数据库","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]},{"title":"oracle创建用户、角色、授权、建表以及查看相应属性","slug":"E_学习笔记/数据库/Oracle/实验一、Oracle体系结构与框架","date":"2022-12-27T03:12:54.049Z","updated":"2022-12-27T03:12:54.049Z","comments":true,"path":"posts/1efa294c.html","link":"","permalink":"https://www.mingsrc.work/posts/1efa294c","excerpt":"orcale创建及配置角色，参数查看与设置\noracle的创建以及启动，角色的创建于授权等内容\n\n\n转载声明： https://www.cnblogs.com/roger112/p/7685307.html\n","text":"orcale创建及配置角色，参数查看与设置 oracle的创建以及启动，角色的创建于授权等内容 转载声明： https://www.cnblogs.com/roger112/p/7685307.html oracle创建用户、角色、授权、建表oracle数据库的权限系统分为系统权限与对象权限。系统权限( database system privilege )可以让用户执行特定的命令集。例如，create table权限允许用户创建表，grant any privilege 权限允许用户授予任何系统权限。对象权限( database object privilege )可以让用户能够对各个对象进行某些操作。例如delete权限允许用户删除表或视图的行，select权限允许用户通过select从表、视图、序列(sequences)或快照(snapshots)中查询信息。 每个oracle用户都有一个名字和口令,并拥有一些由其创建的表、视图和其他资源。oracle角色(role)就是一组权限(privilege)(或者是每个用户根据其状态和条件所需的访问类型)。用户可以给角色授予或赋予指定的权限，然后将角色赋给相应的用户。一个用户也可以直接给其他用户授权。 一、创建用户oracle内部有两个建好的用户：system和sys。用户可直接登录到system用户以创建其他用户，因为system具有创建别 的用户的 权限。 在安装oracle时，用户或系统管理员首先可以为自己建立一个用户。 语法[创建用户]： create user 用户名 identified by 口令[即密码]； 例子： create user test identified by test; 语法[更改用户]: alter user 用户名 identified by 口令[改变的口令]; 例子： alter user test identified by 123456; 二、删除用户语法：drop user 用户名; 例子：drop user test; 若用户拥有对象，则不能直接删除，否则将返回一个错误值。指定关键字cascade,可删除用户所有的对象，然后再删除用户。 语法： drop user 用户名 cascade; 例子： drop user test cascade; 三、授权角色oracle为兼容以前版本，提供三种标准角色（role）:connect&#x2F;resource和dba. （1）讲解三种标准角色： 1》. connect role(连接角色) –临时用户，特指不需要建表的用户，通常只赋予他们connect role. –connect是使用oracle简单权限，这种权限只对其他用户的表有访问权限，包括select&#x2F;insert&#x2F;update和delete等。 –拥有connect role 的用户还能够创建表、视图、序列（sequence）、簇（cluster）、同义词(synonym)、回话（session）和其他 数据的链（link） 2》. resource role(资源角色) –更可靠和正式的数据库用户可以授予resource role。 –resource提供给用户另外的权限以创建他们自己的表、序列、过程(procedure)、触发器(trigger)、索引(index)和簇(cluster)。 3》. dba role(数据库管理员角色) –dba role拥有所有的系统权限 –包括无限制的空间限额和给其他用户授予各种权限的能力。system由dba用户拥有 （2）授权命令 语法： grant connect, resource to 用户名; 例子： grant connect, resource to test; （3）撤销权限 语法： revoke connect, resource from 用户名; 列子： revoke connect, resource from test; 四、创建&#x2F;授权&#x2F;删除角色除了前面讲到的三种系统角色—-connect、resource和dba，用户还可以在oracle创建自己的role。用户创建的role可以由表或系统权限或两者的组合构成。为了创建role，用户必须具有create role系统权限。 1》创建角色 语法： create role 角色名; 例子： create role testRole; 2》授权角色 语法： grant select on class to 角色名; 列子： grant select on class to testRole; 注：现在，拥有testRole角色的所有用户都具有对class表的select查询权限 3》删除角色 语法： drop role 角色名; 例子： drop role testRole; 注：与testRole角色相关的权限将从数据库全部删除 oracle的启动关闭与属性查看修改启动和关闭数据库 展示相关参数select * from v$bgprocess where paddr&lt;&gt;’00’; select * from v$controlfile; 查参数是否都可以用此模糊查询 show parameter db_cache show parameter log 11) show parameter sga; 12)alter session set nls_language&#x3D;american; 13)alter system set db_cache_size&#x3D;16m; 14)select * from authers;15)show parameter db 16)alter system set db_cache_advice&#x3D;on; 17)show parameter log_bufffer18)select * from v$bgprocess where paddr&lt;&gt; ‘00’;19)archive log list &#x2F;&#x2F;看是否归档模式 20)commit &#x2F;&#x2F;LGWR写","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Oracle数据库","slug":"学习笔记/Oracle数据库","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]},{"title":"Oracle体系结构与组件","slug":"E_学习笔记/数据库/Oracle/Oracle体系结构与组件","date":"2022-12-27T03:12:54.048Z","updated":"2022-12-27T03:12:54.048Z","comments":true,"path":"posts/18cff4c7.html","link":"","permalink":"https://www.mingsrc.work/posts/18cff4c7","excerpt":"","text":"Oracle体系结构和组件 系统的体系结构决定了数据库如何使用内存、硬件和网络，以及哪个进程或程序运行在哪台机器上。Oracle数据库服务器有两个主要的组成部分：数据库和实例(instance)。Oracle数据库用于存储和检索信息，是数据的集合。Oracle实例是指数据库服务器的内存及相关处理程序。 图示并解释Oracle体系结构和组件Oracle体系结构如下图所示： 物理结构一个Oracle数据库的物理结构，是由为数据库信息提供真实屋物理存储的操作系统文件决定的。 控制文件 数据文件 重做日志文件 内存结构Oracle内存结构由两个存储区域组成： 系统全局区（System Global Area，SGA）：在实例启动时被分配，是Oracle实例的一个基本组件 程序全局区（Program Global Area，PGA）：在服务器进程启动时分配 系统全局区 SGA(系统全局区)包括共享池、数据库缓冲区高速缓存、重做日志缓冲区、Java池、大型共享池等（锁管理、统计数据）。 SGA能配置两个可选存储结构：大池和Java池 SGA是可变大小的,使用SGA_MAX_SIZE来设置大小 SGA组件分配SGA内存空间,并分割成更小的颗粒 分配连续的虚拟内存 基于SGA_ MAX_ SIZE来分配大小 1. 共享池(SHARE POOL) 共享池包括`库高速缓存`和`数据字典高速缓存`，共享池的主要作用和功能如下： 共享池是对SQL、PL&#x2F;SQL程序进行语法分析、编译、执行的内存区域。 共享池由库缓存和数据字典缓存组成。 库缓存含有最近执行的SQL、PL&#x2F;SQL语句的分析码和执行计划； 数据字典缓存含有从数据字典中得到的表、索引、列定义和权限等信息。共享池的大小直接影响数据库的性能。 共享池的大小由初始化参数shared_pool_size决定，该参数以KB或MB为单位。默认的大小为8MB。 查询语句：SQL &gt; show parameter shared_pool_size 用如下命令可以调整，参数为SHARED_POOL_SIZE： 12ALTER SYSTEM SETSHARED_POOL_SIZE = 64M; 2. 数据高速缓冲区(DATABASE BUFFER CACHE) 由最近最少使用（LRU）算法来管理 用于存储从磁盘数据文件中读入的数据，服务器进程将读入的数据保存在数据缓冲区中，当后续的请求需要这些数据时可以在内存中找到，不再从磁盘读取，提高了读取速度。 数据高速缓冲区中存放着Oracle系统最近使用过的数据库数据块。 数据缓冲区的大小对数据库的读取速度有直接的影响。 数据缓冲区直接由初始化参数文件中的DB_CACHE_SIZE参数决定，DB_ CACHE_ ADVICE能被设置为收集统计量,以预测不同高速缓存的大小调整 DB_BLOCK_SIZE用于定义标准块的大小 查询语句：SQL &gt; show parameter db 可以使用ALTER_SYSTEM动态调节大小，包括增加或减小 1ALTER SYSTEM SET DB_CACHE_SIZE 96M; 3. 重做日志缓冲区(REDO LOG BUFFER) 日志记录数据库的所有修改信息，日志信息首先产生于日志缓冲区。 当日志缓冲区的日志数据达到一定数量时，由后台进程将日志数据写入日志文件中。 在初始化参数文件中查询参数log_buffer。 查询语句：SQL &gt; show parameter log_buffer 4. 库高速缓存库高速缓存存储的是最，近使用过的SQL和PL &#x2F;SQL语句相关的信息。库高速缓存: 使得共同使用的语句可以共享 可由最近最少使用(LRU)算法来管理 由两种结构组成: 共享SQL区域 共享PL &#x2F;SQL区域 它的大小由 共享池大小的设置来决定 5. 数据字典高速缓存数据字典高速缓存是数据库中最近最多使用的定义的集合 它包 括数据库文件、表、索引、列、用户、特权和其它数据库对象的有关信息 在解析阶段，服务器进程查看数据字典,核对信息，以解析对象名，并验证存取 把数据字典信息高速缓存到内存,提高查询响应时间 大小由共享池大小的设置来决定 6. Java池(JAVA POOL) 存储JAVA命令服务分析要求 安装和使用JAVA时必须的 大小有JAVA_POOL_SIZE确定 6. 大型共享池(LARGE POOL) SGA可选的内存区 分担了共享池的一部分工作 用于共享服务器的UGA 用于I&#x2F;O服务器进程 备份和恢复操作或RMAN 并行执行消息缓冲区（前提PARALLEL_POOL_SIZE=TRUE） 不使用LRU列表 大小由LARGE_POOL_SIZE确定 1ALTER SYSTEM SET LARGE_POOL_SIZE = 64M; 程序全局区 除此之外，还有程序全局区(PGA)，是为每一个连接到Oracle数据库的用户进程预留的内存 1. 用户进程用户进程是一个程序，它请求与Oracle服务器的连接 它必须首先建立一个连接 它不直接与Oracle服务器进行交互 2. 服务器进程服务器进程是一个程序，它与Oracle服务器直接作用 它回应用户进程产生的调用。并返回结果 可能是独占的或共享的服务器 3. 后台进程硬盘和内存之间的关系被保持，并由Oracle的后台进程驱动： 必须的后台进程 DBWn PMON CKPT LGWR SMON RECO 可选的后台进程 ARCn LMON Snnn QMNn LMDn CJQ0 Pnnn LCKn Dnnn 1. 数据库写进程（DBWn）DBWn延迟写入数据文件,直到发生下列事件之一： 增量或正常检查点 灰数据缓冲区的数量达到阈值 进程扫描指定数量的块而无法找到任何空闲缓冲区时 出现超时 实时应用集群(Real Application Clusters, RAC)环境中出现ping请求 使一般表空间或临时表空间处于脱机状态 使表空间处于只读模式 删除或截断表 执行ALTER TABLESPACE表空间名BEGIN BACKUP操作 2. 日志写进程（LGWR）LGWR在下列情况下执行从重做日志缓冲区到重做日志文件的连续写入： 当提交事务时 当重做日志缓冲区的三分之一填满时 当重做日志缓冲区中记录了超过1 MB\\2MB的更改时 在DBWn将数据库缓冲区高速缓存中修改的块写入数据文件以前 每隔三秒 3. 系统监控（SMON） 实例恢复 前滚重做日志中的更改 打开数据库供用户访问 回滚未提交的事务处理 每三秒对自由空间的整理 对临时段的清空 4. 进程监控（PMON）进程失败后，后台进程PMON通过下面的方法进行清理： 回滚用户的当前事务处理 释放当前保留的所有表锁或行锁 释放用户当前保留的其它资源 重新启动已失效（死锁）的调度程序 5. 检查点Checkpoint（CKPT） 在检查点发信号给DBWn 使用检查点信息更新数据文件的标头 使用检查点信息更新控制 启动检查点的原因如下： 确保定期向磁盘写入内存中发生修改的数据块，以便在系统或数据库失败时不会丢失数据 缩短例程恢复所需的时间。只需处理最后一个检查点后面的重做日志条目以启动恢复操作 确保提交的所有数据在关闭期间均已写入数据文件 由CKPT写入的检查点信息包括检查点位置、系统更改号、重做日志中恢复操作的起始位置以及有关日志的信息等等。 注：CKPT并不将数据块写入磁盘，或将重做块写入联机重做日志。 6. 归档日志（ARCn） 可选的后台进程 设置ARCHIVELOG模式时自动归档联机重做日志 保留数据库的全部更改记录 4. QMNn会话内存(SESSION MEMORY)为保留会话变量以及与该会话相关的其它信息而分配的内存。对于共享服务器环境，该会话是共享的而不是专用的。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Oracle数据库","slug":"学习笔记/Oracle数据库","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]},{"title":"Oracle Undo","slug":"E_学习笔记/数据库/Oracle/Oracle回滚撤销","date":"2022-12-27T03:12:54.048Z","updated":"2022-12-27T03:12:54.048Z","comments":true,"path":"posts/7e1f6773.html","link":"","permalink":"https://www.mingsrc.work/posts/7e1f6773","excerpt":"","text":"Oracle回滚&#x2F;撤销 撤销数据是反转DML语句结果所需的信息。撤销数据通常被称为“回滚数据”，在过去的Oracle版本中，“回滚数据”和“撤销数据”可以交替使用，但从9i版本开始，这两个术语有所不同：功能相同，但管理方式不同。只要某个事务修改了数据，那么更新前的原有数据就会被写入一个回滚段或撤销段。回滚段在11g版本中依然存在，但从9i版本开始，Oracle数据库引入了可供选择的撤销段。Oracle强烈建议所有数据库都应当使用撤销段，回滚段只被保留用于向后兼容。 撤销管理Oracle数据库中，也设置了一个专门的存储空间，用来保存操作过程及被操作的数据，即撤销记录，以便提供撤销功能，即允许用户撤销对数据库所执行的最后操作。撤销表空间中创建撤销段，自动保存当前对数据库的操作，以便实现自动撤销管理，撤销该操作。 撤销表空间，也叫还原空间，Undo tablespace 自动撤销管理 undo_tablespace指定默认的撤销表空间 undo_retention指定撤销记录在撤销段中保留的时间 undo_management设置为auto，即使用的是自动撤销管理功能由系统来决定在undo表空间内开多少undo段Oracle服务器在UNDO表空间中，自动维护撤销数据 在system表空间中保留一个system回退段，以便存放和处理由Oracle系统事务产生的撤销数据。创建数据库时，运行sql.bsq脚本会自动创建system回退段，DBA不需要对它进行任何维护和管理，也不能删除它 撤销的目的与作用 ①事物的回退在Oracle数据库中，对数据库的操作被划分成事务，一个事务由一条或多条SQL语句组成。一个事务中的SQL语句要么都执行要么都不执行，即可以回退当用户回退一个事务时，Oracle使用撤销段中的撤销数据来撤销自从这个事务开始以来所发生的全部更改，并释放这个事务所涉及的表行上的任何锁，然后结束这个事务 ②读一致性 数据库的读操作不会妨碍写操作，而数据库的写操作也不会妨碍读操作 举例：如果在查询所有员工工资数据的同时有人修改了几个员工的工资数据，那么查询出来的所有员工的工资数据应该是修改前的、上一次提交后的数据，而不是修改后的数据。 有了读一致性，就能保证修改前的数据和修改后的数据不会混杂在一起。读一致性是由Oracle自动提供的，并由撤销段中的撤销记录来实现 ③闪回查询 利用撤销段和闪回查询功能实现 闪回查询允许用户回到过去，查询刚刚过去的某个时间点上已经存在的一个表中的内容（这个时间点必然受到撤销空间、撤销信息保留时间的限制） 看起来像一条SELECT语句，不同的是它另外包含一个AS OF TIMESTAMP子句 ④事物的恢复事务恢复是例程恢复的一部分，是由Oracle自动完成的。在数据库运行过程中，正在做大量的事务，其中一些事务还没有提交，但出现了例程失败（如断电、内存故障、后台进程故障等），此时就可以使用撤销恢复数据。 创建和配置撤销段①类型 SYSTEM：用于在SYSTEM表空间中的对象 Non-SYSTEM：用于其它表空间中的对象 自动模式：需要一个撤销表空间 手动模式：8i之前才使用的 私有的：仅用于一个单独实例、 公用的：用于任意实例 延迟的撤销段：用于表空间立即、临时离线时，或恢复时 ②配置 在初始化文件中配置两个参数：UNDO_MANAGEMENT（auto或manual）指定系统是使用自动的还是手动的模式UNDO_TABLESPACE指定使用一个特定的撤销表空间 建立至少一个撤销表空间。 ③创建撤销表空间 undo_management=auto使用自动管理方式 必须在数据库中创建一个撤销表空间，以便Oracle在其中分配撤销段来保存撤销数据。 在创建数据库的同时创建一个默认的撤销表空间 在数据库创建之后创建一个撤销表空间 如果没有指定一个撤销表空间，则在例程启动时，Oracle会自动搜索是否存在一个可用的（或联机的）撤销表空间，并自动选择第一个可用的撤销表空间来保存撤销数据。 如果没有找到一个可用的撤销表空间，Oracle就使用SYSTEM表空间的system回退段来保存撤销数据，并会在预警文件中记录如下警告信息： Warning – Executing transaction without active Undo Tablespace ④创建UNDO表空间通过在CREATE DATABASE命令中增加一个子句，可以为数据库建立UNDO表空间 1234CREATE DATABASE db01. . .UNDO TABLESPACE undo1 DATAFILE &#x27;undo1db01.dbf&#x27;SIZE 20M AUTOEXTEND ON 或者通过使用CREATE UNDO TABLESPACE命令，在之后建立 12CREATE UNDO TABLESPACE undo1DATAFILE &#x27;undo1db01.dbf&#x27; SIZE 20M; ⑤改变UNDO表空间ALTER TABLESPACE命令能改变UNDO表空间例：把另一个数据文件加入到UNDO表空间中： 123ALTER TABLESPACE undotbsADD DATAFILE &#x27;undotbs2.dbf&#x27; SIZE 30MAUTOEXTEND ON; ⑥切换UNDO表空间可以在不同的UNDO表空间之间进行切换 由于不能实际缩小撤销表空间的大小，如果启用了自动扩展功能，则为了响应一个产生大量撤销数据的大事务时，撤销表空间会自动增大。因为需要备份撤销表空间的数据文件，所以这会影响未来所有备份的大小 解决这个问题的方法是及时更换撤销表空间 注： 在任何时候，一个实例只能指定一个UNDO表空间 一个实例可以有多于一个的UNDO表空间，但是只能有一个是活跃的(被激活) 使用ALTER SYSTEM命令动态地在UNDO表空间之间切换 创建一个新的撤销表空间 CREATE DATABASE db01 . . . UNDO TABLESPACE undo1 DATAFILE &#39;undo1db01.dbf&#39; SIZE 20M AUTOEXTEND ON 或者 CREATE UNDO TABLESPACE undo1 DATAFILE &#39;undo1db01.dbf&#39; SIZE 20M; 更改使用该新的撤销表空间：ALTER SYSTEM SET undo_tablespace=undotbs_new删除旧的撤销表空间： DROP TABLESPACE undotbs_old ⑦删除一个UNDO表空间DROP TABLESPACE命令删除一个UNDO表空间 1DROP TABLESPACE UNDOTBS2; 一个UNDO表空间只能在当前实例没有用它时才被删除。为了删除一个活跃的UNDO表空间： 切换到一个新的UNDO表空间 等待在原表空间工作的当前事务都完成之后，删除表空间 ⑧其他参数UNDO_SUPPRESS_ERRORS：设置为真，这个参数在AUTO模式中确定是否报错UNDO_RETENTION：单位是秒。控制回滚数据的数量，保持读一致性的时间(在回滚段中保持一段时间，保持读一致性) 12ALTER SYSTEM SET undo_retention=600 SCOPE=memory;#如果将UNDO_RETENTION设置成较大的值，就应该保证撤销表空间具有足够的空间，否则UNDO_RETENTION参数的值就会失去意义。 ⑨设置UNDO表空间的大小$UndoSize &#x3D; UR × UPS × BS ×( 1 + overhead)$ 参数 意义 UndoSize 所需的撤销表空间的大小。 UR 表示UNDO_RETENTION参数的值（以秒为单位）。 UPS 表示每秒钟产生的撤销数据的Oracle块数。 BS 表示由DB_BLOCK_SIZE参数决定的Oracle块的大小。 Overhead 表示在撤销表空间中保留系统信息所需要的额外开销（一般为UR × UPS × BS 的5%~10%）。 ⑩撤销数据统计量12SELECT end_time,begin_time,undoblksFROM v$undostat; ------------------------------V$UNDOSTAT中的常用列-------------------------------- 参数名 意义 Endtime 以10分钟为间隔的结束时间 UndoBlocksUsed 使用的undo块总数 TxnConcurrency 事务并发执行的最大数 TxnTotal 在时间段内事务执行总数 QueryLength 查询长度的最大值 ExtentsStolen 在时间段内undo区必须从一个undo段转到另一个的次数 SSTooOldError 在时间段内’Snapshot Too Old’错误发生的次数 UNDOTSN 这段时间内最后活动的undo表空间ID 获得撤销段信息1234567891011#数据字典视图DBA_ROLLBACK_SEGS#动态性能视图V$ROLLNAMEV$ROLLSTATV$UNDOSTATV$SESSIONV$TRANSACTION用法:select * from V$ROLLNAME;","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Oracle数据库","slug":"学习笔记/Oracle数据库","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]},{"title":"Oracle数据库的启动过程和关闭模式","slug":"E_学习笔记/数据库/Oracle/Oracle数据库的启动过程和关闭模式","date":"2022-12-27T03:12:54.048Z","updated":"2022-12-27T03:12:54.049Z","comments":true,"path":"posts/69b24920.html","link":"","permalink":"https://www.mingsrc.work/posts/69b24920","excerpt":"","text":"Oracle数据库的启动过程和关闭模式。一 启动数据库Oracle启动过程涉及几种模式，这些模式涉及不同的文件，每个状态下数据库做不同的事情，同时这些模式适用于不同的维护需求，主要的模式有三种：NOMOUNT、MOUNT、OPEN。 NOMOUNT：启动数据库实例， 此时读取参数文件，但是不加载数据库; MOUNT：启动数据库实例，加载数据库，但是数据库处于关闭状态； OPEN: 启动数据库实例，加载并打开数据库； FORCE: 终止实例并重启数据库，这种模式在数据库关闭或者启动遇到问题时使用，这种方式不到万不得已时不要使用，会有数据丢失； 1 NOMOUNT 启动例程 在启动例程时，这些内存结构和服务进程得到分配、初始化和启动，以便Oracle能够管理数据库 此时的例程还没有与一个确定的数据库相联系，或者说数据库是否存在对例程的启动并没有影响，即还没有装载数据库 若初始化参数文件设置有误，则无法启动例程 这种模式只会创建实例（创建Oracle实例的各种内存结构与服务进程，其中有5个进程必须启动， DBWR、LGWR、SMON、PMON、CKPT），并不加载数据库，也不会打开任何数据文件。其任务为： 读取参数文件 根据该参数文件中有关SGA区、PGA区的参数设置的值，在内存中分配相应的空间 根据该参数文件中有关后台进程的参数设置的值，启动相应后台进程 打开跟踪文件和报警文件 ① 先关闭数据库 ② 使用STARTUP NOMOUNT命令启动例程。通常使用数据库的这种状态来创建一个新的数据库，或创建一个新的控制文件。 1startup nomount 数据库的启动过程记录在警告追踪文件中，该警告追踪文件中包括数据库启动信息，它存放在参数BACKGOUND_DUMP_DEST定义的目录下，警告日志的名字为alert_orcl.log ③ 进入到目录查看警告日志关于startup nomount过程记录 ④ 测试在nomount状态时数据字典是否打的开，下图说明数据库字典在nomount状态下是无法访问的，因为数据字典需要从控制文件获取文件的信息，而此时控制文件没有打开所以无法查看。 但是在nomount下可以通过参数文件获得控制文件的位置，因为此时参数文件已经打开 2 MOUNT 装载数据库这种模式将启动实例，加载数据库并保持数据库关闭状态。数据库启动到MOUNT状态有两种方式： 一是可以直接启动数据库到MOUNT 二是如果数据库已经启动到NOMOUNT状态，使用alter database mount把数据库切换到MOUNT状态； ① alert database mount ② startup mount 此时我们可以查看数据字典，因为控制文件已经打开 注意：但是此时我们不能访问数据库的数据文件（表，视图），文件此时数据文件没有打开。 MOUNT下改变状态：改变归档模式 123ARCHIVE LOG LISTALTER DATABASE ARCHIVELOG；ALTER DATABASE NOARCHIVELOG； 暂停和重新开始数据库 12ALTER SYSTEM SUSPEND;ALTER SYSTEM RESUME; 执行数据库备份时，为了避免控制文件和数据文件之间的I&#x2F;O冲突，可以使用ALTER SYSTEM语句来暂停和重新开始数据库。暂停之后，禁止在控制文件和数据文件上进行任何I&#x2F;O操作. 3 OPEN 打开数据库 使用STARTUP OPEN（或STARTUP）命令启动例程、装在数据库并打开数据库 这种模式将启动实例，加载并打开数据库，这是常规的启动模式，用户想要对数据库进行多种操作就必须使用OPEN模式启动数据库，启动到OPEN状态，有两种方式： 一是直接启动到OPEN状态（使用startup或者startup open） 二是如果数据库处于NOMOUNT或者MOUNT状态，可以通过alter database open切换到OPEN状态。 此时可以访问数据文件了。 4 FORCE 强制执行这种模式将终止实例并重启数据库，这是一种强制性启动模式，只有在启动或者关闭出现问题时才使用，并且有一定的风险，会丢失数据，造成意外的问题。 二 关闭数据库 与启动数据库顺序相反，也分三个步骤：关闭数据库(CLOSE 关闭数据文件)，卸载数据库(关闭控制文件 DISMOUNT)，关闭Oracle实例(SHUTDOWN)。同时关闭模式也有多种常见的有： 1 NORMAL正常的关闭方式，如果对于关闭数据库的时间没有限制，通常采用这种方式，以NORMAL方式关闭数据库，Oracle将执行如下操作： A 阻止任何用户建立新的连接； B 等待当前所有正在连接的用户主动断开连接； C 当前所有用户的都断开连接后，将立即关闭数据库； 2 TRANSACTION事务关闭方式，它的首要任务是保证当前所有活动的事务都可以被提交，并在尽可能短的时间内关闭数据库。以事务方式关闭，Oracle将执行如下操作： A 阻止用户建立新连接和开始新事务；B 等待所有活动事务提交后，再断开用户连接；C 当所有活动事务提交完毕，用户断开连接后，关闭数据库； 3 IMMEDIATE立即关闭方式，可以较快且安全的关闭数据库，是DBA经常采用的关闭数据库的方式，立即关闭方式，Oracle执行如下操作： A 阻止用户建立新的连接和开始新的事务； B 中断当前事务，回滚未提交事务； C 强制断开所有用户连接和执行检查点把脏数据写到数据文件中； D 关闭数据库","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Oracle数据库","slug":"学习笔记/Oracle数据库","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]},{"title":"Oracle存储结构","slug":"E_学习笔记/数据库/Oracle/Oracle存储结构","date":"2022-12-27T03:12:54.048Z","updated":"2022-12-27T03:12:54.048Z","comments":true,"path":"posts/ac7c815e.html","link":"","permalink":"https://www.mingsrc.work/posts/ac7c815e","excerpt":"","text":"Oracle存储结构存储结构数据库的主要功能是保存数据，所以可以将数据库看成是保存数据的容器。数据库的存储结构也就是数据库存储数据的结构或方式、方法、方案等。 oracle 数据库的存储结构分为物理存储结构和逻辑存储结构两种。 物理存储结构主要用于描述在 oracle 数据库外部数据的存储，即在操作系统层面中如何组织和管理数据，与具体的操作系统有关。 逻辑存储结构主要描述oracle 数据库内部数据的组织和管理方式，即在数据库管理系统的层面中如何组织和管理数据，与操作系统没有关系。 两者的关系 oracle 数据库的物理存储结构与逻辑存储结构既相互独立又相互联系，如下图： 从上面图中可以看出数据库物理存储结构和逻辑存储结构的基本关系： 一个数据库在物理上包含多个数据文件，在逻辑上包含多个表空间 一个表空间包含一个或多个数据文件，一个数据文件只能从属于某个表空间 数据库的逻辑块由一个或多个操作系统块组成 一个逻辑区只能从属于一个数据文件，而一个数据文件可包括一个或多个逻辑区 逻辑存储结构 是从逻辑的角度定义数据库的构成，比物理存储结构更高一层，许多初始化参数都是针对逻辑存储结构来定义的。 主要描述Oracle数据库的内部存储结构，即从技术概念上描述在Oracle数据库中如何组织、管理数据。 数据字典描述 在操作系统中无法找到逻辑存储结构，但通过查询Oracle数据库的数据字典，可以找到逻辑存储结构的描述。 包括表空间、段、区、块 一个区只能在一个数据文件中 一个段中的各个区可以分别在多个数据文件中 组成区的块是连续的。 由于逻辑块对应磁盘空间中某个固定大小的尺寸（一般为操作系统数据块的整数倍），所以逻辑存储结构也是有大小的。 逻辑结构类型按照尺寸从小到大分可分为：块(block)–&gt;区(extent)–&gt;段(segment)–&gt;表空间(tablespace)，下边依次阐述： 表空间(tablespace) 表空间组织数据和分配空间的逻辑结构，是最大的逻辑单位。数据库的大小从逻辑上看就是由表空间决定的，所有表空间大小的和就是数据库的大小。表空间与数据库文件直接关联，在 oracle 数据库中，存储结构管理主要就是通过对表空间的管理来实现的。 一个数据库可以有多个表空间 一个表空间只属于一个数据库。 一个表空间必须有一个数据文件。 一个表空间的大小等于其中所有数据文件的大小之和。数据库的大小等于其中所有表空间的大小之和。 表空间可以被联机和脱机。 SYSTEM表空间不能被脱机。 表空间可以在读写、只读状态之间切换。 每个表空间由一个或多个物理存在的操作系统的数据文件组成。这种数据文件可以具有固定的大小，或允许其自动变大。可以在表空间中添加、删除数据文件。 方案、对象、表、索引的数据都被存储在表空间的数据文件中。一个数据文件存储不下，就存储在另一个数据文件中，只要该数据文件是本表空间中的就行。 一个用户默认使用一个表空间，但他的不同方案对象的数据可以被存储在不同表空间中。 一个用户使用的表空间的数量是有一定配额的，不能超出这个配额。 可以根据使用目的，创建不同类型的表空间，如永久表空间、临时表空间、撤销表空间、大表空间等。不同类型的表空间的格式、使用方式及目的是不同的。 表空间又根据存储数据类型的不同，分为系统表空间和非系统表空间两类。 系统表空间主要存放数据库的系统信息，如数据字典、数据库对象定义信息，数据库组件信息等。 非系统表空间又分为撤销表空间、临时表空间和用户表空间等。其中撤销表空间用于自动管理数据库的回退信息，临时表空间用于管理数据库的临时信息，用户表空间用于存储业务数据。 段(segment)段用于存储表空间中表一种特定的、具有独立存储结构的数据库对象的数据，它由一个或多个连续分区组成。当创建表、索引、簇等对象时，Oracle就会为这些对象分配存储空间（即段），以便存储它们的数据。按照段中所存储的数据的特征、用途不同，可以将段分成以下几种类型： 表段存储表的所有数据。当用户创建表时，就会在该用户的默认表空间中为该表分配一个与表名相同的表段，以便将来存储该表的所有数据。显然，在一个表空间中创建了几个表，在该表空间中就有几个表段。 表分区段用于存储分区表的所有数据。当用户创建分区表时，就会在该用户的默认表空间中为该表的每个分区分配一个表分区段。通过将一个大表的数据分散到不同的表分区段中，能降低I/O次数，提高性能。 簇段把几张表组织在一起，放在一个物理段中。 索引段存储索引的所有数据。当用户创建索引或定义约束而自动创建索引时，就会在该用户的默认表空间中为该索引分配一个与索引名相同的索引段，以便将来存储该索引的所有数据。 Index-organized table按照索引的顺序来存储的表。数据是有序存放的。按照索引的键值升序或降序排序。 Index partition用于大的索引，物理上放置在不同的段中。如果为分区表创建分区索引，则会为每个分区索引分配一个索引分区段，其功能与表分区段相同。 Undo segment是有序的、循环的使用。用来存放oracle运行过程中发生数据改变时，存放数据的old value。帮助完成加滚和恢复。撤销段存储数据修改之前的位置和值。利用这些信息，可以回退未提交的事务，维护数据库的读一致性，并能从例程的崩溃中进行恢复。 临时段支持排序。临时段存储排序操作所产生的临时数据。临时数据首先会被暂存到排序区（属于PGA区）中，当排序区（其大小由SORT_AREA_SIZE初始化参数决定）不足以暂存这些临时数据时，则会在该用户的临时表空间中自动创建一个临时段，用于暂存这些临时数据，排序结束时，临时段自动消除。 二进制大对象段用于存储LOB数据类型列中的数据，如文档、图像、音频、视频数据。创建表时，可以定义LOB数据类型（包括CLOB，BLOB，NCLOB，BFILE）的列，Oracle会为此自动分配对应的二进制大对象段。对于LOB列来说，如果数据长度少于4000字节，则与其他列的数据会一起存放在表段中；否则数据就会被存储到二进制大对象段中。 Bootstrap segment：初始化实例的。创建数据库时自动创建，用过后自动释放。 区(extent)区由物理上连续存放的块构成，是Oracle存储分配的最小单位，由一个或多个块组成区，由一个或多个分区组成段.一个分区只能属于一个数据文件当在数据库中创建带有实际存储结构的方案对象（如表、索引、簇）时，Oracle将为该方案对象分配若干个分区（视该方案对象的初始大小而定），以便组成一个对应的段，来为该方案对象提供初始的存储空间。当段中已分配的区都写满后，Oracle就要在该方案对象所在的表空间中为该段分配下一个新的空白区，以便容纳更多的数据。 块(block) 是最小的数据管理单位，即数据管理中I&#x2F;O的最小单位其大小是OS块大小的整数倍块大小是表空间的一个属性 物理存储结构 oracle 数据库的物理存储结构是由一系列操作系统文件组成的，存放于物理磁盘上，是数据库的实际存储单元。这些文件主要包括数据文件、控制文件、重做日志文件、归档文件、初始化参数文件、跟踪文件、告警文件等。每种文件都存储特定内容的信息，其数量也因文件类型不同而不同。 数据文件：是数据库所有数据的实际存储空间，所有数据文件的大小和构成了数据库的大小。控制文件：记录数据库结构信息的重要的二进制文件，由oracle 系统进行读 &#x2F; 写操作。重做日志文件：是以重做记录的形式记录、保存用户对数据库所进行的变更操作，是数据库中最重要的物理文件。归档日志文件：是历史联机重做日志文件的集合，是联机重做日志文件被覆盖之前备份的副本。初始化参数文件：是数据库启动过程所必需的文件，记录了数据库显式参数的设置。数据库启动的第一步是根据初始化参数文件中的设置， 创建并启动实例，即分配内存空间、启动后台进程。 跟踪文件：是数据库中重要的诊断文件，是获取数据库信息的重要工具，对管理数据库的实例起着至关重要的作用。跟踪文件中包含数据库系统运行过程中所发生的重大事件的有关信息，可以为数据库运行故障的解决提供重要信息。告警文件：是数据库中重要的诊断文件，记录数据库在启动、关闭和运行期间后台进程的活动情况。 获得存储信息使用数据字典 12345DBA_TABLESPACESDBA_DATA_FILESDBA_SEGMENTSDBA_EXTENTSDBA_FREE_SPACE 数据库的三级模式、二级映像结构 模式 也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有应用程序的公共的数据结构。在信息世界中描述了现实世界中的实现及其联系。 特点： 一个数据库只有一个模式，它统一地、综合地考虑了所有用户的需求，并将这些需求有机地结合成一个逻辑整体。不同的应用程序可能只使用模式中的一部分； 模式是逻辑的，即它与具体珠应用程序无关或不属于某个应用程序。它描述的是一个数据库的总体结构，是装配数据的一个框架； 模式是以某种数据模型为基础的。定义模式时不仅要定义数据的逻辑结构（如表有哪些数据项，每个数据项的名字、类型、取值范围等），而且还要定义这些数据项之间的联系（如外键），定义与数据项有关的安全性、完整性（如约束、主键）要求等； 模式用模式描述语言（如DDL）来定义。模式设计是数据库设计的重要任务。 外模式 也称用户模式，是数据库用户（应用程序、终端用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是用户所用的数据库结构。 特点： 一个数据库可以有多个外模式，分别对应于每个用户。由于各个用户在应用需求、看待数据的方式、对数据的保密程度等方面存在差异，所以其外模式可能不一样。如，即使对模式中同一个数据，在外模式中的结构、类型、长度、保密程度等都有可能不一样 外模式是保证数据库安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据，而看不见其他数据 可以通过授权等方式，使一个用户可以使用另一个用户的外模式 外模式是外模式描述语言（一般也归类到DDL）来定义。 内模式 也称为存储模式，是对数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式，是整个数据库底层结构的表示，是数据库在物理存储方面的描述。 特点： 一个数据库只有一个内模式 一个数据库由多个文件组成 内模式对用户是透明的，即在用DML操纵数据库时不涉及内模式 内模式不同于物理层（或独立于物理设备）。它只是一个描述（如，数据是否压缩、加密；存储方式是按顺序、B树结构，还是Hash方法；按照什么方式组织索引；记录的结构有何规定等） 内模式由内模式描述语言（一般也归类到DDL）来定义。因为内模式的设计直接影响到数据库的性能，所以必须要对其有充分的了解，才能合理、有效地优化数据库的性能 二级映像 数据独立性（逻辑独立性、物理独立性）是由二级映像功能来保证的。 逻辑独立性是指应用程序与数据的逻辑结构之间是相互独立的。即，当模式（即逻辑结构）发生改变（如，增加新的关系或表、增加新的数据项或字段、更改数据项的名称或数据类型）时，只要数据库管理员对相应的外模式&#x2F;模式映像做相应的修改，就可以使外模式保持不变，从而应用程序不需要改变。 物理独立性是指应用程序与存储在磁盘上的数据库中的数据是相互独立的。即，数据在磁盘上的数据库中如何存储完全由DBMS来管理，应用程序不需要了解，它只需要了解数据的逻辑结构就可以了。这样，当数据的存储格式和组织方式改变时，应用程序不需要改变。 外模式&#x2F;模式映像 由模式生成外模式的规则,定义了各个外模式和模式之间的对应关系 一个数据库可以有多个外模式&#x2F;模式映像。对应于一个模式可以有多个外模式，所以对于每一个外模式都有一个外模式&#x2F;模式映像 给数据库提供了逻辑独立性。 指模式在物理设备中的存储结构，定义了模式和内模式之间的对应关系 一个数据库只有一个模式&#x2F;内模式映像。因为数据库只有一个模式和一个内模式，所以只有一个模式&#x2F;内模式映像 给数据库提供了物理独立性。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Oracle数据库","slug":"学习笔记/Oracle数据库","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]},{"title":"数据库主键外键","slug":"E_学习笔记/数据库/MySQL/外键","date":"2022-12-27T03:12:54.047Z","updated":"2022-12-27T03:12:54.047Z","comments":true,"path":"posts/2a1f41d8.html","link":"","permalink":"https://www.mingsrc.work/posts/2a1f41d8","excerpt":"","text":"一、什么是主键、外键：关系型数据库中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键比如 学生表(学号，姓名，性别，班级) 其中每个学生的学号是唯一的，学号就是一个主键 课程表(课程编号,课程名,学分) 其中课程编号是唯一的,课程编号就是一个主键 成绩表(学号,课程号,成绩) 成绩表中单一一个属性无法唯一标识一条记录，学号和课程号的组合才可以唯一标识一条记录，所以 学号和课程号的属性组是一个主键 。 成绩表中的学号不是成绩表的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的外键 同理 成绩表中的课程号是课程表的外键 定义主键和外键主要是为了维护关系数据库的完整性，总结一下： 主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。 身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。 外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。 比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。 二、 主键、外键和索引的区别主键、外键和索引的区别？ 主键 外键 索引 定义： 唯一标识一条记录，不能有重复的，不允许为空 表的外键是另一表的主键, 外键可以有重复的, 可以是空值 该字段没有重复值，但可以有一个空值 作用： 用来保证数据完整性 用来和其他表建立联系用的 是提高查询排序的速度 个数： 主键只能有一个 一个表可以有多个外键 一个表可以有多个惟一索引 聚集索引和非聚集索引的区别？聚集索引一定是唯一索引。但唯一索引不一定是聚集索引。 聚集索引，在索引页里直接存放数据，而非聚集索引在索引页里存放的是索引，这些索引指向专门的数据页的数据。 三、数据库中主键和外键的设计原则主键和外键是把多个表组织为一个有效的关系数据库的粘合剂。主键和外键的设计对物理数据库的性能和可用性都有着决定性的影响。 必须将数据库模式从理论上的逻辑设计转换为实际的物理设计。而主键和外键的结构是这个设计过程的症结所在。一旦将所设计的数据库用于了生产环境，就很难对这些键进行修改，所以在开发阶段就设计好主键和外键就是非常必要和值得的。 主键： 关系数据库依赖于主键—它是数据库物理模式的基石。 主键在物理层面上只有两个用途： 唯一地标识一行。 作为一个可以被外键有效引用的对象。 基于以上这两个用途，下面给出了我在设计物理层面的主键时所遵循的一些原则： 主键应当是对用户没有意义的。如果用户看到了一个表示多对多关系的连接表中的数据，并抱怨它没有什么用处，那就证明它的主键设计地很好。 主键应该是单列的，以便提高连接和筛选操作的效率。 ​ 注：使用复合键的人通常有两个理由为自己开脱，而这两个理由都是错误的。其一是主键应当具有实际意义，然而，让主键具有意义只不过是给人为地破坏数据库提供了方便。其二是利用这种方法可以在描述多对多关系的连接表中使用两个外部键来作为主键，我也反对这种做法，理由是：复合主键常常导致不良的外键，即当连接表成为另一个从表的主表，而依据上面的第二种方法成为这个表主键的一部分，然，这个表又有可能再成为其它从表的主表，其主键又有可能成了其它从表主键的一部分，如此传递下去，越靠后的从表，其主键将会包含越多的列了。 永远也不要更新主键。实际上，因为主键除了惟一地标识一行之外，再没有其他的用途了，所以也就没有理由去对它更新。如果主键需要更新，则说明主键应对用户无意义的原则被违反了。 ​ 注：这项原则对于那些经常需要在数据转换或多数据库合并时进行数据整理的数据并不适用。 主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等。 主键应当有计算机自动生成。如果由人来对主键的创建进行干预，就会使它带有除了惟一标识一行以外的意义。一旦越过这个界限，就可能产生认为修改主键的动机，这样，这种系统用来链接记录行、管理记录行的关键手段就会落入不了解数据库设计的人的手中。 四、数据库主键 选取策略我们在建立数据库的时候，需要为每张表指定一个主键，所谓主键就是能够唯一标识表中某一行的属性或属性组，一个表只能有一个主键，但可以有多个候选索引。因为主键可以唯一标识某一行记录，所以可以确保执行数据更新、删除的时候不会出现张冠李戴的错误。当然，其它字段可以辅助我们在执行这些操作时消除共享冲突，不过就不在这里讨论了。主键除了上述作用外，常常与外键构成参照完整性约束，防止出现数据不一致。所以数据库在设计时，主键起到了很重要的作用。 常见的数据库主键选取方式有： · 自动增长字段 · 手动增长字段 · UniqueIdentifier · “COMB（Combine）”类型 1自动增长型字段 很多数据库设计者喜欢使用自动增长型字段，因为它使用简单。自动增长型字段允许我们在向数据库添加数据时，不考虑主键的取值，记录插入后，数据库系统会自动为其分配一个值，确保绝对不会出现重复。如果使用SQL Server数据库的话，我们还可以在记录插入后使用@@IDENTITY全局变量获取系统分配的主键键值。 尽管自动增长型字段会省掉我们很多繁琐的工作，但使用它也存在潜在的问题，那就是在数据缓冲模式下，很难预先填写主键与外键的值。假设有两张表： Order(OrderID, OrderDate)OrderDetial(OrderID, LineNum, ProductID, Price) Order表中的OrderID是自动增长型的字段。现在需要我们录入一张订单，包括在Order表中插入一条记录以及在OrderDetail表中插入若干条记录。因为Order表中的OrderID是自动增长型的字段，那么我们在记录正式插入到数据库之前无法事先得知它的取值，只有在更新后才能知道数据库为它分配的是什么值。这会造成以下矛盾发生： 首先，为了能在OrderDetail的OrderID字段中添入正确的值，必须先更新Order表以获取到系统为其分配的OrderID值，然后再用这个OrderID填充OrderDetail表。最后更新OderDetail表。但是，为了确保数据的一致性，Order与OrderDetail在更新时必须在事务保护下同时进行，即确保两表同时更行成功。显然它们是相互矛盾的。 除此之外，当我们需要在多个数据库间进行数据的复制时（SQL Server的数据分发、订阅机制允许我们进行库间的数据复制操作），自动增长型字段可能造成数据合并时的主键冲突。设想一个数据库中的Order表向另一个库中的Order表复制数据库时，OrderID到底该不该自动增长呢？ ADO.NET允许我们在DataSet中将某一个字段设置为自动增长型字段，但千万记住，这个自动增长字段仅仅是个占位符而已，当数据库进行更新时，数据库生成的值会自动取代ADO.Net分配的值。所以为了防止用户产生误解，建议大家将ADO.NET中的自动增长初始值以及增量都设置成-1。此外，在ADO.NET中，我们可以为两张表建立DataRelation，这样存在级联关系的两张表更新时，一张表更新后另外一张表对应键的值也会自动发生变化，这会大大减少了我们对存在级联关系的两表间更新时自动增长型字段带来的麻烦。 2手动增长型字段 既然自动增长型字段会带来如此的麻烦，我们不妨考虑使用手动增长型的字段，也就是说主键的值需要自己维护，通常情况下需要建立一张单独的表存储当前主键键值。还用上面的例子来说，这次我们新建一张表叫IntKey，包含两个字段，KeyName以及KeyValue。就像一个HashTable，给一个KeyName，就可以知道目前的KeyValue是什么，然后手工实现键值数据递增。在SQL Server中可以编写这样一个存储过程，让取键值的过程自动进行。代码如下： CREATE PROCEDURE [GetKey] @KeyName char(10),@KeyValue int OUTPUT ASUPDATE IntKey SET @KeyValue &#x3D; KeyValue &#x3D; KeyValue + 1 WHERE KeyName &#x3D; @KeyNameGo 这样，通过调用存储过程，我们可以获得最新键值，确保不会出现重复。若将OrderID字段设置为手动增长型字段，我们的程序可以由以下几步来实现：首先调用存储过程，获得一个OrderID，然后使用这个OrderID填充Order表与OrderDetail表，最后在事务保护下对两表进行更新。 使用手动增长型字段作为主键在进行数据库间数据复制时，可以确保数据合并过程中不会出现键值冲突，只要我们为不同的数据库分配不同的主键取值段就行了。但是，使用手动增长型字段会增加网络的RoundTrip，我们必须通过增加一次数据库访问来获取当前主键键值，这会增加网络和数据库的负载，当处于一个低速或断开的网络环境中时，这种做法会有很大的弊端。同时，手工维护主键还要考虑并发冲突等种种因素，这更会增加系统的复杂程度。 3使用UniqueIdentifier SQL Server为我们提供了UniqueIdentifier数据类型，并提供了一个生成函数NEWID( )，使用NEWID( )可以生成一个唯一的UniqueIdentifier。UniqueIdentifier在数据库中占用16个字节，出现重复的概率非常小，以至于可以认为是0。我们经常从注册表中看到类似 {45F0EB02-0727-4F2E-AAB5-E8AEDEE0CEC5} 的东西实际上就是一个UniqueIdentifier，Windows用它来做COM组件以及接口的标识，防止出现重复。在.NET里管UniqueIdentifier称之为GUID（Global Unique Identifier）。在C#中可以使用如下命令生成一个GUID： Guid u &#x3D; System.Guid.NewGuid(); 对于上面提到的Order与OrderDetail的程序，如果选用UniqueIdentifier作为主键的话，我们完全可以避免上面提到的增加网络RoundTrip的问题。通过程序直接生成GUID填充主键，不用考虑是否会出现重复。 UniqueIdentifier字段也存在严重的缺陷：首先，它的长度是16字节，是整数的4倍长，会占用大量存储空间。更为严重的是，UniqueIdentifier的生成毫无规律可言，要想在上面建立索引（绝大多数数据库在主键上都有索引）是一个非常耗时的操作。有人做过实验，插入同样的数据量，使用UniqueIdentifier型数据做主键要比使用Integer型数据慢，所以，出于效率考虑，尽可能避免使用UniqueIdentifier型数据库作为主键键值。 4使用“COMB（Combine）”类型 既然上面三种主键类型选取策略都存在各自的缺点，那么到底有没有好的办法加以解决呢？答案是肯定的。通过使用COMB类型（数据库中没有COMB类型，它是Jimmy Nilsson在他的“The Cost of GUIDs as Primary Keys”一文中设计出来的），可以在三者之间找到一个很好的平衡点。 COMB数据类型的基本设计思路是这样的：既然UniqueIdentifier数据因毫无规律可言造成索引效率低下，影响了系统的性能，那么我们能不能通过组合的方式，保留UniqueIdentifier的前10个字节，用后6个字节表示GUID生成的时间（DateTime），这样我们将时间信息与UniqueIdentifier组合起来，在保留UniqueIdentifier的唯一性的同时增加了有序性，以此来提高索引效率。也许有人会担心UniqueIdentifier减少到10字节会造成数据出现重复，其实不用担心，后6字节的时间精度可以达到1&#x2F;300秒，两个COMB类型数据完全相同的可能性是在这1&#x2F;300秒内生成的两个GUID前10个字节完全相同，这几乎是不可能的！在SQL Server中用SQL命令将这一思路实现出来便是： DECLARE @aGuid UNIQUEIDENTIFIER SET @aGuid &#x3D; CAST(CAST(NEWID() AS BINARY(10))+ CAST(GETDATE() AS BINARY(6)) AS UNIQUEIDENTIFIER) 经过测试，使用COMB做主键比使用INT做主键，在检索、插入、更新、删除等操作上仍然显慢，但比Unidentifier类型要快上一些","raw":null,"content":null,"categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.mingsrc.work/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.mingsrc.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"C++连接Oracle","slug":"E_学习笔记/数据库/Oracle/C++连接Oracle","date":"2022-12-27T03:12:54.047Z","updated":"2022-12-27T03:12:54.047Z","comments":true,"path":"posts/ddbf2ebc.html","link":"","permalink":"https://www.mingsrc.work/posts/ddbf2ebc","excerpt":"","text":"C++连接Oracle常见的几种连接Oracle的方式 ODAC，通过 COM 的形式调用 Oracle，缺点是需要装 ODAC 客户端，而且体积不小 OCCI，通过动态库调用 Oracle, 不需要安装客户端，只需要几个 DLL 即可，问题是 Oracle 12.2 开始支持 VS2015，但不支持 XP OCI，C语言的 API，调用起来稍显复杂 ODPI-C，也是C语言的 API，在 OCI 基础上做了一层封装，对比前两者，仍然不够简洁 cx_Oracle，Python 的第三方库，各方面都满足要求，但是甲方禁止使用 Python ODBC，效率估计最低了吧 Pro*C，个人比较反感这种方案，不多说了 OTL，基于模板和流的 C++ 库，依赖 OCI 而使用C&#x2F;C++操作Oracle数据库的方法有以下几种种： pro*C：易入门，但程序代码繁琐； OCI：Oracle Call Interface，功能强大，性能卓越，但难以驾驭； ​ OCI是Oracle提供的C语言函数库，如果不对OCI进行封装，C程序员对Oracle的开发比较困难。 ​ freecplus框架吧OCI封装成connection和sqlstatement两个类，C程序员对Oracle数据的操作成为了体力活。 ODBC：效率较低 1、无结果集SQL的程序流程图","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Oracle数据库","slug":"学习笔记/Oracle数据库","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]},{"title":"前端样式整理","slug":"E_学习笔记/前端/HTML/按钮样式整理","date":"2022-12-27T03:12:54.046Z","updated":"2022-12-27T03:12:54.046Z","comments":true,"path":"posts/3ec63883.html","link":"","permalink":"https://www.mingsrc.work/posts/3ec63883","excerpt":"","text":"span list 12345678910111213141516171819202122231&lt;span class=&quot;fas faa-ring animated-hover&quot; style=&quot;border-bottom:3px solid green&quot;&gt;《半小时漫画中国哲学史》&lt;/span&gt;2&lt;span style=&quot;text-align:center;font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;&quot;&gt;“ 既许一人以偏爱，愿尽余生之慷慨 ”&lt;/span&gt;3&lt;span style=&quot;class: faa-bounce animated-hover;border-bottom: 5px solid #8F81EF;&quot;&gt;[data.json文件链接](https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA )&lt;/span&gt; 4 &lt;mark style=&quot;background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas&quot;&gt;当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。&lt;/mark&gt;5&lt;span style=&quot;background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900&quot;&gt;存储结构管理主要就是通过对表空间的管理来实现的&lt;/span&gt;6&lt;mark style=&quot;background:green;border-radius:10px;color:white&quot;&gt;效果如下：&lt;/mark&gt;7&lt;font size=10px style=&quot;font-weight:700;font-family:&#x27;华文彩云&#x27;;color:rgb(100,190,100)&quot;&gt;基本语言(一)&lt;/font&gt;8&lt;span style=&quot;border-bottom: 2px dashed #000000&quot;&gt;代码段、数据段、BSS段、堆区、文件映射区以及栈区&lt;/span&gt;9&lt;div style=&quot;background:black;font:conloas;color:white;&quot;&gt;&amp;nbsp;数组长度为：3&lt;br&gt;&amp;nbsp;请按任意键继续. . .&lt;/div&gt;10&lt;mark style=&quot;color:white;background:red;font-weight:600;border_radius:100px&quot;&gt;但效率更高&lt;/mark&gt; 《半小时漫画中国哲学史》 “ 既许一人以偏爱，愿尽余生之慷慨 ” data.json文件链接 当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。 存储结构管理主要就是通过对表空间的管理来实现的 效果如下： 基本语言(一) 代码段、数据段、BSS段、堆区、文件映射区以及栈区 &nbsp; 数组长度为：3 &nbsp; 请按任意键继续. . . 但效率更高","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"学习笔记/前端","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://www.mingsrc.work/tags/HTML/"}]},{"title":"初识VUE","slug":"E_学习笔记/前端/VUE学习笔记","date":"2022-12-27T03:12:54.046Z","updated":"2022-12-27T03:12:54.046Z","comments":true,"path":"posts/f1706fda.html","link":"","permalink":"https://www.mingsrc.work/posts/f1706fda","excerpt":"","text":"总想学点什么，又不知道学点什么的好，刚好一直也在美化博客，就学点前端的知识，总比不学的好。希望能把自己的学习经验和学习经历记录整理，也便于以后用的时候复习该方面的知识。 VUE是国人尤雨溪开发的一款前端框架，初步了解之后，确实很神奇，但由于仅仅只是学习，缺乏项目经验，因此本篇文章只记录Vue的相关语法。 我自己也是参考B站视频教程学习：黑马程序员vue前端基础教程-4个小时带你快速入门vue [toc] 在使用之前，有必要去vue官网查看相关的简介和快速开始，以便于对vue整体有一个初步的了解。 要是用vue，首先得引入相关js，即： 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; 其次，学习Vue可能需要不断地去创建html文件，因此，最好整一个模板文件，每次都复制模板文件即可，这里po一个通用的vue-html文件模板： Vue文件模板1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; &lt;/style&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue_01_Demo&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt; &lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello World!&#x27; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; el挂载点也是实现标签和js绑定的一个最基础的实现，大致语法如下： 123456var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello World!&#x27; &#125; &#125;); 这里的#app就是所说的挂载点，如上代码便是实现id为app的标签的挂载。有了上述js代码，还得添加专门的标签才能生效和使用，语法如下： 123&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 以上标签就基本实现了一个初步的vue程序。 完整代码1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; &lt;/style&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue_01_Demo&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt; &lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello World!&#x27; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 结果相关函数的一些高级用法123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Auraro&lt;/title&gt;&lt;script src=&quot;https://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;修改输入框的值，查看效果：&lt;/p&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;* message&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;!-- 字符串连接 --&gt; &lt;p&gt;&#123;&#123; message + &#x27;官网地址：www.mingsrc.work&#x27; &#125;&#125;&lt;/p&gt; &lt;!-- 字符串反转 --&gt; &lt;p&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;&lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data:&#123; message: &quot;学习Vue&quot;, &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码就是Vue的最基础的入门实例了，关于Vue的其他用法则需要一步一步了解。 其实不难发现，new出来的Vue的内容就是json格式的串。 el作为一个挂载点出现在Json对象中 data则保存数据 相应的还有methods方法用来实现函数、交互等。 本地应用什么是本地应用？通俗理解就是js基于dom来获取并操作页面元素的方法，在Vue中使用以v-开头的特殊语法来实现，如v-text、v-html、v-on、v-show、v-if、v-on等一系列vue指令。 v-textv-htmlv-onv-showv-ifv-bindv-forv-on补充v-modelv-text就是把内容直接输出为内容，不进行渲染，以下为例： 1234567891011 &lt;div id=&quot;app&quot;&gt; &lt;p v-text=&quot;content&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; content: &#x27;&lt;a href=&quot;https://www.mingsrc.work&quot;&gt;Auraro&lt;/a&gt;&#x27;, &#125; &#125;);&lt;/script&gt; 其输出就是 ：&lt;a href=&quot;https://www.mingsrc.work&quot;&gt;Auraro&lt;/a&gt;v-html会把Json对象指向的内容渲染为HTML元素，同上代码，如果v-text替换为v-html，其输出就会变为： Aurarov-on即交互事件，当发生点击事件时的处理，v-on有多种写法，可以使用v-on，也可以使用简写的方式： 123&lt;input type=&quot;button&quot; value=&quot;v-on指令&quot; v-on:click=&quot;doIt&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;v-on简写&quot; @click=&quot;doIt&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;双击事件&quot; @dblclick=&quot;doIt&quot;&gt; 直接pao一个代码： v-on1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;vue_04_交互&lt;/title&gt;&lt;script src=&quot;https://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;v-on指令&quot; v-on:click=&quot;doIt&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;v-on简写&quot; @click=&quot;doIt&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;双击事件&quot; @dblclick=&quot;doIt&quot;&gt; &lt;h2 @dblclick=&quot;changeFood&quot;&gt;&#123;&#123; food &#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; food: &quot;西蓝花炒蛋&quot;, todos: [ &#123; text: &#x27;菜鸟教程&#x27; &#125;, &#123; text: &#x27;www.runoob.com&#x27; &#125;, &#123; text: &#x27;www.w3cschool.cc&#x27; &#125; ] &#125;, methods: &#123; doIt:function()&#123; alert(&quot;this is &#x27;Hello World&#x27; Button&quot;); &#125;, changeFood:function()&#123; console.log(this.food); this.food+=&quot;好好吃！&quot;; &#125; &#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用v-on实现一个简单的计数器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;style&gt; #app&#123; text-align: center; vertical-align: middle; padding: 300px; font-size: 100px; &#125; button&#123; font-size: 100px; width: 200px; &#125;&lt;/style&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue_05_+-&lt;/title&gt; &lt;script src=&quot;https://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot; class=&quot;input-num&quot;&gt; &lt;button @click=&quot;sub&quot;&gt;-&lt;/button&gt; &lt;span&gt;&#123;&#123; num &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;add&quot;&gt;+&lt;/button&gt; &lt;/div&gt; &lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello World!&#x27;, num: 1 &#125;, methods: &#123; add: function () &#123; console.log(&quot;add&quot;); if (this.num &lt; 10) &#123; this.num++; &#125; else &#123; alert(&quot;已经是最大值了&quot;); &#125; &#125;, sub: function () &#123; console.log(&quot;sub&quot;); if (this.num &gt; 0) &#123; this.num--; &#125; else &#123; alert(&quot;已经是最小值了&quot;); &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-showv-show为标签的显示开关，可以通过设置v-show的值选择组件是否展示。 #注意：v-show相当于通过设置标签的visibility为hidden，在源码中还是能看到该元素标签，对内存消耗较小。 v-show用法示例1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;changeIsShow&quot;&gt;图片显示开关&lt;/button&gt; &lt;button @click=&quot;addArg&quot;&gt;累加Arg &#123;&#123; isShowArg &#125;&#125;&lt;/button&gt; &lt;br&gt; &lt;img src=&quot;../img/1.jpg&quot; v-show=&quot;isShow&quot; alt=&quot;v-show test&quot;&gt; &lt;img src=&quot;../img/2.jpg&quot; v-show=&quot;isShowArg&gt;=10&quot; alt=&quot;v-show test&quot;&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello World!&#x27;, isShow: false, isShowArg: 1 &#125;, methods: &#123; changeIsShow:function()&#123; this.isShow = !this.isShow; &#125;, addArg:function()&#123; this.isShowArg++; &#125; &#125; &#125;);&lt;/script&gt; v-if与v-show功能类似的还有v-if，但不同的是，v-if会直接隐藏掉源码，即通过修改HTML源码删除相应的标签修改页面展示 v-if用法示例12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换文字显示状态&quot; @click=&quot;toggleIsShow&quot;&gt; &lt;p v-if=&quot;isShow&quot; &gt; &#123;&#123; message &#125;&#125; 测试文字&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello World!&#x27;, isShow: true &#125;, methods:&#123; toggleIsShow:function()&#123; this.isShow = !this.isShow; &#125; &#125; &#125;);&lt;/script&gt; v-bindv-bind就是绑定的意思，可以绑定标签的一些属性，写法为v-bind:src=“imgSrc”，即绑定标签的src属性，设置其值为Json对象imgSrc的值。 v-bind用法示例1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;input value=&quot;切换&quot; type=&quot;button&quot; @click=&quot;toggleActive&quot;&gt; &lt;img :src=&quot;imgSrc&quot; :class=&quot;isActive?&#x27;active&#x27;:&#x27;&#x27;&quot;/&gt; &lt;img :src=&quot;imgSrc&quot; :class=&quot;&#123;active:isActive&#125;&quot;/&gt;&lt;/div&gt;&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;&lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello World!&#x27;, imgSrc: &quot;../img/4.jpg&quot;, imgTitle: &quot;&quot;, isActive: false &#125;, methods:&#123; toggleActive:function()&#123; this.isActive = !this.isActive; &#125; &#125; &#125;);&lt;/script&gt; v-for即Vue的遍历插件，会对Json数组对象的每个成员访问。下边使用v-for打印李商隐的《荷花》。 [荷花 ](https://so.gushiwen.cn/shiwenv_2c99bc7b0323.aspx) [李商隐](https://so.gushiwen.cn/authorv.aspx?name=李商隐)[〔唐代〕](https://so.gushiwen.cn/shiwens/default.aspx?cstr=唐代) 都无色可并，不奈此香何。 瑶席乘凉设，金羁落晚过。 回衾灯照绮，渡袜水沾罗。 预想前秋别，离居梦棹歌。 v-for代码示例123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;(item,index) in msgArr&quot; :title=&quot;index&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt; &lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello World!&#x27;, msgArr: [ &quot;荷花&quot;, &quot;李商隐〔唐代〕&quot;, &quot;都无色可并，不奈此香何。&quot;, &quot;瑶席乘凉设，金羁落晚过。&quot;, &quot;回衾灯照绮，渡袜水沾罗。&quot;, &quot;预想前秋别，离居梦棹歌。&quot; ] &#125; &#125;); &lt;/script&gt; 浏览器就会输出这首《荷花》。 需要注意的几个用法： v-for的作用是：根据列表生成列表结构 v-for主要和数组结合使用 语法(item,index) in 数据 || item in 数据 item和index可以结合其他指令一起使用 12&lt;!-- 指定标签title为it --&gt;&lt;p v-for=&quot;(it,index) in msg&quot; :title=&quot;it&quot;&gt;&#123;&#123; it &#125;&#125;&lt;/p&gt; 当然，也支持Json数组的解析。 123456789101112131415161718msg_2:&#123; title:&quot;荷花&quot;, author:&quot;李商隐〔唐代〕&quot;, content:[ &#123; sentence: &quot;都无色可并，不奈此香何。&quot;, &#125;, &#123; sentence: &quot;瑶席乘凉设，金羁落晚过。&quot;, &#125;, &#123; sentence: &quot;回衾灯照绮，渡袜水沾罗。&quot;, &#125;, &#123; sentence: &quot;预想前秋别，离居梦棹歌。&quot;, &#125; ]&#125; 使用上述Json数据时，则需要更改v-for的格式才能有效遍历： 1&lt;p v-for=&quot;it_2 in msg_2.content&quot; :title=&quot;it_2&quot;&gt;&#123;&#123; it_2.secntence &#125;&#125;&lt;/p&gt;使用了v-model绑定了input，每点击一次按钮，界面就会增加输入框中的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; &lt;/style&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue_01_Demo&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;打印输入内容&quot; @click=&quot;print(&#x27;hello&#x27;)&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot; @keyup.enter=&quot;msgBox&quot;&gt; &lt;p v-for=&quot;it in showValue&quot;&gt;&#123;&#123; it.name &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt; &lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello World!&#x27;, inputValue:&#x27;&#x27;, showValue:[] &#125;, methods:&#123; print:function(str)&#123; this.showValue.push(&#123;name:this.inputValue&#125;) &#125;, msgBox:function()&#123; alert(&quot;ok&quot;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;简而言之就是实现标签的绑定，应用于关联标签之间的数据绑定。在v-on补充中有相应的用法可以参考使用。 123&#123;% hideToggle 分割线 %&#125;&#123;% endhideToggle %&#125; 综合上述所学，实现首页图片切换的功能代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; a&#123; text-decoration: none; font-size: 40px; background-color: rgba(255, 255, 255, 0.5); padding: 10px; border-radius: 25px; position: relative; z-index: 99; width: 100%; color: black; top: 510px; &#125; a:active &#123; color: white; &#125; body&#123; align-items: center; text-align: center; /* padding: 20%; */ &#125; .imgShift&#123; zoom: 100%; border: 1px solid white; width: 1960px; height: 1060px; &#125; &lt;/style&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue_09_ShiftImg&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mask&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;prev&quot; style=&quot;right:45%&quot;&gt;←&lt;/a&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;next&quot; style=&quot;left:45%&quot;&gt;→&lt;/a&gt; &lt;br&gt; &lt;img :src=&quot;imgArr[index]&quot; alt=&quot;&quot; :class=&quot;&#x27;imgShift&#x27;&quot; /&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt; &lt;script&gt; var app = new Vue(&#123; el: &#x27;#mask&#x27;, data: &#123; imgArr: [ &quot;../img/2.jpg&quot;, &quot;../img/3.jpg&quot;, &quot;../img/4.jpg&quot;, &quot;../img/1.jpg&quot; ], message: &#x27;Hello World!&#x27;, index: 0 &#125;, methods: &#123; prev: function () &#123; this.index--; if(this.index &lt; 0) &#123; this.index = 3; &#125; &#125;, next: function () &#123; this.index++; if(this.index &gt; 3) &#123; this.index = 0; &#125; &#125; &#125; &#125;); &lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 小黑记事本的实现 结合以上所学，实现一个记事本功能，CSS样式修饰比较麻烦，仅就功能敲一下代码 Temp_Code代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; &lt;/style&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Vue_01_Demo&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;style&gt; #todoapp&#123; display:grid; border: none; width: 100%; height: 100%; align-self: center; text-align: center; max-width: 550px; min-width: 230px; line-height: 1.4em; margin: 0 auto; font-weight: 300; filter:drop-shadow(1px 1px 5px rgb(2, 1, 2)); border-radius: 25px; transform: scale3d(1,1,1); transition: cubic-bezier(0.215, 0.610, 0.355, 1); background-color: white; &#125; #footer &#123; color: rgb(138, 133, 133); border: 1px rgb(182, 180, 180) solid; display:inline-block; padding: 10px 15px; border-bottom: none; border-radius: inherit; &#125; #main&#123; height: 30%; width: 80%; &#125; #todo-list &#123; width: 100%; &#125; #todo&#123; list-style-type: none; font: &#x27;微软雅黑&#x27;; font-size: 15px; padding: 10px; border: 1px rgb(194, 192, 192) solid; text-align: center; width: 100%; &#125; .new-todo&#123; width: 90%; font-size: 15px; padding: 10px; border: 1px rgb(194, 192, 192) solid; height: 30%; display:flexbox; filter: opacity(1); background-color: transparent!important; &#125; #view &#123; &#125; #index&#123; text-align: left; float: left; &#125; #destroy &#123; float: right; height: 10%; width: 9%; filter: opacity(0); border: none; background-color: none; &#125; li:hover #destroy &#123; filter: opacity(1); background-color: none; color: black; font-size: 15px; &#125; li:hover &#123; color: white; background-color: rgb(46, 115, 243); &#125; #info &#123; bottom: -850px; text-align: center!important; &#125; button &#123; background-color: transparent; width: 10%; height: 100%; border: none; &#125; button:hover &#123; background-color: rgb(46, 115, 243); color: white; border-radius: 25px; filter: drop-shadow(1px 2px 5px rgb(229, 221, 230)); transform: scale(1.5,1.5); font-size: 15px; font-family: &#x27;Franklin Gothic Medium&#x27;, &#x27;Arial Narrow&#x27;, Arial, sans-serif; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 主题区域 --&gt; &lt;section id=&quot;todoapp&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1&gt; 记事本 &lt;/h1&gt; &lt;input v-model=&quot;inputValue&quot; type=&quot;text&quot; @keyup.enter=&quot;add&quot; placeholder=&quot;请输入任务&quot; class=&quot;new-todo&quot; /&gt; &lt;/header&gt; &lt;!-- 列表区域 --&gt; &lt;section id=&quot;main&quot;&gt; &lt;ul id=&quot;todo-list&quot;&gt; &lt;li id=&quot;todo&quot; v-for=&quot;(item,index) in list&quot;&gt; &lt;div id=&quot;view&quot;&gt; &lt;span id=&quot;index&quot;&gt;&#123;&#123; index+1&#125;&#125;&lt;/span&gt; &lt;label style=&quot;text-align: left;&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/label&gt; &lt;button id=&quot;destroy&quot; @click=&quot;remove(index)&quot;&gt;×&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;!--统计和清空 --&gt; &lt;footer id=&quot;footer&quot;&gt; &lt;label style=&quot;float: left;&quot;&gt;&#123;&#123; list.length &#125;&#125; items left&lt;/label&gt; &lt;button style=&quot;float: right;&quot; @click=&quot;clear&quot;&gt;clear&lt;/button&gt; &lt;/footer&gt; &lt;/section&gt; &lt;!-- 底部 --&gt; &lt;footer id=&quot;info&quot;&gt;CopyRight By mignming.shi&lt;/footer&gt; &lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt; &lt;script&gt; var app = new Vue(&#123; el: &#x27;#todoapp&#x27;, data: &#123; list:[&quot;牺牲你宝贵的时间去干了更宝贵的事情吗？&quot;,&quot;保持思考&quot;], inputValue:&quot;&quot; &#125;, methods:&#123; add:function()&#123; if(this.inputValue.length != 0)&#123; this.list.push(this.inputValue); this.inputValue = &quot;&quot;; &#125; &#125;, remove:function(x)&#123; console.log(x); this.list.splice(x,1); &#125;, clear:function()&#123; this.list = []; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果","raw":null,"content":null,"categories":[{"name":"学习笔记，前端","slug":"学习笔记，前端","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.mingsrc.work/tags/VUE/"}]},{"title":"HTML和Markdown设置下换线","slug":"E_学习笔记/前端/HTML/HTML之下划线","date":"2022-12-27T03:12:54.045Z","updated":"2022-12-27T03:12:54.045Z","comments":true,"path":"posts/19f15521.html","link":"","permalink":"https://www.mingsrc.work/posts/19f15521","excerpt":"","text":"HTML以及编辑的Markdown如何设置下划线样式本篇文章就给大家介绍css添加文字下划线样式的方法。有一定的参考价值，有需要的朋友可以参考一下，希望对大家有所帮助。 常规办法1&lt;u&gt;这里是常规办法添加下划线&lt;/u&gt; 效果如下： 这里是常规办法添加下划线 text-decoration属性1&lt;span style=&quot;text-decoration:underline&quot;&gt;这是text-decoration属性设置的下划线。&lt;/span&gt; 效果如下： 这是text-decoration属性设置的下划线。 border-bottom属性border-bottom属性使用起来比较灵活，并且可以设置线的格式，因此能满足你一篇文章的不同需求~~~ 12345&lt;p&gt;这是第实线样式，&lt;span style=&quot;border-bottom: 1px solid #000000;&quot;&gt;Mming‘s Blog&lt;/span&gt;! &lt;/p&gt; &lt;p&gt;这是变粗的实线，&lt;span style=&quot;border-bottom: 5px solid #0081EF;&quot;&gt;Mming‘s Blog&lt;/span&gt;! &lt;/p&gt;&lt;p&gt;这是虚线样式，&lt;span style=&quot;border-bottom: 2px dashed #000000;&quot;&gt;Mming‘s Blog&lt;/span&gt;! &lt;/p&gt;&lt;p&gt;这是虚点下划线，&lt;span style=&quot;border-bottom: 2px dotted #000000;&quot;&gt;Mming‘s Blog&lt;/span&gt;! &lt;/p&gt;&lt;p&gt;这是双下划綫，&lt;span style=&quot;border-bottom: 5px double #000000;&quot;&gt;Mming‘s Blog&lt;/span&gt;! &lt;/p&gt; 效果如下： 这是第实线样式，Mming‘s Blog! 这是变粗的实线，Mming‘s Blog! 这是虚线样式，Mming‘s Blog! 这是虚点下划线，Mming‘s Blog! 这是双下划线，Mming‘s Blog! border-bottom属性可以通过控制线的粗细、颜色、样式来实现不同的文字下划线样式。此外还有如下边框样式供参考⬇️ ： groove: 定义3D沟槽边框。效果取决于边框的颜色值 ridge: 定义3D脊边框。效果取决于边框的颜色值 inset:定义一个3D的嵌入边框。效果取决于边框的颜色值 outset: 定义一个3D突出边框。 效果取决于边框的颜色值 以上就是在HTML或者支持HTML的markdown文件中给文字添加下划线的方式，简单处理可以直接使用u标签，对下划线格式有要求时可以使用border-bottom属性对下划线进行设置。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"学习笔记/前端","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://www.mingsrc.work/tags/HTML/"}]},{"title":"HTML图片位置相关设置","slug":"E_学习笔记/前端/HTML/图片相关","date":"2022-12-27T03:12:54.045Z","updated":"2022-12-27T03:12:54.045Z","comments":true,"path":"posts/d047e518.html","link":"","permalink":"https://www.mingsrc.work/posts/d047e518","excerpt":"","text":"HTML img标签1. 相关属性 2. CSS案例1&lt;style&gt;.b-game-card&#123;position:relative;z-index:1;width:50%;padding-bottom:150%;perspective:1000px&#125;.b-game-card&#123;position:relative;z-index:1;width:100%;padding-bottom:150%;perspective:1000px&#125;.b-game-card__cover&#123;position:absolute;z-index:1;top:0;left:0;width:100%;height:100%;overflow:hidden;background-image:linear-gradient(120deg,#f6d365 0,#fda085 100%);background-size:cover;perspective-origin:50% 50%;transform-style:preserve-3d;transform-origin:top center;will-change:transform;transform:skewX(0.001deg);transition:transform .35s ease-in-out&#125;.b-game-card__cover::after&#123;display:block;content:&quot;&quot;;position:absolute;z-index:100;top:0;left:0;width:100%;height:120%;background:linear-gradient(226deg,rgba(255,255,255,0.4) 0,rgba(255,255,255,0.4) 35%,rgba(255,255,255,0.2) 42%,rgba(255,255,255,0) 60%);transform:translateY(-20%);will-change:transform;transition:transform .65s cubic-bezier(0.18,0.9,0.58,1)&#125;.b-game-card:hover .b-game-card__cover&#123;transform:rotateX(7deg) translateY(-6px)&#125;.b-game-card:hover .b-game-card__cover::after&#123;transform:translateY(0%)&#125;.b-game-card::before&#123;display:block;content:&quot;&quot;;position:absolute;top:5%;left:5%;width:90%;height:90%;background:rgba(0,0,0,0.5);box-shadow:0 6px 12px 12px rgba(0,0,0,0.4);will-change:opacity;transform-origin:top center;transform:skewX(0.001deg);transition:transform .35s ease-in-out,opacity .5s ease-in-out&#125;.b-game-card:hover::before&#123;opacity:.6;transform:rotateX(7deg) translateY(-6px) scale(1.05)&#125;&lt;/style&gt; 效果.b-game-card{position:relative;z-index:1;width:50%;padding-bottom:150%;perspective:1000px}.b-game-card{position:relative;z-index:1;width:100%;padding-bottom:150%;perspective:1000px}.b-game-card__cover{position:absolute;z-index:1;top:0;left:0;width:100%;height:100%;overflow:hidden;background-image:linear-gradient(120deg,#f6d365 0,#fda085 100%);background-size:cover;perspective-origin:50% 50%;transform-style:preserve-3d;transform-origin:top center;will-change:transform;transform:skewX(0.001deg);transition:transform .35s ease-in-out}.b-game-card__cover::after{display:block;content:\"\";position:absolute;z-index:100;top:0;left:0;width:100%;height:120%;background:linear-gradient(226deg,rgba(255,255,255,0.4) 0,rgba(255,255,255,0.4) 35%,rgba(255,255,255,0.2) 42%,rgba(255,255,255,0) 60%);transform:translateY(-20%);will-change:transform;transition:transform .65s cubic-bezier(0.18,0.9,0.58,1)}.b-game-card:hover .b-game-card__cover{transform:rotateX(7deg) translateY(-6px)}.b-game-card:hover .b-game-card__cover::after{transform:translateY(0%)}.b-game-card::before{display:block;content:\"\";position:absolute;top:5%;left:5%;width:90%;height:90%;background:rgba(0,0,0,0.5);box-shadow:0 6px 12px 12px rgba(0,0,0,0.4);will-change:opacity;transform-origin:top center;transform:skewX(0.001deg);transition:transform .35s ease-in-out,opacity .5s ease-in-out}.b-game-card:hover::before{opacity:.6;transform:rotateX(7deg) translateY(-6px) scale(1.05)}","raw":null,"content":null,"categories":[{"name":"学习笔记，前端","slug":"学习笔记，前端","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://www.mingsrc.work/tags/HTML/"}]},{"title":"力扣高效算法入门","slug":"E_学习笔记/刷题笔记/Go刷题笔记/力扣高效算法入门","date":"2022-12-27T03:12:54.044Z","updated":"2022-12-27T03:12:54.045Z","comments":true,"path":"posts/8cb5320c.html","link":"","permalink":"https://www.mingsrc.work/posts/8cb5320c","excerpt":"","text":"[toc] 1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt; -10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt; -10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt; 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n&lt;sup&gt;2&lt;/sup&gt;) 的算法吗？ Solution12345678910func twoSum(nums []int, target int) []int &#123; for i,x := range nums &#123; for j := i + 1; j &lt; len(nums); j++ &#123; if x+nums[j] == target &#123; return []int&#123;i,j&#125; &#125; &#125; &#125; return nil&#125; 167. 两数之和 II - 输入有序数组给定一个已按照**非递减顺序排列 ** 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值_。_numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。 示例 1： 123输入：numbers = [2,7,11,15], target = 9输出：[1,2]解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 示例 2： 12输入：numbers = [2,3,4], target = 6输出：[1,3] 示例 3： 12输入：numbers = [-1,0], target = -1输出：[1,2] 提示： 2 &lt;= numbers.length &lt;= 3 * 10&lt;sup&gt;4&lt;/sup&gt; -1000 &lt;= numbers[i] &lt;= 1000 numbers 按 非递减顺序 排列 -1000 &lt;= target &lt;= 1000 仅存在一个有效答案 Solution#双指针 12345678910111213141516func twoSum(numbers []int, target int) []int &#123; left,right := 0, len(numbers) - 1 for left &lt; right &#123; sum := numbers[left] + numbers [right] if sum == target &#123; return []int&#123;left + 1, right + 1&#125; &#125; else if sum &lt; target &#123; left++ &#125; else &#123; right-- &#125; &#125; return []int&#123;-1,-1&#125; &#125; 15. 三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 _a，b，c ，_使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 12输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]] 示例 2： 12输入：nums = []输出：[] 示例 3： 12输入：nums = [0]输出：[] 提示： 0 &lt;= nums.length &lt;= 3000 -10&lt;sup&gt;5&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt; Solution#三指针 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; // 先排序 int n = nums.size(); sort(nums.begin(), nums.end()); // 定义首指针==target for (int i = 0; i &lt; n; i++) &#123; if ( i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; int k = n - 1; // 内层首指针 int target = -nums[i]; for (int j = i + 1; j &lt; n; j++) // 内层尾指针 &#123; if( j &gt; i + 1 &amp;&amp; nums[j] == nums[j-1]) continue; while (j &lt; k &amp;&amp; nums[j] + nums[k] &gt; target) &#123; // 遍历尾指针，找合适序列 --k; &#125; // 当前i不满足 if(j == k) &#123; break; &#125; // 得到符合条件序列 if(nums[j] + nums[k] == target) &#123; ans.push_back(&#123;nums[i],nums[j],nums[k]&#125;); &#125; &#125; &#125; return ans; &#125;&#125;; 18. 四数之和给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 1： 12输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 12输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]] 提示： 1 &lt;= nums.length &lt;= 200 -10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt; -10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt; Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ans; int n = nums.size(); if(n &lt; 4) return ans; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; n - 3; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123; break; &#125; if ((long) nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] &lt; target) &#123; continue; &#125; for (int j = i + 1; j &lt; n - 2; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j-1]) continue; if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) &#123; break; &#125; if ((long) nums[i] + nums[j] + nums[n - 2] + nums[n - 1] &lt; target) &#123; continue; &#125; // 最内层首尾指针 int m = n - 1, k = j + 1; while(k &lt; m) &#123; int sum = nums[i] + nums[j] + nums[k] + nums[m]; if (sum == target) &#123; ans.push_back(&#123;nums[i], nums[j], nums[k], nums[m]&#125;); while (k &lt; m &amp;&amp; nums[k] == nums[k + 1]) &#123; k++; &#125; k++; while (k &lt; m &amp;&amp; nums[m] == nums[m - 1]) &#123; m--; &#125; m--; &#125; else if (sum &lt; target) &#123; k++; &#125; else &#123; m--; &#125; &#125; &#125; &#125; return ans; &#125;&#125;; 509. 斐波那契数斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你 n ，请计算 F(n) 。 示例 1： 123输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 123输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 123输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 &lt;= n &lt;= 30 Solution123456789func fib(n int) int &#123; if n == 0 &#123; return 0 &#125; else if n == 1 &#123; return 1 &#125; else &#123; return fib(n-2) + fib(n-1) &#125;&#125; 70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1\\. 1 阶 + 1 阶2\\. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1\\. 1 阶 + 1 阶 + 1 阶2\\. 1 阶 + 2 阶3\\. 2 阶 + 1 阶 Solution12345678910111213func climbStairs(n int) int &#123; if n &lt;= 2 &#123; return n &#125; pre1,pre2 := 2,1 for i := 2; i &lt; n; i++ &#123; cur := pre1 + pre2 pre2 = pre1 pre1 = cur &#125; return pre1&#125; 53. 最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 123输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 12输入：nums = [1]输出：1 示例 3： 12输入：nums = [5,4,-1,7,8]输出：23 提示： 1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt; -10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt; 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 Solution#动态规划 123456789101112func maxSubArray(nums []int) int &#123; sum := nums[0] for i := 1; i &lt; len(nums); i++ &#123; if nums[i] + nums[i-1] &gt; nums[i] &#123; nums[i] += nums[i-1] &#125; if nums[i] &gt; sum &#123; sum = nums[i] &#125; &#125; return sum&#125; 416. 分割等和子集给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 123输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2： 123输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 Solution#动态规划 #背包问题 #difficult 1234567891011121314151617181920212223242526272829303132333435func canPartition(nums []int) bool &#123; n := len(nums) if n &lt; 2 &#123; return false &#125; sum, maxNum := 0,0 for _,num := range nums &#123; sum += num if num &gt; maxNum &#123; maxNum = num &#125; &#125; // 判断总和是不是奇数 if sum%2 != 0 &#123; return false &#125; target := sum / 2 if target &lt; maxNum &#123; return false &#125; dp := make([]bool, target+1) dp[0] = true for i := 0; i &lt; n; i++ &#123; v := nums[i] for j := target; j &gt;= v; j-- &#123; dp[j] = dp[j] || dp[j-v] &#125; &#125; return dp[target]&#125; 322. 零钱兑换给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 123输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1 示例 2： 12输入：coins = [2], amount = 3输出：-1 示例 3： 12输入：coins = [1], amount = 0输出：0 示例 4： 12输入：coins = [1], amount = 1输出：1 示例 5： 12输入：coins = [1], amount = 2输出：2 提示： 1 &lt;= coins.length &lt;= 12 1 &lt;= coins[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1 0 &lt;= amount &lt;= 10&lt;sup&gt;4&lt;/sup&gt; Solution#动态规划 1234567891011121314151617181920212223242526272829func coinChange(coins []int, amount int) int &#123; dp := make([]int, amount + 1) dp[0] = 0 // 初始化为math.MaxInt32 for j := 1; j &lt;= amount; j++ &#123; dp[j] = math.MaxInt32 &#125; for i := 0; i &lt; len(coins); i++ &#123; for j := coins[i]; j &lt;= amount ; j++ &#123; if dp[j-coins[i]] != math.MaxInt32 &#123; dp[j] = min(dp[j], dp[j-coins[i]]+1) &#125; &#125; &#125; // 没找到能装满背包的, 就返回-1 if dp[amount] == math.MaxInt32 &#123; return -1 &#125; return dp[amount]&#125;func min(a, b int) int &#123; if a &lt; b&#123; return a &#125; return b&#125; 20. 有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 12输入：s = &quot;()&quot;输出：true 示例 2： 12输入：s = &quot;()[]&#123;&#125;&quot;输出：true 示例 3： 12输入：s = &quot;(]&quot;输出：false 示例 4： 12输入：s = &quot;([)]&quot;输出：false 示例 5： 12输入：s = &quot;&#123;[]&#125;&quot;输出：true 提示： 1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt; s 仅由括号 &#39;()[]&#123;&#125;&#39; 组成 Solution#栈 12345678910111213141516171819202122232425func isValid(s string) bool &#123; n := len(s) if n % 2 == 1 &#123; return false &#125; pairs := map[byte]byte &#123; &#x27;)&#x27;:&#x27;(&#x27;, &#x27;]&#x27;:&#x27;[&#x27;, &#x27;&#125;&#x27;:&#x27;&#123;&#x27;, &#125; stack := []byte&#123;&#125; for i := 0; i &lt; n; i++ &#123; if pairs[s[i]] &gt; 0 &#123; if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] &#123; return false &#125; stack = stack[:len(stack)-1] &#125; else &#123; stack = append(stack,s[i]) &#125; &#125; return len(stack) == 0&#125; 20. 有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 12输入：s = &quot;()&quot;输出：true 示例 2： 12输入：s = &quot;()[]&#123;&#125;&quot;输出：true 示例 3： 12输入：s = &quot;(]&quot;输出：false 示例 4： 12输入：s = &quot;([)]&quot;输出：false 示例 5： 12输入：s = &quot;&#123;[]&#125;&quot;输出：true 提示： 1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt; s 仅由括号 &#39;()[]&#123;&#125;&#39; 组成 Solution#栈 12345678910111213141516171819202122232425func isValid(s string) bool &#123; n := len(s) if n % 2 == 1 &#123; return false &#125; pairs := map[byte]byte &#123; &#x27;)&#x27;:&#x27;(&#x27;, &#x27;]&#x27;:&#x27;[&#x27;, &#x27;&#125;&#x27;:&#x27;&#123;&#x27;, &#125; stack := []byte&#123;&#125; for i := 0; i &lt; n; i++ &#123; if pairs[s[i]] &gt; 0 &#123; if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] &#123; return false &#125; stack = stack[:len(stack)-1] &#125; else &#123; stack = append(stack,s[i]) &#125; &#125; return len(stack) == 0&#125; 496. 下一个更大元素 Inums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x大的元素。 给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。 对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。 返回一个长度为 nums1.length 的数组ans作为答案，满足ans[i]是如上所述的 下一个更大元素 。 示例 1： 123456输入：nums1 = [4,1,2], nums2 = [1,3,4,2].输出：[-1,3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 示例 2： 12345输入：nums1 = [2,4], nums2 = [1,2,3,4].输出：[3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。 提示： 1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt; nums1和nums2中所有整数 互不相同 nums1 中的所有整数同样出现在 nums2 中 进阶：你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？ Solution&#x2F;#暴力解 12345678910111213141516171819202122func nextGreaterElement(nums1 []int, nums2 []int) []int &#123; m,n := len(nums1),len(nums2) res := make([]int, m) for i := 0; i &lt; m; i++ &#123; j := 0 for j &lt; n &amp;&amp; nums2[j] != nums1[i] &#123; j++ &#125; k := j + 1 for k &lt; n &amp;&amp; nums2[k] &lt; nums2[j] &#123; k++ &#125; if k &lt; n &#123; res[i] = nums2[k] &#125; else &#123; res[i] = -1 &#125; &#125; return res&#125; 456. 132 模式给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 示例 1： 123输入：nums = [1,2,3,4]输出：false解释：序列中不存在 132 模式的子序列。 示例 2： 123输入：nums = [3,1,4,2]输出：true解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例 3： 123输入：nums = [-1,3,2,0]输出：true解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。 提示： n == nums.length 1 &lt;= n &lt;= 2 * 10&lt;sup&gt;5&lt;/sup&gt; -10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt; Solution#栈 #单调栈 12345678910111213141516171819202122func find132pattern(nums []int) bool &#123; n := len(nums) candidateK := []int&#123;nums[n-1]&#125; maxK := math.MinInt64 for i := n - 2; i &gt;= 0; i-- &#123; if nums[i] &lt; maxK &#123; return true &#125; for len(candidateK) &gt; 0 &amp;&amp; nums[i] &gt; candidateK[len(candidateK)-1] &#123; maxK = candidateK[len(candidateK)-1] candidateK = candidateK[:len(candidateK)-1] &#125; if nums[i] &gt; maxK &#123; candidateK = append(candidateK, nums[i]) &#125; &#125; return false&#125; 119. 杨辉三角 II给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 示例 1: 12输入: rowIndex = 3输出: [1,3,3,1] 示例 2: 12输入: rowIndex = 0输出: [1] 示例 3: 12输入: rowIndex = 1输出: [1,1] 提示: 0 &lt;= rowIndex &lt;= 33 进阶： 你可以优化你的算法到 _O_(_rowIndex_) 空间复杂度吗？ Solution#数学 1234567891011func getRow(rowIndex int) []int &#123; C := make([][]int, rowIndex+1) for i := range C &#123; C[i] = make([]int,i+1) C[i][0],C[i][i] = 1,1 for j := 1; j &lt; i; j++ &#123; C[i][j] = C[i-1][j-1] + C[i-1][j] &#125; &#125; return C[rowIndex]&#125; 279. 完全平方数给定正整数 _n_，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 _n_。你需要让组成和的完全平方数的个数最少。 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 123输入：n = 12输出：3 解释：12 = 4 + 4 + 4 示例 2： 123输入：n = 13输出：2解释：13 = 4 + 9 提示： 1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt; Solution#动态规划 123456789101112131415161718func numSquares(n int) int &#123; f := make([]int, n+1) for i := 1; i &lt;= n; i++ &#123; minn := math.MaxInt32 for j := 1; j*j &lt;= i; j++ &#123; minn = min(minn, f[i-j*j]) &#125; f[i] = minn + 1 &#125; return f[n]&#125;func min(a,b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125; 112. 路径总和给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例 1： 123输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2： 123456输入：root = [1,2,3], targetSum = 5输出：false解释：树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。 示例 3： 123输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示： 树中节点的数目在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 Solution#广度搜索 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func hasPathSum(root *TreeNode, targetSum int) bool &#123; if root == nil &#123; return false &#125; queNode := []*TreeNode&#123;&#125; queVal := []int&#123;&#125; queNode = append(queNode,root) queVal = append(queVal,root.Val) for len(queNode) != 0 &#123; now := queNode[0] queNode = queNode[1:] temp := queVal[0] queVal = queVal[1:] if now.Left == nil &amp;&amp; now.Right == nil &#123; if temp == targetSum &#123; return true &#125; continue &#125; if now.Left != nil &#123; queNode = append(queNode,now.Left) queVal = append(queVal,now.Left.Val + temp) &#125; if now.Right != nil &#123; queNode = append(queNode, now.Right) queVal = append(queVal, now.Right.Val + temp) &#125; &#125; return false&#125; 720. 词典中最长的单词给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。 若无答案，则返回空字符串。 示例 1： 12345输入：words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]输出：&quot;world&quot;解释： 单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;添加一个字母组成。 示例 2： 12345输入：words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]输出：&quot;apple&quot;解释：&quot;apply&quot;和&quot;apple&quot;都能由词典中的单词组成。但是&quot;apple&quot;的字典序小于&quot;apply&quot;。 提示： 所有输入的字符串都只包含小写字母。 words数组长度范围为[1,1000]。 words[i]的长度范围为[1,30]。 SolutionLanguage: **** 123456789101112131415161718192021222324func longestWord(words []string) string &#123; // 排序哈希 sort.Strings(words) // 字符串/是否出现 wordsMap := make(map[string]bool) res := &quot;&quot; for _,word := range words &#123; wlen, reslen := len(word), len(res) // 字符串前缀 if wlen == 1 || wordsMap[word[:wlen-1]] &#123; wordsMap[word] = true // 更新res为最长的单词 if reslen == 0 || reslen &lt; wlen &#123; res = word &#125; &#125; &#125; return res&#125; 28. 实现 strStr()实现 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 以及 Java 的 定义相符。 示例 1： 12输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出：2 示例 2： 12输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出：-1 示例 3： 12输入：haystack = &quot;&quot;, needle = &quot;&quot;输出：0 提示： 0 &lt;= haystack.length, needle.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt; haystack 和 needle 仅由小写英文字符组成 Solution12345678910111213func strStr(haystack string, needle string) int &#123; n,m := len(haystack), len(needle)outer: for i := 0; i + m &lt;= n; i++ &#123; for j:= range needle &#123; if haystack[i+j] != needle[j] &#123; continue outer &#125; &#125; return i &#125; return -1&#125; 3. 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 **最长子串 **的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 示例 4: 12输入: s = &quot;&quot;输出: 0 提示： 0 &lt;= s.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt; s 由英文字母、数字、符号和空格组成 SolutionLanguage: **** 1234567891011121314151617181920212223242526func lengthOfLongestSubstring(s string) int &#123; m := map[byte]int&#123;&#125; n := len(s) rk, ans := -1, 0 for i := 0; i &lt; n; i++ &#123; if i != 0 &#123; delete(m,s[i-1]) &#125; for rk + 1 &lt; n &amp;&amp; m[s[rk+1]] == 0 &#123; m[s[rk+1]]++ rk++ &#125; ans = max(ans, rk - i + 1) &#125; return ans&#125;func max(x, y int) int &#123; if x &lt; y &#123; return y &#125; return x&#125;","raw":null,"content":null,"categories":[{"name":"Go","slug":"Go","permalink":"https://www.mingsrc.work/categories/Go/"},{"name":"学习笔记","slug":"Go/学习笔记","permalink":"https://www.mingsrc.work/categories/Go/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"刷题笔记","slug":"Go/学习笔记/刷题笔记","permalink":"https://www.mingsrc.work/categories/Go/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.mingsrc.work/tags/Go/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mingsrc.work/tags/LeetCode/"}]},{"title":"力扣每日一题","slug":"E_学习笔记/刷题笔记/Go刷题笔记/PerDaySolution","date":"2022-12-27T03:12:54.043Z","updated":"2022-12-27T03:12:54.043Z","comments":true,"path":"posts/206c9e3b.html","link":"","permalink":"https://www.mingsrc.work/posts/206c9e3b","excerpt":"","text":"[Toc] 382. 链表随机节点给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。 实现 Solution 类： Solution(ListNode head) 使用整数数组初始化对象。 int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。 示例： 1234567891011121314输入[&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;][[[1, 2, 3]], [], [], [], [], []]输出[null, 1, 3, 2, 2, 3]解释Solution solution = new Solution([1, 2, 3]);solution.getRandom(); // 返回 1solution.getRandom(); // 返回 3solution.getRandom(); // 返回 2solution.getRandom(); // 返回 2solution.getRandom(); // 返回 3// getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。 提示： 链表中的节点数在范围 [1, 10&lt;sup&gt;4&lt;/sup&gt;] 内 -10&lt;sup&gt;4&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt; 至多调用 getRandom 方法 10&lt;sup&gt;4&lt;/sup&gt; 次 进阶： 如果链表非常大且长度未知，该怎么处理？ 你能否在不使用额外空间的情况下解决此问题？ Solution#链表 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */type Solution []intfunc Constructor(head *ListNode) (s Solution) &#123; for node := head; node != nil; node = node.Next &#123; s = append(s, node.Val) &#125; return s&#125;func (s Solution) GetRandom() int &#123; return s[rand.Intn(len(s))]&#125;/** * Your Solution object will be instantiated and called as such: * obj := Constructor(head); * param_1 := obj.GetRandom(); */","raw":null,"content":null,"categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.mingsrc.work/tags/Go/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mingsrc.work/tags/LeetCode/"}]},{"title":"Go_hard_Algorithm","slug":"E_学习笔记/刷题笔记/Go刷题笔记/hardAlgorithm","date":"2022-12-27T03:12:54.043Z","updated":"2022-12-27T03:12:54.043Z","comments":true,"path":"posts/24feca74.html","link":"","permalink":"https://www.mingsrc.work/posts/24feca74","excerpt":"","text":"913. 猫和老鼠 #图 #dfs #dp两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。 图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。 老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。 在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。 此外，猫无法移动到洞中（节点 0）。 然后，游戏在出现以下三种情形之一时结束： 如果猫和老鼠出现在同一个节点，猫获胜。 如果老鼠到达洞中，老鼠获胜。 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏： 如果老鼠获胜，则返回 1； 如果猫获胜，则返回 2； 如果平局，则返回 0 。 示例 1： 12输入：graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]输出：0 示例 2： 12输入：graph = [[1,3],[0],[3],[0,2]]输出：1 提示： 3 &lt;= graph.length &lt;= 50 1 &lt;= graph[i].length &lt; graph.length 0 &lt;= graph[i][j] &lt; graph.length graph[i][j] != i graph[i] 互不相同 猫和老鼠在游戏中总是移动 Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const int MOUSE_WIN = 1;const int CAT_WIN = 2;const int DRAW = 0;const int MAXN = 51;class Solution &#123;public: int n; int dp[MAXN][MAXN][MAXN*2]; vector&lt;vector&lt;int&gt;&gt; graph; int catMouseGame(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; this-&gt;n = graph.size(); this-&gt;graph = graph; memset(dp,-1,sizeof(dp)); return getResult(1, 2, 0); &#125; int getResult(int mouse, int cat, int turns) &#123; if(turns == n * 2) &#123; return DRAW; &#125; if( dp[mouse][cat][turns] &lt; 0 ) &#123; if(mouse == 0) &#123; dp[mouse][cat][turns] = MOUSE_WIN; &#125; else if (cat == mouse) &#123; dp[mouse][cat][turns] = CAT_WIN; &#125; else &#123; getNextResult(mouse, cat, turns); &#125; &#125; return dp[mouse][cat][turns]; &#125; void getNextResult(int mouse, int cat, int turns) &#123; int curMove = turns % 2 == 0 ? mouse : cat; int defaultResult = curMove == mouse ? CAT_WIN : MOUSE_WIN; int result = defaultResult; for(int next : graph[curMove]) &#123; if(curMove == cat &amp;&amp; next == 0) &#123; continue; &#125; int nextMouse = curMove == mouse ? next : mouse; int nextCat = curMove == cat ? next : cat; int nextResult = getResult(nextMouse, nextCat, turns+1); if(nextResult != defaultResult) &#123; result = nextResult; if(result != DRAW) &#123; break; &#125; &#125; &#125; dp[mouse][cat][turns] = result; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const ( draw = 0 mouseWin = 1 catWin = 2)func catMouseGame(graph [][]int) int &#123; n := len(graph) dp := make([][][]int, n) for i:= range dp &#123; dp[i] = make([][]int, n) for j:= range dp[i] &#123; dp[i][j] = make([]int, n*2) for k:= range dp[i][j] &#123; dp[i][j][k] = -1 &#125; &#125; &#125; var getResult, getNextResult func (int, int, int) int getResult = func(mouse, cat, turns int) int &#123; if turns == n*2 &#123; return draw &#125; res := dp[mouse][cat][turns] if res != -1 &#123; return res &#125; if mouse == 0 &#123; res = mouseWin &#125; else if cat == mouse &#123; res = catWin &#125; else &#123; res = getNextResult(mouse, cat, turns) &#125; dp[mouse][cat][turns] = res return res &#125; getNextResult = func(mouse, cat, turns int) int &#123; curMove := mouse if turns % 2 == 1 &#123; curMove = cat &#125; defaultRes := mouseWin if curMove == mouse &#123; defaultRes = catWin &#125; res := defaultRes for _,next := range graph[curMove] &#123; if curMove == cat &amp;&amp; next == 0 &#123; continue &#125; nextMouse, nextCat := mouse,cat if curMove == mouse &#123; nextMouse = next &#125; else if curMove == cat &#123; nextCat = next &#125; nextRes := getResult(nextMouse, nextCat, turns + 1 ) if nextRes != defaultRes &#123; res = nextRes if res != draw &#123; break &#125; &#125; &#125; return res &#125; return getResult(1,2,0)&#125; 思路（转自力扣官方）这道题是博弈问题，猫和老鼠都按照最优策略参与游戏。 在阐述具体解法之前，首先介绍博弈问题中的三个概念：必胜状态、必败状态与必和状态。 对于特定状态，如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态与必和状态。 如果分出胜负，则该特定状态对于获胜方为必胜状态，对于落败方为必败状态。 如果是平局，则该特定状态对于双方都为必和状态。 从特定状态开始，如果存在一种操作将状态变成必败状态，则当前玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家为必胜状态。 从特定状态开始，如果所有操作都会将状态变成必胜状态，则无论当前玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态。 从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都为必和状态。 对于每个玩家，最优策略如下： 争取将必胜状态留给自己，将必败状态留给对方玩家。 在自己无法到达必胜状态的情况下，争取将必和状态留给自己。 方法一：动态规划博弈问题通常可以使用动态规划求解。 使用三维数组 $dp$ 表示状态，$dp[mouse][cat][turns] $表示从老鼠位于节点 $\\textit{mouse}mouse$、猫位于节点 $\\textit{cat}cat$、游戏已经进行了 $\\textit{turns}turns $轮的状态开始，猫和老鼠都按照最优策略的情况下的游戏结果。假设图中的节点数是 nn，则有 $0 \\le \\textit{mouse}, \\textit{cat} &lt; n0≤mouse,cat&lt;n$。 由于游戏的初始状态是老鼠位于节点 11，猫位于节点 22，因此$ \\textit{dp}[1][2][0]dp[1][2][0] $为从初始状态开始的游戏结果。 动态规划的边界条件为可以直接得到游戏结果的状态，包括以下三种状态： 如果$ \\textit{mouse} &#x3D; 0mouse&#x3D;0$，老鼠躲入洞里，则老鼠获胜，因此对于任意$ \\textit{cat}cat$ 和 $\\textit{turns}turns 都有 \\textit{dp}[0][\\textit{cat}][\\textit{turns}] &#x3D; 1dp[0][cat][turns]&#x3D;1$，该状态为老鼠的必胜状态，猫的必败状态。 如果$ \\textit{cat} &#x3D; \\textit{mouse}cat&#x3D;mouse$，猫和老鼠占据相同的节点，则猫获胜，因此当 $\\textit{cat} &#x3D; \\textit{mouse}cat&#x3D;mouse $时，对于任意 $\\textit{mouse}mouse、\\textit{cat}cat $和 $\\textit{turns}turns$ 都有$ \\textit{dp}[\\textit{mouse}][\\textit{cat}][\\textit{turns}] &#x3D; 2dp[mouse][cat][turns]&#x3D;2$，该状态为老鼠的必败状态，猫的必胜状态。注意猫不能移动到节点 00，因此当$ \\textit{mouse} &#x3D; 0mouse&#x3D;0$ 时，一定有$ \\textit{cat} \\ne \\textit{mouse}cat &#x3D;mouse$。 如果$ \\textit{turns} \\ge 2nturns≥2n$，则是平局，该状态为双方的必和状态。 为什么当 $\\textit{turns} \\ge 2nturns≥2n$时，游戏结果是平局呢？ 如果游戏已经进行了$ 2n2n$ 轮，但是仍然没有任何一方获胜，此时猫和老鼠各移动了 nn 次，该移动次数等于图中的节点数，因此一定存在一个老鼠到达过至少两次的节点，以及一定存在一个猫到达过至少两次的节点。 对于老鼠而言，即使按照最优策略，也无法躲入洞内，而是只能回到一个已经到达过的节点。当老鼠回到一个在过去的某个回合已经到达过的节点时，猫可能回到在相同回合已经到达过的节点，也可能移动到一个更有利于猫获胜的节点，不可能移动到一个更有利于老鼠获胜的节点（否则猫就不是按照最优策略参与游戏）。如果猫回到在相同回合已经到达过的节点，则形成循环，因此是平局；如果猫移动到一个更有利于猫获胜的节点，则老鼠的获胜机会更小，因此老鼠无法获胜。 同理可知，如果猫按照最优策略也只能回到一个已经到达过的节点，则猫无法获胜。因此当猫和老鼠分别回到一个已经到达过的节点时，猫和老鼠都无法获胜，游戏结果是平局。 动态规划的状态转移需要考虑当前玩家所有可能的移动，选择最优策略的移动。由于老鼠先开始移动，猫后开始移动，因此可以根据游戏已经进行的轮数 $\\textit{turns}turns $的奇偶性决定当前轮到的玩家，当$ \\textit{turns}turns $是偶数时轮到老鼠移动，当 $\\textit{turns}turns $是奇数时轮到猫移动。 如果轮到老鼠移动，则对于老鼠从当前节点移动一次之后可能到达的每个节点，进行如下操作： 如果存在一个节点，老鼠到达该节点之后，老鼠可以获胜，则老鼠到达该节点之后的状态为老鼠的必胜状态，猫的必败状态，因此在老鼠移动之前的当前状态为老鼠的必胜状态。如果老鼠到达任何节点之后的状态都不是老鼠的必胜状态，但是存在一个节点，老鼠到达该节点之后，结果是平局，则老鼠到达该节点之后的状态为双方的必和状态，因此在老鼠移动之前的当前状态为双方的必和状态。 如果老鼠到达任何节点之后的状态都不是老鼠的必胜状态或必和状态，则老鼠到达任何节点之后的状态都为老鼠的必败状态，猫的必胜状态，因此在老鼠移动之前的当前状态为老鼠的必败状态。 如果轮到猫移动，则对于猫从当前节点移动一次之后可能到达的每个节点，进行如下操作： 如果存在一个节点，猫到达该节点之后，猫可以获胜，则猫到达该节点之后的状态为猫的必胜状态，老鼠的必败状态，因此在猫移动之前的当前状态为猫的必胜状态。 如果猫到达任何节点之后的状态都不是猫的必胜状态，但是存在一个节点，猫到达该节点之后，结果是平局，则猫到达该节点之后的状态为双方的必和状态，因此在猫移动之前的当前状态为双方的必和状态。 如果猫到达任何节点之后的状态都不是猫的必胜状态或必和状态，则猫到达任何节点之后的状态都为猫的必败状态，老鼠的必胜状态，因此在猫移动之前的当前状态为猫的必败状态。 实现方面，由于双方移动的策略相似，因此可以使用一个函数实现移动策略，根据游戏已经进行的轮数的奇偶性决定当前轮到的玩家。对于特定玩家的移动，实现方法如下： 如果当前玩家存在一种移动方法到达非必败状态，则用该状态更新游戏结果。 如果该移动方法到达必胜状态，则将当前状态（移动前的状态）设为必胜状态，结束遍历其他可能的移动。 如果该移动方法到达必和状态，则将当前状态（移动前的状态）设为必和状态，继续遍历其他可能的移动，因为可能存在到达必胜状态的移动方法。 如果当前玩家的任何移动方法都到达必败状态，则将当前状态（移动前的状态）设为必败状态。 特别地，如果当前玩家是猫，则不能移动到节点 00。 作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/cat-and-mouse/solution/mao-he-lao-shu-by-leetcode-solution-444x/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"Go","permalink":"https://www.mingsrc.work/categories/Go/"},{"name":"刷题笔记","slug":"学习笔记/刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.mingsrc.work/tags/Go/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mingsrc.work/tags/LeetCode/"}]},{"title":"Windows Cmd命令整理","slug":"E_学习笔记/SYSTEM/WindowsBat","date":"2022-12-27T03:12:54.042Z","updated":"2022-12-27T03:12:54.042Z","comments":true,"path":"posts/4d62d9f3.html","link":"","permalink":"https://www.mingsrc.work/posts/4d62d9f3","excerpt":"","text":"Cmd高级用法整理查看路由1route print 无限ping1ping 192.168.1.1 /t 关机1234567891011# 本地5分钟关机shutdown/s# 本地定时关机shutdown/s /t XXX（时间，按秒记）# 网络关机shutdown/s /m xxx.xxx.xxx.xxx（IP地址）# 取消关机shutdown/a sfc命令检查系统完整性 1sfc /scannow Talnet命令 1Talnet IP:端口号 vol检查硬盘分区","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SYSTEM","slug":"学习笔记/SYSTEM","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SYSTEM/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.mingsrc.work/tags/Windows/"},{"name":"cmd","slug":"cmd","permalink":"https://www.mingsrc.work/tags/cmd/"}]},{"title":"Windows平台下的内存泄露检测","slug":"E_学习笔记/SYSTEM/Windows/Windows平台下的内存泄露检测","date":"2022-12-27T03:12:54.042Z","updated":"2022-12-27T03:12:54.042Z","comments":true,"path":"posts/32ba7a76.html","link":"","permalink":"https://www.mingsrc.work/posts/32ba7a76","excerpt":"","text":"转载声明： 原文链接@千么漾漾 Windows平台下的内存泄漏检测检测是否存在内存泄漏问题Windows平台下面Visual Studio 调试器和 C 运行时 (CRT) 库为我们提供了检测和识别内存泄漏的有效方法，原理大致如下：内存分配要通过CRT在运行时实现，只要在分配内存和释放内存时分别做好记录，程序结束时对比分配内存和释放内存的记录就可以确定是不是有内存泄漏。在vs中启用内存检测的方法如下： STEP1，在程序中包括以下语句： （#include 语句必须采用上文所示顺序。 如果更改了顺序，所使用的函数可能无法正常工作。） 123#define _CRTDBG_MAP_ALLOC#include &lt;stdlib.h&gt;#include &lt;crtdbg.h&gt; 通过包括 crtdbg.h，将 malloc 和 free 函数映射到它们的调试版本，即 _malloc_dbg 和 _free_dbg，这两个函数将跟踪内存分配和释放。 此映射只在调试版本（在其中定义了**_DEBUG**）中发生。 发布版本使用普通的 malloc 和 free 函数。 #define 语句将 CRT 堆函数的基版本映射到对应的“Debug”版本。 并非绝对需要该语句；但如果没有该语句，内存泄漏转储包含的有用信息将较少。 STEP2， 在添加了上述语句之后，可以通过在程序中包括以下语句（通常应恰好放在程序退出位置之前）来转储内存泄漏信息： 1_CrtDumpMemoryLeaks(); 此时，完整的代码如下： 1234567891011121314151617181920 #define _CRTDBG_MAP_ALLOC``#include &lt;stdlib.h&gt;``#include &lt;crtdbg.h&gt; #include &lt;iostream&gt;``using namespace std; void GetMemory(``char *p, ``int num)``&#123;`` ``p = (``char``*)``malloc``(``sizeof``(``char``) * num);``&#125; int main(``int argc,``char``** argv)``&#123;`` ``char *str = NULL;`` ``GetMemory(str, 100);`` ``cout&lt;&lt;``&quot;Memory leak test!&quot;``&lt;&lt;endl;`` ``_CrtDumpMemoryLeaks();`` ``return 0; 当在调试器下运行程序时，_CrtDumpMemoryLeaks 将在“输出”窗口中显示内存泄漏信息。 内存泄漏信息如下所示： 如果没有使用 #define _CRTDBG_MAP_ALLOC 语句，内存泄漏转储将如下所示： 未定义 _CRTDBG_MAP_ALLOC 时，所显示的会是： 内存分配编号（在大括号内）。 块类型（普通、客户端或 CRT）。 “普通块”是由程序分配的普通内存。 “客户端块”是由 MFC 程序用于需要析构函数的对象的特殊类型内存块。 MFC new 操作根据正在创建的对象的需要创建普通块或客户端块。 “CRT 块”是由 CRT 库为自己使用而分配的内存块。 CRT 库处理这些块的释放，因此您不大可能在内存泄漏报告中看到这些块，除非出现严重错误（例如 CRT 库损坏）。 从不会在内存泄漏信息中看到下面两种块类型： “可用块”是已释放的内存块。 “忽略块”是您已特别标记的块，因而不出现在内存泄漏报告中。 十六进制形式的内存位置。 以字节为单位的块大小。 前 16 字节的内容（亦为十六进制）。 定义了 _CRTDBG_MAP_ALLOC 时，还会显示在其中分配泄漏的内存的文件。 文件名后括号中的数字（本示例中为 10）是该文件中的行号。 注意：如果程序总是在同一位置退出，调用 _CrtDumpMemoryLeaks 将非常容易。 如果程序从多个位置退出，则无需在每个可能退出的位置放置对 _CrtDumpMemoryLeaks 的调用，而可以在程序开始处包含以下调用： 1_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF ); 该语句在程序退出时自动调用 _CrtDumpMemoryLeaks。 必须同时设置 _CRTDBG_ALLOC_MEM_DF 和**_CRTDBG_LEAK_CHECK_DF** 两个位域，如前面所示。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"杂记","slug":"学习笔记/杂记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://www.mingsrc.work/tags/%E6%9D%82%E8%AE%B0/"}]},{"title":"Go_Easy_Algorithm","slug":"E_学习笔记/刷题笔记/Go刷题笔记/EasyAlgorithm","date":"2022-12-27T03:12:54.042Z","updated":"2022-12-27T03:12:54.043Z","comments":true,"path":"posts/a0a70754.html","link":"","permalink":"https://www.mingsrc.work/posts/a0a70754","excerpt":"","text":"[toc] 7. 整数反转 #for #整型Difficulty: **给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x &#x3D; 123 输出：321 示例 2： 输入：x &#x3D; -123 输出：-321 示例 3： 输入：x &#x3D; 120 输出：21 示例 4： 输入：x &#x3D; 0 输出：0 提示： -231 &lt;&#x3D; x &lt;&#x3D; 231 - 1 ** 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31 &lt;/sup&gt;− 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 12输入：x = 123输出：321 示例 2： 12输入：x = -123输出：-321 示例 3： 12输入：x = 120输出：21 示例 4： 12输入：x = 0输出：0 提示： -2&lt;sup&gt;31&lt;/sup&gt; &lt;= x &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1 SolutionLanguage: go 123456789101112func reverse(x int) (rev int) &#123; for x != 0 &#123; if rev &lt; math.MinInt32/10 || rev &gt; math.MaxInt32/10 &#123; return 0 &#125; digit := x % 10 x /= 10 rev = rev*10 + digit &#125; return &#125; 1614. 括号的最大嵌套深度 #字符串 #for如果字符串满足以下条件之一，则可以称之为 有效括号字符串****（valid parentheses string，可以简写为 VPS）： 字符串是一个空字符串 &quot;&quot;，或者是一个不为 &quot;(&quot; 或 &quot;)&quot; 的单字符。 字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。 字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。 类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)： depth(&quot;&quot;) = 0 depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 &quot;(&quot; 或者 &quot;)&quot; depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串 depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)，其中 A 是一个 有效括号字符串 例如：&quot;&quot;、&quot;()()&quot;、&quot;()(()())&quot; 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 &quot;)(&quot; 、&quot;(()&quot; 都不是 有效括号字符串 。 给你一个 有效括号字符串 s，返回该字符串的s 嵌套深度 。 示例 1： 123输入：s = &quot;(1+(2*3)+((8)/4))+1&quot;输出：3解释：数字 8 在嵌套的 3 层括号中。 示例 2： 12输入：s = &quot;(1)+((2))+(((3)))&quot;输出：3 示例 3： 12输入：s = &quot;1+(2*3)/(2-1)&quot;输出：1 示例 4： 12输入：s = &quot;1&quot;输出：0 提示： 1 &lt;= s.length &lt;= 100 s 由数字 0-9 和字符 &#39;+&#39;、&#39;-&#39;、&#39;*&#39;、&#39;/&#39;、&#39;(&#39;、&#39;)&#39; 组成 题目数据保证括号表达式 s 是 有效的括号表达式 SolutionLanguage: go 1234567891011121314func maxDepth(s string) (ans int) &#123; dept := 0 for _,ch := range s &#123; if ch == &#x27;(&#x27; &#123; dept++; if dept &gt;= ans &#123; ans = dept &#125; &#125; else if ch == &#x27;)&#x27; &#123; dept--; &#125; &#125; return &#125; 71. 简化路径 #字符串切割 #栈给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 &#39;/&#39; 开头），请你将其转化为更加简洁的规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，&#39;//&#39;）都被视为单个斜杠 &#39;/&#39; 。 对于此问题，任何其他格式的点（例如，&#39;...&#39;）均被视为文件&#x2F;目录名称。 请注意，返回的 规范路径 必须遵循下述格式： 始终以斜杠 &#39;/&#39; 开头。 两个目录名之间必须只有一个斜杠 &#39;/&#39; 。 最后一个目录名（如果存在）不能 以 &#39;/&#39; 结尾。 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 &#39;.&#39; 或 &#39;..&#39;）。 返回简化后得到的 规范路径 。 示例 1： 123输入：path = &quot;/home/&quot;输出：&quot;/home&quot;解释：注意，最后一个目录名后面没有斜杠。 示例 2： 123输入：path = &quot;/../&quot;输出：&quot;/&quot;解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。 示例 3： 123输入：path = &quot;/home//foo/&quot;输出：&quot;/home/foo&quot;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 示例 4： 12输入：path = &quot;/a/./b/../../c/&quot;输出：&quot;/c&quot; 提示： 1 &lt;= path.length &lt;= 3000 path 由英文字母，数字，&#39;.&#39;，&#39;/&#39; 或 &#39;_&#39; 组成。 path 是一个有效的 Unix 风格绝对路径。 SolutionLanguage: go 12345678910111213func simplifyPath(path string) string &#123; stack := []string&#123;&#125; for _,name := range strings.Split(path, &quot;/&quot;) &#123; if name == &quot;..&quot; &#123; if len(stack) &gt; 0 &#123; stack = stack[:len(stack)-1] &#125; &#125; else if name != &quot;&quot; &amp;&amp; name != &quot;.&quot; &#123; stack = append(stack, name) &#125; &#125; return &quot;/&quot; + strings.Join(stack,&quot;/&quot;)&#125; 1576. 替换所有的问号 #字符串给你一个仅包含小写英文字母和 &#39;?&#39; 字符的字符串 s，请你将所有的 &#39;?&#39; 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。 注意：你 不能 修改非 &#39;?&#39; 字符。 题目测试用例保证 除 &#39;?&#39; 字符 之外，不存在连续重复的字符。 在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。 示例 1： 123输入：s = &quot;?zs&quot;输出：&quot;azs&quot;解释：该示例共有 25 种解决方案，从 &quot;azs&quot; 到 &quot;yzs&quot; 都是符合题目要求的。只有 &quot;z&quot; 是无效的修改，因为字符串 &quot;zzs&quot; 中有连续重复的两个 &#x27;z&#x27; 。 示例 2： 123输入：s = &quot;ubv?w&quot;输出：&quot;ubvaw&quot;解释：该示例共有 24 种解决方案，只有替换成 &quot;v&quot; 和 &quot;w&quot; 不符合题目要求。因为 &quot;ubvvw&quot; 和 &quot;ubvww&quot; 都包含连续重复的字符。 示例 3： 12输入：s = &quot;j?qg??b&quot;输出：&quot;jaqgacb&quot; 示例 4： 12输入：s = &quot;??yw?ipkj?&quot;输出：&quot;acywaipkja&quot; 提示： 1 &lt;= s.length &lt;= 100 s 仅包含小写英文字母和 &#39;?&#39; 字符 SolutionLanguage: go 123456789101112131415func modifyString(s string) string &#123; res := []byte(s) n := len(res) for i,ch := range res &#123; if ch == &#x27;?&#x27; &#123; for b := byte(&#x27;a&#x27;); b &lt;= &#x27;c&#x27;; b++ &#123; if !(i &gt; 0 &amp;&amp; res[i-1] == b || i &lt; n - 1 &amp;&amp; res[i+1] == b) &#123; res[i] = b break &#125; &#125; &#125; &#125; return string(res)&#125; 1629. 按键持续时间最长的键 #数组LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。 给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。 测试人员想要找出按键 持续时间最长 的键。第 i次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。 注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。 请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。 示例 1： 123456789输入：releaseTimes = [9,29,49,50], keysPressed = &quot;cbcd&quot;输出：&quot;c&quot;解释：按键顺序和持续时间如下：按下 &#x27;c&#x27; ，持续时间 9（时间 0 按下，时间 9 松开）按下 &#x27;b&#x27; ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）按下 &#x27;c&#x27; ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）按下 &#x27;d&#x27; ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）按键持续时间最长的键是 &#x27;b&#x27; 和 &#x27;c&#x27;（第二次按下时），持续时间都是 20&#x27;c&#x27; 按字母顺序排列比 &#x27;b&#x27; 大，所以答案是 &#x27;c&#x27; 示例 2： 123456789输入：releaseTimes = [12,23,36,46,62], keysPressed = &quot;spuda&quot;输出：&quot;a&quot;解释：按键顺序和持续时间如下：按下 &#x27;s&#x27; ，持续时间 12按下 &#x27;p&#x27; ，持续时间 23 - 12 = 11按下 &#x27;u&#x27; ，持续时间 36 - 23 = 13按下 &#x27;d&#x27; ，持续时间 46 - 36 = 10按下 &#x27;a&#x27; ，持续时间 62 - 46 = 16按键持续时间最长的键是 &#x27;a&#x27; ，持续时间 16 提示： releaseTimes.length == n keysPressed.length == n 2 &lt;= n &lt;= 1000 1 &lt;= releaseTimes[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt; releaseTimes[i] &lt; releaseTimes[i+1] keysPressed 仅由小写英文字母组成 SolutionLanguage: go 123456789101112131415func slowestKey(releaseTimes []int, keysPressed string) byte &#123; n := len(releaseTimes) var ans byte = keysPressed[0] maxTime := releaseTimes[0] for i := int(1); i &lt; n; i++ &#123; key := keysPressed[i] time := releaseTimes[i] - releaseTimes[i-1] if(time &gt; maxTime || (time == maxTime &amp;&amp; key &gt; ans)) &#123; ans = key maxTime = time &#125; &#125; return ans&#125; 206. 反转链表 #链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： 12输入：head = [1,2]输出：[2,1] 示例 3： 12输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ Solution1234567891011121314151617181920/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func reverseList(head *ListNode) *ListNode &#123; var prev * ListNode curr := head for curr != nil &#123; next := curr.Next curr.Next = prev prev = curr curr = next &#125; return prev&#125; 121. 买卖股票的最佳时机 #数组 #dp给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt; 0 &lt;= prices[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt; Solution12345678910111213141516func maxProfit(prices []int) (max int) &#123; min := prices[0] max = 0 for _,price := range prices &#123; if price &lt; min &#123; min = price &#125; else &#123; if max &gt; price - min &#123; continue &#125; else &#123; max = price - min &#125; &#125; &#125; return&#125; 剑指 Offer 03. 数组中重复的数字 #数组 #坐标交换找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 Solution坐标交换：通俗讲就是每个人都有一个自己位置，坐标交换就是先把每个人都放到自己的位置上，当发现自己的位置被人占了以后，就说明出现了重复元素。 12345678910111213141516func findRepeatNumber(nums []int) int &#123; i := 0 for i &lt; len(nums) &#123; if nums[i] == i &#123; i++ continue &#125; if nums[nums[i]] == nums[i] &#123; return nums[i] &#125; nums[nums[i]], nums[i] = nums[i], nums[nums[i]] &#125; return -1&#125;","raw":null,"content":null,"categories":[{"name":"Go","slug":"Go","permalink":"https://www.mingsrc.work/categories/Go/"},{"name":"学习笔记","slug":"Go/学习笔记","permalink":"https://www.mingsrc.work/categories/Go/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"刷题笔记","slug":"Go/学习笔记/刷题笔记","permalink":"https://www.mingsrc.work/categories/Go/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.mingsrc.work/tags/Go/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mingsrc.work/tags/LeetCode/"}]},{"title":"STL常用函数","slug":"E_学习笔记/STL/STL常用函数","date":"2022-12-27T03:12:54.041Z","updated":"2022-12-27T03:12:54.041Z","comments":true,"path":"posts/b84e1b9c.html","link":"","permalink":"https://www.mingsrc.work/posts/b84e1b9c","excerpt":"STL函数","text":"STL函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 删除向量中的所有元素，然后将选代器first和last指示范围中的元素插入该向量中void assign(iterator first,iterator last) //删除向量中的所有元素，然后将cdl的n个副本插入该向量中void assign(size_type n,constT&amp;el=T()) //返回向量中位置为n的元素T&amp;at(siz type n) //返回向量中位置为n的元素const T&amp;at(size_type n)const //返回向量的最后一个元素T&amp;back() //返回向量的最后一个元素const T&amp;back()const //返回一个选代器，该选代器引用向量的第一个元素iterator begin() //返回一个迭代器∶该送代都引用向量的第一个元素const_iterator begin()const //返回可以存储在向量中的元素数目siz_type capacity() //清除向量中的所有元素void clear() //如果向量不包括元素，则返回true，否则返回falsebool empty()const //返回一个迭代器。，该选代器位于向量的最后一个元素之后iterator end() //返回一个const达代器，该达代器位于向量的最后一个元素之后const_iterator end()const //除由迭代器i引用的元素，返回一个迭代器，用被除元素之后的元素iterator erase(teator i)//删除迭代器first和last指示范围中的元素，返回一个达代器，引用被除的最后一个元素之后的元素iterator erase(iterator fist,iterator last) //返回向量的第一个元素T&amp; front() //返回向量的第一个元素const T&amp; front()const //在由选代器i引用的元素之前插入d，并返回引用新插入元素的选代器iterator insert(iterator const T&amp; el=T()) //在选代器i引用的元素之前插入el的n个副本void insert(iterator i,size_type n, const T&amp;el) //在选代器i引用的元素之前插入迭代器frs和hst指示范围中的元素void insert(iterator i,iterator fist,iterator last) //返回向量的最大元素数size _type max_sizt()const //下标运算符T&amp;operator[] //下标运算符const T&amp; operatof[]const //删除向量的最后一个元素void pop_back() //在向量的末尾插入elvoid push_back(const T&amp; el) //返回引用向量中最后一个元素的迭代器reverse_iterator rbegin() //返回引用向量中最后一个元素的选代器const_reverse_iterator rbegin()const //返回位于向量中第一个元素之前的选代器reverse_iterator rend() //返回位于向量中第一个元素之前的迭代器const_reverse_iternator rend()const //如果向量的容量小于n，该函数就为向量预留保存n项的足够空间void reserve(size_type n) //反转向量void reverse()//使向量保存n个元素，方法是∶通过元素el再添加n-size()个位置，或者丢弃向量末尾溢出的sizs()-n个位置void resize(size_type n,const T&amp;el=T)) //返回向量中的元素数量size_type size()const //与另一个向量v交换内容void swap(vector&lt;T&gt;&amp;v) //创建空向量vector() //用类型T的n个el副本创建一个向量（如果没有提供ed，则使用默认的构造函数T()）vector(siz_type n, const T&amp;el=T()) //用达代器fist 和last指示范围中的元素构造一个向量vector(iterator fist,iterator last) //复制构造函数vector(const vector&lt;T&gt;&amp; v) sort()排序函数 排序算法具有同样的灵活性，在对向量v5排序的例子中，v5是以升序来排序的。那么v5如何 按降序排序呢?方法之一先对向量进行升序排序，然后用 reverse()算法来反转向量。另一种方法是 强制sort0算法在得出结果时使用&gt;运算符。为此，可以直接把函数对象作为参数∶ 12345678sort(v5.begin(),v5.end(),greater&lt;int&gt;());//或者间接使用sort(v5.begin(),v5.end(),f2);bool f2(int m,int n)&#123; return m &gt; n ;&#125; greater()函数 头文件 #include STL已定义的函数，这个函数对象定义为模板结构，实际上该函数重载了运算符&gt;。 函数size()： 返回向量当前的元素数目（即：向量大小） 函数capacity()：返回向量能够拥有的元素数目（即：向量的容量） 函数resize() ：可以改变函数的容量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void main(int arhc, const char * argv[])&#123; int a[] = &#123; 1,2,3,4,5 &#125;; int b[] = &#123;0&#125;; // b[1] = 5; //cout &lt;&lt; &quot;b1:&quot; &lt;&lt; b[1] &lt;&lt;endl; vector&lt;int&gt; v1; for (int j = 1; j &lt;= 5; j++) &#123; v1.push_back(j); &#125; cout &lt;&lt; &quot;v1:&quot; &lt;&lt; v1.size() &lt;&lt; endl; vector&lt;int&gt; v2(3, 7); cout &lt;&lt; &quot;v2:&quot; &lt;&lt; v2.size() &lt;&lt; endl; //获取v1的下标为【1】的元素复制给i1 vector&lt;int&gt;::iterator i1 = v1.begin() + 1; vector&lt;int&gt; v3(i1, i1 + 3); cout &lt;&lt; &quot;v3:&quot; &lt;&lt; v3.at(2) &lt;&lt; endl; v3[1] = v3.front(); for (SIZE_T i = 0; i &lt; v3.size(); i++) &#123; cout &lt;&lt; &quot;V3[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; v3[i] &lt;&lt; endl; &#125; vector&lt;int&gt; v4(v1); // v4=(1 2 3 4 5),size=5,capacity=5 vector&lt;int&gt; v5(5); // v5=&#123;0 0 0 0 0&#125; v5[1] = v5.at(3)=9; // v5 = (0 9 0 9 0) v3.reserve(6); // v3=(2 3),size= 2,capacity=6 v4.resize(7); // v4=(1234500),size=7,capacity=10 v4.resize(3); // v4=(123),size=3,capacity=10 v4.clear(); // v4 is empty,size=0,capacity=10(!) v4.insert(v4.end(), v3[1]); // v4 = (3) v4.insert(v4.end(), v3.at(1)); // v - (33) v4.insert(v4.end(), 2, 4); // 4=(3344) v4.insert(v4.end(), v1.begin() + 1, v1.end() - 1);// v4=(3 3 4 4 2 3 4) v4.erase(v4.end() - 2); //v4=(3 3 4 4 2 4) v4.erase(v4.begin(), v4.begin() + 4); // v4 = (2 4) v4.assign(3, 8); // v4 = (8 8 8) v4.assign(a, a + 3); // v4 = (1 2 3) replace(v5.begin(), v5.end(), 0, 7); printVector(v5); const char *s = &quot;Green&quot;; vector&lt;Person&gt; v6(1,Person(s,25)); v6.push_back(Person(&quot;Ann&quot;, 30)); v6.push_back(Person(&quot;Bill&quot;, 20)); sort(v6.begin(), v6.end(),greater&lt;Person&gt;()); for (size_t i = 0; i &lt; v6.size(); i++) &#123; info manInfo = v6[i].getInfo(v6[i]); cout &lt;&lt; manInfo.name &lt;&lt; &quot;今年&quot; &lt;&lt; manInfo.age &lt;&lt; &quot;了&quot; &lt;&lt; endl; &#125; sort(v6.begin(), v6.end(),lesserAge); for (size_t i = 0; i &lt; v6.size(); i++) &#123; info manInfo = v6[i].getInfo(v6[i]); cout &lt;&lt; manInfo.name &lt;&lt; &quot;今年&quot; &lt;&lt; manInfo.age &lt;&lt; &quot;了&quot; &lt;&lt; endl; &#125; return;&#125;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"C-笔记/STL","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.mingsrc.work/tags/STL/"}]},{"title":"unorder_map容器必知必会攻略🐘","slug":"E_学习笔记/STL/STL之unorder_map","date":"2022-12-27T03:12:54.040Z","updated":"2022-12-27T03:12:54.040Z","comments":true,"path":"posts/5ec68291.html","link":"","permalink":"https://www.mingsrc.work/posts/5ec68291","excerpt":"","text":"挂上map的学习笔记 Post not found: 学习笔记/STL/STL之map unordered_map 容器，直译过来就是”无序 map 容器”的意思。所谓“无序”，指的是 unordered_map 容器不会像 map 容器那样对存储的数据进行排序。换句话说，unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。 对于已经学过 map 容器的读者，可以将 unordered_map 容器等价为无序的 map 容器。 具体来讲，unordered_map 容器和 map 容器一样，以键值对（pair类型）的形式存储数据，存储的各个键值对的键互不相同且不允许被修改。但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。 值得一提的是，unordered_map 容器在&lt;unordered_map&gt;头文件中，并位于 std 命名空间中。因此，如果想使用该容器，代码中应包含如下语句： 12#include &lt;unordered_map&gt;using namespace std; 如果使用的是map则需要添加map的头文件以及命名空间； 12#include &lt;map&gt;using namespace std; 如果需要使用到容器中的函数，还需要添加头文件#include &lt;algorithm&gt;。 unordered_map 容器模板的定义如下所示： 123456template &lt; class Key, //键值对中键的类型 class T, //键值对中值的类型 class Hash = hash&lt;Key&gt;, //容器内部存储键值对所用的哈希函数 class Pred = equal_to&lt;Key&gt;, //判断各个键值对键相同的规则 class Alloc = allocator&lt; pair&lt;const Key,T&gt; &gt; // 指定分配器对象的类型 &gt; class unordered_map; 以上 5 个参数中，必须显式给前 2 个参数传值，并且除特殊情况外，最多只需要使用前 4 个参数，各自的含义和功能如表 1 所示。 参数 含义 前 2 个参数分别用于确定键值对中键和值的类型，也就是存储键值对的类型。 Hash = hash 用于指明容器在存储各个键值对时要使用的哈希函数，默认使用 STL 标准库提供的 hash 哈希函数。注意，默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。 Pred = equal_to 要知道，unordered_map 容器中存储的各个键值对的键是不能相等的，而判断是否相等的规则，就由此参数指定。默认情况下，使用 STL 标准库中提供的 equal_to 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。 总的来说，当无序容器中存储键值对的键为自定义类型时，默认的哈希函数 hash 以及比较函数 equal_to 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。至于如何实现自定义，后续章节会做详细讲解。 demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename A, typename B&gt;bool insertToMap(unordered_map&lt;A, B&gt; *tempUmap, string a, vector&lt;int&gt; b)&#123; unordered_map&lt;A, B&gt; temp; temp[a] = b; tempUmap-&gt;insert(make_pair(a,b)); cout &lt;&lt; a &lt;&lt; &quot; is here&quot; &lt;&lt; endl; return true;&#125;int main()&#123; /* insert() 会返回一个迭代器，如下两种形式： //1、引用传递一个键值对 pair&lt;iterator,bool&gt; insert (const value_type&amp; val); //2、以右值引用的方式传递键值对 template &lt;class P&gt; pair&lt;iterator,bool&gt; insert (P&amp;&amp; val); 如果插入成功，返回的bool值为true(1)，否则为false(0), 而返回的iterator则指向插入的键值对，如果插入失败，则会指向有冲突的键值对 */ cout &lt;&lt; &quot;this is \\&quot;unordered_map\\&quot;:&quot; &lt;&lt; endl; unordered_map&lt;string, vector&lt;int&gt; &gt; personalInfoUMap; insertToMap(&amp;personalInfoUMap, &quot;bbb&quot;, &#123;1,2,3,4,5,6&#125;); cout &lt;&lt; personalInfoUMap[&quot;aaa&quot;].size() &lt;&lt; endl; personalInfoUMap[&quot;aaa&quot;] = &#123;6,1,0,3,2,2&#125;; for (auto iit : personalInfoUMap) &#123; cout &lt;&lt; iit.first &lt;&lt; &quot;:&quot;; for (auto it : iit.second) &#123; cout &lt;&lt; it; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; &quot;------------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;this is \\&quot;map\\&quot; demo:&quot; &lt;&lt; endl; map&lt;string, vector&lt;int&gt; &gt; personalInfoMap; personalInfoMap[&quot;bbb&quot;] = &#123; 2,2,0,8,0,2 &#125;; personalInfoMap[&quot;aaa&quot;] = &#123; 6,1,0,3,2,2 &#125;; for (auto iit : personalInfoMap) &#123; cout &lt;&lt; iit.first &lt;&lt; &quot;:&quot;; for (auto it : iit.second) &#123; cout &lt;&lt; it; &#125; cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"C-笔记/STL","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.mingsrc.work/tags/STL/"},{"name":"set","slug":"set","permalink":"https://www.mingsrc.work/tags/set/"}]},{"title":"STL基本概念","slug":"E_学习笔记/STL/STL基本概念","date":"2022-12-27T03:12:54.040Z","updated":"2022-12-27T03:12:54.040Z","comments":true,"path":"posts/ecf76003.html","link":"","permalink":"https://www.mingsrc.work/posts/ecf76003","excerpt":"STL基本概念STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。\nSTL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。\nSTL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。","text":"STL基本概念STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。 STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。 STL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。 STL细说六大件： ​ – 容器（Container） ​ – 算法（Algorithm） ​ – 迭代器（Iterator） ​ – 仿函数（Function object） ​ – 适配器（Adaptor） ​ – 空间配制器（allocator） 在C++标准中，STL被组织为下面的13个头文 件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt;。 说了这么多，使用STL有什么好处呢？1）STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。 2）STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。 3） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。 4） STL具有高可重用性，高性能，高移植性，跨平台的优点。 高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。 高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种) 高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。 跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。 5） 了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C＋＋程序员都应该好好学习STL。只有能够熟练使用STL的程序员，才是好的C++程序员。 6） 总之：招聘工作中，经常遇到C++程序员对STL不是非常了解。大多是有一个大致的映像，而对于在什么情况下应该使用哪个容器和算法都感到比较茫然。STL是C++程序员的一项不可或缺的基本技能，掌握它对提升C++编程大有裨益。 Alexander Stepanov 容器一些封装数据结构的模板类，简单来说，就是存储数据的结构 序列式容器：特点是不会对存储的元素进行排序，元素排列的顺序取决于存储它们的顺序。 关联式容器：在存储元素时会为每个元素在配备一个键，整体以键值对的方式存储到容器中，可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素，默认会根据各元素键值的大小做升序排序。 迭代器用来遍历容器中的元素的类型，类中类(可以理解为指针)，扮演着容器和算法之间的胶合剂 算法解决问题的方法 容器、迭代器、算法分离案例12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;//算法：求数组元素个数int mcount(int *begin,int *end,int arr[])&#123; int num=0; while (begin != end) &#123; num++; begin++; &#125; return num;&#125;int main()&#123; //容器 int arr[] = &#123; 7,1,2,5,4,7,5 &#125;; //迭代器 int *begin = arr; int *end = &amp;arr[sizeof(arr) / sizeof(arr[0])]; cout&lt;&lt;mcount(begin,end,arr); while (1); return 0;&#125; string容器string概念 string是STL的字符串类型，通常用来表示字符串。而在使用string之前，字符串通常是用char表示的。string与char都可以用来表示字符串，那么二者有什么区别呢。 string和char*的比较 string是一个类, char*是一个指向字符的指针。 ​ string封装了char*，管理这个字符串，是一个char*型的容器 string不用考虑内存释放和越界。 ​ string管理char所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。* string提供了一系列的字符串操作函数（这个等下会详讲） *查找find，拷贝copy，删除erase，替换replace，插入insert* string的构造函数 默认构造函数： ​ string(); &#x2F;&#x2F;构造一个空的字符串string s1。 拷贝构造函数： ​ string(const string &amp;str); &#x2F;&#x2F;构造一个与str一样的string。如string s1(s2)。 带参数的构造函数 string(const char *s); //用字符串s初始化 string(int n,char c); &#x2F;&#x2F;用n个字符c初始化 string的存取字符操作 char &amp;operator[] (int n); char &amp;at(int n); operator[]和at()均返回当前字符串中第n个字符，但二者是有区别的。 主要区别在于at()在越界时会抛出异常，[]在刚好越界时会返回‘\\0’，再继续越界时，程序直接中断。如果你的程序希望可以通过try,catch捕获异常，建议采用at()。 从string取得const char* const char *c_str() const; &#x2F;&#x2F;返回一个以’\\0’结尾的字符串的首地址 const char *data() const; &#x2F;&#x2F;同上 把string拷贝到char*指向的内存空间的操作 int copy(char *s, int n, int pos&#x3D;0) const; 把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目。注意要保证s所指向的空间足够大以容纳当前字符串，不然会越界。 123string str(&quot;maye&quot;);char arr[10] = &quot;&quot;;str.copy(arr, 2); string的长度 int length() const; &#x2F;&#x2F;返回当前字符串的长度。长度不包括字符串结尾的’\\0’。 int size() const; &#x2F;&#x2F;同上 bool empty() const; &#x2F;&#x2F;当前字符串是否为空 string的赋值 string &amp;operator&#x3D;(const string &amp;s);&#x2F;&#x2F;把字符串s赋给当前的字符串 string &amp;assign(const char *s); &#x2F;&#x2F;把字符串s赋给当前的字符串 string &amp;assign(const char *s, int n); &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串 string &amp;assign(const string &amp;s); &#x2F;&#x2F;把字符串s赋给当前字符串 string &amp;assign(int n,char c); &#x2F;&#x2F;用n个字符c赋给当前字符串 string &amp;assign(const string &amp;s,int start, int n); &#x2F;&#x2F;把字符串s中从start开始的n个字符赋给当前字符串 string字符串连接 string &amp;operator+&#x3D;(const string &amp;s); &#x2F;&#x2F;把字符串s连接到当前字符串结尾 string &amp;operator+&#x3D;(const char *s);&#x2F;&#x2F;把字符串s连接到当前字符串结尾 string &amp;append(const char *s); &#x2F;&#x2F;把字符串s连接到当前字符串结尾 string &amp;append(const char *s,int n); &#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾 string &amp;append(const string &amp;s); &#x2F;&#x2F;同operator+&#x3D;() string &amp;append(const string &amp;s,int pos, int n);&#x2F;&#x2F;把字符串s中从pos开始的n个字符连接到当前字符串结尾 string &amp;append(int n, char c); &#x2F;&#x2F;在当前字符串结尾添加n个字符c string比较int compare(const string &amp;s) const; &#x2F;&#x2F;与字符串s比较 int compare(const char *s) const; &#x2F;&#x2F;与字符串s比较 compare函数在&gt;时返回 1，&lt;时返回 -1，&#x3D;&#x3D;时返回 0。此外还支持&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;直接比较 string的子串string substr(int pos&#x3D;0, int n&#x3D;npos) const; &#x2F;&#x2F;返回由pos开始的n个字符组成的子字符串 string的查找和替换查找int find(char c,int pos&#x3D;0) const; &#x2F;&#x2F;从pos开始查找字符c在当前字符串的位置 int find(const char *s, int pos&#x3D;0) const; &#x2F;&#x2F;从pos开始查找字符串s在当前字符串的位置 int find(const string &amp;s, int pos&#x3D;0) const; &#x2F;&#x2F;从pos开始查找字符串s在当前字符串中的位置 find函数如果查找不到，就返回-1 int rfind(char c, int pos&#x3D;npos) const; &#x2F;&#x2F;从pos开始从后向前查找字符c在当前字符串中的位置 int rfind(const char *s, int pos&#x3D;npos) const; int rfind(const string &amp;s, int pos&#x3D;npos) const; &#x2F;&#x2F;rfind是反向查找的意思，如果查找不到， 返回-1 替换string &amp;replace(int pos, int n, const char *s);&#x2F;&#x2F;删除从pos开始的n个字符，然后在pos处插入串s string &amp;replace(int pos, int n, const string &amp;s); &#x2F;&#x2F;删除从pos开始的n个字符，然后在pos处插入串s void swap(string &amp;s2); &#x2F;&#x2F;交换当前字符串与s2的值 String的区间删除和插入string &amp;insert(int pos, const char *s); string &amp;insert(int pos, const string &amp;s); &#x2F;&#x2F;前两个函数在pos位置插入字符串s string &amp;insert(int pos, int n, char c); &#x2F;&#x2F;在pos位置 插入n个字符c string &amp;erase(int pos&#x3D;0, int n&#x3D;npos); &#x2F;&#x2F;删除pos开始的n个字符，返回修改后的字符串 vector容器Vector容器简介vector是将元素置于一个动态数组中加以管理的容器。 vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲） vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时 vector的构造函数vector采用模板类实现，vector对象的默认构造形式 vector&lt;T&gt; vecT; &#x2F;&#x2F;尖括号内还可以设置任意的数据类型。 存放对象的时候值得注意：由于容器元素的存放是按值复制的方式进行的，所以此时类必须提供对象的拷贝构造函数，以保证对象间拷贝正常。 vector(begin,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。(能取begin的值，不能取end的值) vector(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。 vector(const vector &amp;vec); &#x2F;&#x2F;拷贝构造函数 123456int iArray[] = &#123; 0,1,2,3,4 &#125;;vector&lt;int&gt; vecIntA(iArray, iArray + 5);vector&lt;int&gt; vecIntB(vecIntA.begin(), vecIntA.end()); //用构造函数初始化容器vecIntB vector&lt;int&gt; vecIntB(vecIntA.begin(), vecIntA.begin() + 3);vector&lt;int&gt; vecIntC(3, 9); //容器vecIntB存放3个元素，每个元素的值是9。vector&lt;int&gt; vecIntD(vecIntA); vector的赋值 vector.assign(beg,end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。 vector.assign(n,elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。 vector&amp; operator&#x3D;(const vector &amp;vec); &#x2F;&#x2F;重载等号操作符 vector.swap(vec); &#x2F;&#x2F; 将vec与本身的元素互换。 12345678vector&lt;int&gt; vecIntA, vecIntB, vecIntC, vecIntD;int iArray[] = &#123; 0,1,2,3,4 &#125;;vecIntA.assign(iArray, iArray + 5); //把iArray全部赋值给vecIntAvecIntB.assign(vecIntA.begin(), vecIntA.end()); //用其它容器的迭代器作参数。vecIntC.assign(3, 9);//容器vecIntB存放3个元素，每个元素的值是9。vector&lt;int&gt; vecIntD;vecIntD = vecIntA;vecIntA.swap(vecIntD);//交换vecIntA和vecIntD的数据 vector的大小vector.size(); &#x2F;&#x2F;返回容器中元素的个数 vector.empty(); &#x2F;&#x2F;判断容器是否为空 vector.resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 vector.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 vector末尾的添加移除操作vector.push_back(data);&#x2F;&#x2F;在尾部添加一个元素 vector.pop_back();&#x2F;&#x2F;删除尾部元素 vector的数据存取vec.at(index); &#x2F;&#x2F;返回索引index所指的数据，如果index越界，抛出out_of_range异常。 vec[index]; &#x2F;&#x2F;返回索引index所指的数据，越界时，运行直接报错 deque容器Deque简介deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数组，而vector是单端的。 deque在接口上和vector非常相似，在许多操作的地方可以直接替换。 deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。 deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。 #include deque对象的默认构造deque采用模板类实现，deque对象的默认构造形式：deque deqT; deque deqInt; &#x2F;&#x2F;一个存放int的deque容器。 deque deq Float; &#x2F;&#x2F;一个存放float的deque容器。 deque deq String; &#x2F;&#x2F;一个存放string的deque容器。 … &#x2F;&#x2F;尖括号内还可以设置指针类型或自定义类型。 deque对象的带参数构造deque(beg,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。 deque(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。 deque(const deque &amp;deq); &#x2F;&#x2F;拷贝构造函数。 deque末尾的添加移除操作deque.push_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据 deque.push_front(elem); &#x2F;&#x2F;在容器头部插入一个数据 deque.pop_back(); &#x2F;&#x2F;删除容器最后一个数据 deque.pop_front(); &#x2F;&#x2F;删除容器第一个数据 deque的数据存取deque.at(idx); &#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，抛出out_of_range。 deque[idx]; &#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。 deque.front(); &#x2F;&#x2F;返回第一个数据。 deque.back(); &#x2F;&#x2F;返回最后一个数据 deque的赋值deque.assign(beg,end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。 deque.assign(n,elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。 deque&amp; operator&#x3D;(const deque &amp;deq); &#x2F;&#x2F;重载等号操作符 deque.swap(deq); &#x2F;&#x2F; 将vec与本身的元素互换 deque的大小deque.size(); &#x2F;&#x2F;返回容器中元素的个数 deque.empty(); &#x2F;&#x2F;判断容器是否为空 deque.resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 deque.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 deque的插入deque.insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。 deque.insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。 deque.insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。 deque的删除deque.clear(); &#x2F;&#x2F;移除容器的所有数据 deque.erase(beg,end); &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。 deque.erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。 迭代器基本原理 代器是一个“可遍历STL容器内全部或部分元素”的对象。 迭代器指出容器中的一个特定位置。 迭代器就如同一个指针。 迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围。 迭代器的类别输入迭代器：也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。 输出迭代器：也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。 正向迭代器：组合输入迭代器和输出迭代器的功能，还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读&#x2F;写。 双向迭代器：组合正向迭代器的功能，还可以通过++操作符向后移动位置。 随机访问迭代器：组合双向迭代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。 迭代器的操作 迭代器 操作 所有迭代器 it++、++it 输入迭代器 *it、it1&#x3D;it2、it1&#x3D;&#x3D;it2、it1！&#x3D;it2 输出迭代器 *it、it1&#x3D;it2 正向迭代器 提供输入输出迭代器的所有功能 双向迭代器 it–、–it 随机迭代器 +&#x3D;、-&#x3D;、+、-、[]、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D; 这里用到的容器，都支持双向迭代器或随机访问迭代器，下面将会详细介绍这两个类别的迭代器。 容器 对应迭代器类型 array 随机访问迭代器 vector 随机访问迭代器 deque 随机访问迭代器 list 双向迭代器 set &#x2F; multiset 双向迭代器 map &#x2F; multimap 双向迭代器 forward_list 前向迭代器 unordered_map &#x2F; unordered_multimap 前向迭代器 unordered_set &#x2F; unordered_multiset 前向迭代器 stack 不支持迭代器 queue 不支持迭代器 迭代器实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119template&lt;typename Data&gt;class Vector&#123;public: Vector() :Array(nullptr), curSize(0), capacity(0) &#123;&#125; Vector(int size) :curSize(0), capacity(size) &#123; Array = new Data[size]; &#125; Vector(Vector&amp; arr) :curSize(arr.curSize), capacity(arr.capacity) &#123; Array = new Data[capacity]; for (int i = 0; i &lt; arr.curSize; i++) &#123; this-&gt;Array[i] = arr.Array[i]; &#125; &#125; void push(Data data) &#123; if (curSize &lt; capacity) &#123; Array[curSize] = data; curSize++; return; &#125; cout &lt;&lt; &quot;数组越界&quot; &lt;&lt; endl; &#125; void arrMul(int mulNum) &#123; for (int i = 0; i &lt; curSize; i++) &#123; Array[i] *= mulNum; //要确保存的数据类型，能够相乘 &#125; &#125; void operator=(Vector&amp; arr) &#123; //判断当前对象和arr的关系 if (capacity &lt; arr.curSize) &#123; delete[] Array; capacity = arr.capacity; curSize = arr.curSize; Array = new Data[capacity]; &#125; for (int i = 0; i &lt; arr.curSize; i++) &#123; this-&gt;Array[i] = arr[i]; //要确保，存的类型能够相互赋值 &#125; curSize = arr.curSize; &#125; Data&amp; operator[](int index) &#123; if (index &gt;= 0 &amp;&amp; index &lt; capacity) &#123; return Array[index]; &#125; cout &lt;&lt; &quot;数组访问越界&quot; &lt;&lt; endl; &#125; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Vector&amp; Array) &#123; for (int i = 0; i &lt; Array.curSize; i++) &#123; out &lt;&lt; setw(5) &lt;&lt; setiosflags(ios::left) &lt;&lt; Array[i]; &#125; return out; &#125; ~Vector() &#123; delete[] Array; &#125; //迭代器 Data* begin() &#123; return Array; &#125; Data* end() &#123; return &amp;Array[curSize]; &#125; class iterotar &#123; public: iterotar(Data *begin=nullptr) &#123; pmove = begin; &#125; ~iterotar() &#123; &#125; bool operator!=(Data* end) &#123; return pmove != end; &#125; Data* operator++(int) &#123; Data* temp = pmove; this-&gt;pmove++; return temp; &#125; //一定要返回引用，否则匿名对象不接受会出错 Data&amp; operator*() &#123; return *pmove; &#125; Data* operator-&gt;() &#123; return pmove; &#125; private: Data* pmove; &#125;;protected: Data* Array; //数组指针 int curSzie; //数组当前大小 int capacity; //数组最大容量&#125;; initializer_list聚合初始化前面给大家讲过数组可以用聚合的方式初始化，int arr[]&#x3D;{1,3,1,4,5,2,0};那么咱们自己写的vector能用聚合初始化吗？ 答案是否定的，那么怎么做才能使用聚合形式进行初始化呢？ C++11提供的新模板类型initializer_list,有了它之后咱们就可以使用聚合进行初始化啦！ 用法： 123456789void show(initializer_list&lt;int&gt; ls)&#123; for (int i : ls) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;&#125;show(&#123; 1,3,1,4,5,2,0 &#125;);//输出 同理，在类中我们可以提供一个initializer_list类型的构造函数 1234567891011//构造聚合初始化Vector(initializer_list&lt;Data&gt; ls)&#123; _capacity = ls.size(); _curSize = 0; _Array = new Data[_capacity]; for (const Data&amp; temp : ls) &#123; this-&gt;push_back(temp); &#125;&#125; list容器list简介 list是一个双向链表容器，可高效地进行插入删除元素。 list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok) it+5(err) list对象的默认构造list采用采用模板类实现,对象的默认构造形式：list lsT; 如： list lstInt; &#x2F;&#x2F;定义一个存放int的list容器。 list lstFloat; &#x2F;&#x2F;定义一个存放float的list容器。 list lstString; &#x2F;&#x2F;定义一个存放string的list容器。 … &#x2F;&#x2F;尖括号内还可以设置指针类型或自定义类型。 list头尾的添加移除操作list.push_back(elem); &#x2F;&#x2F;在容器尾部加入一个元素 list.pop_back(); &#x2F;&#x2F;删除容器中最后一个元素 list.push_front(elem); &#x2F;&#x2F;在容器开头插入一个元素 list.pop_front(); &#x2F;&#x2F;从容器开头移除第一个元素 list的数据存取list.front(); &#x2F;&#x2F;返回第一个元素。 list.back(); &#x2F;&#x2F;返回最后一个元素。 list与迭代器list.begin(); &#x2F;&#x2F;返回容器中第一个元素的迭代器。 list.end(); &#x2F;&#x2F;返回容器中最后一个元素之后的迭代器。 list.rbegin(); &#x2F;&#x2F;返回容器中倒数第一个元素的迭代器。 list.rend(); &#x2F;&#x2F;返回容器中倒数最后一个元素的后面的迭代器。 list对象的带参数构造list(beg,end); &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。 list(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。 list(const list &amp;lst); &#x2F;&#x2F;拷贝构造函数。 list的赋值list.assign(beg,end); &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。 list.assign(n,elem); &#x2F;&#x2F;将n个elem拷贝赋值给本身。 list&amp; operator&#x3D;(const list &amp;lst); &#x2F;&#x2F;重载等号操作符 list.swap(lst); &#x2F;&#x2F; 将lst与本身的元素互换。 list的大小list.size(); &#x2F;&#x2F;返回容器中元素的个数 list.empty(); &#x2F;&#x2F;判断容器是否为空 list.resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 list.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 list的插入list.insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。 list.insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。 list.insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。 list的删除list.clear(); &#x2F;&#x2F;移除容器的所有数据 list.erase(beg,end); &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。 list.erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。 lst.remove(elem); &#x2F;&#x2F;删除容器中所有与elem值匹配的元素。 当使用一个容器的insert或者erase函数通过迭代器插入或删除元素”可能”会导致迭代器失效，因此我们为了避免危险，应该获取insert或者erase返回的迭代器，以便用重新获取的新的有效的迭代器进行正确的操作 1234567891011121314list&lt;int&gt; ls;for (int i = 0; i &lt; 10; i++)&#123; ls.push_back(i);&#125;list&lt;int&gt;::iterator it;for (it = ls.begin(); it != ls.end(); it++)&#123; if (*it == 5) &#123; it=ls.erase(it); &#125; cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#125; list的反序排列lst.reverse(); &#x2F;&#x2F;反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。 小结一、容器deque的使用方法 ​ 适合在头尾添加移除元素。使用方法与vector类似。 二、容器queue,stack的使用方法 ​ 适合队列，堆栈的操作方式。 三、容器list的使用方法 ​ 适合在任意位置快速插入移除元素 stack容器Stack简介 stack是堆栈容器，是一种“先进后出”的容器。 stack是简单地装饰deque容器而成为另外的一种容器。 #include stack对象的默认构造stack采用模板类实现， stack对象的默认构造形式： stack stkT; stack stkInt; &#x2F;&#x2F;一个存放int的stack容器。 stack stkFloat; &#x2F;&#x2F;一个存放float的stack容器。 stack stkString; &#x2F;&#x2F;一个存放string的stack容器。 … &#x2F;&#x2F;尖括号内还可以设置指针类型或自定义类型。 stack元素获取与删除stack.push(elem); &#x2F;&#x2F;往栈头添加元素 stack.pop(); &#x2F;&#x2F;从栈头移除第一个元素 stack.top(); &#x2F;&#x2F;返回最栈顶元素 stack对象的拷贝构造与赋值stack(const stack &amp;stk); &#x2F;&#x2F;拷贝构造函数 stack&amp; operator&#x3D;(const stack &amp;stk); &#x2F;&#x2F;重载等号操作符 stack的大小stack.empty(); &#x2F;&#x2F;判断堆栈是否为空 stack.size(); &#x2F;&#x2F;返回堆栈的大小 Queue容器Queue简介queue是队列容器，是一种“先进先出”的容器。 queue是简单地装饰deque容器而成为另外的一种容器。 #include queue对象的默认构造queue采用模板类实现，queue对象的默认构造形式：queue queT; 如： queue queInt; &#x2F;&#x2F;一个存放int的queue容器。 queue queFloat; &#x2F;&#x2F;一个存放float的queue容器。 queue queString; &#x2F;&#x2F;一个存放string的queue容器。 … &#x2F;&#x2F;尖括号内还可以设置指针类型或自定义类型。 queue的数据存取queue.push(elem); &#x2F;&#x2F;往队尾添加元素 queue.pop(); &#x2F;&#x2F;从队头移除第一个元素 queue.back(); &#x2F;&#x2F;返回最后一个元素 queue.front(); &#x2F;&#x2F;返回第一个元素 queue对象的拷贝构造与赋值queue(const queue &amp;que); &#x2F;&#x2F;拷贝构造函数 queue&amp; operator&#x3D;(const queue &amp;que); &#x2F;&#x2F;重载等号操作符 queue的大小queue.empty(); &#x2F;&#x2F;判断队列是否为空 queue.size(); &#x2F;&#x2F;返回队列的大小 set&#x2F;multiset容器set&#x2F;multiset的简介set是一个集合容器，其中所包含的元素是唯一的，集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。 set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。 set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。 multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。 不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。 #include set&#x2F;multiset对象的默认构造set setInt; &#x2F;&#x2F;一个存放int的set容器。 set setFloat; &#x2F;&#x2F;一个存放float的set容器。 set setString; &#x2F;&#x2F;一个存放string的set容器。 multiset mulsetInt; &#x2F;&#x2F;一个存放int的multi set容器。 multi set multisetFloat; &#x2F;&#x2F;一个存放float的multi set容器。 multi set multisetString; &#x2F;&#x2F;一个存放string的multi set容器。 set的插入set.insert(elem); &#x2F;&#x2F;在容器中插入元素。 Set集合的元素排序set&lt;int,less &gt; setIntA; &#x2F;&#x2F;该容器是按升序方式排列元素。 set&lt;int,greater&gt; setIntB; &#x2F;&#x2F;该容器是按降序方式排列元素。 set 相当于 set&lt;int,less&gt;。 less与greater中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。 疑问1： less&lt;&gt;与greate&lt; &gt;是什么？ 疑问2：如果set&lt;&gt;不包含int类型，而是包含自定义类型，set容器如何排序？ 要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。 下面将讲解什么是functor以及用法。 使用stl提供的函数对象 set&lt;int,greater&gt; setIntB; setIntB.insert(3); setIntB.insert(1); setIntB.insert(5); setIntB.insert(2); 此时容器setIntB就包含了按顺序的5,3,2,1元素 函数对象functor的用法尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。 functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。 greater&lt;&gt;与less&lt;&gt;就是函数对象。 下面举出greater的简易实现原理。 12345678class greater&#123;public: bool operator()(const int&amp; iLeft, const int&amp; iRight) &#123; return iLeft &gt; iRight; //如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight); &#125;&#125;; 容器就是调用函数对象的operator()方法去比较两个值的大小。 仿函数练习学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。 解： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;//学生类class CStudent&#123;public: CStudent(int iID, string strName) &#123; m_iID = iID; m_strName = strName; &#125; //private: int m_iID; //学号 string m_strName; //姓名&#125;;//为保持主题鲜明，本类不写拷贝构造函数，不类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。//函数对象struct StuFunctor&#123; bool operator()(const CStudent&amp; stu1,const CStudent&amp; stu2) const &#123; return (stu1.m_iID &lt; stu2.m_iID); &#125;&#125;;int main()&#123; set&lt;CStudent, StuFunctor&gt; setStu; setStu.insert(CStudent(3, &quot;小张&quot;)); setStu.insert(CStudent(1, &quot;小李&quot;)); setStu.insert(CStudent(5, &quot;小王&quot;)); setStu.insert(CStudent(2, &quot;小刘&quot;)); for (auto i : setStu) &#123; cout &lt;&lt; i.m_iID &lt;&lt; &quot; &quot;; &#125; return 0;&#125; set对象的拷贝构造与赋值set(const set &amp;st); &#x2F;&#x2F;拷贝构造函数 set&amp; operator&#x3D;(const set &amp;st); &#x2F;&#x2F;重载等号操作符 set.swap(st); &#x2F;&#x2F;交换两个集合容器 set的大小set.size(); &#x2F;&#x2F;返回容器中元素的数目 set.empty();&#x2F;&#x2F;判断容器是否为空 set的删除set.clear(); &#x2F;&#x2F;清除所有元素 set.erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。 set.erase(beg,end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 set.erase(elem); &#x2F;&#x2F;删除容器中值为elem的元素。 set的查找set.find(elem); &#x2F;&#x2F;查找elem元素，返回指向elem元素的迭代器。 set.count(elem); &#x2F;&#x2F;返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。 set.lower_bound(elem); &#x2F;&#x2F;返回第一个&gt;&#x3D;elem元素的迭代器。 set.upper_bound(elem); &#x2F;&#x2F; 返回第一个&gt;elem元素的迭代器。 set.equal_range(elem); &#x2F;&#x2F;返回一对迭代器，这两个迭代器分别用于发现set中其键大于指定键的第一个元素，以及集中其键等于或大于指定键的第一个元素。 以上函数返回两个迭代器，而这两个迭代器被封装在pair中。 pair以下讲解pair的含义与使用方法。 pair的使用pair译为对组，可以将两个值视为一个单元。 pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。 pair.first是pair里面的第一个值，是T1类型。 pair.second是pair里面的第二个值，是T2类型。 小结一、容器set&#x2F;multiset的使用方法； ​ 红黑树的变体，查找效率高，插入不能指定位置，插入时自动排序。 二、functor的使用方法； 类似于函数的功能，可用来自定义一些规则，如元素比较规则。 三、pair的使用方法。 ​ 对组，一个整体的单元，存放两个类型(T1,T2，T1可与T2一样)的两个元素。 map\\multimap容器map&#x2F;multimap的简介map是标准的关联式容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。 map中key值是唯一的。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。 map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入操作和删除操作上比vector快。 map可以直接存取key所对应的value，支持[]操作符，如map[key]&#x3D;value。 multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]和at操作。 #include map&#x2F;multimap对象的默认构造map&lt;T1,T2&gt; mapTT; multimap&lt;T1,T2&gt; multimapTT; map的插入与迭代器map.insert(…); &#x2F;&#x2F;往容器插入元素，返回pair&lt;iterator,bool&gt; 在map中插入元素的三种方式： 假设 map&lt;int, string&gt; mapStu; 一、通过pair的方式插入对象 mapStu.insert( pair&lt;int,string&gt;(3,”小张”) ); 二、通过pair的方式插入对象 mapStu.inset(make_pair(-1, “校长-1”)); 三、通过value_type的方式插入对象 mapStu.insert( map&lt;int,string&gt;::value_type(1,”小李”) ); 四、通过数组的方式插入值(multimap不支持) mapStu[3] &#x3D; “小刘”; mapStu.at(4) &#x3D; “小王”； 123456map&lt;int, string&gt; chess;chess.insert(pair&lt;int,string&gt;(1,&quot;将&quot;));chess.insert(make_pair(2, &quot;士&quot;));chess.insert(map&lt;int, string&gt;::value_type(3, &quot;像&quot;));chess.at(3) = &quot;马&quot;;chess[4] = &quot;車&quot;; 前三种方法，采用的是insert()方法，该方法返回值为pair&lt;iterator,bool&gt; 第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值修改成“小刘”。若发现已存在3这个键，则修改这个键对应的value。 string strName &#x3D; mapStu[2]; &#x2F;&#x2F;取操作或插入操作 只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值。 函数对象functor的用法map&lt;T1,T2,less &gt; mapA; &#x2F;&#x2F;该容器是按键的升序方式排列元素。未指定函数对象，默认采用less函数对象。 map&lt;T1,T2,greater&gt; mapB; &#x2F;&#x2F;该容器是按键的降序方式排列元素。 less与greater 可以替换成其它的函数对象functor。 可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。 map对象的拷贝构造与赋值map(const map &amp;mp); &#x2F;&#x2F;拷贝构造函数 map&amp; operator&#x3D;(const map &amp;mp); &#x2F;&#x2F;重载等号操作符 map.swap(mp); &#x2F;&#x2F;交换两个集合容器 map的大小map.size(); &#x2F;&#x2F;返回容器中元素的数目 map.empty();&#x2F;&#x2F;判断容器是否为空 map的删除map.clear(); &#x2F;&#x2F;删除所有元素 map.erase(pos); &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。 map.erase(beg,end); &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 map.erase(keyElem); &#x2F;&#x2F;删除容器中key为keyElem的对组。 map的查找map.find(key); 查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end(); map.count(keyElem); &#x2F;&#x2F;返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。 map.equal_range(keyElem); &#x2F;&#x2F;返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。 以上函数返回两个迭代器，而这两个迭代器被封装在pair中。 Multimap 案例: &#x2F;&#x2F;1个key值可以对应多个value &#x3D; 分组 &#x2F;&#x2F;公司有销售部 sale （员工2名）、技术研发部 development （1人）、财务部 Financial （2人） &#x2F;&#x2F;人员信息有：姓名，年龄，电话、工资等组成 &#x2F;&#x2F;通过 multimap进行 信息的插入、保存、显示 &#x2F;&#x2F;分部门显示员工信息 STL容器共性机制STL容器所提供的都是值（value）寓意，而非引用（reference）寓意，也就是说当我们给容器中插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另行拷贝一份放入到容器中，而不是将原数据元素直接放进容器中，也就是说我们提供的元素必须能够被拷贝。 除了queue和stack之外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。 通过STL不会抛出异常，需要使用者传入正确参数。 每个容器都提供一个默认的构造函数和默认的拷贝构造函数。 大小相关的构造方法： （1）size()返回容器中元素的个数； （2）empty()判断容器是否为空。 vector deque list set multiset map multimap 内存结构 单端数组 双端数组 双向链表 二叉树 二叉树 二叉树 二叉树 可随机存取 是 是 否 否 否 对key而言：是 否 元素查找速度 慢 慢 非常慢 快 快 对key而言：快 对key而言：快 元素添加移除 尾端 头尾两端 任何位置 - - - - 各容器使用场景在实际使用过程中，到底选择这几种容器中的哪一个，应该根据遵循以下原则： １、如果需要高效的随机存取，不在乎插入和删除的效率，使用vector； 2、如果需要大量的插入和删除元素，不关心随机存取的效率，使用list； 3、如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque； 4、如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap； 5、如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。 6、如果要求很快的查找速度，根据情况选择使用unordered_map或unordered_set。 STL算法sort()排序函数该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如std::greater&lt;T&gt;降序排序规则），甚至还可以自定义排序规则。 需要注意的是，sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数： 容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 array、vector、deque 这 3 个容器提供支持。 如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持&lt;小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符； sort()函数有两种用法： 1234//对 [first, last) 区域内的元素做默认的升序排序void sort (first, last);//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序void sort (first, last, Compare comp); transform()转换函数将指定范围内的元素进行转换，并将结果存储在从result开始的范围中。 123Iterator transform (first, last,result, const T&amp; val);transform(maye.begin(), maye.end(), maye.begin(), toupper);//转大写transform(maye.begin(), maye.end(), maye.begin(), tolower);//转小写 find()查找函数该函数专门用来对容器或普通数组中，指定范围内查找和目标元素值相等的第一个元素。 find()函数用法： 1Iterator find (first, last, const T&amp; val); find_if()查找使用自定义的比较函数代替find函数默认的 &#x3D;&#x3D; 比较操作。 1234567891011121314bool cmp(int i)&#123; return i == 1;&#125;void fun_find_if()&#123; vector&lt;int&gt; v = &#123; 9,8,7,6,5,1,2,3,4 &#125;; auto temp=find_if(v.begin(), v.end(), cmp); if (temp != v.end()) &#123; cout &lt;&lt; *temp ; &#125;&#125; adjacent_find()指定范围内查找连续的两个连续相等的元素，并返回第一个元素的迭代器，如果没有找到，返回end迭代器。 1234567891011121314bool cmp(int i, int j)&#123; return i == j;&#125;void fun_adjacent_find()&#123; vector&lt;int&gt; v = &#123; 9,8,7,6,5,1,2,3,4 &#125;; auto temp=adjacent_find(v.begin(), v.end(), cmp); if (temp != v.end()) &#123; cout &lt;&lt; *temp; &#125;&#125; count()统计函数该函数专门用来对容器或普通数组中，指定范围内查找和目标元素值相等的所有元素。 1int count(first,last,const T&amp; val); for_each函数该函数专门用来对容器或普通数组中指定范围内的元素进行处理，把处理功能用函数封装。返回一个函数对象 用法： 1FUNC for_each(first, last, 函数对象); 1234567void show(int a)&#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125;int arr[] = &#123; 1,2,4,5,6,4 &#125;;for_each(&amp;arr[0], &amp;arr[6], show); copy()函数把一个容器指定范围内的元素，拷贝到另一个容器中（目标容器必须内存足够）。返回一个迭代器，指向目标容器被拷贝元素范围的末尾 12345678910111213Iterator count(first,last,destit);void fun_copy()&#123; vector&lt;int&gt; v = &#123; 9,8,7,6,5,1,2,3,4 &#125;; vector&lt;int&gt; v1(v.size()); //list&lt;int&gt; v1(v.size()+10); cout &lt;&lt; *copy(v.begin(), v.end(), v1.begin()) &lt;&lt; endl;; for (auto i : v1) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;&#125; 更多算法C++参考手册 仿函数为什么要有仿函数？从一个非常简单的问题入手，来了解为什么要有仿函数。 假设我们现在有一个数组，数组中存有任意数量的数字，我们希望能够统计出这个数组中大于 10 的数字的数量(按照容器、迭代器、算法分离来实现) 一般这么写： 12345678910111213141516171819202122232425262728typedef bool FUNC(int);int arrNum(int* first, int* last, FUNC func)&#123; int _count = 0; while (first != last) &#123; if (func(*first)) &#123; _count++; &#125; first++; &#125; return _count;&#125;bool isRight(int num)&#123; return num &gt; 10;&#125;int main()&#123; int arr[] = &#123; 1,2,3,4,5,68,5,1,6,45,3,164,6,1,64 &#125;; //求出数组中大于5的元素个数 int len = sizeof(arr) / sizeof(arr[0]); int num=arrNum(arr, arr + len, isRight); cout &lt;&lt; &quot;共有..个：&quot; &lt;&lt;num &lt;&lt; endl; return 0;&#125; arrNum()函数的第三个参数是一个函数指针，用于回调，而 isRight() 函数也是外部定义好的，它只接受一个参数的函数。如果此时希望将判定的阈值也作为一个变量传入，变为如下函数就不可行了： 1234bool isRight(int num,int threshold)&#123; return num &gt; threshold;&#125; 虽然这个函数看起来可以，但是它不能满足已经定义好的函数指针参数的要求，因为函数指针参数的类型是bool (*)(int)，与函数arrNum()的类型不兼容。如果一定要完成这个任务，按照以往的经验，我们可以考虑如下途径：（1）阈值作为函数的局部变量。局部变量不能在函数调用中传递，故不可行；（2）函数传参。这种方法我们已经讨论过了，多个参数不适用于已定义好的 arrNum() 函数。（3）全局变量。我们可以将阈值设置成一个全局变量。这种方法虽然可行，但是不优雅，且非常容易引入 Bug，比如全局变量容易同名，造成命名空间污染。 那么有什么好的处理方法呢？仿函数应运而生。 仿函数的定义仿函数（Functor）又称为函数对象（Function Object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载 operator() 运算符。因为调用仿函数，实际上就是通过类对象调用重载后的 operator() 运算符。 如果编程者要将某种“操作”当做算法的参数，一般有两种方法：（1）一个办法就是先将该“操作”设计为一个函数，再将函数指针当做算法的一个参数。上面的实例就是该做法；（2）将该“操作”设计为一个仿函数（就语言层面而言是个 class），再以该仿函数产生一个对象，并以此对象作为算法的一个参数。 很明显第二种方法会更优秀，因为第一种方法扩展性较差，当函数参数有所变化，则无法兼容旧的代码，具体在第一小节已经阐述。正如上面的例子，在我们写代码时有时会发现有些功能代码，会不断地被使用。 这时就可以使用仿函数了，写一个简单类，除了维护类的基本成员函数外，只需要重载 operator() 运算符 。这样既可以免去对一些公共变量的维护，也可以使重复使用的代码独立出来，以便下次复用。 STL 中也大量涉及到仿函数，有时仿函数的使用是为了函数拥有类的性质，以达到安全传递函数指针、依据函数生成对象、甚至是让函数之间有继承关系、对函数进行运算和操作的效果。比如 STL 中的容器 set 就使用了仿函数 less ，而 less 继承的 binary_function，就可以看作是对于一类函数的总体声明，这是函数做不到的。 所以使用仿函数之后可以这样写： 123456789101112131415161718192021222324252627282930313233struct isRight&#123; isRight(int res=0):res(res) &#123;&#125; bool operator()(int num) &#123; return num &gt; res; &#125;private: int res;&#125;;using FUNC = isRight;int arrNum(int* first, int* last, FUNC func)&#123; int _count = 0; while (first != last) &#123; if (func(*first)) &#123; _count++; &#125; first++; &#125; return _count;&#125;int main()&#123; int arr[] = &#123; 1,2,3,4,5,68,5,1,6,45,3,164,6,1,64 &#125;; //求出数组中大于5的元素个数 int len = sizeof(arr) / sizeof(arr[0]); int num = arrNum(arr, arr + len, isRight(10)); cout &lt;&lt; &quot;共有..个：&quot; &lt;&lt; num &lt;&lt; endl; return 0;&#125; 谓词谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式 函数对象适配器函数对象适配器是完成一些配接工作，这些配接包括绑定(bind)，否定(negate),以及对一般函数或成员函数的修饰，使其成为函数对象，重点掌握函数对象适配器(红色字体): bind1st 将参数绑定为函数对象的第一个参数 bind2nd 将参数绑定为函数对象的第二个参数 not1 对一元函数对象取反 not2 对二元函数对象取反 ptr_fun 将普通函数修饰成函数对象 mem_fun 修饰成员函数(容器里存的是对象) mem_fun_ref 修饰成员函数(容器里存的是指针) bind1st将一个二元函数转换成一个一元函数。（绑定到第一个参数） 其他同下 bind2nd12template &lt;class Operation, class T&gt; binder2nd&lt;Operation&gt; bind2nd (const Operation&amp; op, const T&amp; x); 将一个二元函数转换成一个一元函数。（绑定到第二个参数） 1234567891011121314struct CTest :public binary_function&lt;int, int, void&gt;&#123; void operator()(int i, int val) const &#123; cout &lt;&lt; i &lt;&lt; &quot; + &quot; &lt;&lt; val &lt;&lt;&quot; = &quot;&lt;&lt;i+val&lt;&lt; endl; &#125;&#125;;void obj3()&#123; vector&lt;int&gt; v = &#123; 9,8,7,6,5,1,2,3,4 &#125;; for_each(v.begin(), v.end(), bind2nd(CTest(), 10)); //for_each(v.begin(), v.end(), bind1st(CTest(),10));&#125; not1一元函数取反适配器 1234567891011121314151617struct Mycmp1:public unary_function&lt;int,bool&gt;&#123; bool operator()(int v1)const &#123; return v1 &gt; 5; &#125;&#125;;void fun_not1()&#123; vector&lt;int&gt; v = &#123; 9,8,7,6,5,1,2,3,4 &#125;; auto it = find_if(v.begin(), v.end(), not1(Mycmp1())); if (it != v.end()) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125; not2二元函数取反适配器 12345678910111213141516171819struct MCMP1 :public binary_function&lt;int, int, bool&gt;&#123;public: bool operator()(int a, int b) const &#123; return a == b; &#125;&#125;;void fun_not2()&#123; vector&lt;int&gt; v = &#123; 50,4,1,2,4,5,5,7,8,2 &#125;; auto it = adjacent_find(v.begin(), v.end(), not2(MCMP1())); cout &lt;&lt; *it &lt;&lt; endl; for (auto i : v) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#125;&#125; ptr_fun把普通函数转成仿函数 1234567891011121314bool mycmp2(int v1)&#123; return v1 &gt; 5;&#125;void fun_not1()&#123; vector&lt;int&gt; v = &#123; 9,8,7,6,5,1,2,3,4 &#125;; auto it = find_if(v.begin(), v.end(),not1(ptr_fun(mycmp2))); if (it != v.end()) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125; mem_fun把类的成员函数转成仿函数 123456789101112131415161718class Person&#123;public: Person(int age,int id):_age(age),_id(id)&#123;&#125; void show() &#123; cout &lt;&lt; &quot;id: &quot; &lt;&lt; _id &lt;&lt; &quot;age: &quot; &lt;&lt; _age &lt;&lt; endl; &#125;private: int _age; int _id;&#125;;void fun_cref()&#123; Person p1(1, 2), p2(3, 4), p3(5, 6); vector&lt; Person*&gt; v = &#123; &amp;p1,&amp;p2,&amp;p3 &#125;; for_each(v.begin(), v.end(), mem_fun(&amp;Person::show));&#125; mem_fun_ref同上，把类的成员函数转成仿函数 123456789101112131415161718class Person&#123;public: Person(int age,int id):_age(age),_id(id)&#123;&#125; void show() &#123; cout &lt;&lt; &quot;id: &quot; &lt;&lt; _id &lt;&lt; &quot;age: &quot; &lt;&lt; _age &lt;&lt; endl; &#125;private: int _age; int _id;&#125;;void fun_cref()&#123; Person p1(1, 2), p2(3, 4), p3(5, 6); vector&lt; Person&gt; v = &#123; p1,p2,p3 &#125;; for_each(v.begin(), v.end(), mem_fun_ref(&amp;Person::show));&#125; mem_fun和mem_fun_ref的区别在哪？ 当存的是对象时使用mem_fun_ref 存放的是对象的指针时使用mem_fun","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"C-笔记/STL","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.mingsrc.work/tags/STL/"}]},{"title":"deque容器必知必会攻略🐋","slug":"E_学习笔记/STL/STL之deque容器","date":"2022-12-27T03:12:54.039Z","updated":"2022-12-27T03:12:54.039Z","comments":true,"path":"posts/ed78b4bb.html","link":"","permalink":"https://www.mingsrc.work/posts/ed78b4bb","excerpt":"","text":"🐋deque容器和其他STL容器一样，deque容器也是以模板类deque&lt;T&gt;的&lt;deque&gt;头文件中，并位于std命名空间中。因此，在使用该容器之前，代码中需要包含如下代码(注意：std 命名空间也可以在使用 deque 容器时额外注明，两种方式都可以。)： 12#include &lt;deque&gt;using namespace std; deque 是 double-ended queue 的缩写，又称双端队列容器。如果你已经了解vector，在学完deque之后，你就能发现这两者有很多相似之处，比如： deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为O(1)），而不擅长在序列中间添加或删除元素。 deque 容器也可以根据需要修改自身的容量和大小。 和vector不同的是，deque还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常熟阶O(1)。并且更重要的一点是，deque容器中存储元素并不能保证所有元素都存储到连续的内存空间中。 当需要想序列两端频繁的添加元素师，应首选deque容器。 🐋 创建deque容器创建 deque 容器，根据不同的实际场景，可选择使用如下几种方式。 创建一个没有任何元素的空 deque 容器： 1234567deque&lt;int&gt; d; //创建一个存放int的deque容器deque&lt;float&gt; dflt; //创建一个存放float的deque容器deque&lt;string&gt; dstr; // 创建一个存放string的deque容器//在头插入使用push_front()d.push_front(1); //d = &#123;1&#125;//在尾插入则使用push_back()d.push_back(2); // d = &#123;1,2&#125; 和空 array 容器不同，空的 deque 容器在创建之后可以做添加或删除元素的操作，因此这种简单创建 deque 容器的方式比较常见。 创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值： 12//创建一个大小为10的deque容器，默认元素为0deque&lt;int&gt; d(10); 此行代码创建一个具有 10 个元素（默认都为 0）的 deque 容器。 创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如： deque(n,elem); &#x2F;&#x2F;构造函数将n个elem拷贝给本身。 12//创建具有10个元素为5的deque 容器deque&lt;int&gt; d(10, 5) 如此就创建了一个包含 10 个元素（值都为 5）的 deque 容器。 在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如： deque(const deque &amp;deq); 拷贝构造函数。 12deque&lt;int&gt; d1(5); // 创建大小为5的deque容器d1deque&lt;int&gt; d2(d1); //通过拷贝构造函数创建d2 注意，采用此方式，必须保证新旧容器存储的元素类型一致。 通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），可以创建一个新容器，例如： deque(beg,end); 构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。 123456//拷贝普通数组，创建deque容器int a[] = &#123; 1,2,3,4,5 &#125;;deque&lt;int&gt;d(a, a + 5);//适用于所有类型的容器array&lt;int, 5&gt; arr&#123; 11,12,13,14,15 &#125;;deque&lt;int&gt;d(arr.begin()+2, arr.end());//拷贝arr容器中的&#123;13,14,15&#125; 🐋deque容器的操作🐋deque末尾的添加移除操作1234deque.push_back(elem); //在容器尾部添加一个数据deque.push_front(elem); //在容器头部插入一个数据deque.pop_back(); //删除容器最后一个数据deque.pop_front(); //删除容器第一个数据 deque的赋值1234deque.assign(beg,end); //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。deque.assign(n,elem); //将n个elem拷贝赋值给本身。deque&amp; operator=(const deque &amp;deq); //重载等号操作符 deque.swap(deq); // 将vec与本身的元素互换 deque的大小1234deque.size(); //返回容器中元素的个数deque.empty(); //判断容器是否为空deque.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。deque.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 deque的插入第一个参数为迭代器 123deque.insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。deque.insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。deque.insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 deque的删除123deque.clear(); //移除容器的所有数据 执行此操作之后deque.size() = 0deque.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。deque.erase(pos); //删除pos位置的数据，返回下一个数据的位置。 🐋deque容器成员方法基于deque双端队列的特点，该容器包含一些 array、vector 容器都没有的成员函数。 下表中罗列了deque容器提供的所有成员函数。 函数成员 函数功能 begin() 返回指向容器中第一个元素的迭代器。 end() 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 rbegin() 返回指向最后一个元素的迭代器。 rend() 返回指向第一个元素所在位置前一个位置的迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 size() 返回实际元素个数。 max_size() 返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 232-1，我们很少会用到这个函数。 resize() 改变实际元素的个数。 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 shrink _to_fit() 将内存减少到等于当前元素实际所使用的大小。 at() 使用经过边界检查的索引访问元素。 front() 返回第一个元素的引用。 back() 返回最后一个元素的引用。 assign() 用新元素替换原有内容。 push_back() 在序列的尾部添加一个元素。 push_front() 在序列的头部添加一个元素。 pop_back() 移除容器尾部的元素。 pop_front() 移除容器头部的元素。 insert() 在指定的位置插入一个或多个元素。 erase() 移除一个元素或一段元素。 clear() 移出所有的元素，容器大小变为 0。 swap() 交换两个容器的所有元素。 emplace() 在指定的位置直接生成一个元素。 emplace_front() 在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。 emplace_back() 在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。 和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。 💻程序演示1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;int main()&#123; deque&lt;int&gt; dq(1,2); dq.push_front(1); dq.push_back(3); cout &lt;&lt; &quot;dq当前的大小为：&quot; &lt;&lt; dq.size() &lt;&lt; endl; cout &lt;&lt; &quot;dq中的元素为：&quot;; for (auto it : dq) cout &lt;&lt; it &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; deque&lt;int&gt; dq2(dq.begin(),dq.end()); //拷贝构造赋值 cout &lt;&lt; &quot;dq2的大小为：&quot; &lt;&lt; dq2.size() &lt;&lt; endl; //dq2.size() = 3 dq2.insert(dq2.end(),4,4); //第一个参数是迭代器 dq2 = &#123;1,2,3,4,4,4,4&#125; dq2.clear(); // 移除容器的所有数据 dq2.size() = 0 cout &lt;&lt; &quot;执行\\&quot;dq2.clear()\\&quot;移除容器后dq2.size() = &quot; &lt;&lt; dq2.size() &lt;&lt; endl; dq2.resize(5, 5); //重新定义 dq2 = &#123;5,5,5,5,5&#125; cout &lt;&lt; &quot;执行\\&quot;dq2.resize(5, 5)\\&quot;移除容器后dq2.size() = &quot; &lt;&lt; dq2.size() &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 运行结果为： dq当前的大小为：3 dq中的元素为：1 2 3 dq2的大小为：3 执行\"dq2.clear()\"移除容器后dq2.size() = 0 执行\"dq2.resize(5, 5)\"移除容器后dq2.size() = 5","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"C-笔记/STL","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.mingsrc.work/tags/STL/"},{"name":"deque","slug":"deque","permalink":"https://www.mingsrc.work/tags/deque/"}]},{"title":"unorder_map容器必知必会攻略🐘","slug":"E_学习笔记/STL/STL之map","date":"2022-12-27T03:12:54.039Z","updated":"2022-12-27T03:12:54.039Z","comments":true,"path":"posts/5ec68291.html","link":"","permalink":"https://www.mingsrc.work/posts/5ec68291","excerpt":"","text":"点击加速到unorder_mapPost not found: 学习笔记/STL/STL之unorder_map 🐘mapmap 由红黑树实现，其元素都是 “键值&#x2F;实值” 所形成的一个对组（key&#x2F;value pairs)。每个元素有一个键，是排序准则的基础。每一个键只能出现一次，不允许重复。 map 主要用于资料一对一映射的情况，map 内部自建一颗红黑树，这颗树具有对数据自动排序的功能，所以在 map 内部所有的数据都是有序的。比如一个班级中，每个学生的学号跟他的姓名就存在着一对一映射的关系。 特点 自动建立 Key - value 的对应。key 和 value 可以是任意你需要的类型。 根据 key 值快速查找记录，查找的复杂度基本是 O(logN)，如果有 1000 个记录，二分查找最多查找 10次(1024)。 增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。 对于迭代器来说，可以修改实值，而不能修改 key。 优缺点和适用场景 优点：使用平衡二叉树实现，便于元素查找，且能把一个值映射成另一个值，可以创建字典。 缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响。 适用场景：适用于需要存储一个数据字典，并要求方便地根据key找value的场景. 1、如果需要高效的随机存取，不在乎插入和删除的效率，使用 vector。2、如果需要大量的插入和删除元素，不关心随机存取的效率，使用 list。3、如果需要随机存取，并且关心两端数据的插入和删除效率，使用 deque。4、如果打算存储数据字典，并且要求方便地根据 key 找到 value，一对一的情况使用 map，一对多的情况使用 multimap。5、如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用 set，不唯一存在的情况使用 multiset。","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"C-笔记/STL","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.mingsrc.work/tags/STL/"},{"name":"set","slug":"set","permalink":"https://www.mingsrc.work/tags/set/"}]},{"title":"set容器必知必会攻略🐢","slug":"E_学习笔记/STL/STL之set","date":"2022-12-27T03:12:54.039Z","updated":"2022-12-27T03:12:54.040Z","comments":true,"path":"posts/99373a3e.html","link":"","permalink":"https://www.mingsrc.work/posts/99373a3e","excerpt":"","text":"set 容器定义于&lt;set&gt;头文件，并位于 std 命名空间中。如果想在程序中使用 set 容器，该程序代码应先包含如下语句： 12#include &lt;set&gt;using namespace std; set 容器的类模板定义如下： 12345template &lt; class T, // 键 key 和值 value 的类型 class Compare = less&lt;T&gt;, // 指定 set 容器内部的排序规则 class Alloc = allocator&lt;T&gt; // 指定分配器对象的类型 &gt; class set; 注意，由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。 对于 set 类模板中的 3 个参数，后 2 个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3 个参数不会用到。 🐢set容器 和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。 举个例子，如下有 2 组键值对数据： 12&#123;&lt;&#x27;a&#x27;, 1&gt;, &lt;&#x27;b&#x27;, 2&gt;, &lt;&#x27;c&#x27;, 3&gt;&#125;&#123;&lt;&#x27;a&#x27;, &#x27;a&#x27;&gt;, &lt;&#x27;b&#x27;, &#x27;b&#x27;&gt;, &lt;&#x27;c&#x27;, &#x27;c&#x27;&gt;&#125; 显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而无法存储第一组键值对。 基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {‘a’,’b’,’c’} ，该容器即可成功将它们存储起来。 🐢set的简介 set是一个集合容器，其中所包含的元素是唯一的，集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。 set采用Post not found: 程序员内功/算法与数据结构/数据结构/红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。 set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。 multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。 &lt;/p&gt;不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。 🐢创建set容器常见的创建set容器的方法，大致有以下5种： 1）默认构造函数调用默认构造函数，创建空的set容器。set对象的默认构造 123set&lt;int&gt; setInt; //一个存放int的set容器。set&lt;float&gt; setFloat; //一个存放float的set容器。set&lt;string&gt; setString; //一个存放string的set容器。 由此就创建好了一个 set 容器，该容器采用默认的std::less&lt;T&gt;规则，会对存储的 string 类型元素做升序排序。注意，由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。 2）创建并初始化12345set&lt;string&gt; myBlogSet&#123; &quot;http://fole-del.github.io&quot;, &quot;http://fole-del.gitee.io&quot;, &quot;http://www.mingsrc.work&quot;&#125;; 由此即创建好了包含 3 个 string 元素的 myBlogSet容器。由于其采用默认的 std::less 规则，因此其内部存储 string 元素的顺序如下所示： http://fole-del.gitee.io http://fole-del.github.io http://www.mingsrc.work 3）拷贝构造函数使用set类模板提供的拷贝构造函数，在第2种myBlog的基础上，执行如下代码： 123std::set&lt;std::string&gt; copyBlogSet(myBlogSet);//等同于//std::set&lt;std::string&gt; copyBlogSet = myBlogSet 该行代码在创建 copyBlogSet 容器的基础上，还会将myBlogSet容器中存储的所有元素，全部复制给copyBlogSet容器一份。 除此之外，C++11标准还为set类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。比如： 123456789set&lt;string&gt; retBlogSet() &#123; std::set&lt;std::string&gt; myBlogSet&#123; &quot;http://fole-del.github.io&quot;, &quot;http://fole-del.gitee.io&quot;, &quot;http://www.mingsrc.work&quot;&#125;; return myBlogSet;&#125;std::set&lt;std::string&gt; copyBlogSet(retBlogSet());//或者//std::set&lt;std::string&gt; copyBlogSet = retBlogSet(); 4) 使用已有set的部分初始化set在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。例如： 1234set&lt;string&gt; myBlogSet&#123;&quot;http://fole-del.github.io&quot;, &quot;http://fole-del.gitee.io&quot;, &quot;http://www.mingsrc.work&quot;&#125;;std::set&lt;std::string&gt; copyBlogSet(++myBlogSet.begin(), myBlogSet.end()); 由此初始化的copyset容器，其内部有如下2两个字符串： http://fole-del.github.io http://www.mingsrc.work 5）修改set的排序规则以上几种方式创建的 set 容器，都采用了默认的std::less&lt;T&gt;规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。比如： 123set&lt;string,greater&lt;string&gt; &gt; myBlogSet&#123;&quot;http://fole-del.github.io&quot;, &quot;http://fole-del.gitee.io&quot;, &quot;http://www.mingsrc.work&quot;&#125;; http://www.mingsrc.work http://fole-del.github.io http://fole-del.gitee.io # 🐢set容器成员方法 下表C++ set 容器常用成员方法 成员方法 功能 begin() 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 end() 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 rbegin() 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 rend() 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。 find(val) 在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 lower_bound(val) 返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 upper_bound(val) 返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。 equal_range(val) 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。 empty() 若容器为空，则返回 true；否则 false。 size() 返回当前 set 容器中存有元素的个数。 max_size() 返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 insert() 向 set 容器中插入元素。 erase() 删除 set 容器中存储的元素。 swap() 交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。 clear() 清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。 emplace() 在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。 emplace_hint() 在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。 count(val) 在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。 🐢set的操作set的插入set.insert(elem); //在容器中插入元素。 Set集合的元素排序set &gt; setIntA; //该容器是按升序方式排列元素。 set&gt; setIntB; //该容器是按降序方式排列元素。 set 相当于 set&gt;。 less与greater中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。 注意点1： less&lt;&gt;与greate&lt; &gt;是什么？ 注意点2：如果set&lt;&gt;不包含int类型，而是包含自定义类型，set容器如何排序？ 要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。 下面将讲解什么是functor以及用法。 使用stl提供的函数对象 set&gt; setIntB; setIntB.insert(3); setIntB.insert(1); setIntB.insert(5); setIntB.insert(2); 此时容器setIntB就包含了按顺序的5,3,2,1元素 函数对象functor的用法尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。 functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。 greater&lt;&gt;与less&lt;&gt;就是函数对象。 下面举出greater的简易实现原理。 12345678class greater&#123;public: bool operator()(const int&amp; iLeft, const int&amp; iRight) &#123; return iLeft &gt; iRight; //如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight); &#125;&#125;; 容器就是调用函数对象的operator()方法去比较两个值的大小。 仿函数练习学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。 解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;//学生类class CStudent&#123;public: CStudent(int iID, string strName) &#123; m_iID = iID; m_strName = strName; &#125; //private: int m_iID; //学号 string m_strName; //姓名&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; os, CStudent&amp; stu) &#123; os &lt;&lt; stu.m_iID &lt;&lt; &quot; &quot;; for (auto it : stu.m_strName) os &lt;&lt; it; return os;&#125;//为保持主题鲜明，本类不写拷贝构造函数，本类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。//函数对象struct StuFunctor&#123; bool operator()(const CStudent&amp; stu1, const CStudent&amp; stu2) const &#123; return (stu1.m_iID &lt; stu2.m_iID); &#125;&#125;;int main()&#123; set&lt;CStudent, StuFunctor&gt; setStu; setStu.insert(CStudent(3, &quot;小张&quot;)); setStu.insert(CStudent(1, &quot;小李&quot;)); setStu.insert(CStudent(5, &quot;小王&quot;)); setStu.insert(CStudent(2, &quot;小刘&quot;)); for (auto i : setStu) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 程序运行结果： 1 小李 2 小刘 3 小张 5 小王 ## set对象的拷贝构造与赋值 set(const set &st); //拷贝构造函数 set& operator=(const set &st); //重载等号操作符 set.swap(st); //交换两个集合容器 ## set的大小 set.size(); //返回容器中元素的数目 set.empty();//判断容器是否为空 ## set的删除 set.clear(); //清除所有元素 set.erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 set.erase(beg,end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 set.erase(elem); //删除容器中值为elem的元素。 ## set的查找 set.find(elem); //查找elem元素，返回指向elem元素的迭代器。 set.count(elem); //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。 set.lower_bound(elem); //返回第一个>=elem元素的迭代器。 set.upper_bound(elem); // 返回第一个>elem元素的迭代器。 set.equal_range(elem); //返回一对迭代器，这两个迭代器分别用于发现set中其键大于指定键的第一个元素，以及集中其键等于或大于指定键的第一个元素。 以上函数返回两个迭代器，而这两个迭代器被封装在pair中。 # 💻程序演示： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;using namespace std;int main()&#123; //创建空set容器 std::set&lt;std::string&gt; myBlogSet; //空set容器不存储任何元素 cout &lt;&lt; &quot;1、myBlogSet size = &quot; &lt;&lt; myset.size() &lt;&lt; endl; //向myBlogSet容器中插入新元素 myset.insert(&quot;http://www.mingsrc.work&quot;); myset.insert(&quot;http://fole-del.github.io&quot;); myset.insert(&quot;http://fole-del.gitee.io&quot;); cout &lt;&lt; &quot;2、myBlogSet size = &quot; &lt;&lt; myBlogSet.size() &lt;&lt; endl; //利用双向迭代器，遍历myBlogSet for (auto iter = myBlogSet.begin(); iter != myBlogSet.end(); ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; endl; &#125; return 0;&#125; 程序的执行结果为： 1、myBlogSet size = 0 2、myBlogSet size = 3 http://fole-del.gitee.io http://fole-del.github.io http://www.mingsrc.work","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"STL","slug":"C-笔记/STL","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://www.mingsrc.work/tags/STL/"},{"name":"set","slug":"set","permalink":"https://www.mingsrc.work/tags/set/"}]},{"title":"","slug":"E_学习笔记/STL/C++实现STL/Linux运行C++程序","date":"2022-12-27T03:12:54.039Z","updated":"2022-12-27T03:12:54.039Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://www.mingsrc.work/posts/0","excerpt":"","text":"12345#生成运行文件g++ helloworld.cpp -o helloworld#执行生成的文件（helloworld）./helloworld","raw":null,"content":null,"categories":[],"tags":[]},{"title":"STL实现—C++STL简介","slug":"E_学习笔记/STL/C++实现STL/1、C++STL简介","date":"2022-12-27T03:12:54.038Z","updated":"2022-12-27T03:12:54.038Z","comments":true,"path":"posts/9b43cc40.html","link":"","permalink":"https://www.mingsrc.work/posts/9b43cc40","excerpt":"","text":"C++ STL简介一、STL介绍本次课程主要面对有一定 c++ 基础（了解基本语法，熟悉常用特性）的 ，想要学习 c++ 更深入特性 ，掌握 c++ 强大标准库的同学 。通过本次课程，你将学习到 c++ template ，异常处理 ，并回顾数据库的部分知识 ，初步掌握 STL 开发 ，避免重复制造轮子。 将学习到的知识点： 模板编程 泛型编程 STL 常用组件 lambda 表达式 异常处理 内存处理 部分数据结构 部分算法 提示：本课程所有代码至少需要开启 -std&#x3D;c++11 选项来支持 C++11 相关特性，在介绍 C++14 特性时的相关代码需要开启 -std&#x3D;c++14 的编译选项，例如： 12+ g++ main.cpp -std=c++11+ g++ main.cpp -std=c++14 如果你没有使用过 STL，那么你是不爱 c++ 的，STL 的原名是“Standard Template Library”，翻译过来就是标准模板库。STL 是 C++ 标准库的一个重要组成部分，STL 实现了常用的数据结构和算法 ，蕴含其间的泛型编程和代码复用的思想深刻的影响了编程习惯，像微积分延长天文学家寿命一样，STL 延长了程序员的寿命。 STL 由算法，容器，迭代器，适配器，仿函数（函数对象），空间适配器六大部件组成 。我们将主要讲解容器，迭代器，算法和仿函数。适配器的部分会交给学员来实现，而空间适配器不会太过于深入。从上往下学习 STL，学习曲线不再那么陡峭。 二、容器鱼缸是容器，瓶子是容器，饭碗也是容器，STL 的容器也不列外。这里的容器首先是一个模板类，在类中实现对数据的操作，而包含这样的类的实现就叫一个容器。STL 有许多这样的容器，它们包括：向量（vector），列表（list），队列（queue），双端队列（deque），优先队列（Priority queue），集合（set），多种集合（multiset），映射（map），多重映射（multimap）。 三、算法数据结构加算法等于程序，如果说容器实现了数据结构的话，那么算法就是 STL 的灵魂 ，STL 的算法是一种通用的算法，并不依赖于特定的数据结构和对象 。这样的好处是不用针对每种情况编写特定的代码，而是给出一种通用的做法，是代码复用的一种实现方法，模板编程则是泛型编程的基础。 四、迭代器让我们演示一个简单的函数： add（int &amp;a ，int &amp;b） ，它传入两个引用，然后执行加法操作，可以看到它依赖于 int 这个特定的类型，而且暴露了这个函数的内部结构不利于对底层的隔离和封装。那么 STL 是怎么解决这个问题的呢？他们使用了迭代器（对指针的一种泛化）。迭代器底层是由指针实现的，是容器和算法的桥梁。STL 里大多数容器都实现了自己的迭代器，我们可以使用迭代器来完成对容器的访问。后面我们会详细讲到迭代器的种类，性质，使用，实现。 五、适配器学习过数据结构的同学大都知道，数据结构不是独立的，部分数据结构是可以相互转换的。比如栈和队列可以互相实现。当我们需要一个碗的时候我们不一定重新制造，我们可以把瓶子的上部去掉。同样的道理，当我们需要队列（queue）的时候，也可以用双端队列（deque）去实现。而 queue 就叫做适配器。STL 有三种基本容器 vector，deque，list。有用基本容器扩展的适配器 queue，stack 等。适配器主要有容器适配器，迭代器适配器，函数适配器，它们的作用范围不同，意思大致一致。后面我们也会详细讲到。 六、仿函数仿函数又叫做函数对象，其本质是类的对象，一种可回调机制，在类中重载了（）运算符，使对象在用（）时呈现出函数的特性，所以叫做仿函数。叫仿函数体现了它的作用，叫函数对象体现其本质，大家喜欢叫什么都可以。而为什么需要仿函数呢？因为 STL 没有也不可能将所有东西都包含到函数中，而程序是对现实的模拟，现实又是最复杂的，一个sort（），你要 &lt; ，我要 &gt; 。如何协调呢？我们可以定义自己需要的仿函数，定制自己的操作。具体的内容我们后面会讲。这儿只做说明。 七、空间配置器c++ 的一大魅力就是对底层的操作，你像一个魔法师一样，挥舞着魔杖操纵着底层的各种资源。当然一个不好，程序也崩给你看。而空间配置器就是 STL 自己的“内存池”。完成对内存的申请，释放，维护。配置器有两个部分：一级空间配置器，二级空间配置器。本次课程不会过度讲解配置器，感兴趣的同学可以去看一下实验楼另外一个课程：c++ 实现高性能内存池。","raw":null,"content":null,"categories":[{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"实现STL","slug":"实验楼/实现STL","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/%E5%AE%9E%E7%8E%B0STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://www.mingsrc.work/tags/STL/"}]},{"title":"STL实现—迭代器","slug":"E_学习笔记/STL/C++实现STL/3、迭代器","date":"2022-12-27T03:12:54.038Z","updated":"2022-12-27T03:12:54.038Z","comments":true,"path":"posts/f8b7acae.html","link":"","permalink":"https://www.mingsrc.work/posts/f8b7acae","excerpt":"迭代器","text":"迭代器 一、实验内容本节实验我们将为大家讲解迭代器，主要介绍 5 种常见迭代器：输入、输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。主要内容包括各自的构造方法和操作方法。 1.1 知识点 输出迭代器 输入迭代器 前向迭代器 双向迭代器 随机迭代器 迭代器辅助函数 1.2 实验环境 g++ ubuntu 16.04 1.3 代码获取可以通过以下链接获取本课程的源码内容，本次实验内容主要包含在文件Iterator.h。 123//获取代码wget https://labfile.oss.aliyuncs.com/courses/1166/mySTL.zipunzip -q mySTL.zip -d ./Code/ 二、迭代器详述迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。迭代器基本分为五种，输入输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。 简单概括：迭代器是一种检查容器内元素并遍历元素的可带泛型数据类型。 下面，我们新建头文件Iterator.h是头文件，用来实现我们的迭代器，这里的代码需要引用到系统头文件#include &lt;cstddef&gt;，它主要用于定义一些类型。接下来我们定义 5 种迭代器的类型，将其写入Iterator.h文件中： 12345struct input_iterator_tag&#123;&#125;;//返回输入迭代器struct output_iterator_tag&#123;&#125;;//返回输出迭代器struct forward_iterator_tag :public input_iterator_tag &#123;&#125;;//返回前向迭代器struct bidirectional_iterator_tag :public forward_iterator_tag &#123;&#125;;//返回双向迭代器struct random_access_iterator_tag :public bidirectional_iterator_tag &#123;&#125;;//返回随机迭代器 2.1 输入迭代器通过对输入迭代器解除引用，它将引用对象，而对象可能位于集合中。通常用于传递地址。 12345678template&lt;class T, class Distance&gt;struct input_iterator &#123; typedef input_iterator_tag iterator_category;//返回类型 typedef T value_type;//所指对象类型 typedef Distance difference_type;//迭代器间距离类型 typedef T* pointer;//操作结果类型 typedef T&amp; reference;//解引用操作结果类型&#125;; 2.2 输出迭代器该类迭代器和输入迭代器极其相似，也只能单步向前迭代元素，不同的是该类迭代器对元素只有写的权力。通常用于返回地址。 1234567struct output_iterator&#123; typedef output_iterator_tag iterator_category; typedef void value_type; typedef void difference_type; typedef void pointer; typedef void reference;&#125;; 2.3 前向迭代器前向迭代器可以在一个正确的区间中进行读写操作，它拥有输入迭代器的所有特性，和输出迭代器的部分特性，以及单步向前迭代元素的能力。通常用于遍历。 1234567template &lt;class T, class Distance&gt; struct forward_iterator&#123; typedef forward_iterator_tag iterator_category; typedef T value_type; typedef Distance difference_type; typedef T* pointer; typedef T&amp; reference;&#125;; 2.4 双向迭代器该类迭代器是在前向迭代器的基础上提供了单步向后迭代元素的能力，前向迭代器的高级版。 1234567template &lt;class T, class Distance&gt; struct bidirectional_iterator&#123; typedef bidirectional_iterator_tag iterator_category; typedef T value_type; typedef Distance difference_type; typedef T* pointer; typedef T&amp; reference;&#125;; 2.5 随机迭代器该类迭代器能完成上面所有迭代器的工作，它自己独有的特性就是可以像指针那样进行算术计算，而不是仅仅只有单步向前或向后迭代。 1234567template &lt;class T, class Distance&gt; struct random_access_iterator&#123; typedef random_access_iterator_tag iterator_category; typedef T value_type; typedef Distance difference_type; typedef T* pointer; typedef T&amp; reference;&#125;;","raw":null,"content":null,"categories":[{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"实现STL","slug":"实验楼/实现STL","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/%E5%AE%9E%E7%8E%B0STL/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://www.mingsrc.work/tags/STL/"}]},{"title":"Qt“CV”大法——Linux下的TCP通信","slug":"E_学习笔记/Qt/TCPIP","date":"2022-12-27T03:12:54.037Z","updated":"2022-12-27T03:12:54.037Z","comments":true,"path":"posts/9dc0717d.html","link":"","permalink":"https://www.mingsrc.work/posts/9dc0717d","excerpt":"Linux 下的 TCP 通信第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。\n第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n四次挥手过程理解 ","text":"Linux 下的 TCP 通信第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 四次挥手过程理解 TCP三次和四次握手 1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 Qt下的tcp 1. 服务器端 123//断开链接tcpSocket-&gt;disconnectFromHost();tcpSocket-&gt;close(); 2. 客户端12345678910//客户端链接服务器端void clientWidget::on_buttonConnect_clicked()&#123; //获取服务器ip和端口 QString ip = ui-&gt;lineEditIP-&gt;text(); qint16 port = ui-&gt;lineEditPort-&gt;text().toInt(); tcpSocket-&gt;connectToHost(QHostAdderss(ip),port); &#125; 123456789101112131415161718192021//发送数据void send()&#123; //获取编辑框内容 QString str = ui-&gt;textEditWrite-&gt;toPlainText(); //发送数据 tcpSocket-&gt;write( str.toUtf8().data() ); &#125;//构造函数读取内容connect(tcpSocket,&amp;QTcpSocket::readyRead, [=]() &#123; //获取对方发送的内容 QByteArray array = tcpSocket-&gt;readAll(); //追加到编辑框 ui.TextEditRead-&gt;append(array); &#125; ) 这篇文章还在编辑中······","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Qt","slug":"学习笔记/Qt","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Qt/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"Qt","slug":"Qt","permalink":"https://www.mingsrc.work/tags/Qt/"}]},{"title":"窗口显示在顶层","slug":"E_学习笔记/Qt/窗口布局","date":"2022-12-27T03:12:54.037Z","updated":"2022-12-27T03:12:54.037Z","comments":true,"path":"posts/79fd161.html","link":"","permalink":"https://www.mingsrc.work/posts/79fd161","excerpt":"窗口显示在顶层","text":"窗口显示在顶层 代码比较简单: 12345//保持在最前w.setWindowFlags(w.windowFlags() | Qt::WindowStaysOnTopHint);w.show();//仅仅显示在最前1次(点击主窗体时主窗体回到最前)w.raise(); 效果: 任意拖动窗口位置 重写mouseEvent事件 在Qt程序中，当&#x3D;&#x3D;隐藏掉窗体的标题栏&#x3D;&#x3D;之后，如果不重写鼠标移动事件，我们是无法通过鼠标任意拖拽窗体的。下面收藏了两个重写的方法，只要在程序里添加鼠标事件，并重写即可。方法一： 1234567891011121314151617181920212223void Widget::mousePressEvent(QMouseEvent *event)&#123; bPressFlag = true; beginDrag = event-&gt;pos(); QWidget::mousePressEvent(event);&#125;void Widget::mouseReleaseEvent(QMouseEvent *event)&#123; bPressFlag = false; QWidget::mouseReleaseEvent(event);&#125;void Widget::mouseMoveEvent(QMouseEvent *event)&#123; if(bPressFlag) &#123; QPoint relaPos(QCursor::pos() - beginDrag); move(relaPos); &#125; QWidget::mouseMoveEvent(event);&#125;其中，bPressFlag是布尔型成员变量,beginDrag是QPoint型成员变量.1234567891011121314151617181920212223 方法二： 12345678910111213141516171819202122232425void Widget::mousePressEvent(QMouseEvent *e)&#123; if(e-&gt;button() == Qt::LeftButton) &#123; isDrag = true; m_position = e-&gt;globalPos() - this-&gt;pos(); e-&gt;accept(); &#125;&#125;void Widget::mouseMoveEvent(QMouseEvent *e)&#123; if(isDrag &amp;&amp; (e-&gt;buttons() &amp;&amp; Qt::LeftButton)) &#123; move(e-&gt;globalPos() - m_position); e-&gt;accept(); &#125;&#125;void Widget::mouseReleaseEvent(QMouseEvent *)&#123; isDrag = false;&#125;其中，isDrag 是布尔型成员变量,m_position是QPoint型成员变量.12345678910111213141516171819202122232425 我们知道设置无标题栏窗体的代码是:setWindowFlags(Qt::FramelessWindowHint);但是这样会出现一个问题，当我们在电脑的状态栏点击程序图标时，如果它原本在最前端那么隐藏掉，如果隐藏了则显示出来，大部分的程序都是这样的。但是，按照上面的那代码是有时候有效果，有时候没有。所以这条代码应该是这样:setWindowFlags(Qt::FramelessWindowHint|Qt::WindowMinimizeButtonHint); QLcdNumber显示时间12345678910111213141516 //设置定时器并绑定，然后启动 QTimer *timer = new QTimer(this); //新建一个定时器对象 connect(timer, &amp;QTimer::timeout, this, &amp;Dialog::showTime); //(d) timer-&gt;start(1000);/* QTime time = QTime::currentTime(); QString text=time.toString(&quot;hh:mm:ss&quot;);*/void Dialog::showTime()&#123; QTime time=QTime::currentTime(); QString text=time.toString(&quot;hh:mm:ss&quot;); display(text);&#125; Qt鼠标事件1234567891011121314void PushButton::leaveEvent(QEvent *event)&#123; nStart = btnNomal;&#125;void PushButton::enterEvent(QEvent *event)&#123; nStart = btnHover;&#125;void PushButton::onClicked()&#123; nStart = btnPressed;&#125; 本文结束~","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Qt","slug":"学习笔记/Qt","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://www.mingsrc.work/tags/Qt/"},{"name":"窗口布局","slug":"窗口布局","permalink":"https://www.mingsrc.work/tags/%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80/"}]},{"title":"关于QByteArray中的URL编解码","slug":"E_学习笔记/Qt/Qt_Url编解码","date":"2022-12-27T03:12:54.036Z","updated":"2022-12-27T03:12:54.036Z","comments":true,"path":"posts/e35c7634.html","link":"","permalink":"https://www.mingsrc.work/posts/e35c7634","excerpt":"","text":"关于Qt中的URL编解码的使用QByteArray中的toPercentEncoding和fromPercentEncoding支持对URL的编解码工作。 先看一下toPercentEncoding的官方文档。 说明非常简单了。fromPercentEncoding()就刚好相反。说白了就是把你的这个输入转换为网址的格式。可以理解为URL编码的过程 demo： 123456789QByteArray text = &#123;&quot;http://www.baidu.com/s?ie=utf-8&amp;f=8&amp;tn=baidu&amp;wd=临时邮箱&quot;&#125;;QByteArray urlEncode = text.toPercentEncoding();qDebug(&quot;编码后&quot;);qDebug(urlEncode.constData());QByteArray urlDecode = QByteArray::fromPercentEncoding(urlEncode);qDebug(&quot;-------------------------------------------------&quot;); qDebug(&quot;解码后&quot;); qDebug(urlDecode.constData()); 输出： 编码后：http0.0000000.0000000.000000www.baidu.com0.000000s0.000000ie%3Dutf-8 0.000000%3D8 %3Dbaidu%26wd%3D5.185438E-3164%B8%B48.694087E-3156%97%B65.190920E-3169%820.000000E5.182199E-31670.000000E%B1----------------------------------解码后：http://www.baidu.com/s?ie=utf-8&f=8&tn=baidu&wd=临时邮箱 所以当你需要把解码后的网址作为数据发送或使用时就可以使用Encoding，需要解码URL的网址是就使用Decoding。","raw":null,"content":null,"categories":[{"name":"Qt","slug":"Qt","permalink":"https://www.mingsrc.work/categories/Qt/"},{"name":"QByteArray","slug":"Qt/QByteArray","permalink":"https://www.mingsrc.work/categories/Qt/QByteArray/"}],"tags":[]},{"title":"Qt线程","slug":"E_学习笔记/Qt/Qt线程","date":"2022-12-27T03:12:54.036Z","updated":"2022-12-27T03:12:54.037Z","comments":true,"path":"posts/40b71726.html","link":"","permalink":"https://www.mingsrc.work/posts/40b71726","excerpt":"","text":"Qt线程#include &lt; QThread&gt; 这篇文章还在编辑中······","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Qt","slug":"学习笔记/Qt","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://www.mingsrc.work/tags/Qt/"},{"name":"线程","slug":"线程","permalink":"https://www.mingsrc.work/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"QPROPETRY属性","slug":"E_学习笔记/Qt/QPORPETRY","date":"2022-12-27T03:12:54.035Z","updated":"2022-12-27T03:12:54.036Z","comments":true,"path":"posts/8aa93b6e.html","link":"","permalink":"https://www.mingsrc.work/posts/8aa93b6e","excerpt":"","text":"说明Q_PROPERTY 是 Qt 中的一个宏，是用类中声明属性。如果需要使用该宏，必须要继承 QObject 类或者其子类。QPushButton 则是 QObject 的间接子类，所以继承 QPushButton 类后同样可以使用 Q_PROPERTY 宏。 Q_PROPERTY 属性自带了一些属性，同样程序可以自定义。本实验中只讲解 Q_PROPERTY 自带的属性。 在自定义导航按钮的程序中同样使用了 Q_PROPERTY，且程序中只使用了 Q_PROPERTY 的 READ 属性和 WRITE 属性。 用法Q_PROPERTY 自带属性： 1234567891011Q_PROPERTY(type name READ getFunction [WRITE setFunction] [RESET resetFunction] [NOTIFY notifySignal] [DESIGNABLE bool] [SCRIPTABLE bool] [STORED bool] [USER bool] [CONSTANT] [FINAL]) 在上面的代码中，方括号 [] 中的内容属性可选。 必选 READ 属性：用来读取属性值，因此使用 const 限制，返回值类型必须为属性类型或者属性类型的引用或者指针。 可选 WRITE 属性：用来设置属性值，返回值必须为 void 类型，需要一个参数。 可选 RESET 属性：能够将值设置为默认状态，返回值为 void 类型且不带参数。 可选 NOTIFY 属性：提供一个信号，当值发送改变是该信号会自动被触发。 可选 DESIGNABLE 属性：是否在界面设计器的属性编辑器中出现。大多数属性是可见的，除了可以为变量传入 true 或 false 还可以执行一个 bool 行的成员函数。 可选 SCRIPTABLE 属性：是够可以被脚本引擎操作（默认为 true）。可以赋予 true 或者 false 或 bool 类型的函数。 可选 STORED 属性：是否被认为是独立存在还是依赖于其他的值而存在，也可以表明是否在保存对象状态时保存此属性的值。大多数属性都是需要保存的，但也有例外，例如 QWidget::minimumWidth() 就是不被保存的，因为它的值是从另一个属性 QWidget::minimumSize() 得来的。 可选 USER 属性：是否被设计为面向用户的或用户可修改的类属性。通常，每个类只有一个 USER 属性。例如 QAbstractButton::checked 是按钮类的用户可修改属性。注意 QItemDelegate 获取和设置 widget 的 USER 属性。 可选 CONSTANT 属性：表示属性的值是不变的。 可选 FINAL 属性：表示属性不能被派生类所重写。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Qt","slug":"学习笔记/Qt","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://www.mingsrc.work/tags/Qt/"}]},{"title":"Jupyter扩展技能","slug":"E_学习笔记/Python/python相关/jupyter相关","date":"2022-12-27T03:12:54.035Z","updated":"2022-12-27T03:12:54.035Z","comments":true,"path":"posts/2018b55.html","link":"","permalink":"https://www.mingsrc.work/posts/2018b55","excerpt":"","text":"Jupyter 使用相关一、安装主题安装 1pip install --upgrade jupyterthemes 查看可用主题 1jt -l 设置推荐12jt -t chesterish -fs 14 -cellw 85% -ofs 13 -dfs 11 -Tjt -t oceans16 -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T -N 二、自动补全等功能","raw":null,"content":null,"categories":[],"tags":[]},{"title":"numpy使用案例","slug":"E_学习笔记/Python/python数据分析/numpy使用","date":"2022-12-27T03:12:54.034Z","updated":"2022-12-27T03:12:54.034Z","comments":true,"path":"posts/1df7a3e4.html","link":"","permalink":"https://www.mingsrc.work/posts/1df7a3e4","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"学习笔记/python","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/python/"},{"name":"python数据分析","slug":"学习笔记/python/python数据分析","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.mingsrc.work/tags/python/"},{"name":"数据分析","slug":"数据分析","permalink":"https://www.mingsrc.work/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"numpy","slug":"numpy","permalink":"https://www.mingsrc.work/tags/numpy/"}]},{"title":"numpy\\pandas\\random查询手册集合","slug":"E_学习笔记/Python/python数据分析/函数自查手册","date":"2022-12-27T03:12:54.034Z","updated":"2022-12-27T03:12:54.034Z","comments":true,"path":"posts/1804fe66.html","link":"","permalink":"https://www.mingsrc.work/posts/1804fe66","excerpt":"","text":"1. 设置小数点位数 ~~~pythondf[‘a’] &#x3D; df[‘a’].round(decimals&#x3D;2)1232. ~~~python decimals = pd.Series([1, 0, 2], index=[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]) df.round(decimals) 2. pandas统计每行的个数12zero_col_count = dict(df[0].value_counts())#统计第0列元素的值的个数three_row_count = dict(df.loc[3].value_counts())#统计第3行元素的值的个数 🎵我喜欢的音乐-Ming 3. 全局变量 global 1234567i = 0def add(a,b): global i print(&#x27;第&#x27;+i+&#x27;次计算&#x27;) return a+bfor i in range(10): print(add(i,i+1)) 4. pandas中apply列的输入输出 1 to 1 1234def judge(x): if x &lt; 10: return 0df[&#x27;new_col&#x27;] = df[&#x27;exist_col&#x27;].apply(judge) N to 1 1234def judge(x): if(x[&#x27;old_col_1&#x27;] &lt; 10 &amp;&amp; x[&#x27;old_col_2&#x27;] == &#x27;boy&#x27;): return &#x27;child&#x27;df[&#x27;new_col&#x27;] = df.apply(judge,axis=1) 1 to N 12345678910111213141516就是针对输出的三行写三个函数即可，或者使用lambda分别处理就行df_test = pd.DataFrame([ &#123;&#x27;dir&#x27;: &#x27;/Users/uname1&#x27;, &#x27;size&#x27;: 994933&#125;, &#123;&#x27;dir&#x27;: &#x27;/Users/uname2&#x27;, &#x27;size&#x27;: 109338711&#125;,])df_test[&#x27;size_kb&#x27;] = df_test[&#x27;size&#x27;].astype(int).apply(lambda x: locale.format(&quot;%.1f&quot;, x / 1024.0, grouping=True) + &#x27; KB&#x27;)df_test[&#x27;size_mb&#x27;] = df_test[&#x27;size&#x27;].astype(int).apply(lambda x: locale.format(&quot;%.1f&quot;, x / 1024.0 ** 2, grouping=True) + &#x27; MB&#x27;)df_test[&#x27;size_gb&#x27;] = df_test[&#x27;size&#x27;].astype(int).apply(lambda x: locale.format(&quot;%.1f&quot;, x / 1024.0 ** 3, grouping=True) + &#x27; GB&#x27;)df_test dir size size_kb size_mb size_gb0 /Users/uname1 994933 971.6 KB 0.9 MB 0.0 GB1 /Users/uname2 109338711 106,776.1 KB 104.3 MB 0.1 GB 5. 删除空值123cond = df.isnull().any(axis = 1)index = df[cond].indexdf2 = df.drop(labels=index) 6. 根据条件删除值123cond = (df &lt; 60).any(axis=1)index = df[cond].indexdf3 = df.drop[labels=index] 7. 规范化到[0,1]123456from sklearn import preprocessing# 规范化到 [0,1] 空间min_max_scaler=preprocessing.MinMaxScaler()car_x=min_max_scaler.fit_transform(car_x)pd.DataFrame(car_x).to_csv(&#x27;temp.csv&#x27;, index=False)print(car_x) 8. pandas删除行、列 删除行 1234567891011# 按行名指定print(df.drop(&#x27;Charlie&#x27;, axis=0))print(df.drop(&#x27;Charlie&#x27;))print(df.drop(index=&#x27;Charlie&#x27;))## 一次删除多行print(df.drop([&#x27;Bob&#x27;, &#x27;Dave&#x27;, &#x27;Frank&#x27;]))print(df.drop(index=[&#x27;Bob&#x27;, &#x27;Dave&#x27;, &#x27;Frank&#x27;]))# 按行号指定print(df.index[[1, 3, 5]])print(df.drop(df.index[[1, 3, 5]]))print(df.drop(index=df.index[[1, 3, 5]])) 删除列 12345678910# 按列名指定print(df.drop(&#x27;state&#x27;, axis=1))print(df.drop(columns=&#x27;state&#x27;))## 一次删除多行print(df.drop([&#x27;state&#x27;, &#x27;point&#x27;], axis=1))print(df.drop(columns=[&#x27;state&#x27;, &#x27;point&#x27;]))# 按列号指定print(df.columns[[1, 2]])print(df.drop(df.columns[[1, 2]], axis=1))print(df.drop(columns=df.columns[[1, 2]])) 删除多行多列 123456789print(df.drop(index=[&#x27;Bob&#x27;, &#x27;Dave&#x27;, &#x27;Frank&#x27;], columns=[&#x27;state&#x27;, &#x27;point&#x27;]))print(df.drop(index=df.index[[1, 3, 5]], columns=df.columns[[1, 2]]))df_org = df.copy()df_org.drop(index=[&#x27;Bob&#x27;, &#x27;Dave&#x27;, &#x27;Frank&#x27;], columns=[&#x27;state&#x27;, &#x27;point&#x27;], inplace=True) 9. 删除缺失值的行 1df = df[~df[&#x27;col&#x27;].isnull()] 10. 删除索引在读取的时候不要读取索引列！ 1qs = pd.read_excel(&#x27;./2018-QS-World-University-Rankings-Top200.xlsx&#x27;,index=False) 11. matplotlib画图看这个就完事了 12. 你问我怎么添加图例13. 设置行的索引为一列1data[&#x27;user_geohash&#x27;] = data._stat_axis.values.tolist() # 行名称 14. pandas修改列名1df1.rename(columns=&#123;&#x27;c&#x27;:&#x27;D&#x27;&#125;,inplace=True) 15. pandas修改列顺序12order = [&#x27;date&#x27;, &#x27;time&#x27;, &#x27;open&#x27;, &#x27;high&#x27;, &#x27;low&#x27;, &#x27;close&#x27;, &#x27;volumefrom&#x27;, &#x27;volumeto&#x27;]df = df[order] 16. pandas获取指定列中某个值（范围）所属的行1df[df[&#x27;colName&#x27;].isin([left,right])] 17. pandas合并表123df.join()pd.conact()df.merge() 18. 三目运算符1a = b if b &gt; 10 else c 19. 查看列名1234~~~#### 20. 添加说明 plt.annotate(s&#x3D;’’,xy &#x3D; (6,30),xytext &#x3D; (8,32),arrowprops&#x3D;{‘arrowstyle’:’-&gt;’})","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Python端口占用测试（检测Socket）","slug":"E_学习笔记/Python/python应用实例/Python端口调试","date":"2022-12-27T03:12:54.033Z","updated":"2022-12-27T03:12:54.033Z","comments":true,"path":"posts/2498e501.html","link":"","permalink":"https://www.mingsrc.work/posts/2498e501","excerpt":"","text":"windows 端口相关动态端口查询123456netsh int ipv4 show dynamicport tcp协议 tcp 动态端口范围---------------------------------启动端口 : 49152端口数 : 16384 动态端口设置需要再管理员命令行下： 1netsh int ipv4 set dynamicport tcp start=49152 num=2000 Python实现的端口测试接口客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：client.py from ast import Tryimport socket # 导入 socket 模块import syssocketList = []host = socket.gethostname() # 获取本地主机名remoteHost = &#x27;192.168.3.171&#x27;remotePort = 6000 # 设置端口号errNum = 0ToTalNum = 0errPorts = &#123;&#125;print(&quot;请通过\\&#x27;netsh int ipv4 show dynamicport tcp\\&#x27;查看启动端口和端口数,一般情况下该值为49152&quot;)start = eval(input(&quot;启动端口:&quot;))end = eval(input(&quot;终止端口:&quot;))for i in range(start , end): ToTalNum += 1 s = socket.socket() # 创建 socket 对象 localHostAndPort = (host,i) try: s.bind(localHostAndPort) if s.connect((remoteHost, remotePort)) == socket.error: print(&#x27;FAILED&#x27;, i) print(s.recv(1024).decode(), i) socketList.append(s) except OSError as e: errNum += 1 errPorts[i] = (localHostAndPort, &quot;OSError:&quot;, e)print(&quot;Total Port Number(%r)&quot;%ToTalNum, &quot;Error Port Number(%r)&quot;%errNum)print(&quot;Error Ports:&quot;)for err in errPorts.keys(): print(err, errPorts[err])if len(errPorts) == 0: print(&quot;All Ports success (%d) ~&quot;%start, &quot;(%d)&quot;% end)print(&quot;输入\\&#x27;exit\\&#x27;关闭CLIENT:&quot;)char = input()while char != &quot;exit&quot;: # print(char) char = input()for skt in socketList: skt.close()# print(socketList) 服务端12345678910111213141516171819#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：server.py import socket # 导入 socket 模块 s = socket.socket() # 创建 socket 对象host = socket.gethostname() # 获取本地主机名port = 12345 # 设置端口s.bind((host, port)) # 绑定端口msg = &#x27;Success！&#x27; #strip默认取出字符串的头尾空格 s.listen(5) # 等待客户端连接while True: c,addr = s.accept() # 建立客户端连接 print(&#x27;连接地址：&#x27;, addr) c.send(msg.encode(&#x27;utf-8&#x27;)) c.close() # 关闭连接","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"学习笔记/python","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.mingsrc.work/tags/python/"},{"name":"Socket","slug":"Socket","permalink":"https://www.mingsrc.work/tags/Socket/"}]},{"title":"python 读取Json文件","slug":"E_学习笔记/Python/python应用实例/ReadJson","date":"2022-12-27T03:12:54.033Z","updated":"2022-12-27T03:12:54.033Z","comments":true,"path":"posts/c54b070b.html","link":"","permalink":"https://www.mingsrc.work/posts/c54b070b","excerpt":"","text":"解析Json的常见代码1import json # 导入json解析需要的包 1. json.loads()读取字符串到json objectjson.loads()是将str\\bytes\\bytearray等格式的文件读取到json object中。但是在使用的时候往往会因为一些小问题导致读取错误等。 1234567891011121314151617181920212223242526272829303132Docstring:Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instancecontaining a JSON document) to a Python object.``object_hook`` is an optional function that will be called with theresult of any object literal decode (a ``dict``). The return value of``object_hook`` will be used instead of the ``dict``. This featurecan be used to implement custom decoders (e.g. JSON-RPC class hinting).``object_pairs_hook`` is an optional function that will be called with theresult of any object literal decoded with an ordered list of pairs. Thereturn value of ``object_pairs_hook`` will be used instead of the ``dict``.This feature can be used to implement custom decoders. If ``object_hook``is also defined, the ``object_pairs_hook`` takes priority.``parse_float``, if specified, will be called with the stringof every JSON float to be decoded. By default this is equivalent tofloat(num_str). This can be used to use another datatype or parserfor JSON floats (e.g. decimal.Decimal).``parse_int``, if specified, will be called with the stringof every JSON int to be decoded. By default this is equivalent toint(num_str). This can be used to use another datatype or parserfor JSON integers (e.g. float).``parse_constant``, if specified, will be called with one of thefollowing strings: -Infinity, Infinity, NaN.This can be used to raise an exception if invalid JSON numbersare encountered.To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``kwarg; otherwise ``JSONDecoder`` is used. data.json文件链接 链接：https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA提取码：ysly复制这段内容后打开百度网盘手机App，操作更方便哦 上述文件相对常见的Json文件来说，还是有点区别的，用python的json库操作相对有点困难。 报错Expection \\，delimiter，看了好些解决办法仍然没能成功解决： 12345678910111213141516171819202122232425262728# 常见的Json读取JsonText = open(&#x27;data.json&#x27;,encoding=&#x27;utf-8&#x27;) # 打开data.jsonJson = JsonText.readlines() # 把json中的文件全部读取到Json对象中。# 读取上述data.json为json对象的代码list_data = list()def read_Json_file(i,x): # 返回有效的Json字段 print(&quot;第&quot; + i + &quot;行:&quot;) print(x) # 关于expectint的报错，我这处理就是但凡报错，直接返回空字段，如果你有别的解决办法，一定指教一下，不胜感激 try: JsonStr = x.replace(&quot;&#x27;&quot;, &#x27;&quot;&#x27;).replace(&#x27;/ &#x27;, &#x27;/&#x27;).replace(&#x27;, &#x27;,&#x27;,&#x27;) ret = json.loads(JsonStr,strict=False) except json.JSONDecodeError: return &#x27; &#x27; if(&#x27;categories&#x27; in ret): print(ret[&#x27;categories&#x27;]) return ret[&#x27;categories&#x27;] else: return &#x27; &#x27; list_data = list()for i in range(0,len(Json)): list_data.append(read_Json_file(str(i+1),Json[i])) 2. 常见错误及解决办法描述解决办法Json文件的单双引号不对，如下所示Python中的一个str，Json中的Key值都是用单引号&#39;括起来的，就会报错Expecting property name enclosed in double quotes： 1&quot;&#123;&#x27;asin&#x27;: &#x27;0000032069&#x27;, &#x27;title&#x27;: &#x27;Adult Ballet Tutu Cheetah Pink&#x27;, &#x27;price&#x27;: 7.89, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/51EzU6quNML._SX342_.jpg&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;0000032034&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00EXVN9PU&#x27;, &#x27;B0041EOTJO&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B001GTKPDQ&#x27;, &#x27;B00EON0SJ2&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002XZMGGQ&#x27;], &#x27;also_viewed&#x27;: [&#x27;B00D0F450I&#x27;, &#x27;0000032050&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;0000032042&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B0071KR2LC&#x27;, &#x27;B00GOR07RE&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B0079MCIMU&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00H3RYN3I&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B007IEFT84&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B007R2RM8W&#x27;, &#x27;B007VM3AMK&#x27;, &#x27;B00C0PLENA&#x27;, &#x27;B00BJGG6VG&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00IIK61WA&#x27;, &#x27;B009UC638W&#x27;, &#x27;B00KZN6RVI&#x27;, &#x27;B00CSFEENY&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00HSOJJ94&#x27;, &#x27;B00LIPP4VG&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B00E87F196&#x27;, &#x27;B005HMHOQY&#x27;, &#x27;B00J6S9MSS&#x27;, &#x27;0000032034&#x27;, &#x27;B00CJQGNJK&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B0056LG7GY&#x27;, &#x27;B00DPQWCZ2&#x27;, &#x27;B00I3PV0US&#x27;, &#x27;B00KZN6IVW&#x27;, &#x27;B0054TBWKO&#x27;, &#x27;B00I2S01I8&#x27;, &#x27;B00BXF12P8&#x27;, &#x27;B00GVHU678&#x27;, &#x27;B005NWENGC&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B00JK8MQ4Q&#x27;, &#x27;B00FZIMVQS&#x27;, &#x27;B008BB19VE&#x27;, &#x27;B00GTEXPOE&#x27;, &#x27;B009WPT2RQ&#x27;, &#x27;B00E37SBBG&#x27;], &#x27;bought_together&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;]&#125;, &#x27;brand&#x27;: &#x27;BubuBibi&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]]&#125;&quot;替换掉str中的&#39;为&quot;，替换/_（空格）为/: 1text.replace(&quot;&#x27;&quot;, &#x27;&quot;&#x27;).replace(&#x27;/ &#x27;, &#x27;/&#x27;) 再接着读取就不会报错了！！！ 1JsonValue[&#x27;categories&#x27;] 结果： 1[[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]] 描述问题解决这个问题真的被搞得头疼，到目前还没解决，Json字段是没有问题的，但是loads()函数就是会报错解决办法","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"学习笔记/python","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/python/"},{"name":"应用实例","slug":"学习笔记/python/应用实例","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/python/%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/"}],"tags":[{"name":"python应用实例","slug":"python应用实例","permalink":"https://www.mingsrc.work/tags/python%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/"}]},{"title":"根据地名获取经纬度","slug":"E_学习笔记/Python/python应用实例/根据地名获取经纬度","date":"2022-12-27T03:12:54.033Z","updated":"2022-12-27T03:12:54.034Z","comments":true,"path":"posts/2a450757.html","link":"","permalink":"https://www.mingsrc.work/posts/2a450757","excerpt":"","text":"本文是通过调用百度开放平台的API实现的经纬度查询。因此在使用前需要你去注册一个应用。 相关步骤 打开链接 百度地图开放平台 创建应用 获取AK 替换程序中的AK，运行就能得到返回的JSON字符串 源码12345import requestsimport timeimport reimport jsonimport pandas as pd 数据准备 CSV文件中有一列是city。 123df = pd.DataFrame()df = pd.read_csv(r&#x27;./city.csv&#x27;,encoding=&quot;gbk&quot;)df[&#x27;city&#x27;] 得到的数据如下所示，总共有一百条： 0 昆山市 1 江阴市 2 张家港市 3 晋江市 4 常熟市 ... 95 福安市 96 射阳县 97 邹平县 98 海城市 99 青州市 Name: city, Length: 100, dtype: object .dataframe tbody tr th:only-of-type { vertical-align: middle;} .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } user_geohash num city 0 94ek6ke 1028 昆山市 1 94ek6lj 980 江阴市 2 94ek6lw 919 张家港市 3 94ek6kn 908 晋江市 4 94ek6l5 517 常熟市 ... ... ... ... 95 9q0ltaw 243 福安市 96 99s4avh 242 射阳县 97 9519pwt 240 邹平县 98 94jrlp3 240 海城市 99 946hodd 240 青州市 100 rows × 3 columns 123showLocation&amp;&amp;showLocation(&#123;&quot;status&quot;:0,&quot;result&quot;:&#123;&quot;location&quot;:&#123;&quot;lng&quot;:120.98745249794995,&quot;lat&quot;:31.390863425081866&#125;,&quot;precise&quot;:0,&quot;confidence&quot;:20,&quot;comprehension&quot;:100,&quot;level&quot;:&quot;区县&quot;&#125;&#125;)showLocation&amp;&amp;showLocation(&#123;&quot;status&quot;:0,&quot;result&quot;:&#123;&quot;location&quot;:&#123;&quot;lng&quot;:120.29156800752115,&quot;lat&quot;:31.926044909769045&#125;,&quot;precise&quot;:0,&quot;confidence&quot;:20,&quot;comprehension&quot;:100,&quot;level&quot;:&quot;区县&quot;&#125;&#125;)showLocation&amp;&amp;showLocation(&#123;&quot;status&quot;:0,&quot;result&quot;:&#123;&quot;location&quot;: 因为使用的是API，因此得到是上述的Json字符串。 代码如下： 12345678910111213141516def calc_ll(x): Post_url = &quot;http://api.map.baidu.com/geocoding/v3/?address=&quot; + x + &quot;&amp;output=json&amp;ak=（百度API开放平台获取的AK）&amp;callback=showLocation&quot; #自己想办法弄到key Post_data = &#123; &#x27;address&#x27;: x &#125; Text = se.post(Post_url, data=Post_data).text.replace(&quot;&#x27;&quot;, &#x27;&quot;&#x27;).replace(&#x27;/ &#x27;, &#x27;/&#x27;)[27:-1] # 提取为Json格式，去掉‘showLocation&amp;&amp;showLocation()’这些额外的字符 jsonValue = json.loads(Text) # 转化为Json对象 # print(jsonValue) # 打印Json值 if(&#x27;result&#x27; in jsonValue): print(jsonValue[&#x27;result&#x27;][&#x27;location&#x27;][&#x27;lng&#x27;]) return [jsonValue[&#x27;result&#x27;][&#x27;location&#x27;][&#x27;lng&#x27;],jsonValue[&#x27;result&#x27;][&#x27;location&#x27;][&#x27;lat&#x27;]] else: return &#x27; &#x27; address = df[&#x27;city&#x27;].apply(calc_ll)se = requests.session() &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.98745249794995, &#39;lat&#39;: 31.390863425081864&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.98745249794995 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.29156800752115, &#39;lat&#39;: 31.926044909769043&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.29156800752115 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.56155363871446, &#39;lat&#39;: 31.88114053634028&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.56155363871446 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.55843052000408, &#39;lat&#39;: 24.787824575144548&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 118.55843052000408 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.75949588665195, &#39;lat&#39;: 31.65953827674108&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.75949588665195 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.27259613631863, &#39;lat&#39;: 30.175256610720446&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 121.27259613631863 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.83160603216115, &#39;lat&#39;: 31.342956624267874&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.83160603216115 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.08755916595523, &#39;lat&#39;: 28.251818487944462&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 113.08755916595523 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.08158099305928, &#39;lat&#39;: 29.31114987541007&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.08158099305928 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.13559529350024, &#39;lat&#39;: 31.464599352977785&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 121.13559529350024 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.64939823850789, &#39;lat&#39;: 28.169832216070507&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 113.64939823850789 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 110.50542966826288, &#39;lat&#39;: 38.848544495220935&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 110.50542966826288 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.18843649817478, &#39;lat&#39;: 31.87361172603022&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 121.18843649817478 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.80341550029883, &#39;lat&#39;: 25.03694981503913&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 118.80341550029883 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.25340833196779, &#39;lat&#39;: 29.714934649194955&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.25340833196779 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 106.4075265551776, &#39;lat&#39;: 27.797752158542853&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 106.4075265551776 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.39257197205464, &#39;lat&#39;: 24.966362350467605&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 118.39257197205464 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 112.55840691564445, &#39;lat&#39;: 28.284104536209348&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 112.55840691564445 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.57946558109177, &#39;lat&#39;: 32.37785148610902&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.57946558109177 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.9925018561657, &#39;lat&#39;: 28.118179995228274&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.9925018561657 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.39046524748903, &#39;lat&#39;: 25.72634329903456&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.39046524748903 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.16058507482123, &#39;lat&#39;: 30.042734639570824&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 121.16058507482123 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.66347374677267, &#39;lat&#39;: 31.81423284964318&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 121.66347374677267 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.03953537126692, &#39;lat&#39;: 36.27034908804922&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.03953537126692 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.47443309577918, &#39;lat&#39;: 32.53919574424043&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.47443309577918 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.61250060471407, &#39;lat&#39;: 32.01592027416992&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.61250060471407 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.39258889457587, &#39;lat&#39;: 28.377655489850408&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 121.39258889457587 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.05859939046078, &#39;lat&#39;: 32.17747402371212&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.05859939046078 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.48536852807433, &#39;lat&#39;: 37.65255512549617&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.48536852807433 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.19243791023843, &#39;lat&#39;: 32.33587288615511&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 121.19243791023843 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 115.95046017276752, &#39;lat&#39;: 28.551604186108275&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 115.95046017276752 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.68656506738283, &#39;lat&#39;: 30.51792376977565&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.68656506738283 &#123;&#39;status&#39;: 1, &#39;msg&#39;: &#39;Internal Service Error:无相关结果&#39;, &#39;results&#39;: []&#125; &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.66158218606775, &#39;lat&#39;: 27.783950736231652&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.66158218606775 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.28353203592053, &#39;lat&#39;: 31.988170075210594&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.28353203592053 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.57154315530762, &#39;lat&#39;: 30.63631118771037&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.57154315530762 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.0191233013022, &#39;lat&#39;: 34.34464551932591&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 118.0191233013022 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.70645736056483, &#39;lat&#39;: 40.00418392493125&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 118.70645736056483 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 104.03757322351338, &#39;lat&#39;: 30.648477494759213&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 75, &#39;comprehension&#39;: 0, &#39;level&#39;: &#39;购物&#39;&#125;&#125; 104.03757322351338 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.32653706475246, &#39;lat&#39;: 32.872716312488244&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.32653706475246 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 122.49250463073764, &#39;lat&#39;: 37.171317939253235&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 122.49250463073764 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.65451902647484, &#39;lat&#39;: 24.737665160882703&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 118.65451902647484 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.98563754334361, &#39;lat&#39;: 39.63274074738802&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 121.98563754334361 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.85751406137442, &#39;lat&#39;: 32.917824213889254&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.85751406137442 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.44960935856369, &#39;lat&#39;: 30.33358775114635&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;城市&#39;&#125;&#125; 113.44960935856369 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 111.24639840545701, &#39;lat&#39;: 39.87054026503683&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 111.24639840545701 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.46561561653884, &#39;lat&#39;: 32.787147020528316&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.46561561653884 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 112.9054740908161, &#39;lat&#39;: 30.40835793241892&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;城市&#39;&#125;&#125; 112.9054740908161 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.01440416129005, &#39;lat&#39;: 35.40752093244999&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 117.01440416129005 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.16455781372443, &#39;lat&#39;: 31.712962132716886&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 117.16455781372443 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.02843100495258, &#39;lat&#39;: 34.754096888696935&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 113.02843100495258 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 116.94258562390337, &#39;lat&#39;: 34.76515195541547&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 116.94258562390337 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.19146705795117, &#39;lat&#39;: 32.27809048316069&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.19146705795117 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.7974153748082, &#39;lat&#39;: 36.86192174647094&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 118.7974153748082 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.49522360557991, &#39;lat&#39;: 34.14826652246125&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 113.49522360557991 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.17256521920983, &#39;lat&#39;: 35.120034809573916&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 117.17256521920983 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.13848201812112, &#39;lat&#39;: 26.156035214577336&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.13848201812112 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 109.75459043995566, &#39;lat&#39;: 39.570092815192666&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 109.75459043995566 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.74643447195358, &#39;lat&#39;: 34.40176637910559&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 113.74643447195358 &#123;&#39;status&#39;: 1, &#39;msg&#39;: &#39;Internal Service Error:无相关结果&#39;, &#39;results&#39;: []&#125; &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 112.77847075950989, &#39;lat&#39;: 32.13472991431875&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 112.77847075950989 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 86.18149430993829, &#39;lat&#39;: 41.7323732214122&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 86.18149430993829 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.43643177294247, &#39;lat&#39;: 29.294317441105566&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 121.43643177294247 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.91749832197264, &#39;lat&#39;: 31.0325793268347&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.91749832197264 &#123;&#39;status&#39;: 1, &#39;msg&#39;: &#39;Internal Service Error:无相关结果&#39;, &#39;results&#39;: []&#125; &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 112.60858070620743, &#39;lat&#39;: 35.072907226846525&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;城市&#39;&#125;&#125; 112.60858070620743 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.36153652101795, &#39;lat&#39;: 34.37561095463685&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 118.36153652101795 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.9944142939757, &#39;lat&#39;: 36.78269225408944&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.9944142939757 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.39739094909922, &#39;lat&#39;: 34.54589798344474&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 113.39739094909922 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.44060165264568, &#39;lat&#39;: 37.36113714256612&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.44060165264568 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 111.456515837124, &#39;lat&#39;: 30.38440427431352&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 111.456515837124 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.94859307736998, &#39;lat&#39;: 37.18263660907421&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.94859307736998 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.17543320290359, &#39;lat&#39;: 31.950923490521372&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.17543320290359 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.4335951222883, &#39;lat&#39;: 27.523066788446513&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.4335951222883 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.2484219279141, &#39;lat&#39;: 29.295861065150863&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.2484219279141 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 114.21051607638233, &#39;lat&#39;: 36.70248828627979&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 114.21051607638233 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 122.97449548262718, &#39;lat&#39;: 39.686956078878055&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 122.97449548262718 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.41640221866636, &#39;lat&#39;: 36.00200885807568&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.41640221866636 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.77460624826666, &#39;lat&#39;: 35.9146198665876&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 117.77460624826666 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.26472938795023, &#39;lat&#39;: 23.0309091042802&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 25, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;乡镇&#39;&#125;&#125; 120.26472938795023 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 116.1724489811672, &#39;lat&#39;: 23.30363452186039&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 116.1724489811672 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 114.72642585137605, &#39;lat&#39;: 22.991443112002415&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 114.72642585137605 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 114.98643626401979, &#39;lat&#39;: 30.10166780010339&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 114.98643626401979 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 104.47858183931757, &#39;lat&#39;: 25.715651258076416&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 104.47858183931757 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.23851297084417, &#39;lat&#39;: 28.14186298682908&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 121.23851297084417 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 116.45556614759954, &#39;lat&#39;: 33.93480147585089&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 116.45556614759954 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 116.1056050954973, &#39;lat&#39;: 38.717348630774524&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 116.1056050954973 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.17356009256213, &#39;lat&#39;: 32.483722623763164&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 117.17356009256213 &#123;&#39;status&#39;: 1, &#39;msg&#39;: &#39;Internal Service Error:无相关结果&#39;, &#39;results&#39;: []&#125; &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.02257525525401, &#39;lat&#39;: 30.682240998057836&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 121.02257525525401 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.41349864392043, &#39;lat&#39;: 37.059638498906146&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 118.41349864392043 &#123;&#39;status&#39;: 1, &#39;msg&#39;: &#39;Internal Service Error:无相关结果&#39;, &#39;results&#39;: []&#125; &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.93251060584033, &#39;lat&#39;: 30.83712219382042&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.93251060584033 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 114.29657265142765, &#39;lat&#39;: 23.178805592432578&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 114.29657265142765 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 103.72553503682038, &#39;lat&#39;: 36.10975375497273&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 103.72553503682038 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.65440636047963, &#39;lat&#39;: 27.094323508059915&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 119.65440636047963 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.26444564891948, &#39;lat&#39;: 33.78101359213001&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 120.26444564891948 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.74947848721935, &#39;lat&#39;: 36.8700322166973&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 117.74947848721935 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 109.12452136754654, &#39;lat&#39;: 21.481065838235963&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 109.12452136754654 &#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.48653672086745, &#39;lat&#39;: 36.690416508705376&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125; 118.48653672086745 1address 0 [120.98745249794995, 31.390863425081864] 1 [120.29156800752115, 31.926044909769043] 2 [120.56155363871446, 31.88114053634028] 3 [118.55843052000408, 24.787824575144548] 4 [120.75949588665195, 31.65953827674108] ... 95 [119.65440636047963, 27.094323508059915] 96 [120.26444564891948, 33.78101359213001] 97 [117.74947848721935, 36.8700322166973] 98 [109.12452136754654, 21.481065838235963] 99 [118.48653672086745, 36.690416508705376] Name: city, Length: 100, dtype: object 1address 1 [120.29156800752115, 31.926044909769043] 2 [120.56155363871446, 31.88114053634028] 3 [118.55843052000408, 24.787824575144548] 4 [120.75949588665195, 31.65953827674108] 5 [121.27259613631863, 30.175256610720446] ... 94 [103.72553503682038, 36.10975375497273] 95 [119.65440636047963, 27.094323508059915] 96 [120.26444564891948, 33.78101359213001] 97 [117.74947848721935, 36.8700322166973] 98 [109.12452136754654, 21.481065838235963] Name: city, Length: 98, dtype: object 1df[&#x27;pos&#x27;] = df1 # 保存到df文件中 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } user_geohash num city pos 0 94ek6ke 1028 昆山市 [120.98745249794995, 31.390863425081864] 1 94ek6lj 980 江阴市 [120.29156800752115, 31.926044909769043] 2 94ek6lw 919 张家港市 [120.56155363871446, 31.88114053634028] 3 94ek6kn 908 晋江市 [118.55843052000408, 24.787824575144548] 4 94ek6l5 517 常熟市 [120.75949588665195, 31.65953827674108] ... ... ... ... ... 95 9q0ltaw 243 福安市 [119.65440636047963, 27.094323508059915] 96 99s4avh 242 射阳县 [120.26444564891948, 33.78101359213001] 97 9519pwt 240 邹平县 [117.74947848721935, 36.8700322166973] 98 94jrlp3 240 海城市 [109.12452136754654, 21.481065838235963] 99 946hodd 240 青州市 [118.48653672086745, 36.690416508705376] 100 rows × 4 columns 计算两者之间的距离在得到相关地名的经纬度之后，进一步就是根据经纬度，输入的是度数（°） 根据经纬度计算实际距离的代码： 123456789101112131415161718192021222324252627import mathEarth_Radius=6378.137def sin_square(a): result=math.sin(a) return result*resultdef rad(ang): return math.pi*ang/180.0#a,b参数是数组def distance_calculate(a,b): lata,lnga=a[0],a[1] latb,lngb=b[0],b[1] radlata,radlnga=rad(lata),rad(lnga) radlatb, radlngb = rad(latb), rad(lngb) #纬度差 minus_a=radlata-radlatb #经度差 minus_b=radlnga-radlngb return 2*math.asin( math.sqrt(sin_square(minus_a/2) + math.cos(radlata)*math.cos(radlatb)*sin_square(minus_b/2)))*Earth_Radius#坐标测试#googleprint(1000*distance_calculate((30.26848247,119.9499548338),(30.2688658749,119.9628533571)))#baiduprint(1000*distance_calculate((30.274671,119.969392),(30.274261,119.956631)))","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"学习笔记/python","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/python/"},{"name":"应用实例","slug":"学习笔记/python/应用实例","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/python/%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/"}],"tags":[{"name":"python应用实例","slug":"python应用实例","permalink":"https://www.mingsrc.work/tags/python%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/"}]},{"title":"Python基础语法一遍过","slug":"E_学习笔记/Python/Python一遍过","date":"2022-12-27T03:12:54.032Z","updated":"2022-12-27T03:12:54.032Z","comments":true,"path":"posts/c7968c37.html","link":"","permalink":"https://www.mingsrc.work/posts/c7968c37","excerpt":"","text":"Python基础语法如果有相应的coding基础，那这篇文章对你而言的意义仅限于python的一些常见语法等，并不能有效帮助你更好地学习Python；但是如果你是和我一样刚接触Python的话，那这篇文章值得你看一遍。 一些协助操作 操作 dir() 返回包含的方法以及操作以及人特殊属性 help() 帮助函数，返回类的参考手册 id() 获取当前变量地址 先从一个小游戏开始一个简单的猜数游戏 123456789101112131415import randomsecret = random.randint(1,100)temp = input(&#x27;输入一个数\\n&#x27;)guess = int(temp)while guess != secret: temp = input(&#x27;猜错了,重新猜\\n&#x27;) guess = int(temp) if guess == secret: print(&quot;猜中了&quot;) else: if guess &lt; secret: print(&#x27;猜小了&#x27;) else: print(&#x27;猜大了&#x27;)print(&#x27;游戏结束&#x27;) 1、数据类型Python中的数据类型有以下三种 str（字符串）、float（浮点型）、int（整型） 三种类型之间可以通过int(),float(),str()相互转换，但是有一定限制，比如某些时候就无法从str转float 如上所示，str类型转float失败，但是某些情况下又是正常的，如果letter是数字的话，是可以进行类型转换的。如下所示： 具体用法如下： 1234567891011121314151617181920212223firstStr = &#x27;你好&#x27;secondStr = &#x27;我是小明同学&#x27;thirdStr = firstStr + secondStrprint(thirdStr) # 输出‘你好我是小明同学’print(1500000000)# 浮点型print(1.5e9) # 输出1500000000.0# bool 类型print(True + True)# 三种类型的转换 ## str() 转换为字符串 ## int() 转换为整型 ## float() 转换为浮点型 ## 可以使用 type() 获取参数类型 ## 使用isinstance() 函数判断两个变量类型是否一致a = str(&#x27;你好&#x27;)b = int (1314)c = float(520)print(&#x27;判断a、b、c三者是否属于str字符变量&#x27;)print(isinstance(a,str)) # 输出Trueprint(isinstance(b,str)) # 输出Falseprint(isinstance(c,str)) # 输出False 2、操作符python中的操作符与C++有一丝区别 算术操作符：除了+-*/，多了一个**(乘方) //(浮点除法(四舍五入)) 比较操作符：python的标准比较操作符有：&lt; &lt;&#x3D; &gt; &gt;&#x3D; &#x3D;&#x3D; !&#x3D; &lt;&gt;，根据表达式的真假，返回True&#x2F;False布尔值数据类型 逻辑操作符：and、or、not是python提供的逻辑操作符，其作用是把表达式连接在一起，得到一个布尔值， 12345678910111213141516171819202122232425262728# python 中的操作符 + - * / % **(幂运算) //(浮点除法(四舍五入))# //整除a = 8 // 3 # a=2print (a)b = 8 / 3 # b=2.66666666665print (b)c = 2 ** 4print(c)# ** 幂运算符# 逻辑操作符# and or notwrong = not Trueprint(wrong)# 三元操作符a,b = 4,5max = a if a &gt; b else bprint(&#x27;max number是a&#x27;) if a &gt; b else print(&#x27;max number是b,值为&#x27;,b)a = int(input(&quot;Input a: &quot;))b = int(input(&quot;Input b: &quot;))print(&quot;a大于b&quot;) if a &gt; b else (print(&quot;a小于b&quot;) if a &lt; b else print(&quot;a等于b&quot;))# 逻辑运算符True and True # TrueTrue and False # FalseTrue or False # Truenot False and True # True 一道小的逻辑运算编写如下所示为简单的成绩判断代码。后边标注了悬挂else，python是根据缩进判断if-else的匹配，所以可以有效的避免else的悬挂问题。 1234567891011121314151617181920212223242526score = input(&#x27;请输入你的成绩:\\n&#x27;)temp = int(score)if temp &gt;= 90: print(&quot;A&quot;)elif 80 &lt;= temp &lt; 90: print(&#x27;B&#x27;)elif 70 &lt;= temp &lt; 80: print(&#x27;C&#x27;)elif temp &lt; 70: print(&#x27;D&#x27;)else: print(&#x27;输入错误\\n&#x27;)# 悬挂elsetemp = input(&#x27;请输入成绩\\n&#x27;);temp = int(temp)if (temp &gt; 80): print(&#x27;成绩在80以上\\n&#x27;) if(temp &gt; 90): print(&#x27;成绩优异&#x27;) else: print(&#x27;成绩良好，确认完毕&#x27;)else: print(&quot;因为temp(&quot;,temp,&quot;)小于80，所以这里就是所谓的悬挂else，&quot; &quot;相匹配的是上边temp&gt;90所对应的if,但是python可以避免，&quot; &quot;所以这里的else对应的是temp&gt;80所对应的if&quot;) 什么是悬挂else？悬挂else是面试中最常见的一个问题，就是C\\C++中的else与离他最近的if匹配如下所示： 1234567int i = 0;cin &gt;&gt; i;if(i &gt; 50) if(i&gt;55) cout &lt;&lt; &quot;稍微有点重&quot;; else cout &lt;&lt; &quot;这个我喜欢&quot;; 3、列表12345678910111213141516171819202122232425262728293031323334353637# 创建一个普通列表member = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;]print(&#x27;打印member列表：\\n&#x27;,member)# 创建一个混合列表mix = [1,&#x27;二&#x27;,3.14,[1,2,3]]print(&#x27;打印mix列表：&#x27;)print(&#x27;位置&#x27;, &#x27;|&#x27;, &#x27;元素&#x27;)i = 0for each in mix: i = i + 1; print(i,&#x27;|&#x27;,each)# 创建一个空列表empty = []print(&#x27;打印empty列表&#x27;,empty)print(&quot;对member列表进行操作&quot;)# 向列表末尾添加元素 append()方法print(&quot;使用append()方法插入新元素‘F’&quot;)member.append(&#x27;F&#x27;)print(member[5]) # 输出 Fprint(&#x27;member的长度为：&#x27;,len(member))# extend()方法# - 使用一个列表扩充另一个列表print(&#x27;使用extend()方法插入新元素‘G’‘H’&#x27;)member.extend([&#x27;G&#x27;,&#x27;H&#x27;])print(&#x27;member&#x27;,member,&#x27;的长度为：&#x27;,len(member))# 向列表中循环插入小写字母元素i,j = 1,0letter = &quot;abcdefgh&quot;while i &lt; (len(member)+1): member.insert(i,letter[j]) i += 2 j +=1print(&#x27;插入小写字母后的member列表：\\n&#x27;,member) 输出如下： 打印member列表： ['A', 'B', 'C', 'D', 'E'] 打印mix列表： 位置 | 元素 1 | 1 2 | 二 3 | 3.14 4 | [1, 2, 3] 打印empty列表 [] 对member列表进行操作 使用append()方法插入新元素‘F’ F member ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 的长度为： 8 插入小写字母后的member列表 ['A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f', 'G', 'g', 'H', 'h'] 操作符在列表中的应用列表常见的一下操作符运算 1234567891011121314151617181920212223242526272829# 比较运算符numlist1 = [123]numlist2 =[456]numlist1 &lt; numlist2 # Truenumlist3 = [&#x27;123&#x27;,&#x27;456&#x27;]numlist4 = [&#x27;456&#x27;,&#x27;123&#x27;]numlist3 == numlist4 # Falsenumlist3 &lt; numlist4 # Truenumlist5 = [&#x27;123&#x27;,&#x27;456&#x27;]numlist3 == numlist5 # Truelist1 = [123]list2 = [234]list1.extend(list2)# 算术运算符list1 # [123, 234]list1*3 # [123, 234, 123, 234, 123, 234]list1*=3list1 # [123, 234,123, 234,123, 234]# 逻辑运算符111 not in list1 # True123 in list1 # True#混合列表的操作符运算mixlist = [&#x27;小明同学&#x27;,[&#x27;小红&#x27;,&#x27;李华&#x27;],456]&#x27;小明同学&#x27; in mixlist # True&#x27;小红&#x27; in mixlist # Falsemixlist[1][1] # &#x27;李华&#x27; 列表中常见的一些逻辑操作符使用dir(list)可以查看list的方法和内置函数： &#39;append&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;, &#39;remove&#39;, &#39;reverse&#39;, &#39;sort&#39; 方法名 操作 append 在末尾添加元素 clear 清除列表 copy 复制 count 统计元素 extend 添加 index 返回相应元素的下标 insert 插入元素 pop 删除并返回最后一个元素 remove 移除操作 reverse 翻转列表 sort 排序（递增）可以使用list1.sort(reverse=True)进行降序排列 True可以改为1 12345678910111213#countlist1.count(123) # 3 统计列表中123的个数#indexlist1.index(123) # 0返回列表中第一个123的下标list1.index(123,3,7) # 4 从第3位开始返回第一个123的下标#sortlist3 = [23,34,654,876,123,1]list3.sort()list3 #[1, 23, 34, 123, 654, 876]list3.sort(reverse=True)list3 # [876, 654, 123, 34, 23, 1] 列表中的深拷贝与浅拷贝可以看到等号进行的浅拷贝，相当于有一个指针指向了list3，而list5则是单独开辟了一块空间进行存储 123456list5 = list3[:] #使用切片拷贝属于深拷贝list6 = list3 # 等号操作符执行的是浅拷贝list3.sort()list3 # [1, 23, 34, 123, 654, 876]list5 # [876, 654, 123, 34, 23, 1]list6 # [1, 23, 34, 123, 654, 876] 附带操作1234list3 = [23,34,654,876,123,1]max(list3) # 876min(list3) # 1sum(list3) # 1711 4、元组和列表123456789101112131415161718#元组 tuple# 创建一个元组tuple1tuple1 = 1,2,4,5,6print(tuple1)# 列表# 创建一个列表list1 = [1,2,4,5,6]print(list1)# 列表和元组插入元素（拼接）list1 = list1[:2] + [3] + list1[2:] #列表中使用切片插入元素时需要用[]print(&#x27;插入元素之后的列表和元组\\n&#x27;,list1)tuple1 = tuple1[:2] + (3,) + tuple1[2:] # 3所在位置的逗号与括号缺一不可print(tuple1)# 删除操作temp = tuple1[:]del temp # 释放掉temptuple2 = 2*tuple1 #tuple2 = (1, 2, 3, 4, 5, 1, 2, 3, 4, 5) (1, 2, 4, 5, 6) [1, 2, 4, 5, 6] 插入元素之后的列表和元组 [1, 2, 3, 4, 5, 6] (1, 2, 3, 4, 5, 6) 元组的操作符使用和列表一致。 5、字符串str字符串的一些方法： 方法名 用法 capitalize() 大写单词首字母 casefold() 小写所有字母 center() 居中字符串 count(sub[,start,end]) # [] 表示可选 统计start到end区间的sub字符串个数 encode(encoding &#x3D; ‘utf-8’,errors&#x3D;’strict’) 编码设置 espandtabs([tabsize&#x3D;8]) 把字符串中的\\t 都替换成空格，可设置替换的空格数量 endswith(sub[,start,end]) 判断是否以sub字符串结尾 find(sub[,start,end]) 检测sub是否包含在字符串中，如果有则返回索引值，否则返回-1.start和end参数表示范围，可选 index(sub[,start,end]) 和find基本一致，但是如果sub不在string0中则会产生一个异常 isalnum() 如果字符串中至少有一个字母并且全都是字母或数字则返回True，否则返回False isalpha() 如果字符串中至少有一个字母并且全都是字母则返回True，否则返回False isdigit() 如果字符串中只包含数字则返回True，否则返回False islower() 如果字符串可以区分大小写，并且都是小写，则返回Ttrue，否则返回False isnumeric() 如果字符中是包含数字，则返回True，否则False isspace() 如果字符只包含空格，则返回True，否则False istitle() 所有单词开头字母是大写就返回True,否则返回False isupper() 如果字符串可以区分大小写，并且都是大写，则返回Ttrue，否则返回False join(sub) 以字符串为分隔符插入到sub中所以的字符之间 ljust() 左对齐 strip() 去掉前后的空格，对应的还有lstrip()、rstrip(),分别是去掉左边和右边的空格 partition(sub) 以sub字符串为分界符，把字符串划分为一个三元组，默认返回一个元组；如果字符串中不包含sub，则返回(&#39;原字符串&#39;,&#39;&#39;,&#39;&#39;) replace(old,new[,count]) 替换字符串，如果指定count，则只替换指定次数 split(sep&#x3D;None,maxsplit&#x3D;-1) 不带参数默认是以空格为分解符切片字符串，如果maxsplit参数有设置，则仅分割maxsplit个子字符串，返回切片后的字符串列表 startswith(sub[,start,end]) title() translate() 根据table的规则（可以由str.maketrans(&#39;a&#39;,&#39;d&#39;)定制）转换字符串中的字符 upper() 将所有字母都大写 zfill(lenght) 返回指定长度的字符串，如果原字符串不够，则前边用0代替 代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960name = &quot; ada lovelace &quot;name&#x27; ada lovelace &#x27;name[:4]&#x27; ada&#x27;# stripname.rstrip() # 输出“ ada lovelace”name.lstrip() # 输出“ada lovelace ”name.strip() # 输出“ada lovelace”# capitalizename.strip().capitalize() #string 是去掉开头和结尾的空格&#x27;Ada lovelace&#x27;# casefolad 小写所有字母NAME = &#x27;ADA LOVELACE&#x27;NAME.casefold()&#x27;ada lovelace&#x27;# centername.center(40)&#x27; ada lovelace &#x27;# countname.count(&#x27;a&#x27;)3# endswithname.endswith(&#x27;&#x27;)Truename.endswith(&#x27;lace&#x27;)False# find 找到返回索引，否则返回-1name.find(&#x27;ada&#x27;)1name.find(&#x27;cda&#x27;)-1# joinname.join(&#x27;||||||&#x27;)&#x27;| ada lovelace | ada lovelace | ada lovelace | ada lovelace | ada lovelace |&#x27;# partitionlistName = name.partition(&#x27;love&#x27;)listName(&#x27; ada &#x27;, &#x27;love&#x27;, &#x27;lace &#x27;)type(listName)&lt;class &#x27;tuple&#x27;&gt;# replacename.replace(&#x27;ada&#x27;,&#x27;dad&#x27;)&#x27; dad lovelace &#x27;# splitname.split()[&#x27;ada&#x27;, &#x27;lovelace&#x27;]#translatename.translate(str.maketrans(&#x27;a&#x27;,&#x27;b&#x27;))&#x27; bdb lovelbce &#x27;# titlename.title()&#x27; Ada Lovelace &#x27;# uppername.upper()&#x27; ADA LOVELACE &#x27;# zfillname.zfill(40)&#x27;00000000000000000000000000 ada lovelace &#x27; 字符串格式化format()的用法： 1234567891011# 第一种方式，使用数字&quot;&#123;0&#125;,&#123;1&#125;&#123;2&#125;&quot;.format(&quot; ada&quot;,&quot; love&quot;,&quot;lace &quot;)&#x27; ada, lovelace &#x27;# 第二种方式，使用变量&quot;&#123;a&#125;&#123;b&#125;&#123;c&#125;&quot;.format(a=&quot; ada &quot;,b=&quot;love&quot;,c=&quot;lace &quot;)&#x27; ada lovelace &#x27;&quot;&#123;&#123;0&#125;&#125;&quot;.format(&quot;不打印&quot;)&#x27;&#123;0&#125;&#x27;# 控制浮点型变量的输出格式&#x27;&#123;0:.1f&#125;&#123;1&#125;&#x27;.format(3.1415,&#x27;GB&#x27;)&#x27;3.1GB&#x27; 字符串格式化符号含义 符号 说明 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %o 格式化无符号八进制数（octonary，OCT） %x 格式化无符号十六进制数 %f 格式化无符号十六进制数（大写） %e 格式化定点数，可指定小数点后的精度 %E 用作科学技术法格式化定点数 %g 根据值的大小决定%f或%e %G 作用同%g，根据值的大小决定使用%f或者%e 123456789101112131415# %的一些用法#---------------letter = &#x27;%c %c %c&#x27; % (97,98,99)letter&#x27;a b c&#x27;#---------------name = &#x27;%s&#x27; % &#x27;ada lovelace&#x27;name&#x27;ada lovelace&#x27;#---------------&#x27;%f&#x27; % 3.1415&#x27;3.141500&#x27;#---------------&#x27;%#x&#x27; % 18&#x27;0x12&#x27; 格式化操作辅助命令 符号 说明 m.n m是显示的最小总宽度，n是小数点后的位数 - 用于左对齐 + 在正数前面显示加号（+） # 在八进制数前面显示零(‘0’)，在十六进制数前面显示’0x’或者’0x’ 0 显示的数字前面填充’0’取代空格 12345678910#---------------&#x27;%+1.2f&#x27; % 3.1415&#x27;+3.14&#x27;&#x27;%-10.2f&#x27; % 3.1415&#x27;3.14 &#x27;#---------------&#x27;%#x&#x27; % 18&#x27;0x12&#x27;&#x27;%#X&#x27; % 18&#x27;0X12&#x27; 字符串转义字符含义 符号 说明 \\‘ 单引号 \\“ 双引号 \\a 发出系统响铃声 \\b 退格符 \\n 换行符 \\t 横向制表符 \\v 纵向制表符 \\r 回车符 \\f 换页符 \\o 八进制数代表的字符 \\x 十六进制数代表的字符 \\0 表示一个字符 \\\\ 反斜杠 列表、元组、字符串小结列表、元组和字符串的共同点： 都可以通过索引得到每一个元素 默认索引值总是从0开始 可以通过分片的方法得到一个范围内的元素的集合 有很多共同的操作符（无重复操作符、拼接操作符、成员关系操作符） 6、序列1234567891011121314151617181920212223242526# list方法name = &quot;ada lovelace&quot;name = list(name) # 把name转换为列表 同样适用于tuple()print(name)print(min(name)) # 输出列表中的最小值&#x27; &#x27; name最小值为空格print(max(name)) # 输出列表中的最大值&#x27;v&#x27; name最大值为&#x27;v&#x27;tupleNum = (1,2,3,4,5,6)print(max(tupleNum))tupleNum = (1,2,3,4,5,6,&#x27;A&#x27;)#print(max(tupleNum)) # 在添加了A元素之后再进行比较就会出错 # &#x27;&gt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27;tupleNum2 = (2,3,1,5,4)print(&#x27;tupleNum2:&#x27;,tupleNum2)print(&#x27;sun(tupleNum2):&#x27;,sum(tupleNum2))print(&#x27;sorted()排序之后：&#x27;,sorted(tupleNum2))#reverse()反转链表print(&#x27;reversed()函数调用：&#x27;,reversed(tupleNum2))print(&#x27;list(reversed(tumpleNum2))):&#x27;,list(reversed(tupleNum2)))#enumerate() 枚举enumerate(tupleNum2)print(&#x27;list(enumerate(tupleNum2))：&#x27;,list(enumerate(tupleNum2)))#zip() 按最短列表的下标一一对应组合print(&#x27;tupleNum和tupleNum2：&#x27;,tupleNum,tupleNum2)print(&#x27;list(zip(tupleNum,tupleNum2))：&#x27;,list(zip(tupleNum,tupleNum2))) 上述运行结果： ['a', 'd', 'a', ' ', 'l', 'o', 'v', 'e', 'l', 'a', 'c', 'e'] v 6 tupleNum2: (2, 3, 1, 5, 4) sun(tupleNum2): 15 sorted()排序之后： [1, 2, 3, 4, 5] reversed()函数调用： list(reversed(tumpleNum2))): [4, 5, 1, 3, 2] list(enumerate(tupleNum2))： [(0, 2), (1, 3), (2, 1), (3, 5), (4, 4)] tupleNum和tupleNum2： (1, 2, 3, 4, 5, 6, 'A') (2, 3, 1, 5, 4) list(zip(tupleNum,tupleNum2))： [(1, 2), (2, 3), (3, 1), (4, 5), (5, 4)] 7、函数使用def创建函数 12345678910111213141516171819202122232425262728# 无参函数def MyFirstFunction(): print(&quot;调用了MyFirstFunction()函数&quot;) print(&quot;函数创建格式是 \\&#x27;def 函数名():\\&#x27;&quot;)MyFirstFunction()# 带参数的函数，参数个数不限量def PrintName(name): print(&#x27;我的名字是：&#x27;,name)PrintName(&#x27;mingming&#x27;)# example加和函数def add(num1,num2): return(num1+num2)sum = add(5,10)print(sum)# 定义带默认参数的函数def printName(name = &#x27;ada lovelace&#x27;): print(name)print()# 收集参数 在参数前面加上*def collaction(*parameters): print(&#x27;参数的长度是：&#x27;,len(parameters)) print(&quot;第二个参数是：&quot;,parameters[1])collaction(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) 上述代码运行结果： 调用了MyFirstFunction()函数 函数创建格式是 'def 函数名():' 我的名字是： mingming 15 ada lovelace 参数的长度是： 3 第二个参数是： b 函数返回值在python中函数会自动为没有返回值的函数返回None 123# 使用列表作为返回值def letterList(): return [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;] 输出[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] 函数变量的作用域1234567891011121314def discount(price,rate): # 在这里可以对old_price和rate全局变量进行修改，但是是局部变量的old_price和rate，存储位置不同 # 函数修改全局变量可以在函数开头用global+变量名 # global old_price # 取消注释old_price作为全局变量被修改 final_price = price * rate old_price = 1000 return final_priceold_price = float(input(&#x27;请输入原价：&#x27;))rate = float(input(&#x27;请输入折扣：&#x27;))print(&#x27;打折后的价格是：&#x27;)print(discount(old_price,rate))# 全局变量 old_price在执行完discount()函数之后不能被修改pritn(old_price) # 打印100 程序输入： 100 0.8 程序输出： 这里是对全局变量修改后的值 50.0 80.0 old_price修改后的值： 50.0 函数嵌套1234567891011121314# 函数嵌套def fun1(): print(&#x27;fun1函数正在被调用&#x27;) def fun2(): print(&#x27;fun2函数正在被调用&#x27;) fun2()fun1()# 闭包def FunX(x): def FunY(y): return x*y return FunYFunx(2)(5) 在闭包中：外层的局部变量对内层而言也是不可以使用的，可以通过容器实现值传递。如下所示： 12345678910111213141516171819202122# 下列情况会报错 使用未定义变量def fun1(): x = 5 def fun2(): x *= x return x return fun2()#如果fun2()想要使用fun1()的变量，可以通过容器实现def fun1(): x = [5] def fun2(): x[0] *= x[0] return x[0] return fun2()# python3之后可以使用nonlocal+变量名使用def fun1(): x = 5 def fun2(): nonlocal x x *= x return xreturn fun2() 8、lambda表达式使用lambda表达式创建匿名函数，使用lambda表达式有以下优势： Python写一些执行脚本时，使用lambda就可以省下定义函数的过程，可以使代码更加简洁 对于一些比较抽象，调用次数较少的函数可以使用lambda表达式 简化代码的可读性 1234g = lambda x : 2 * x + 1g(5) # 输出5h = lambda x,y : x * yh(3,4) # 返回12 筛选器filter使用filter筛选器对字段进行筛选 12345678910temp = range(1,10)def odd(x): return x % 2;show = filter(odd,temp)print(list(show))# 使用lambda函数设置过滤条件list(filter(lambda x : x % 2,range(10))) # 打印[1, 3, 5, 7, 9] 相比于上边的代码，这种方式简单明了# 同样的使用方式还有：list(map(lambda x : x **2 ,range(10)))[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 9、递归实例一：阶乘123456789101112131415# 定义阶乘函数def factorial(n): result = n for i in range(1,n): result *= i return result# 递归实现阶乘函数def recurisionFac(n): if n != 1: return n * recurisionFac(n-1) else: return 1# 调用阶乘函数num = int(input(&#x27;请输入一个正整数：&#x27;))print(&#x27;%d的阶乘是%d&#x27;%(num,recurisionFac(num))) 实例二：斐波那契数列12345678910111213141516171819# 递归实现def fibonaq(n): if n == 1 or n == 2: return 1 else: return fibonaq(n-1)+fibonaq(n-2)print(fibonaq(10))# 迭代实现def fab(n): n1 = 1 n2 = 1 n3 = 2 while n &gt; 2: n3 = n2 + n1 n1 = n2 n2 = n3 n -= 1 return n3 实例三、汉诺塔12345678910# 四个参数可以理解为：(圆盘数量，起始位置，闲置位置，终点位置)def hanoi(n,x,y,z): if n == 1: print(x,&#x27;---&gt;&#x27;,z) else: hanoi(n-1,x,z,y) # 将前n-1个盘子从x移动到y上 print(x,&#x27;----&gt;&#x27;,z) # 将最底下的最后一个盘子从x移动到z上 hanoi(n-1,y,x,z) # 将y上的n-1个盘子移动到z上n = int(input(&#x27;请输入汉诺塔的层数：&#x27;))hanoi(n,&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;Z&#x27;) 10、字典{}1234567891011121314151617181920212223242526272829303132brand = [&#x27;李宁&#x27;,&#x27;安踏&#x27;,&#x27;耐克&#x27;,&#x27;阿迪&#x27;]slogn = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;]print(&#x27;阿迪对应的的letter是：&#x27;,slogn[brand.index(&#x27;阿迪&#x27;)])# 创建key-value键值对 dictionarydict1 = &#123;&#x27;李宁&#x27;:&#x27;A&#x27;,&#x27;安踏&#x27;:&#x27;B&#x27;,&#x27;耐克&#x27;:&#x27;C&#x27;,&#x27;阿迪&#x27;:&#x27;D&#x27;&#125;print(&#x27;阿迪对应的letter是（2）：&#x27;,dict1[&#x27;阿迪&#x27;])dict3 = dict(((&#x27;F&#x27;,70),(&#x27;B&#x27;,15),(&#x27;C&#x27;,90),(&#x27;S&#x27;,123)))print(dict3)dictEmp = &#123;&#125;dictEmp.fromkeys((1,2,3))dictEmp = dictEmp.fromkeys(range(32),&#x27;赞&#x27;)# 改写键的值dictEmp[4] = &#x27;不赞&#x27;# copy() 浅拷贝dictcopy = dictEmp.copy()print(&#x27;打印拷贝字典：&#x27;,dictcopy)# setdefaultdictEmp.setdefault(&#x27;最后位置&#x27;)dictEmp.setdefault(32,&#x27;第32个位置&#x27;)print(dictEmp)# 弹出索引位置的valueprint(dictEmp.pop(4))# 随机弹出print(dictEmp.popitem())# 清空字典dictEmp.clear()print(dictEmp) 11、文件open()函数原型Open file and return a stream. Raise OSError upon failure. open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) mode的参数： 打开方式 执行操作 r 以只读方式打开文件（默认） w 以写入的当时打开文件 x 会覆盖已存在的文件 a 如果文件已经存在，使用此模式打开将引发异常 b 以写入模式打开，如果文件存在，则在末尾追加写入 t 以文本模式打开 + 可读写模式（可添加到其他模式中使用） U 通用换行符支持 code: 1234Datafile = open(&#x27;D:\\\\Groceries.csv&#x27;) #双反斜杠表是转义字符Datafile # 查看返回的对象Datafile.close()# &lt;_io.TextIOWrapper name=&#x27;D:\\\\Groceries.csv&#x27; mode=&#x27;r&#x27; encoding=&#x27;cp936&#x27;&gt; 文件对象方法 文件对象方法 执行操作 f.close() 关闭文件 f.read(size&#x3D;-1) 从文件读取size个字符，当未给定size或给定负值是，读取剩余的所有字符，然后作为字符串返回 f.readline() 以写入模式打开，如果文件存在，则在末尾追加写入 f.write(str) 将字符串str写入文件 f.writelines(seq) 向文件写入字符串序列seq，seq应该是一个返回字符串的可迭代对象 f.seek(offset,from) 在文件中移动文件指针，从from（0代表起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节 f.tell() 返回当前在文件中的位置 12、集合set在我的世界里，你就是唯一，set()集合中只允许同值数据出现一次。:rescue_worker_helmet: 1234for i in range(0,5): temp.append(i)temp.append(1) # 此时tmep中有两个1 temp = [0,1,2,3,4,1]temp2 = list(set(temp)) temp2 = [0,1,2,3,4] 小甲鱼29：一个任务的代码 123456789101112131415161718192021222324252627282930313233343536f = open(&#x27;record.txt&#x27;)boy = []girl = []for each_line in f: if each_line[:6] != &#x27;=======&#x27;: (role,line_spoken) = each.split(&#x27;:&#x27;,1) if role == &#x27;小甲鱼&#x27;: boy.append(line_spoken) if role == &#x27;小客服&#x27;: girl.append(line_spoken) else: file_name_boy = &#x27;boy_&#x27; + str(count) + &#x27;.txt&#x27; file_name_boy = &#x27;girl_&#x27; + str(count) + &#x27;.txt&#x27; boy_file = open(file_name_boy,&#x27;w&#x27;) girl_file = open(file_name_girl,&#x27;w&#x27;) boy_file.writelines(boy) girl_file.writelines(girl) boy = [] girl = [] count += 1 file_name_boy = &#x27;boy_&#x27; + str(count) + &#x27;.txt&#x27;file_name_boy = &#x27;girl_&#x27; + str(count) + &#x27;.txt&#x27; boy_file = open(file_name_boy,&#x27;w&#x27;)girl_file = open(file_name_girl,&#x27;w&#x27;) boy_file.writelines(boy)girl_file.writelines(girl) #用完记得关闭文件 boy_file.close() girl_file.close() 以上代码冗长繁琐，不够简洁，因此可以对关键部分进行封装： 123456789101112131415161718192021222324252627282930def save_file(boy,girl,count): file_name_boy = &#x27;boy_&#x27; + str(count) + &#x27;.txt&#x27; file_name_boy = &#x27;girl_&#x27; + str(count) + &#x27;.txt&#x27; boy_file = open(file_name_boy,&#x27;w&#x27;) girl_file = open(file_name_girl,&#x27;w&#x27;) boy_file.writelines(boy) girl_file.writelines(girl) boy_file.close() girl_file.close()def split_file(file_name): f = open(file_name) boy = [] girl = [] for each_line in f: if each_line[:6] != &#x27;=======&#x27;: (role,line_spoken) = each.split(&#x27;:&#x27;,1) if role == &#x27;小甲鱼&#x27;: boy.append(line_spoken) if role == &#x27;小客服&#x27;: girl.append(line_spoken) else: save_file(boy,girl.count) boy = [] girl = [] count += 1 split_file(&#x27;record.txt&#x27;) 13、模块os模块os模块中关于文件/目录常用的函数使用方法 函数名 使用方法 getcwd() 返回当前工作目录 chdir(path) 改变工作目录 listdir(path&#x3D;’.’) 列举指定目录中的文件名（’.’表示当前目录，’..’表示上一级目录） mkdir(path) 创建单层目录，如该目录已存在抛出异常 makedirs(path) 递归创建多层目录，如该目录已存在抛出异常，注意：’E:\\a\\b’和’E:\\a\\c’并不会冲突 remove(path) 删除文件 rmdir(path) 删除单层目录，如该目录非空则抛出异常 removedirs(path) 递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常 rename(old, new) 将文件old重命名为new system(command) 运行系统的shell命令 walk(top) 遍历top路径以下所有的子目录，返回一个三元组：(路径, [包含目录], [包含文件])【具体实现方案请看：第30讲课后作业^_^】 以下是支持路径操作中常用到的一些定义，支持所有平台 os.curdir 指代当前目录（’.’） os.pardir 指代上一级目录（’..’） os.sep 输出操作系统特定的路径分隔符（Win下为’\\‘，Linux下为’&#x2F;‘） os.linesep 当前平台使用的行终止符（Win下为’\\r\\n’，Linux下为’\\n’） os.name 指代当前使用的操作系统（包括：’posix’, ‘nt’, ‘mac’, ‘os2’, ‘ce’, ‘java’） os.path模块中关于路径常用的函数使用方法 函数名 使用方法 basename(path) 去掉目录路径，单独返回文件名 dirname(path) 去掉文件名，单独返回目录路径 join(path1[, path2[, …]]) 将path1, path2各部分组合成一个路径名 split(path) 分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在 splitext(path) 分离文件名与扩展名，返回(f_name, f_extension)元组 getsize(file) 返回指定文件的尺寸，单位是字节 getatime(file) 返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getctime(file) 返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） getmtime(file) 返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算） 以下为函数返回 True 或 False exists(path) 判断指定路径（目录或文件）是否存在 isabs(path) 判断指定路径是否为绝对路径 isdir(path) 判断指定路径是否存在且是一个目录 isfile(path) 判断指定路径是否存在且是一个文件 islink(path) 判断指定路径是否存在且是一个符号链接 ismount(path) 判断指定路径是否存在且是一个挂载点 samefile(path1, paht2) 判断path1和path2两个路径是否指向同一个文件 1234567os.mkdir(&#x27;E:\\\\A&#x27;) #会在盘创建一个A文件夹os.getcwd().split()[&#x27;C:\\\\Users\\\\明明\\\\PycharmProjects\\\\StudyFirstDay&#x27;]os.getcwd().split(&#x27;\\\\&#x27;)[&#x27;C:&#x27;, &#x27;Users&#x27;, &#x27;明明&#x27;, &#x27;PycharmProjects&#x27;, &#x27;StudyFirstDay&#x27;]os.getcwd().split(&#x27;\\\\&#x27;)[2]&#x27;明明&#x27; pickle模块下面代码上和通过pkl文件把my_list列表读取到my_list2 1234567my_list = [123,3.14,&#x27;小甲鱼&#x27;,[&#x27;another list&#x27;]]pickle.dump(my_list,pickle_file)pickle_file.close()pickle_file=open(&#x27;my_list.pkl&#x27;,&#x27;rb&#x27;)my_list2 = pickle.load(pickle_file)print(my_list2)&gt;&gt;&gt; [123, 3.14, &#x27;小甲鱼&#x27;, [&#x27;another list&#x27;]] 14、异常Python标准异常总结 AssertionError 断言语句（assert）失败 AttributeError 尝试访问未知的对象属性 EOFError 用户输入文件末尾标志EOF（Ctrl+d） FloatingPointError 浮点计算错误 GeneratorExit generator.close()方法被调用的时候 ImportError 导入模块失败的时候 IndexError 索引超出序列的范围 KeyError 字典中查找一个不存在的关键字 KeyboardInterrupt 用户输入中断键（Ctrl+c） MemoryError 内存溢出（可通过删除对象释放内存） NameError 尝试访问一个不存在的变量 NotImplementedError 尚未实现的方法 OSError 操作系统产生的异常（例如打开一个不存在的文件） OverflowError 数值运算超出最大限制 ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象 RuntimeError 一般的运行时错误 StopIteration 迭代器没有更多的值 SyntaxError Python的语法错误 IndentationError 缩进错误 TabError Tab和空格混合使用 SystemError Python编译器系统错误 SystemExit Python编译器进程被关闭 TypeError 不同类型间的无效操作 UnboundLocalError 访问一个未初始化的本地变量（NameError的子类） UnicodeError Unicode相关的错误（ValueError的子类） UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类） UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类） UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类） ValueError 传入无效的参数 ZeroDivisionError 除数为零 异常捕捉1234try: 检测范围except Exception[as reason]: 出现异常（Exception）后的处理代码 Testdemo📝: 123456789try: # sum = 1 + &#x27;1&#x27; # 这里十类型错误 f = open(&#x27;一个文件.txt&#x27;) # 系统文件错误 print(f.read()) f.close()except OSError as reason: print(&#x27;文件出错了,错误的原因是：&#x27;,str(reason))except TypeError as reason: print(&#x27;类型出错了，错误的原因是：&#x27;,str(reason)) finanlly关键字： 1234567891011try: sum = 1 + &#x27;1&#x27; f = open(&#x27;一个文件.txt&#x27;) print(f.read()) f.close()except OSError as reason: print(&#x27;文件出错了,错误的原因是：&#x27;,str(reason))except TypeError as reason: print(&#x27;类型出错了，错误的原因是：&#x27;,str(reason))finally: print(&#x27;执行备用方案&#x27;) # 最终会执行到finally 额外补充📚: raise #该关键字可以将系统错误自定义设置 15、对象定义一个简单的类1234567891011121314# 简单定义一个类class People: # Python中的类名约定以答谢字母开头 # 属性 name = &#x27;空白&#x27; age = 10 # 方法 def setName(self,name): self.name = name def getName(self): print(&#x27;我是&#x27;+self.name)p = People()p.getName() # ‘我是空白’p.setName(&#x27;小明&#x27;) # name = 小明p.getName() # ‘我是小明’ 构造函数12345class People: # 可以用来初始化属性 def _init_(self,name): self.name = namep1 = People(&quot;HR&quot;) 公有与私有Python中使用name mangling实现访问机制 12345678class People: __name = &quot;Programmer&quot; # 在属性前双下划线 # 定义内部访问机制 def getName(self): return self.__namep = People()p.__name # 调用报错，因为__name是私有变量p.getName() # 通过方法返回属性值 继承1234567891011121314class Parent: def __init__(self): self.number = rd.randint(0,10) print(&quot;正在调用父类构造方法&quot;)class Child(Parent): def __init__(self): # 也可以在代码执行段使用Parent.__init__(Child) Parent.__init__() # 调用了父类的构造函数，同时继承了对象 print(&quot;正在调用子类构造方法&quot;) passp = Parent()p.__init__()c = Child() super()函数 12就是在子类的构造函数中，使用super().__init__() 多继承1234567891011class A: def __init__(self,name): self.name = nameclass B: def __init__(self,name): self.name = nameclass C(A,B): def __init__(self,nameA,nameB): a = self.A(nameA) b = self.b(nameB) print(&quot;我是&quot;+a.name+&quot;和&quot;+b.name+&quot;的儿子&quot;) 拾遗123456789101112class A: def __init__(self,name): self.name = nameclass B: def __init__(self,name): self.name = nameclass C(A,B): def __init__(self,nameA,nameB): self.a = A(nameA) self.b = B(nameB) print(&quot;我是&quot;+self.a.name+&quot;和&quot;+self.b.name+&quot;的儿子&quot;)c = C(&quot;A&quot;,&quot;B&quot;)","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"学习笔记/Python","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.mingsrc.work/tags/Python/"}]},{"title":"Linux-Bash","slug":"E_学习笔记/Linux/bash学习记录","date":"2022-12-27T03:12:54.031Z","updated":"2022-12-27T03:12:54.031Z","comments":true,"path":"posts/dae6345.html","link":"","permalink":"https://www.mingsrc.work/posts/dae6345","excerpt":"bash学习记录——实验楼","text":"bash学习记录——实验楼 1. 简介Bash(GNU Bourne-Again Shell )是一个为GNU计划编写的Unix shell，它是许多Linux平台默认使用的shell。 shell是一个命令解释器，是一个介于操作系统内核与用户之间的绝缘层。准确地说，他也是能力很强的计算机语言，被称为解释性语言或脚本语言。它可以通过将系统调用、公共程序、工具和编译过的二进制程序“粘合”在一起来建立应用，这是大多数脚本语言的共同特征，所以有时候脚本语言又称为“胶水语言”。 事实上，所有的UNIX命令和工具再加上公共程序，对于shell脚本来说，都是可调用的。Shell脚本对于管理系统任务和其他的重复工作的例程来说，表现得非常好，根本不需要那些华而不实的成熟紧凑的编译型程序语言。 2. 初步练习1.Hello World行首以 # 开头(除#!之外)的是注释。#!是用于指定当前脚本的解释器，我们这里为bash，且应该指明完整路径，所以为/bin/bash 1234567891011121314$ vim hello.sh #使用vim编辑hello.shecho Hello World #向文件中输入以下内容# 运行Bash脚本的方式# 1 使用shell来执行$ sh hello.sh# 2 使用bash来执行$ bash hello.sh# 3 使用.来执行$ . ./hello.sh# 4 使用source来执行$ source hello.sh# 5 还可以赋予脚本所有者执行权限，允许用户执行该脚本$ chmod u+rx hello.sh $ ./hello.sh 2. 使用重定向比如我们想要保存刚刚的hello world为一个文本，那么该怎么办呢？ &#x3D;&#x3D;&gt;&#x3D;&#x3D;是重定向，会在当前目录下生成一个my.txt 1234#!/bin/bash$ echo &quot;Hello World&quot; &gt; my.txt$ cat my.txt# 输出Hello World 3. 使用脚本清除**&#x2F;var&#x2F;log&#x2F;wtmp**里边的东西 说白了就是在脚本文件中写入命令，然后在外部使用bash命令调用sh文件（实验内容为编写cleanlogs.sh文件，然后使用命令调用该文件） 1234567891011121314151617181920212223# 先查看wtmp文件中是否有东西cat /var/log/wtmp# 使用vim编辑 cleanlogs.sh##########################################以下内容为cleanlogs.sh文件内容#####!/bin/bash# 初始化一个变量LOG_DIR=/var/logcd $LOG_DIRcat /dev/null &gt; wtmpecho &quot;Logs cleaned up.&quot;exit######################################sudo ./cleanlogs.sh 由于脚本中含有对系统日志文件的清楚操作，这要求要有管理员权限.不然会报**permission denied**错误 使用sudo命令调用管理员权限才能执行成功： $ sudo .&#x2F;cleanlogs.sh #!&#x2F;bin&#x2F;bash这一行是表示使用&#x2F;bin&#x2F;bash作为脚本的解释器，这行要放在脚本的行首并且不要省略 脚本正文中以**#**号开头的行都是注释语句，这些行在脚本的实际执行过程中不会被执行。这些注释语句能方便我们在脚本中做一些注释或标记，让脚本更具可读性。 1. 遇到权限不够的提示，为什么，如何解决？权限不够加sudo啊，可是你会发现 sudo cat /dev/null &gt; /var/log/wtmp 一样会提示权限不够，为什么呢？因为sudo只能让cat命令以sudo的权限执行，而对于&gt;这个符号并没有sudo的权限，我们可以使用 sudo sh -c &quot;cat /dev/null &gt; /var/log/wtmp &quot; 让整个命令都具有sudo的权限执行 2. 为什么cleanlogs.sh可以将log文件清除？因为/dev/null ，里面是空的，重定向到 &#x2F;var&#x2F;log&#x2F;wtmp 文件后，就清空了 wtmp 文件的内容。 3. 简单热身——新建|复制|修改|清楚1. 步骤一 新建一个test.sh 输出Hello Shiyanlou!12345678#题目未要求文件路劲 直接新建并输出echo &quot;Hello Shiyanlou!&quot; &gt; test.sh#或者touch /home/shiyanlou/test.shcat &gt; /home/shiyanlou/test.sh &lt;&lt; EOF#!/bin/bashecho &quot;Hello Shiyanlou!&quot;EOF 2. 步骤二复制test.sh为test2.sh,修改test2.sh实验将Hello Shiyanlou 保存为my.txt文本123456#复制语句cp /home/shiyanlou/test&#123;,2&#125;.sh#修改test2.sh的代码为：#!/bin/bashecho &quot;Hello Shiyanlou!&quot; &gt; my.txt 3. 步骤三新建一个cleantest.sh脚本运行实现清空test.sh里的内容1234567$ touch /home/shiyanlou/cleantest.sh$ cat &gt; /home/shiyanlou/cleantest.sh &lt;&lt; EOF###cleantest.sh文件内容#####!/bin/bashcat /dev/null &gt; test.shEOF########################## 4. 特殊字符1. 注释（#）行首以 # 开头(除#!之外)的是注释。#!是用于指定当前脚本的解释器，我们这里为bash，且应该指明完整路径，所以为/bin/bash 当然，在echo中转义的 # 是不能作为注释的： 1234567891011121314#创建一个test.sh文件$ vim test.sh########test.sh###########!/bin/bashecho &quot;The # here does not begin a comment.&quot;echo &#x27;The # here does not begin a comment.&#x27;echo The \\# here does not begin a comment.echo The # 这里开始一个注释echo $(( 2#101011 )) # 数制转换（使用二进制表示），不是一个注释，双括号表示对于数字的处理# 欢迎来到实验楼参观学习######################### 2. 分号（；）1. 命令分隔符使用分号（;）可以在同一行上写两个或两个以上的命令。 123456789101112131415161718$vim test2.sh# test2.sh ##!/bin/bash echo hello; echo there filename=ttt.sh if [ -e &quot;$filename&quot; ]; then # 注意: &quot;if&quot;和&quot;then&quot;需要分隔，-e用于判断文件是否存在 echo &quot;File $filename exists.&quot;; cp $filename $filename.bak else echo &quot;File $filename not found.&quot;; touch $filename fi; echo &quot;File test complete.&quot; ############### #执行文件 bash test2.sh #结果如下如所示↓ 解释说明 上面脚本使用了一个if分支判断一个文件是否存在，如果文件存在打印相关信息并将该文件备份；如果不存在打印相关信息并创建一个新的文件。最后将输出”测试完成”。 2. 终止case选项（双分号）使用双分号（;;）可以终止case选项 12345678910111213$ vim test3.sh# test3.sh #varnaem = bcase &quot;$varname&quot; in [a-z]) echo &quot;abc&quot;;; [0-9]) echo &quot;123&quot;;;esac##################执行脚本bash test3.sh#输出abc 3. 点号（.）&#x3D;&#x3D;等价于source命令&#x3D;&#x3D; 4. 引号1. 双引号“STRING”将会阻止（解释）STRING中大部分特殊的字符 2. 单引号‘STRING’将会阻止STRING中所有特殊字符的解释，这是一种比使用“更强烈的形式。 同样是$HOME，单引号会直接认为是字符，而双引号会认为是一个变量 5. 斜线和反斜线1. 斜线（&#x2F;)——文件路径分隔符2. 反斜线（\\）——转义符 符号 说明 \\n 表示新的一行 \\r 表示回车 \\t 表示水平制表符 \\v 表示垂直制表符 \\b 表示后退符 \\a 表示”alert”(蜂鸣或者闪烁) \\0xx 转换为八进制的ASCII码, 等价于0xx “ 表示引号字面的意思 6. 反引号（&#96;）命令替换 反引号中的命令会优先执行，如： 12$ cp `mkdir back` test.sh back$ ls 7. 冒号（：）1. 空命令等价于“NOP”（no op ,一个什么也不干的命令）。也可以被认为与shell的内建命令&#x3D;&#x3D;true&#x3D;&#x3D;作用相同 2. 变量扩展&#x2F;子串替换123$ : &gt; test.sh # 文件“test.sh”现在被清空了# 与 cat /dev/null &gt; test.sh 的作用相同# 然而,这并不会产生一个新的进程, 因为“:”是一个内建命令 “:”还用来在 /etc/passwd 和 $PATH 变量中做分隔符，如： 12$ echo $PATH/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games 8. 问号（?）——三元操作符12345#!/bin/basha=10(( t=a&lt;50?8:9 ))echo $t 9. 美元符号变量替换 10. 小括号1. 命令组在括号中的变量，由于是在子shell中，所以对于脚本剩下的部分是不可用的。父进程，也就是脚本本身，将不能够读取在子进程中创建的变量，也就是在子shell 中创建的变量。如： 1$ vim test20.sh 输入代码： 123456#!/bin/basha=123( a=321; )echo &quot;$a&quot; #a的值为123而不是321，因为括号将判断为局部变量 运行代码： 12$ bash test20.sha = 123 在圆括号中 a 变量，更像是一个局部变量。 2.初始化数组创建数组 1$ vim test21.sh 输入代码： 1234#!/bin/basharr=(1 4 5 7 9 21)echo $&#123;arr[3]&#125; # get a value of arr 运行代码： 12$ bash test21.sh7 11. 大括号1.文件名扩展复制 t.txt 的内容到 t.back 中 1$ vim test22.sh 输入代码： 12345678#!/bin/bashif [ ! -w &#x27;t.txt&#x27; ];then touch t.txtfiecho &#x27;test text&#x27; &gt;&gt; t.txtcp t.&#123;txt,back&#125; 运行代码： 1$ bash test22.sh 查看运行结果： 123$ ls$ cat t.txt$ cat t.back 注意： 在大括号中，不允许有空白，除非这个空白被引用或转义。 2.代码块代码块，又被称为内部组，这个结构事实上创建了一个匿名函数（一个没有名字的函数）。然而，与“标准”函数不同的是，在其中声明的变量，对于脚本其他部分的代码来说还是可见的。 1$ vim test23.sh 输入代码： 12345#!/bin/basha=123&#123; a=321; &#125;echo &quot;a = $a&quot; 运行代码： 12$ bash test23.sha = 321 变量 a 的值被更改了。 12. 中括号1.条件测试条件测试表达式放在[ ]中。下列练习中的-lt (less than)表示小于号。 1$ vim test24.sh 输入代码： 123456789#!/bin/basha=5if [ $a -lt 10 ]then echo &quot;a: $a&quot;else echo &#x27;a&gt;=10&#x27;fi 运行代码： 12$ bash test24.sha: 5 双中括号（[[ ]]）也用作条件测试（判断），后面的实验会详细讲解。 2.数组元素在一个array结构的上下文中，中括号用来引用数组中每个元素的编号。 1$ vim test25.sh 输入代码： 12345#!/bin/basharr=(12 22 32)arr[0]=10echo $&#123;arr[0]&#125; 运行代码： 12$ bash test25.sh10 13. 尖括号重定向test.sh &gt; filename：重定向test.sh的输出到文件 filename 中。如果 filename 存在的话，那么将会被&#x3D;&#x3D;覆盖&#x3D;&#x3D;。 test.sh &amp;&gt; filename：重定向 test.sh 的 stdout（标准输出）和 stderr（标准错误）到 filename 中。 test.sh &gt;&amp;2：重定向 test.sh 的 stdout 到 stderr 中。 test.sh &gt;&gt; filename：把 test.sh 的输出&#x3D;&#x3D;追加&#x3D;&#x3D;到文件 filename 中。如果filename 不存在的话，将会被创建。 14. 竖线（|）管道分析前边命令的输出，并将输出作为后边命令的输入。这是一种产生命令链的好方法。 1$ vim test26.sh 输入代码： 1234#!/bin/bashtr &#x27;a-z&#x27; &#x27;A-Z&#x27;exit 0 现在让我们输送ls -l的输出到一个脚本中： 12$ chmod 755 test26.sh$ ls -l | ./test26.sh 输出的内容均变为了大写字母。 15. 破折号（-）1.选项，前缀在所有的命令内如果想使用选项参数的话,前边都要加上“-”。 1$ vim test27.sh 输入代码： 12345678#!/bin/basha=5b=5if [ &quot;$a&quot; -eq &quot;$b&quot; ]then echo &quot;a is equal to b.&quot;fi 运行代码： 12$ bash test27.sha is equal to b. 2.用于重定向stdin或stdout下面脚本用于备份最后24小时当前目录下所有修改的文件. 1$ vim test28.sh 输入代码： 12345678910111213#!/bin/bashBACKUPFILE=backup-$(date +%m-%d-%Y)# 在备份文件中嵌入时间.archive=$&#123;1:-$BACKUPFILE&#125;# 如果在命令行中没有指定备份文件的文件名,# 那么将默认使用&quot;backup-MM-DD-YYYY.tar.gz&quot;.tar cvf - `find . -mtime -1 -type f -print` &gt; $archive.targzip $archive.tarecho &quot;Directory $PWD backed up in archive file \\&quot;$archive.tar.gz\\&quot;.&quot;exit 0 运行代码： 12$ bash test28.sh$ ls 16. 波浪号（~）——表示home目录5. 变量和参数1. 变量定义1.概念变量的名字就是变量保存值的地方。引用变量的值就叫做变量替换。 如果 variable 是一个变量的名字，那么 $variable 就是引用这个变量的值，即这变量所包含的数据。 $variable 事实上只是 ${variable} 的简写形式。在某些上下文中 $variable 可能会引起错误，这时候你就需要用 ${variable} 了。 2.定义变量定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如： myname&#x3D;”shiyanlou” 注意 变量名和等号之间不能有空格。同时，变量名的命名须遵循如下规则： 首个字符必须为字母（a-z，A-Z）。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 除了直接赋值，还可以用语句给变量赋值，如：for file in ls /etc 2. 使用变量变量名前加美元符号，如： 12345678myname=&quot;shiyanlou&quot;echo $mynameecho $&#123;myname&#125;echo $&#123;myname&#125;Goodecho $mynameGoodmyname=&quot;miao&quot;echo $&#123;myname&#125; 加花括号帮助解释器识别变量的边界，若不加，解释器会把mynameGood当成一个变量（值为空） 推荐给所有变量加花括号 已定义的变量可以重新被定义 3. 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 下面的例子尝试更改只读变量，结果报错： 1234#!/bin/bashmyUrl=&quot;http://www.shiyanlou.com&quot;readonly myUrlmyUrl=&quot;http://www.shiyanlou.com&quot; 运行脚本，结果如下： 1/bin/sh: NAME: This variable is read only. 4. 特殊变量1.局部变量这种变量只有在代码块或者函数中才可见。后面的实验会详细讲解。 2.环境变量这种变量将影响用户接口和 shell 的行为。 在通常情况下，每个进程都有自己的“环境”，这个环境是由一组变量组成的，这些变量中存有进程可能需要引用的信息。在这种情况下，shell 与一个一般的进程没什么区别。 3.位置参数从命令行传递到脚本的参数：0，0，1，2，2，3… 0就是脚本文件自身的名字，0就是脚本文件自身的名字，1 是第一个参数，2 是第二个参数，2是第二个参数，3 是第三个参数，然后是第四个。9 之后的位置参数就必须用大括号括起来了，比如，9之后的位置参数就必须用大括号括起来了，比如，{10}，{11}，11，{12}。 $# ： 传递到脚本的参数个数 $* ： 以一个单字符串显示所有向脚本传递的参数。与位置变量不同,此选项参数可超过 9个 $$ ： 脚本运行的当前进程 ID号 $! ： 后台运行的最后一个进程的进程 ID号 $@ ： 与$*相同,但是使用时加引号,并在引号中返回每个参数 $： 显示shell使用的当前选项,与 set命令功能相同 $? ： 显示最后命令的退出状态。 0表示没有错误,其他任何值表明有错误。 4.位置参数实例这个十分重要，在我们运行一套脚本的时候，有时候是需要参数的，这里我们教大家如何获取参数 1$ vim test30.sh 输入代码（中文皆为注释，不用输入）： 123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bash# 作为用例, 调用这个脚本至少需要10个参数, 比如:# bash test.sh 1 2 3 4 5 6 7 8 9 10MINPARAMS=10echoecho &quot;The name of this script is \\&quot;$0\\&quot;.&quot;echo &quot;The name of this script is \\&quot;`basename $0`\\&quot;.&quot;echoif [ -n &quot;$1&quot; ] # 测试变量被引用.thenecho &quot;Parameter #1 is $1&quot; # 需要引用才能够转义&quot;#&quot;fi if [ -n &quot;$2&quot; ]thenecho &quot;Parameter #2 is $2&quot;fi if [ -n &quot;$&#123;10&#125;&quot; ] # 大于$9的参数必须用&#123;&#125;括起来.thenecho &quot;Parameter #10 is $&#123;10&#125;&quot;fi echo &quot;-----------------------------------&quot;echo &quot;All the command-line parameters are: &quot;$*&quot;&quot;if [ $# -lt &quot;$MINPARAMS&quot; ]then echo echo &quot;This script needs at least $MINPARAMS command-line arguments!&quot;fi echoexit 0 运行代码： 123456789101112$ bash test30.sh 1 2 10The name of this script is &quot;test.sh&quot;.The name of this script is &quot;test.sh&quot;.Parameter #1 is 1Parameter #2 is 2-----------------------------------All the command-line parameters are: 1 2 10This script needs at least 10 command-line arguments! 6. 基本运算符1. 算数运算符 1234567891011121314151617181920212223242526272829$vim test.sh#!/bin/basha=10b=20val=`expr $a + $b`echo &quot;a + b : $val&quot;val=`expr $a - $b`echo &quot;a - b : $val&quot;val=`expr $a \\* $b`echo &quot;a * b : $val&quot;val=`expr $b / $a`echo &quot;b / a : $val&quot;val=`expr $b % $a`echo &quot;b % a : $val&quot;if [ $a == $b ]then echo &quot;a == b&quot;fiif [ $a != $b ]then echo &quot;a != b&quot;fi 运行 1234567$bash test.sha + b : 30a - b : -10a * b : 200b / a : 2b % a : 0a != b 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 注意使用的反引号（esc键下边） 表达式和运算符之间要有空格$a + $b写成$a+$b不行 条件表达式要放在方括号之间，并且要有空格[ $a == $b ]写成[$a==$b]不行 乘号（*）前边必须加反斜杠（\\)才能实现乘法运算 2. 关系运算符(大于、小于、等于) 运算符 说明 -eq 检测两个数是否相等，相等返回true. -ne 检测两个数是都相等，不相等返回true -gt 检测左边的数是否大于右边的，如果是，则返回true -lt 检测左边的数是否小于右边的，如果是，则返回true -ge 检测左边的数是否大于右边的，如果是，则返回true -le 检测左边的数是否小于右边的，如果是，则返回true 3. 逻辑运算符 运算符 说明 &amp;&amp; 逻辑的AND || 逻辑的OR 4. 字符运算符 运算符 说明 &#x3D; 检测两个字符串是否相等，相等则返回true ！&#x3D; 检测两个字符串是否相等，不相等则返回true -z 检测两个字符串长度是否为0，为0则返回true -n 检测两个字符串长度是否为0，不为0则返回true str 检测字符串是否为空，不为空返回true 5. 文件测试运算符 6. 浮点运算（小数运算）浮点运算，比如实现求圆的面积和周长。 expr 只能用于整数计算，可以使用 bc 或者 awk 进行浮点数运算。 12345678910111213#!/bin/bashraduis=2.4pi=3.14159girth=$(echo &quot;scale=4; 3.14 * 2 * $raduis&quot; | bc)area=$(echo &quot;scale=4; 3.14 * $raduis * $raduis&quot; | bc)echo &quot;girth=$girth&quot;echo &quot;area=$area&quot; 以上代码如果想在环境中运行，需要先安装 bc。 12$ sudo apt-get update$ sudo apt-get install bc 7. 流程控制（if-else)1. if else和Java、PHP等语言不一样，sh的流程控制不可为空 在sh&#x2F;bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。 1.ifif 语句语法格式： 1234567if conditionthen command1 command2 ... commandN fi 2.if elseif else 语法格式： 123456789if conditionthen command1 command2 ... commandNelse commandfi if-elif-else 语法格式： 123456789if condition1then command1elif condition2 then command2else commandNfi 以下实例判断两个变量是否相等： 1234567891011121314a=10b=20if [ $a == $b ]then echo &quot;a == b&quot;elif [ $a -gt $b ]then echo &quot;a &gt; b&quot;elif [ $a -lt $b ]then echo &quot;a &lt; b&quot;else echo &quot;Ineligible&quot;fi 输出结果： 1a &lt; b if else语句经常与test命令结合使用 12345678num1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo &#x27;Two numbers are equal!&#x27;else echo &#x27;The two numbers are not equal!&#x27;fi 输出结果： 1Two numbers are equal! 2. for循环for循环一般格式为： 1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 例如，顺序输出当前列表中的数字： 1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done 输出结果： 12345The value is: 1The value is: 2The value is: 3The value is: 4The value is: 5 顺序输出字符串中的字符： 1234for str in This is a stringdo echo $strdone 输出结果： 1234Thisisastring for循环高级用法123456789101112#!/bin/bashPREFIX=192.168.1.for i in `seq 100 110`do echo -n &quot;$&#123;PREFIX&#125;$i &quot; ping -c5 $&#123;PREFIX&#125;$&#123;i&#125; &gt;/dev/null 2&gt;&amp;1 if [ &quot;$?&quot; -eq 0 ];then echo &quot;OK&quot; else echo &quot;Failed&quot; fidone 3. while语句while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为： 1234567891011while conditiondo commanddone#!/bin/bashint=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done 运行脚本，输出： 1234512345 如果int小于等于5，那么条件返回真。int从1开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。 使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量 while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量MAN，按结束循环。 123456echo &#x27;press &lt;CTRL-D&gt; exit&#x27;echo -n &#x27;Who do you think is the most handsome: &#x27;while read MANdo echo &quot;Yes！$MAN is really handsome&quot;done 4. 无限循环无限循环语法格式： 123456789while :do commanddone或者while truedo commanddone 或者 1for (( ; ; )) until循环 until循环执行一系列命令直至条件为真时停止。 until循环与while循环在处理方式上刚好相反。 一般while循环优于until循环，但在某些时候—也只是极少数情况下，until循环更加有用。 until 语法格式: 1234until conditiondo commanddone 条件可为任意测试条件，测试发生在循环末尾，因此循环至少执行一次—请注意这一点。 case Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下： 1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac 取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。 取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 下面的脚本提示输入1到4，与每一种模式进行匹配： 123456789101112131415echo &#x27;Enter a number between 1 and 4:&#x27;echo &#x27;The number you entered is:&#x27;read aNumcase $aNum in 1) echo &#x27;You have chosen 1&#x27; ;; 2) echo &#x27;You have chosen 2&#x27; ;; 3) echo &#x27;You have chosen 3&#x27; ;; 4) echo &#x27;You have chosen 4&#x27; ;; *) echo &#x27;You did not enter a number between 1 and 4&#x27; ;;esac 输入不同的内容，会有不同的结果，例如： 1234Enter a number between 1 and 4:The number you entered is:3You have chosen 3 7. 跳出循环在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。 &#x3D;&#x3D;break命令&#x3D;&#x3D; break命令允许跳出所有循环（终止执行后面的所有循环）。 下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。 12345678910111213#!/bin/bashwhile :do echo -n &quot;Enter a number between 1 and 5:&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;The number you entered is $aNum!&quot; ;; *) echo &quot;The number you entered is not between 1 and 5! game over!&quot; break ;; esacdone 执行以上代码，输出结果为： 1234Enter a number between 1 and 5:3The number you entered is 3!Enter a number between 1 and 5:7The number you entered is not between 1 and 5! game over! 8. continuecontinue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。 对上面的例子进行修改： 1234567891011121314#!/bin/bashwhile :do echo -n &quot;Enter a number between 1 and 5: &quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;The number you entered is $aNum!&quot; ;; *) echo &quot;The number you entered is not between 1 and 5!&quot; continue echo &quot;game over&quot; ;; esacdone 运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo &quot;Game is over!&quot; 永远不会被执行。 9. esaccase的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。 8. 函数1. 函数定义shell中函数的定义格式如下： 123456789[ function ] funname [()]&#123; action; [return int;]&#125; 说明： 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255) 下面的例子定义了一个函数并进行调用： 1234567891011121314#!/bin/bashdemoFun()&#123; echo &quot;This is my first shell function!&quot;&#125;echo &quot;-----Execution-----&quot;demoFunecho &quot;-----Finished-----&quot;Output the result：-----Execution-----This is my first shell function!-----Finished----- 下面定义一个带有return语句的函数： 123456789101112#!/bin/bashfunWithReturn()&#123; echo &quot;This function will add the two numbers of the input...&quot; echo &quot;Enter the first number: &quot; read aNum echo &quot;Enter the second number: &quot; read anotherNum echo &quot;The two numbers are $aNum and $anotherNum !&quot; return $(($aNum+$anotherNum))&#125;funWithReturnecho &quot;The sum of the two numbers entered is $? !&quot; 输出类似下面： 1234567This function will add the two numbers of the input...Enter the first number: 1Enter the second number: 2The two numbers are 1 and 2 !The sum of the two numbers entered is 3 ! 函数返回值在调用该函数后通过 $? 来获得 所有函数在使用前必须定义。 2. 函数参数在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 n 的形式来获取参数的值，例如，n的形式来获取参数的值，例如，1表示第一个参数，$2表示第二个参数… 带参数的函数示例： 1234567891011#!/bin/bashfunWithParam()&#123; echo &quot;The first parameter is $1 !&quot; echo &quot;The second parameter is $2 !&quot; echo &quot;The tenth parameter is $10 !&quot; echo &quot;The tenth parameter is $&#123;10&#125; !&quot; echo &quot;The eleventh parameter is $&#123;11&#125; !&quot; echo &quot;The total number of parameters is $# !&quot; echo &quot;Outputs all parameters as a string $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 输出结果： 1234567The first parameter is 1 !The second parameter is 2 !The tenth parameter is 10 !The tenth parameter is 34 !The eleventh parameter is 73 !The total number of parameters is 11 !Outputs all parameters as a string 1 2 3 4 5 6 7 8 9 34 73 ! 注意 10 不能获取第十个参数，获取第十个参数需要10不能获取第十个参数，获取第十个参数需要{10}。当n&gt;&#x3D;10时，需要使用${n}来获取参数。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Bash","slug":"学习笔记/Bash","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Bash/"},{"name":"Bash","slug":"实验楼/Bash","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Bash/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"bash","slug":"bash","permalink":"https://www.mingsrc.work/tags/bash/"}]},{"title":"Linux学习记录-Vim","slug":"E_学习笔记/Linux/Vim","date":"2022-12-27T03:12:54.030Z","updated":"2022-12-27T03:12:54.030Z","comments":true,"path":"posts/6d2dfa59.html","link":"","permalink":"https://www.mingsrc.work/posts/6d2dfa59","excerpt":"Vim常规命令","text":"Vim常规命令 二 删除|移动 撤销 u 粘贴 p 重做 CRTL+R 插入文本 A 插入 i 删除 d 替换 r 替换插入 cw 删除后半部分插入 c$ 括号匹配 % （移动到括号上再输入%） 查找字符串 &#x2F;： 向前查 ？：向后查 三 更改类操作符 四 查找|替换|匹配 五 外部命令 六 查找|插入|复制|粘贴|替换 七 帮助|自动补全","raw":null,"content":null,"categories":[{"name":"Linux学习笔记","slug":"Linux学习笔记","permalink":"https://www.mingsrc.work/categories/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Linux","slug":"Linux学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Vim","slug":"实验楼/Vim","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Vim/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"Vim","slug":"Vim","permalink":"https://www.mingsrc.work/tags/Vim/"}]},{"title":"gcc编译可执行文件的各个过程","slug":"E_学习笔记/Linux/Linux相关/gcc命令","date":"2022-12-27T03:12:54.030Z","updated":"2022-12-27T03:12:54.030Z","comments":true,"path":"posts/d710f2d.html","link":"","permalink":"https://www.mingsrc.work/posts/d710f2d","excerpt":"","text":"编译过程 【预处理阶段】：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件🔻。 【编译阶段】：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件🔻。&#x3D;&#x3D;根据当前源代码编译成二进制目标文件（即.obj文件）&#x3D;&#x3D; 【汇编阶段】：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件🔻。 【链接阶段】：将多个目标文件及所需要的库连接成最终的可执行目标文件。&#x3D;&#x3D;将生成的.obj文件与库文件.lib等文件链接，生成可执行文件（.exe文件）。&#x3D;&#x3D; gcc的编译过程123456789# .i 中间文件，基本不会用到gcc -E main.c -o main.i# .s 汇编语言文件gcc -S main.i -o main.s# .o 汇编文件# -c 只编译不链接，生成.obj文件也就是上述对应的汇编文件gcc -c main.s -o main.o# 生成可执行文件gcc main.o -o main","raw":null,"content":null,"categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/categories/Linux/"}],"tags":[{"name":"gcc","slug":"gcc","permalink":"https://www.mingsrc.work/tags/gcc/"},{"name":"linux","slug":"linux","permalink":"https://www.mingsrc.work/tags/linux/"}]},{"title":"","slug":"E_学习笔记/Linux/Linux相关/3.sed命令与正则表达式","date":"2022-12-27T03:12:54.029Z","updated":"2022-12-27T03:12:54.029Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://www.mingsrc.work/posts/0","excerpt":"","text":"实验介绍本节实验通过使用正则表达式和 sed 工具简单便捷地完成文件查询、修改等功能。 实验知识点 sed 工具 文件副本编辑 1、sed 简介sed 是非交互式的编辑器。它不会修改文件，除非使用 shell 重定向来保存结果。默认情况下，所有的输出行都会被打印到屏幕上。 sed 编辑器逐行处理文件（或输入），并将结果打印到屏幕上。 具体过程如下：首先 sed 把当前正在处理的行保存在一个临时缓存区中（也称为模式空间），然后处理临时缓冲区中的行，完成后把该行发送到屏幕上。 sed 每处理完一行就将其从临时缓冲区删除，然后将下一行读入，进行处理和显示。处理完输入文件的最后一行后，sed 便结束运行。sed 把每一行都存在临时缓冲区中，对这个副本进行编辑，所以**不会修改原文件。 ** 如果要修改原文件，可使用-i 选项。 2、输出文件内容将 regular_express.txt 的内容列出并打印行号，并将 2-5 行删除显示： 1nl regular_express.txt | sed &#x27;2,5d&#x27; ‘2,5d’ 表示删除 2~5 行，d 即为 delete。 同理，删除第 2 行： 1nl regular_express.txt | sed &#x27;2d&#x27; 删除第三行到最后一行, $表示定位到最后一行： 1nl regular_express.txt | sed &#x27;3,$d&#x27; 使用-i 在原文件中删除第 1 行：（注意：该指令会修改原文件） 1sed -i &#x27;1d&#x27; regular_express.txt 3、使用a和i新增输出在第二行后添加字符串 test： 1nl regular_express.txt | sed &#x27;2a test&#x27; 在第二行前添加字符串 test： 1nl regular_express.txt | sed &#x27;2i test&#x27; 在第二行后添加两行 test，“\\n”表示换行符： 1nl regular_express.txt | sed &#x27;2a test\\ntest&#x27; 4、行内容替换将 2-5 行的内容替换为 No 2-5 number，c 为替换内容选项： 1nl regular_express.txt | sed &#x27;2,5c No 2-5 number&#x27; 5、输出指定行输出 regular_express.txt 的第 5-7 行，其中-n 为安静模式选项，我们在前面的章节中已经介绍过。 执行以下两条命令可以明显看出区别： 123nl regular_express.txt |sed -n &#x27;5,7p&#x27;nl regular_express.txt |sed &#x27;5,7p&#x27; 6、字符串替换格式为：sed &#39;s/被替换字符串/新字符串/g&#39; 来看一个实例。首先查看本机 IP 地址： 1/sbin/ifconfig eth0 字段 inet 地址：192.168.x.x 即为本机的 IP 地址，这是经由 NAT 转换后分配的内网 IP 地址，在此不做展开。若想进一步学习计算机网络的相关知识可以参阅 TCP&#x2F;IP 网络协议基础入门。 之后使用 grep 指令在&#x2F;sbin&#x2F;ifconfig eth0 的结果中查找‘inet’，并打印至终端： 1/sbin/ifconfig eth0 |grep &#x27;inet &#x27; 可以使用字符串替换功能将 IP 前面的部分予以删除，按照思路，也就是将 inet 地址: 替换为空字符串，可以简单写成： 1/sbin/ifconfig eth0 |grep &#x27;inet &#x27;|sed &#x27;s/inet 地址://g&#x27; （注意中文字符不能直接复制，需要自己在终端输入） 但正则表达式在实际应用中可以非常灵活，回想一下我们在前两节所学的关于正则表达式的知识（忘了也不要紧，可以随时返回查看）。 . 表示任意一个字符，* 表示重复字符，{ } 表示限定连续字符范围，则表达式可以写成 123/sbin/ifconfig eth0 |grep &#x27;inet &#x27;| sed &#x27;s/.inet...://g&#x27;或者/sbin/ifconfig eth0 |grep &#x27;inet &#x27;| sed &#x27;s/.\\&#123;0,9\\&#125;://&#x27; 表达式的写法并不唯一，在此也并未全部列出，大家亦可自行尝试使用其他写法，欢迎在评论区中讨论。 将 IP 后面的部分删除： 123/sbin/ifconfig eth0 |grep &#x27;inet &#x27;| sed &#x27;s/.inet...://g&#x27;| sed &#x27;s/..:.*$//g&#x27;/sbin/ifconfig eth0 |grep &#x27;inet &#x27;| sed &#x27;s/.inet...://g&#x27;| sed &#x27;s/.\\&#123;0,3\\&#125;:.*$//g&#x27; 上述指令是比较复杂的正则表达式运用，熟悉正则表达式后可以明显地简化指令，简单便捷地完成文件的查询、修改等任务。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"正则表达式","slug":"E_学习笔记/Linux/Linux相关/4.正则表达式扩展应用","date":"2022-12-27T03:12:54.029Z","updated":"2022-12-27T03:12:54.029Z","comments":true,"path":"posts/2f57a694.html","link":"","permalink":"https://www.mingsrc.work/posts/2f57a694","excerpt":"","text":"正则表达式扩展应用 实验介绍事实上，基础的正则表达式已经足以满足大部分情况下的使用需求。不过有时候为了进一步简化命令操作，了解一些使用范围更广的扩展表达式会更加方便。本节实验将介绍扩展正则表达式的基本知识。 实验知识点 egrep 命令 扩展正则表达式 1、使用扩展正则表达式 egrep首先来看一条前面章节学习过的用来去除空白行和注释行的指令： 1grep -v &#x27;^$&#x27; regular_express.txt |grep -v &#x27;^#&#x27; 可见，通常的 grep 指令需要使用两次管线命令。 那么如果使用扩展正则表达式，则可以简化为： 1egrep -v &#x27;^$|^#&#x27; regular_express.txt 利用支持扩展正则表达式的 egrep 与特殊字符 “|” 的组功能来间隔两组字符串，如此一来，可以极大地化简指令。 此外，也可以使用 grep - E 来使用扩展正则表达式，不过一般更建议直接使用 egrep，grep -E 与 egrep 之间类似命令别名的关系。 2、扩展规则（一）回忆一下，在非扩展正则表达式中，我们使用 * 来表示任意个重复字符（零至无穷多个）： 1grep -n &#x27;goo*d&#x27; regular_express.txt 在扩展正则表达式中，则可以进一步细分为”一个或一个以上“和”零个或一个“字符： + ：表示重复一个或一个以上的前一个字符1egrep -n &#x27;go+d&#x27; regular_express.txt ? ： 表示重复零个或一个的前一个字符1egrep -n &#x27;go?d&#x27; regular_express.txt 执行上述三条指令，比较三者的不同。 3、扩展规则（二）|：表示用或（or）的方式找出数个字符串查找 gd 或 good： 1egrep -n &#x27;gd|good&#x27; regular_express.txt () : 表示找出组字符串查找 glad 或 good，注意到由于二者存在重复字母，所以可以将其合并： 1egrep -n &#x27;g(la|oo)d&#x27; regular_express.txt 2.2.5 ()+ : 多个重复群组判别查找开头是 A 结尾是 C 中间有一个以上的’xyz’或’‘xz’字符串： 123echo &#x27;AxyzxyzxyzxyzC&#x27;|egrep &#x27;A(xyz)+C&#x27;echo &#x27;AxyzxyzxyzxyzC&#x27;|egrep &#x27;A(xz)+C&#x27; 结果显示 A(xyz)+C 可以匹配，A(xz)+C 没有匹配项。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"拓展","slug":"学习笔记/拓展","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8B%93%E5%B1%95/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.mingsrc.work/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"bash中与美元符$连用的符号含义说明——($?/$0/$?/$!/$$/$*/$#/$@)","slug":"E_学习笔记/Linux/Linux相关/5.bash中美元符的一些用法含义","date":"2022-12-27T03:12:54.029Z","updated":"2022-12-27T03:12:54.029Z","comments":true,"path":"posts/91f0715b.html","link":"","permalink":"https://www.mingsrc.work/posts/91f0715b","excerpt":"","text":"bash中与美元符$连用的符号含义说明——($?/$0/$?/$!/$$/$*/$#/$@)$? $0 $? $! $$ $* $# $@","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux相关","slug":"学习笔记/Linux/Linux相关","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/Linux%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"bash","slug":"bash","permalink":"https://www.mingsrc.work/tags/bash/"}]},{"title":"N、Linux轻松一刻","slug":"E_学习笔记/Linux/Linux_实验楼/9999-N、Linux轻松一下","date":"2022-12-27T03:12:54.028Z","updated":"2022-12-27T03:12:54.028Z","comments":true,"path":"posts/3ac4cd3c.html","link":"","permalink":"https://www.mingsrc.work/posts/3ac4cd3c","excerpt":"","text":"一、火焰天冷的时候，要是有个火炉就好了。这里有个有趣的程序： 123$ sudo apt-get install libaa-bin# 提示 command not found ，请自行解决$ aafire 二、屏幕特效（cmatrix）123$ sudo apt-get update$ sudo apt-get install cmatrix$ camtris 三、图画轻松一下cowsay命令，可以让你在终端里以一种动物说话的形式打印出一段话。 1234567891011121314151617181920# 更新软件包$ sudo apt update# 安装$ sudo apt install -y cowsay# 默认是一只牛$ cowsay hello shiyanlou# 加上&#x27;-l&#x27;参数打印所有支持的动物（其实不只是动物）种类$ cowsay -l# 使用&#x27;-f&#x27;参数选择动物种类$ cowsay -f elephant hello shiyanlou# 安装 fortune-zh$ sudo apt-get install fortune-zh# 此外它还可以结合我们之前的作业讲过的 fortune 命令一起使用$ /usr/games/fortune | cowsay -f daemon 四、显示图片使用以前介绍过的方法，安装aview和imagemagick，然后用asciiview命令显示图片，使用方法可以用 man 命令查看。 Linus 大神的照片地址 https://labfile.oss.aliyuncs.com/courses/1/Linus.png 执行以下命令安装工具包并下载图片： 12345shiyanlou:~/ $ sudo apt updateshiyanlou:~/ $ sudo apt install -y aview imagemagickshiyanlou:~/ $ wget https://labfile.oss.aliyuncs.com/courses/1/Linus.png 执行 asciiview [图片文件名] 即可打开图片： https://b287.photo.store.qq.com/psb?/V141y5OQ39HXnh/Ze5q9eV9O7czDkzvDkjVWgUOJSx38g9dbb1ENFsRTMQ!/b/dB8BAAAAAAAA&amp;bo=AQPQAwAAAAARB.E!&amp;rf=viewer_4 五、蜜蜂大战轻松一下还记得小时候在小霸王上面玩的小蜜蜂游戏么？它的正统名字应该是Space Invaders:太空侵略者。 使用下面这个命令可以安装，之所以叫 ninvaders 是因为这款游戏是基于 ncurses 命令行图形库做的： 12$ sudo apt-get install ninvaders$ /usr/games/ninvaders 六、彩色火焰轻松一下之前介绍过一个在命令行将图片转换为 ascii 字符查看的工具 aview&#x2F;asciiview，不过它是黑白的。现在，这里是个彩色的： 1234$ sudo apt-get install caca-utils$ cacaview &lt;pic_file&gt;$ cacademo$ cacafire","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"正则表达式","slug":"E_学习笔记/Linux/Linux相关/1.正则表达式","date":"2022-12-27T03:12:54.028Z","updated":"2022-12-27T03:12:54.028Z","comments":true,"path":"posts/2f57a694.html","link":"","permalink":"https://www.mingsrc.work/posts/2f57a694","excerpt":"","text":"正则表达式正则表达式特殊符号首先是正则表达式的特殊符号： 123456789101112[:alnum:]代表英文大小写字母及数字[:alpha:]代表英文大小写字母[:blank:]代表空格和 tab 键[:cntrl:]键盘上的控制按键，如 CR,LF,TAB,DEL[:digit:]代表数字[:graph:]代表空白字符以外的其他[:lower:]小写字母[:print:]可以被打印出来的任何字符[:punct:]代表标点符号[:upper:]代表大写字母[:space:]任何会产生空白的字符如空格，tab,CR 等[:xdigit:]代表 16 进位的数字类型 特殊符号实例在 WebIDE 中使用 touch 命令或图形界面新建一个 .txt 文件并将下文中的文本内容复制进去。 1touch regular_express.txt 也可以使用 wget 指令从本节开头的实验环境说明处下载，这两种方式取得的文件是一样的。 文本内容为： 12345678910111213141516171819202122&quot;Open Source&quot; is a good mechanism to develop programs.apple is my favorite food.Football game is not use feet only.this dress doesn&#x27;t fit me.However, this dress is about \\$ 3183 dollars.GNU is free air not free beer.Her hair is very beauty.I can&#x27;t finish the test.Oh! The soup taste good.motorcycle is cheap than car.This window is clear.the symbol &#x27;\\*&#x27; is represented as start.Oh!My god!The gd software is a library for drafting programs.You are the best is mean you are the no. 1.The world &lt;Happy&gt; is the same with &quot;glad&quot;.I like dog.google is the best tools for search keyword.goooooogle yes!go! go! Let&#x27;s go.# I am VBird 使用特殊符号查找小写字母： 1grep -n &#x27;[[:lower:]]&#x27; regular_express.txt 红色为匹配成功的字符 使用特殊符号查找数字： 1grep -n &#x27;[[:digit:]]&#x27; regular_express.txt 语系对正则表达式的影响我们知道，计算机可以直接处理的文件中只有 0 和 1，我们看到的字符文字和数字都是通过编码表转换而来的。不同语系的编码不同会导致不同语系的数据选取结果有所差异。 以英文大小写为例，zh_CN.big5 及 C 这两种语系差异如下： LANG&#x3D;C 时： 0 1 2 3 4….A B C D E…Z a b c d e…z LANG&#x3D;zh_CN.big5 时：0 1 2 3 4…a A b B c C d D…..z Z 在使用正则表达式[A-Z]时， LANG&#x3D;C 的情况下，找到的是大写字符 A B C D…Z。而在 LANG&#x3D;zh_CN.big5 的情况下，会选取到 A b B c C d D…z Z。所以在使用正则表达式时要特别留意语系。 由于我们一般使用的是兼容于 POSIX 的标准，因此建议使用 C 语系。 需要说明的是，我们实验环境使用的 WebIDE 的默认语系 zh_CN.UTF-8 并没有该编码问题，可以直接使用。 可以使用 echo $LANG 指令查看当前语系。","raw":null,"content":null,"categories":[],"tags":[{"name":"拓展知识","slug":"拓展知识","permalink":"https://www.mingsrc.work/tags/%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86/"},{"name":"正则","slug":"正则","permalink":"https://www.mingsrc.work/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"","slug":"E_学习笔记/Linux/Linux相关/2.grep命令与正则表达式","date":"2022-12-27T03:12:54.028Z","updated":"2022-12-27T03:12:54.029Z","comments":true,"path":"posts/0.html","link":"","permalink":"https://www.mingsrc.work/posts/0","excerpt":"","text":"实验介绍本节实验将介绍通过 grep 命令使用正则表达式。 知识点 grep 命令 字符组匹配 行首行尾符 任意和重复字符 限定连续字符范围 1、查找特定字符串参数说明： -a ：以 text 档案的方式搜寻 binary 档案数据 -c ：计算找到 ‘搜寻字符串’ 的次数 -i ：忽略大小写的不同，所以大小写视为相同 -n ：顺便输出行号 -v ：反向选择，亦即显示没有 ‘搜寻字符串’ 内容的行 123grep -n &#x27;the&#x27; regular_express.txtgrep -in &#x27;the&#x27; regular_express.txt 反向查找，当该行没有字符串’the’时才显示在屏幕上。 1grep -vn &#x27;the&#x27; regular_express.txt 2、字符组匹配[ ]可以用来查找字符组。 值得注意的是，无论[ ]中包含多少个字符，它都只代表一个字符。比如说，我们想要查找”tast”或者”test”这两个字符串，注意到二者的拼写大部分相同，都是 t?st 的形式，故此时可以使用[ ]进行查找： 1grep -n &#x27;t[ae]st&#x27; regular_express.txt 字符组支持使用连字符“ - ”来表示一个范围。当“ - ”前后构成范围时，要求前面字符的码位小于后面字符的码位。 [^] 为反向选择字符组，用于排除后面的字符，使用方式为[^需要反向选择的字符]。 需要注意 [^] 与参数 -v 的区别，尽管二者都表示反向选择，但是如果包含有反向选择的字符的行含有其他字符的话， [^] 仍会输出该行，而 -v 则只会输出不含有反向选择的字符的行。 下面给出一些应用示例： 12345[abc] ：表示“a”或“b”或“c”[0-9] ：表示 0~9 中任意一个数字，等价于[0123456789][\\u4e00-\\u9fa5] :表示任意一个汉字[^a1&lt;] :表示除“a”、“1”、“&lt;”外的其它任意一个字符[^a-z] :表示除小写字母外的任意一个字符 使用 - 和 [^] 查找“Xoo”形式的字符串，要求“oo”之前不能包含小写字母： 1grep -n &#x27;[^a-z]oo&#x27; regular_express.txt 回忆前一节所提到的正则表达式特殊符号，[:lower:]表示小写字母，因此也可以使用 1grep -n &#x27;[^[:lower:]]oo&#x27; regular_express.txt 这两者是等价的，但是可以看出，使用[a-z]来表示小写字母明显更加便捷，也更加灵活。 查找字符”oog”。 1grep -n &#x27;oog&#x27; regular_express.txt 如果我不想要“oog”字符前面有 g，则使用“[^g]oog”。 1grep -n &#x27;[^g]oog&#x27; regular_express.txt 同理，若不想让字符“oog”前面为 g 或者 o，则使用“[^go]oog”。 1grep -n &#x27;[^go]oog&#x27; regular_express.txt 其中， 1grep -n &#x27;[^go]oog&#x27; regular_express.txt 返回结果为空，表示没有匹配到符合要求的字符串。 3、行首符 ^ 与行尾符 $在第一个实验中，我们使用 1grep -n &#x27;the&#x27; regular_express.txt 查找含有“the”的字符串，如果你只想查找行首为“the”的字符行，则使用以下命令： 1grep -n &#x27;^the&#x27; regular_express.txt 查找行首为大写字母的所有行： 1grep -n &#x27;^[A-Z]&#x27; regular_express.txt 注意行首符 ^ 和反向选择 [^] 的区别，’^[A-Z]’ 表示以大写字母开头。’[^a-z]’ 表示除了大写字母 A-Z 的所有字符。 行尾符 $ 的用法与行首符类似。 查找以字母 d 结尾的行： 1grep -n &#x27;d$&#x27; regular_express.txt 这里有一个小技巧，将行首符与行尾符连用，可以用来查找空行： 1grep -n &#x27;^$&#x27; regular_express.txt 应用实例：查看&#x2F;etc&#x2F;insserv.conf 文档 ‘^$’ : 过滤掉空白行 ‘^#’ ：过滤掉注释行（以#号开头） 123cat -n /etc/insserv.confgrep -v &#x27;^$&#x27; /etc/insserv.conf | grep -v &#x27;^#&#x27; 4、任意一个字符 . 与重复字符 *查找 a?ou? 类型的字符： 1grep -n &#x27;a.ou.&#x27; regular_express.txt 其中小数点表示任意一个字符，一个小数点只能表示一个未知字符。 12345*（星号）：代表重复前面 0 个或者多个字符。e*： 表示具有空字符或者一个以上 e 字符。ee*，表示前面的第一个 e 字符必须存在。第二个 e 则可以是 0 个或者多个 e 字符。eee*，表示前面两个 e 字符必须存在。第三个 e 则可以是 0 个或者多个 e 字符。ee*e ：表示前面的第一个与第三个 e 字符必须存在。第二个 e 则可以是 0 个或者多个 e 字符。 下面的第一条命令与第二条命令由于允许存在空字符，所以会打印所有文本。 12345grep -n &#x27;e*&#x27; regular_express.txtgrep -n &#x27;@*&#x27; regular_express.txtgrep -n &#x27;eee*&#x27; regular_express.txt 5、限定连续字符范围 { }{ }可限制一个范围区间内的重复字符数。如果现在要求找出存在连续的两个 o 字符的字符串，根据前面所学的知识，我们可以使用 1grep -n &#x27;ooo*&#x27; regular_express.txt 另一种方式是使用 { }。由于 { 与 } 在 shell 中有特殊意义，故在使用时需要用到转义字符\\。 查找连续的两个 o 字符： 1grep -n &#x27;o\\&#123;2\\&#125;&#x27; regular_express.txt 查找 g 后面接 2 到 5 个 o，然后再接 g 的字符串： 123456789101112grep -n &#x27;go\\&#123;2,5\\&#125;g&#x27; regular_express.txt总结：^word 表示带搜寻的字符串(word)在行首word$ 表示带搜寻的字符串(word)在行尾.(小数点) 表示 1 个任意字符\\ 表示转义字符，在特殊字符前加\\会将特殊字符意义去除* 表示重复 0 到无穷多个前一个 RE(正则表达式)字符[list] 表示搜索含有 l,i,s,t 任意字符的字符串[n1-n2] 表示搜索指定的字符串范围,例如[0-9] [a-z] [A-Z]等[^list] 表示反向字符串的范围,例如[^0-9]表示非数字字符，[^A-Z]表示非大写字符范围\\&#123;n,m\\&#125; 表示找出 n 到 m 个前一个 RE 字符\\&#123;n,\\&#125; 表示 n 个以上的前一个 RE 字符","raw":null,"content":null,"categories":[],"tags":[]},{"title":"八、简单的文本处理","slug":"E_学习笔记/Linux/Linux_实验楼/8-八、简单的文本处理","date":"2022-12-27T03:12:54.027Z","updated":"2022-12-27T03:12:54.027Z","comments":true,"path":"posts/48fd063.html","link":"","permalink":"https://www.mingsrc.work/posts/48fd063","excerpt":"","text":"八、简单的文本处理一、实验介绍1.1 实验内容这一节我们将介绍这几个命令tr（注意不是 tar），col，join，paste。实际这一节是上一节关于能实现管道操作的命令的延续，所以我们依然将结合管道来熟悉这些命令的使用。 1.2 实验知识点 常见文本处理命令 如何简单处理文本 二、文本处理命令2.1 tr 命令tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。 使用方式：1tr [option]...SET1 [SET2] 常用的选项有： 选项 说明 -d 删除和 set1 匹配的字符，注意不是全词匹配也不是按字符顺序匹配 -s 去除 set1 指定的在输入文本中连续并重复的字符 操作举例：1234567# 删除 &quot;hello shiyanlou&quot; 中所有的&#x27;o&#x27;,&#x27;l&#x27;,&#x27;h&#x27;$ echo &#x27;hello shiyanlou&#x27; | tr -d &#x27;olh&#x27;# 将&quot;hello&quot; 中的ll,去重为一个l$ echo &#x27;hello&#x27; | tr -s &#x27;l&#x27;# 将输入文本，全部转换为大写或小写输出$ echo &#x27;input some text here&#x27; | tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;# 上面的&#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;你也可以简单的写作&#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;,当然反过来将大写变小写也是可以的 更多 tr 的使用，你可以使用--help或者man tr获得。 2.2 col 命令col 命令可以将Tab换成对等数量的空格键，或反转这个操作。 使用方式：1col [option] 常用的选项有： 选项 说明 -x 将Tab转换为空格 -h 将空格转换为Tab（默认选项） 操作举例：1234# 查看 /etc/protocols 中的不可见字符，可以看到很多 ^I ，这其实就是 Tab 转义成可见字符的符号$ cat -A /etc/protocols# 使用 col -x 将 /etc/protocols 中的 Tab 转换为空格,然后再使用 cat 查看，你发现 ^I 不见了$ cat /etc/protocols | col -x | cat -A 2.3 join 命令学过数据库的用户对这个应该不会陌生，这个命令就是用于将两个文件中包含相同内容的那一行合并在一起。 使用方式：1join [option]... file1 file2 常用的选项有： 选项 说明 -t 指定分隔符，默认为空格 -i 忽略大小写的差异 -1 指明第一个文件要用哪个字段来对比，默认对比第一个字段 -2 指明第二个文件要用哪个字段来对比，默认对比第一个字段 操作举例：123456789$ cd /home/shiyanlou# 创建两个文件$ echo &#x27;1 hello&#x27; &gt; file1$ echo &#x27;1 shiyanlou&#x27; &gt; file2$ join file1 file2# 将/etc/passwd与/etc/shadow两个文件合并，指定以&#x27;:&#x27;作为分隔符$ sudo join -t&#x27;:&#x27; /etc/passwd /etc/shadow# 将/etc/passwd与/etc/group两个文件合并，指定以&#x27;:&#x27;作为分隔符, 分别比对第4和第3个字段$ sudo join -t&#x27;:&#x27; -1 4 /etc/passwd -2 3 /etc/group 2.4 paste 命令paste这个命令与join 命令类似，它是在不对比数据的情况下，简单地将多个文件合并一起，以Tab隔开。 使用方式：1paste [option] file... 常用的选项有： 选项 说明 -d 指定合并的分隔符，默认为 Tab -s 不合并到一行，每个文件为一行 操作举例：12345$ echo hello &gt; file1$ echo shiyanlou &gt; file2$ echo www.lanqiao.cn &gt; file3$ paste -d &#x27;:&#x27; file1 file2 file3$ paste -s file1 file2 file3","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"九、数据流重定向","slug":"E_学习笔记/Linux/Linux_实验楼/9-九、数据流重定向","date":"2022-12-27T03:12:54.027Z","updated":"2022-12-27T03:12:54.027Z","comments":true,"path":"posts/3083aeb6.html","link":"","permalink":"https://www.mingsrc.work/posts/3083aeb6","excerpt":"","text":"九、数据流重定向一、实验介绍1.1 实验内容你可能对重定向这个概念感到些许陌生，但你应该在前面的课程中多次见过&gt;或&gt;&gt;操作了，并知道他们分别是将标准输出导向一个文件或追加到一个文件中。这其实就是重定向，将原本输出到标准输出的数据重定向到一个文件中，因为标准输出(/dev/stdout)本身也是一个文件，我们将命令输出导向另一个文件自然也是没有任何问题的。 1.2 实验知识点 重定向怎么用 文件描述符(0,1,2) 二、数据流重定向下面我们简单的回顾一下我们前面经常用到的两个重定向操作： 123$ echo &#x27;hello shiyanlou&#x27; &gt; redirect$ echo &#x27;www.shiyanlou.com&#x27; &gt;&gt; redirect$ cat redirect 当然前面没有用到的&lt;和&lt;&lt;操作也是没有问题的，如你理解的一样，它们的区别在于重定向的方向不一致而已，&gt;表示是从左到右，&lt;右到左。 2.1 简单的重定向在更多了解 Linux 的重定向之前，我们需要先知道一些基本的东西，前面我们已经提到过 Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入），stdout（标准输出，对应于终端的输出），stderr（标准错误输出，对应于终端的输出）。 文件描述符 设备文件 说明 0 /dev/stdin 标准输入 1 /dev/stdout 标准输出 2 /dev/stderr 标准错误 文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。 我们可以这样使用这些文件描述符： 默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出 12$ cat（按Ctrl+C退出） 将 cat 的连续输出（heredoc 方式）重定向到一个文件 1234567891011$ mkdir Documents$ cat &gt; Documents/test.c &lt;&lt;EOF#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125;EOF 将一个文件作为命令的输入，标准输出作为命令的输出 1$ cat Documents/test.c 将 echo 命令通过管道传过来的数据作为 cat 命令的输入，将标准输出作为命令的输出 1$ echo &#x27;hi&#x27; | cat 将 echo 命令的输出从默认的标准输出重定向到一个普通文件 12$ echo &#x27;hello shiyanlou&#x27; &gt; redirect$ cat redirect 初学者这里要注意不要将管道和重定向混淆，管道默认是连接前一个命令的输出到下一个命令的输入，而重定向通常是需要一个文件来建立两个命令的连接，你可以仔细体会一下上述第三个操作和最后两个操作的异同点。 2.2 标准错误重定向重定向标准输出到文件，这是一个很实用的操作，另一个很实用的操作是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的。比如下面的操作： 12345# 使用cat 命令同时读取两个文件，其中一个存在，另一个不存在$ cat Documents/test.c hello.c# 你可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息# 下面我们将输出重定向到一个文件$ cat Documents/test.c hello.c &gt; somefile 遗憾的是，这里依然出现了那条错误信息，这正是因为如我上面说的那样，标准输出和标准错误虽然都指向终端屏幕，实际它们并不一样。那有的时候我们就是要隐藏某些错误或者警告，那又该怎么做呢。这就需要用到我们前面讲的文件描述符了： 1234# 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面$ cat Documents/test.c hello.c &gt;somefile 2&gt;&amp;1# 或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件$ cat Documents/test.c hello.c &amp;&gt;somefilehell 注意你应该在输出重定向文件描述符前加上&amp;,否则 shell 会当做重定向到一个文件名为 1 的文件中 2.3 使用tee命令同时重定向到多个文件你可能还有这样的需求，除了需要将输出重定向到文件,也需要将信息打印在终端。那么你可以使用tee命令来实现： 1$ echo &#x27;hello shiyanlou&#x27; | tee hello 2.4 永久重定向你应该可以看出我们前面的重定向操作都只是临时性的，即只对当前命令有效，那如何做到“永久”有效呢，比如在一个脚本中，你需要某一部分的命令的输出全部进行重定向，难道要让你在每个命令上面加上临时重定向的操作嘛，当然不需要，我们可以使用exec命令实现“永久”重定向。exec命令的作用是使用指定的命令替换当前的 Shell，即使用一个进程替换当前进程，或者指定新的重定向： 12345678# 先开启一个子 Shell$ zsh# 使用exec替换当前进程的重定向，将标准输出重定向到一个文件$ exec 1&gt;somefile# 后面你执行的命令的输出都将被重定向到文件中,直到你退出当前子shell，或取消exec的重定向（后面将告诉你怎么做）$ ls$ exit$ cat somefile 2.5 创建输出文件描述符在 Shell 中有 9 个文件描述符。上面我们使用了也是它默认提供的 0,1,2 号文件描述符。另外我们还可以使用 3-8 的文件描述符，只是它们默认没有打开而已。你可以使用下面命令查看当前 Shell 进程中打开的文件描述符： 1$ cd /dev/fd/;ls -Al 同样使用exec命令可以创建新的文件描述符： 12345678$ zsh$ exec 3&gt;somefile# 先进入目录，再查看，否则你可能不能得到正确的结果，然后再回到上一次的目录$ cd /dev/fd/;ls -Al;cd -# 注意下面的命令&gt;与&amp;之间不应该有空格，如果有空格则会出错$ echo &quot;this is test&quot; &gt;&amp;3$ cat somefile$ exit 2.6 关闭文件描述符如上面我们打开的 3 号文件描述符，可以使用如下操作将它关闭： 12$ exec 3&gt;&amp;-$ cd /dev/fd;ls -Al;cd - 2.7 完全屏蔽命令的输出在 Linux 中有一个被称为“黑洞”的设备文件,所有导入它的数据都将被“吞噬”。 在类 UNIX 系统中，&#x2F;dev&#x2F;null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个 EOF。 我们可以利用/dev/null屏蔽命令的输出： 1$ cat Documents/test.c 1&gt;/dev/null 2&gt;&amp;1 上面这样的操作将使你得不到任何输出结果。 2.8 使用 xargs 分割参数列表 xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。 这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果，详细用法请参看 man 文档。 1$ cut -d: -f1 &lt; /etc/passwd | sort | xargs echo 上面这个命令用于将/etc/passwd文件按:分割取第一个字段排序后，使用echo命令生成一个列表。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"五、Linux下的帮助命令","slug":"E_学习笔记/Linux/Linux_实验楼/5-五、Linux下的帮助命令","date":"2022-12-27T03:12:54.026Z","updated":"2022-12-27T03:12:54.026Z","comments":true,"path":"posts/31620285.html","link":"","permalink":"https://www.mingsrc.work/posts/31620285","excerpt":"Linux下的帮助命令一、实验介绍1 实验内容我们时常使用 Linux 的命令，一些常用的命令即使不背我们也能记住，而一些较长的命令或是一些不常用的参数甚至是不常用的命令需要用时怎么也想不出来。本课程将带你好好利用 Linux 系统自带的帮助工具与文档。","text":"Linux下的帮助命令一、实验介绍1 实验内容我们时常使用 Linux 的命令，一些常用的命令即使不背我们也能记住，而一些较长的命令或是一些不常用的参数甚至是不常用的命令需要用时怎么也想不出来。本课程将带你好好利用 Linux 系统自带的帮助工具与文档。 1 实验知识点 内建命令与外部命令之分 help , man , info 命令的使用以及区别 二、内建命令与外部命令什么是内建命令，什么是外部命令呢？这和帮助命令又有什么关系呢？ 因为有一些查看帮助的工具在内建命令与外建命令上是有区别对待的。 内建命令实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在 bash 源码的 builtins 里面的，由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。 外部命令是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在&#x2F;bin，&#x2F;usr&#x2F;bin，&#x2F;sbin，&#x2F;usr&#x2F;sbin 等等。比如：ls、vi 等。 简单来说就是：一个是天生自带的天赋技能，一个是后天得来的附加技能。我们可以使用 type 命令来区分命令是内建的还是外部的。例如这两个得出的结果是不同的 123type exittype vim 得到的是两种结果，若是对 ls 你还能得到第三种结果 123456#得到这样的结果说明是内建命令，正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中xxx is a shell builtin#得到这样的结果说明是外部命令，正如上文所说，外部命令在/usr/bin or /usr/sbin等等中xxx is /usr/bin/xxx#若是得到alias的结果，说明该指令为命令别名所设定的名称；xxx is an alias for xx --xxx 三、帮助命令的使用1. help命令本实验环境是 zsh，而 zsh 中内置并没有 help 命令，我们可以进入 bash 中，在 bash 中内置有该命令 1bash 做好了以上的准备，我们就可以愉快的使用 help 命令了，我们可以尝试下这个命令: 1help ls 得到的结果如图所示，为什么是这样的结果？ 因为 help 命令是用于显示 shell 内建命令的简要帮助信息。帮助信息中显示有该命令的简要说明以及一些参数的使用以及说明，一定记住 help 命令只能用于显示内建命令的帮助信息，不然就会得到你刚刚得到的结果。 那如果是外部命令怎么办，不能就这么抛弃它呀。其实外部命令基本上都有一个参数–help,这样就可以得到相应的帮助，看到你想要的东西了。试试下面这个命令是不是能看到你想要的东西了。 1ls --help 3. man命令你可以尝试下这个命令 1man ls 得到的内容比用 help 更多更详细，而且 man 没有内建与外部命令的区分，因为 man 工具是显示系统手册页中的内容，也就是一本电子版的字典，这些内容大多数都是对命令的解释信息，还有一些相关的描述。通过查看系统文档中的 man 也可以得到程序的更多相关信息和 Linux 的更多特性。 是不是好用许多，当然也不代表 help 就没有存在的必要，当你非常紧急只是忘记该用哪个参数的时候，help 这种显示简单扼要的信息就特别实用，若是不太紧急的时候就可以用 man 这种详细描述的查询方式 在尝试上面这个命令时我们会发现最左上角显示“ LS （1）”，在这里，“ LS ”表示手册名称，而“（1）”表示该手册位于第一章节。这个章节又是什么？在 man 手册中一共有这么几个章节 章节数 说明 1 Standard commands （标准命令） 2 System calls （系统调用） 3 Library functions （库函数） 4 Special devices （设备说明） 5 File formats （文件格式） 6 Games and toys （游戏和娱乐） 7 Miscellaneous （杂项） 8 Administrative Commands （管理员命令） 9 其他（Linux 特定的）， 用来存放内核例行程序的文档。 打开手册之后我们可以通过 pgup 与 pgdn 或者上下键来上下翻看，可以按 q 退出当前页面 3. info命令要是你觉得 man 显示的信息都还不够，满足不了你的需求，那试试 info 命令，注意实验楼的环境中没有安装 info，可以手动安装，安装和操作步骤如下： 12345# 安装 info$ sudo apt-get update$ sudo apt-get install info# 查看 ls 命令的 info$ info ls 得到的信息是不是比 man 还要多了，info 来自自由软件基金会的 GNU 项目，是 GNU 的超文本帮助系统，能够更完整的显示出 GNU 信息。所以得到的信息当然更多 man 和 info 就像两个集合，它们有一个交集部分，但与 man 相比，info 工具可显示更完整的 GNU 工具信息。若 man 页包含的某个工具的概要信息在 info 中也有介绍，那么 man 页中会有“请参考 info 页更详细内容”的字样。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"六、Linux任务计划crontab","slug":"E_学习笔记/Linux/Linux_实验楼/6-六、Linux任务计划crontab","date":"2022-12-27T03:12:54.026Z","updated":"2022-12-27T03:12:54.026Z","comments":true,"path":"posts/433d7c09.html","link":"","permalink":"https://www.mingsrc.work/posts/433d7c09","excerpt":"","text":"Linux任务计划crontab一、实验介绍1.1 实验内容我们时常会有一些定期定时的任务，如周期性的清理一下／tmp，周期性的去备份一次数据库，周期性的分析日志等等。而且有时候因为某些因素的限制，执行该任务的时间会很尴尬。本课程将带你很好的利用 Linux 系统的计划工具 1.2 实验知识点 crontab 语法 1.3 参考资料本节部分内容参考以下文档制作： 例行性工作排程(crontab) - 鸟哥私房菜 Linux Crontab 百度百科 二、crontab 的使用 crontab 命令常见于 Unix 和类 Unix 的操作系统之中（Linux 就属于类 Unix 操作系统），用于设置周期性被执行的指令。 2.1 crontab简介crontab 命令从输入设备读取指令，并将其存放于 crontab 文件中，以供之后读取和执行。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。 通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。 这里我们看一看 crontab 的格式 12345678# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 2.2 crontab准备crontab 在本实验环境中需要做一些特殊的准备，首先我们会启动 rsyslog，以便我们可以通过日志中的信息来了解我们的任务是否真正的被执行了（在本实验环境中需要手动启动，而在自己本地中 Ubuntu 会默认自行启动不需要手动启动） 12sudo apt-get install -y rsyslogsudo service rsyslog start 在本实验环境中 crontab 也是不被默认启动的，同时不能在后台由 upstart 来管理，所以需要我们来启动它: 1sudo cron －f &amp; 2.3 crontab使用下面将开始 crontab 的使用了，我们通过下面一个命令来添加一个计划任务 1crontab -e 第一次启动会出现这样一个画面，这是让我们选择编辑的工具，选择第二个基本的 vim 就可以了 而选择后我们会进入这样一个画面，这就是添加计划的地方了，与一般的配置文档相同，以#号开头的都是注释，通过文档的最后一排我们可以猜猜 crontab 的格式是什么样的呢？ 详细的格式可以使用上一节中学习到的 man 命令查看： 1man crontab 在了解命令格式之后，我们通过这样的一个例子来完成一个任务的添加，在文档的最后一排加上这样一排命令,该任务是每分钟我们会在&#x2F;home&#x2F;shiyanlou 目录下创建一个以当前的年月日时分秒为名字的空白文件 1*/1 * * * * touch /home/shiyanlou/$(date +\\%Y\\%m\\%d\\%H\\%M\\%S) 注意 “ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \\ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。 添加成功后我们会得到最后一排 installing new crontab 的一个提示 当然我们也可以通过这样的一个指令来查看我们添加了哪些任务 1crontab -l 通过图中的显示，我们也可以看出，我们正确的保存并且添加成功了该任务的 虽然我们添加了任务，但是如果 cron 的守护进程并没有启动，它根本都不会监测到有任务，当然也就不会帮我们执行，我们可以通过以下 2 种方式来确定我们的 cron 是否成功的在后台启动，默默的帮我们做事，若是没有就得执行上文准备中的第二步了 12345ps aux | grep cronorpgrep cron 通过下图可以看到任务在创建之后，执行了几次，生成了一些文件，且每分钟生成一个： 我们通过这样一个命令可以查看到执行任务命令之后在日志中的信息反馈 1sudo tail -f /var/log/syslog 从图中我们可以看到分别在 13 点 28、29、30 分的 01 秒为我们在 shiyanlou 用户的家目录下创建了文件 当我们并不需要这个任务的时候我们可以使用这么一个命令去删除任务 1crontab -r 通过图中我们可以看出我们删除之后再查看任务列表，系统已经显示该用户并没有任务哦 三、crontab的深入每个用户使用 crontab -e 添加计划任务，都会在 /var/spool/cron/crontabs 中添加一个该用户自己的任务文档，这样目的是为了隔离。 如果是系统级别的定时任务，应该如何处理？只需要以 sudo 权限编辑 /etc/crontab 文件就可以。 cron 服务监测时间最小单位是分钟，所以 cron 会每分钟去读取一次 &#x2F;etc&#x2F;crontab 与 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs 里面的內容。 在 &#x2F;etc 目录下，cron 相关的目录有下面几个： 每个目录的作用： &#x2F;etc&#x2F;cron.daily，目录下的脚本会每天执行一次，在每天的 6 点 25 分时运行； &#x2F;etc&#x2F;cron.hourly，目录下的脚本会每个小时执行一次，在每小时的 17 分钟时运行； &#x2F;etc&#x2F;cron.monthly，目录下的脚本会每月执行一次，在每月 1 号的 6 点 52 分时运行； &#x2F;etc&#x2F;cron.weekly，目录下的脚本会每周执行一次，在每周第七天的 6 点 47 分时运行； 系统默认执行时间可以根据需求进行修改。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"七、命令顺序控制与管道","slug":"E_学习笔记/Linux/Linux_实验楼/7-七、命令顺序控制与管道","date":"2022-12-27T03:12:54.026Z","updated":"2022-12-27T03:12:54.026Z","comments":true,"path":"posts/5499ad08.html","link":"","permalink":"https://www.mingsrc.work/posts/5499ad08","excerpt":"","text":"七、命令顺序控制与管道1.1 实验内容顺序执行、选择执行、管道、cut 命令、grep 命令、wc 命令、sort 命令等，高效率使用 Linux 的技巧。 1.2 实验知识点 cut，grep，wc，sort命令的使用 管道的理解 二、命令执行顺序的控制通常情况下，我们每次只能在终端输入一条命令，按下回车执行，执行完成后，我们再输入第二条命令，然后再按回车执行……,当有时候我们会一次输入多条命令，这个时候的执行过程又是如何的呢？下面我们将为大家详细讲解下命令的执行顺序的控制问题。 2.1 顺序执行多条命令当我们需要使用apt-get安装一个软件，然后安装完成后立即运行安装的软件（或命令工具），又恰巧你的主机才更换的软件源还没有更新软件列表（比如之前我们的环境中，每次重新开始实验就得 sudo apt-get update，现在已经没有这个问题了）,那么你可能会有如下一系列操作： 12345$ sudo apt-get update# 等待——————————然后输入下面的命令$ sudo apt-get install some-tool //这里some-tool是指具体的软件包# 等待——————————然后输入下面的命令$ some-tool 这时你可能就会想：要是我可以一次性输入完，让它自己去依次执行各命令就好了，这就是我们这一小节要解决的问题。 简单的顺序执行你可以使用;来完成，比如上述操作你可以： 12$ sudo apt-get update;sudo apt-get install some-tool;some-tool# 让它自己运行 2.2 有选择的执行命令关于上面的操作，不知你有没有思考过一个问题，如果我们在让它自动顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖于上一条命令的结果，那么就会造成花了时间，最终却得到一个错误的结果，而且有时候直观的看你还无法判断结果是否正确。那么我们需要能够有选择性的来执行命令，比如上一条命令执行成功才继续下一条，或者不成功又该做出其它什么处理,比如我们使用which来查找是否安装某个命令，如果找到就执行该命令，否则什么也不做（虽然这个操作没有什么实际意义，但可帮你更好的理解一些概念）： 1$ which cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~ 你如果没有安装cowsay，你可以先执行一次上述命令，你会发现什么也没发生，你再安装好之后你再执行一次上述命令，你也会发现一些惊喜。 上面的&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回 0 则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果： 学习过 C 语言的用户应该知道在 C 语言里面&amp;&amp;表示逻辑与，而且还有一个||表示逻辑或，同样 Shell 也有一个||，它们的区别就在于，shell 中的这两个符号除了也可用于表示逻辑与和或之外，就是可以实现这里的命令执行顺序的简单控制。||在这里就是与&amp;&amp;相反的控制效果，当上一条命令执行结果为 ≠0($?≠0)时则执行它后面的命令： 1$ which cowsay&gt;/dev/null || echo &quot;cowsay has not been install, please run &#x27;sudo apt-get install cowsay&#x27; to install&quot; 除了上述基本的使用之外，我们还可以结合着&amp;&amp;和||来实现一些操作，比如： 1$ which cowsay&gt;/dev/null &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot; 我画个流程图来解释一下上面的流程： 三、管道管道是什么？管道是一种&#x3D;&#x3D;通信机制&#x3D;&#x3D;，通常用于进程间的通信（也可通过 socket 进行网络通信），它表现出来的形式就是&#x3D;&#x3D;将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)&#x3D;&#x3D;。 管道又分为&#x3D;&#x3D;匿名管道&#x3D;&#x3D;和&#x3D;&#x3D;具名管道&#x3D;&#x3D;（这里将不会讨论在源程序中使用系统调用创建并使用管道的情况，它与命令行的管道在内核中实际都是采用相同的机制）。我们在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由|分隔符表示，|在前面的内容中我们已经多次使用到了。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。下面我们就将通过一些常用的可以使用管道的”过滤程序”来帮助你熟练管道的使用。 3.1 试用先试用一下管道，比如查看/etc目录下有哪些文件和目录，使用ls命令来查看： 1$ ls -al /etc 有太多内容，屏幕不能完全显示，这时候可以使用滚动条或快捷键滚动窗口来查看。不过这时候可以使用管道： 1$ ls -al /etc | less 通过管道将前一个命令(ls)的输出作为下一个命令(less)的输入，然后就可以一行一行地看。 3.2 cut 命令，打印每一行的某一字段打印/etc/passwd文件中以:为分隔符的第 1 个字段和第 6 个字段分别表示用户名和其家目录： 1$ cut /etc/passwd -d &#x27;:&#x27; -f 1,6 打印/etc/passwd文件中每一行的前 N 个字符： 12345678# 前五个（包含第五个）$ cut /etc/passwd -c -5# 前五个之后的（包含第五个）$ cut /etc/passwd -c 5-# 第五个$ cut /etc/passwd -c 5# 2到5之间的（包含第五个）$ cut /etc/passwd -c 2-5 3.3 grep 命令，在文本中或 stdin 中查找匹配字符串grep命令是很强大的，也是相当常用的一个命令，它结合正则表达式可以实现很复杂却很高效的匹配和查找，不过在学习正则表达式之前，这里介绍它简单的使用，而关于正则表达式后面将会有单独一小节介绍到时会再继续学习grep命令和其他一些命令。 grep命令的一般形式为： 1grep [命令选项]... 用于匹配的表达式 [文件]... 还是先体验一下，我们搜索/home/shiyanlou目录下所有包含”shiyanlou”的文本文件，并显示出现在文本中的行号： 1$ grep -rnI &quot;shiyanlou&quot; ~ -r 参数表示递归搜索子目录中的文件,-n表示打印匹配项行号，-I表示忽略二进制文件。这个操作实际没有多大意义，但可以感受到grep命令的强大与实用。 当然也可以在匹配字段中使用正则表达式，下面简单的演示： 12# 查看环境变量中以&quot;yanlou&quot;结尾的字符串$ export | grep &quot;.*yanlou$&quot; 其中$就表示一行的末尾。 3.4 wc 命令，简单小巧的计数工具wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出/etc/passwd文件的统计信息： 1$ wc /etc/passwd 分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数： 12345678910# 行数$ wc -l /etc/passwd# 单词数$ wc -w /etc/passwd# 字节数$ wc -c /etc/passwd# 字符数$ wc -m /etc/passwd# 最长行字节数$ wc -L /etc/passwd 注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于 2 个字节的，具体数目是由字符编码决定的 再来结合管道来操作一下，下面统计 &#x2F;etc 下面所有目录数： 1$ ls -dl /etc/*/ | wc -l 3.5 sort 排序命令这个命令前面我们也是用过多次，功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。 默认为字典排序： 1$ cat /etc/passwd | sort 反转排序： 1$ cat /etc/passwd | sort -r 按特定字段排序： 1$ cat /etc/passwd | sort -t&#x27;:&#x27; -k 3 上面的-t参数用于指定字段的分隔符，这里是以”:”作为分隔符；-k 字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上-n参数： 1$ cat /etc/passwd | sort -t&#x27;:&#x27; -k 3 -n 注意观察第二个冒号后的数字： 3.6 uniq 去重命令uniq命令可以用于过滤或者输出重复行。 过滤重复行 我们可以使用history命令查看最近执行过的命令（实际为读取${SHELL}_history 文件,如我们环境中的~&#x2F;.zsh_history 文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令： 1$ history | cut -c 8- | cut -d &#x27; &#x27; -f 1 | uniq 然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序： 12$ history | cut -c 8- | cut -d &#x27; &#x27; -f 1 | sort | uniq# 或者$ history | cut -c 8- | cut -d &#x27; &#x27; -f 1 | sort -u 这就是 Linux&#x2F;UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。 输出重复行 1234# 输出重复过的行（重复的只输出一个）及重复次数$ history | cut -c 8- | cut -d &#x27; &#x27; -f 1 | sort | uniq -dc# 输出所有重复的行$ history | cut -c 8- | cut -d &#x27; &#x27; -f 1 | sort | uniq -D 文本处理命令还有很多，下一节将继续介绍一些常用的文本处理的命令。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"二、环境变量与文件查找","slug":"E_学习笔记/Linux/Linux_实验楼/2-二、环境变量与文件查找","date":"2022-12-27T03:12:54.025Z","updated":"2022-12-27T03:12:54.025Z","comments":true,"path":"posts/2e2434d7.html","link":"","permalink":"https://www.mingsrc.work/posts/2e2434d7","excerpt":"","text":"将 shiyanlou.zip 解压到当前目录： 1$ unzip shiyanlou.zip 使用安静模式，将文件解压到指定目录： 1$ unzip -q shiyanlou.zip -d ziptest 上述指定目录不存在，将会自动创建。如果你不想解压只想查看压缩包的内容你可以使用 -l 参数： 1$ unzip -l shiyanlou.zip 注意： 使用 unzip 解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。 使用 -O（英文字母，大写 o）参数指定编码类型： 1unzip -O GBK 中文压缩文件.zip 环境变量与文件查找1.环境变量 通常涉及的变量有三种： 1. 当前Shell进程私有用户自定义变量，如上面所创建的tmp变量。只有在当前Shell中有效》 2. Shell本身内建的变量。 3. 自定义变量导出的环境变量。 与上述三种环境变量相关的命令，都是用于&#x3D;&#x3D;打印环境变量信息&#x3D;&#x3D;，区别在于涉及的变量范围不同。 命令 说明 &#x3D;&#x3D;set&#x3D;&#x3D; 显示当前Shell所有变量，包括其内建环境变量（与Shell外观等相关），用户自定义变量及导出的环境变量。 &#x3D;&#x3D;env&#x3D;&#x3D; 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。 &#x3D;&#x3D;export&#x3D;&#x3D; 显示从Shell中导出成环境变量的变量，也能通过他将自定义变量导出为环境变量。 关于哪些变量是环境变量，可以简单地理解成在当前进程的子进程有效则为环境变量，否则不是（有些人也将所有变量统称为环境变量，只是以全局环境变量和局部环境变量进行区分，我们只要理解它们的实质区别即可）。 按变量的生存周期来划分，Linux 变量可分为两类： 永久的：需要修改配置文件，变量永久生效； 临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。 这里介绍两个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件： ​ .profile只对当前用户永久生效。 &#x3D;&#x3D;添加永久变量，只需打开&#x2F;etc&#x2F;profile,在最后加上想要添加的环境变量就行&#x3D;&#x3D; 1. 命令的查找路径与顺序你可能很早之前就有疑问，我们在 Shell 中输入一个命令，Shell 是怎么知道去哪找到这个命令然后执行的呢？这是通过环境变量 PATH 来进行搜索的，熟悉 Windows 的用户可能知道 Windows 中的也是有这么一个 PATH 环境变量。这个 PATH 里面就保存了 Shell 中执行的命令的搜索路径。 查看 PATH 环境变量的内容： 1echo $PATH 默认情况下你会看到如下输出： 1/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games 如果你还记得 Linux 目录结构那一节的内容，你就应该知道上面这些目录下放的是哪一类文件了。通常这一类目录下放的都是可执行文件，当我们在 Shell 中执行一个命令时，系统就会按照 PATH 中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。 下面我们将练习创建一个最简单的可执行 Shell 脚本和一个使用 C 语言创建的“ hello world ”程序，如果这两部分内容你之前没有学习过，那么你可以进行一个入门学习： C 语言入门教程 高级 Bash 脚本编程指南 Linux Shell Scripting Tutorial (LSST) v2.0 创建一个 Shell 脚本文件，你可以使用 gedit，vim，sublime 等工具编辑。如果你是直接复制的话，建议使用 gedit 或者 sublime，否则可能导致代码缩进混乱。 123cd /home/shiyanloutouch hello_shell.shgedit hello_shell.sh 在脚本中添加如下内容，保存并退出。 注意不要省掉第一行，这不是注释，论坛有用户反映有语法错误，就是因为没有了第一行 123456#!/bin/bashfor ((i=0; i&lt;10; i++));do echo &quot;hello shell&quot;doneexit 0 为文件添加可执行权限，否则执行会报错没有权限： 1chmod 755 hello_shell.sh 执行脚本： 12cd /home/shiyanlou./hello_shell.sh 创建一个 C 语言“ hello world ”程序： 123456789cd /home/shiyanlougedit hello_world.c#include &lt;stdio.h&gt;int main(void)&#123; printf(&quot;hello world!\\n&quot;); return 0;&#125; 保存后使用 gcc 生成可执行文件： 1gcc -o hello_world hello_world.c gcc 生成二进制文件默认具有可执行权限，不需要修改 在 &#x2F;home&#x2F;shiyanlou 家目录创建一个 mybin 目录，并将上述 hello_shell.sh 和 hello_world 文件移动到其中： 123cd /home/shiyanloumkdir mybinmv hello_shell.sh hello_world mybin/ 现在你可以在 mybin 目录中分别运行你刚刚创建的两个程序： 123cd mybin./hello_shell.sh./hello_world 回到上一级目录，也就是 shiyanlou 家目录，当再想运行那两个程序时，会发现提示命令找不到，除非加上命令的完整路径，但那样很不方便，如何做到像使用系统命令一样执行自己创建的脚本文件或者程序呢？那就要将命令所在路径添加到 PATH 环境变量了。 2. 添加自定义路径到“path”环境变量在前面我们应该注意到 PATH 里面的路径是以 : 作为分割符的，所以我们可以这样添加自定义路径： 1PATH=$PATH:/home/shiyanlou/mybin 注意这里一定要使用绝对路径。 现在你就可以在任意目录执行那两个命令了（注意需要去掉前面的 ./）。你可能会意识到这样还并没有很好的解决问题，因为我给 PATH 环境变量追加了一个路径，它也只是在当前 Shell 有效，我一旦退出终端，再打开就会发现又失效了。有没有方法让添加的环境变量全局有效？或者每次启动 Shell 时自动执行上面添加自定义路径到 PATH 的命令？下面我们就来说说后一种方式——让它自动执行。 在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。实验楼的环境使用的 Shell 是 zsh，它的配置文件是 .zshrc，相应的如果使用的 Shell 是 Bash，则配置文件为 .bashrc。它们在 etc 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。Shell 的种类有很多，可以使用 cat /etc/shells 命令查看当前系统已安装的 Shell。 我们可以简单地使用下面命令直接添加内容到 .zshrc 中： 1echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc 上述命令中 &gt;&gt; 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 &gt; 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。 3. 修改和删除已有变量变量修改变量的修改有以下几种方式： 变量设置方式 说明 $&#123;变量名#匹配字串&#125; 从头向后开始匹配，删除符合匹配字串的最短数据 $&#123;变量名##匹配字串&#125; 从头向后开始匹配，删除符合匹配字串的最长数据 $&#123;变量名%匹配字串&#125; 从尾向前开始匹配，删除符合匹配字串的最短数据 $&#123;变量名%%匹配字串&#125; 从尾向前开始匹配，删除符合匹配字串的最长数据 $&#123;变量名/旧的字串/新的字串&#125; 将符合旧字串的第一个字串替换为新的字串 $&#123;变量名//旧的字串/新的字串&#125; 将符合旧字串的全部字串替换为新的字串 比如我们可以修改前面添加到 PATH 的环境变量，将添加的 mybin 目录从环境变量里删除。为了避免操作失误导致命令找不到，我们先将 PATH 赋值给一个新的自定义变量 mypath： 12345mypath=$PATHecho $mypathmypath=$&#123;mypath%/home/shiyanlou/mybin&#125;# 或使用通配符,*表示任意多个任意字符mypath=$&#123;mypath%*/mybin&#125; 可以看到路径已经不存在了。 变量删除可以使用 unset 命令删除一个环境变量： 1unset mypath 4. 如何让环境变量生效前面我们在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 .zshrc），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 source 命令来让其立即生效，如： 12cd /home/shiyanlousource .zshrc source 命令还有一个别名就是 .，上面的命令如果替换成 . 的方式就该是： 1. ./.zshrc 在使用.的时候，需要注意与表示当前路径的那个点区分开。 注意第一个点后面有一个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。 2. 搜索文件与搜索相关的命令常用的有 whereis，which，find 和 locate。 whereis简单快速 12whereis whowhereis find 你会看到 whereis find 找到了三个路径，两个可执行文件路径和一个 man 在线帮助文件所在路径，这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。 whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。 locate快而全 使用 locate 命令查找文件也不会遍历硬盘，它通过查询 /var/lib/mlocate/mlocate.db 数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令来更新数据库。所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令（在我们的环境中必须先执行一次该命令）。注意这个命令也不是内置的命令，例如在我们的环境中就需要手动安装，然后执行更新。 123sudo apt-get updatesudo apt-get install locatesudo updatedb 它可以用来查找指定目录下的不同文件类型，如查找 &#x2F;etc 下所有以 sh 开头的文件： 1locate /etc/sh 注意，它不只是在 &#x2F;etc 目录下查找，还会自动递归子目录进行查找。 查找 &#x2F;usr&#x2F;share&#x2F; 下所有 jpg 文件： 1locate /usr/share/\\*.jpg 注意要添加 \\* 号前面的反斜杠转义，否则会无法找到。 如果想只统计数目可以加上 -c 参数，-i 参数可以忽略大小写进行查找，whereis 的 -b、-m、-s 同样可以使用。 which小而精 which 本身是 Shell 内建的一个命令，我们通常使用 which 来确定是否安装了某个指定的程序，因为它只从 PATH 环境变量指定的路径中去搜索命令并且返回第一个搜索到的结果。也就是说，我们可以看到某个系统命令是否存在以及执行的到底是哪一个地方的命令。 123which manwhich nginxwhich ping find精而细 find 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。find 命令强大到，要把它讲明白至少需要单独好几节课程才行，我们这里只介绍一些常用的内容。 这条命令表示去 &#x2F;etc&#x2F; 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。这是 find 命令最常见的格式，千万记住 find 的第一个参数是要搜索的地方。命令前面加上 sudo 是因为 shiyanlou 只是普通用户，对 &#x2F;etc 目录下的很多文件都没有访问的权限，如果是 root 用户则不用使用。 1sudo find /etc/ -name interfaces 注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path][option] [action] 。 与时间相关的命令参数： 参数 说明 -atime 最后访问时间 -ctime 最后修改文件内容的时间 -mtime 最后修改文件属性的时间 下面以 -mtime 参数举例： -mtime n：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件 -mtime +n：列出在 n 天之前（不包含 n 天本身）被修改过的文件 -mtime -n：列出在 n 天之内（包含 n 天本身）被修改过的文件 -newer file：file 为一个已存在的文件，列出比 file 还要新的文件名 列出 home 目录中，当天（24 小时之内）有改动的文件： 1find ~ -mtime 0 列出用户家目录下比 &#x2F;etc 目录新的文件： 1find ~ -newer /etc","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"三、文件打包与文件查找","slug":"E_学习笔记/Linux/Linux_实验楼/3-三、文件打包与压缩","date":"2022-12-27T03:12:54.025Z","updated":"2022-12-27T03:12:54.025Z","comments":true,"path":"posts/573df444.html","link":"","permalink":"https://www.mingsrc.work/posts/573df444","excerpt":"","text":"1、实验介绍1.1 实验内容介绍 Linux 上常用的压缩&#x2F;解压工具，主要讲解 zip，tar 的使用。 1.2 知识点 zip 命令 tar 命令 压缩与解压常用组合 2、概念讲解在讲 Linux 上的压缩工具之前，有必要先了解一下常见常用的压缩包文件格式。在 Windows 上最常见的不外乎这两种 *.zip，*.7z 后缀的压缩文件。而在 Linux 上面常见的格式除了以上两种外，还有 .rar，*.gz，*.xz，*.bz2，*.tar，*.tar.gz，*.tar.xz，*.tar.bz2，简单介绍如下： 文件后缀名 说明 *.zip zip 程序打包压缩的文件 *.rar rar 程序压缩的文件 *.7z 7zip 程序压缩的文件 *.tar tar 程序打包，未压缩的文件 *.gz gzip 程序（GNU zip）压缩的文件 *.xz xz 程序压缩的文件 *.bz2 bzip2 程序压缩的文件 *.tar.gz tar 打包，gzip 程序压缩的文件 *.tar.xz tar 打包，xz 程序压缩的文件 *tar.bz2 tar 打包，bzip2 程序压缩的文件 *.tar.7z tar 打包，7z 程序压缩的文件 讲了这么多种压缩文件，这么多个命令，不过我们一般只需要掌握几个命令即可，包括 zip，tar。下面会依次介绍这几个命令及对应的解压命令。 3. 实战1. zip压缩打包程序|查看压缩包 使用 zip 打包文件夹： 1234$ cd /home/shiyanlou$ zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop$ du -h shiyanlou.zip$ file shiyanlou.zip 上面命令将目录 &#x2F;home&#x2F;shiyanlou&#x2F;Desktop 打包成一个文件，并查看了打包后文件的大小和类型。第一行命令中，-r ：参数表示递归打包包含子目录的全部内容，-q ：参数表示为安静模式，即不向屏幕输出信息，-o：表示输出文件，需在其后紧跟打包输出文件名。后面使用 du 命令查看打包后文件的大小（后面会具体说明该命令）。 设置压缩级别为 9 和 1（9 最大，1 最小），重新打包： 12$ zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou/Desktop -x ~/*.zip$ zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou/Desktop -x ~/*.zip 这里添加了一个参数用于设置压缩级别 -[1-9]，1 表示最快压缩但体积大，9 表示体积最小但耗时最久。最后那个 -x 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中，注意：这里只能使用绝对路径，否则不起作用。 我们再用 du 命令分别查看默认压缩级别、最低、最高压缩级别及未压缩的文件的大小： 1$ du -h -d 0 *.zip ~ | sort 通过 man 手册可知： h， –human-readable（顾名思义，你可以试试不加的情况） d， –max-depth（所查看文件的深度） 这样一目了然，理论上来说默认压缩级别应该是最高的，但是由于文件不大，这里的差异不明显（几乎看不出差别），不过你在环境中操作之后看到的压缩文件大小可能跟图上的有些不同，因为系统在使用过程中，会随时生成一些缓存文件在当前用户的家目录中，这对于我们学习命令使用来说，是无关紧要的，可以忽略这些不同。 创建加密 zip 包 使用 -e 参数可以创建加密压缩包： 1$ zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou/Desktop 注意： 关于 zip 命令，因为 Windows 系统与 Linux&#x2F;Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux&#x2F;Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，&#x3D;&#x3D;在 Windows 系统上打开可能看起来是没有换行的&#x3D;&#x3D;。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改： 1$ zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop 需要加上 -l 参数将 LF 转换为 CR+LF 来达到以上目的。 2. 使用unzip命令解压缩文件将 shiyanlou.zip 解压到当前目录： 1$ unzip shiyanlou.zip 使用安静模式，将文件解压到指定目录： 1$ unzip -q shiyanlou.zip -d ziptest 上述指定目录不存在，将会自动创建。如果你不想解压只想查看压缩包的内容你可以使用 -l 参数： 1$ unzip -l shiyanlou.zip 注意： 使用 unzip 解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。 使用 -O（英文字母，大写 o）参数指定编码类型： 1unzip -O GBK 中文压缩文件.zip 3. tar打包工具在 Linux 上面更常用的是 tar 工具，tar 原本只是一个打包工具，只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩，所以我们也无需再单独去学习其他几个工具，tar 的解压和压缩都是同一个命令，只需参数不同，使用比较方便。 下面先掌握 tar 命令一些基本的使用方式，即不进行压缩只是进行打包（创建归档文件）和解包的操作。 创建一个 tar 包： 12$ cd /home/shiyanlou$ tar -P -cf shiyanlou.tar /home/shiyanlou/Desktop 上面命令中，-P 保留绝对路径符，-c 表示创建一个 tar 包文件，-f 用于指定创建的文件名，注意文件名必须紧跟在 -f 参数之后，比如不能写成 tar -fc shiyanlou.tar，可以写成 tar -f shiyanlou.tar -c ~。你还可以加上 -v 参数以可视的的方式输出打包的文件。 解包一个文件（-x 参数）到指定路径的已存在目录（-C 参数目标位置目录）： 12$ mkdir tardir$ tar -xf shiyanlou.tar -C tardir 只查看不解包文件 -t 参数： 1$ tar -tf shiyanlou.tar 保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（-p 参数）和备份链接指向的源文件而不是链接本身（-h 参数）： 1$ tar -cphf etc.tar /etc 对于创建不同的压缩格式的文件，对于 tar 来说是相当简单的，需要的只是换一个参数，这里我们就以使用 gzip 工具创建 *.tar.gz 文件为例来说明。 我们只需要在创建 tar 文件的基础上添加 -z 参数，使用 gzip 来压缩文件： 1$ tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop 解压 *.tar.gz 文件： 1$ tar -xzf shiyanlou.tar.gz 现在我们要使用其它的压缩工具创建或解压相应文件只需要更改一个参数即可： 压缩文件格式 参数 *.tar.gz -z *.tar.xz -J *tar.bz2 -j tar 命令的参数很多，不过常用的就是上述这些，需要了解更多你可以查看 man 手册获取帮助。 4. 总结说了这么多，其实平常使用的参数并没有那么复杂，只需要记住常用的组合就可以了。 常用命令： zip： 打包 ：zip something.zip something （目录请加 -r 参数） 解包：unzip something.zip 指定路径：-d 参数 tar： 打包：tar -cf something.tar something 解包：tar -xf something.tar 指定路径：-C 参数","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"四、文件系统与磁盘操作","slug":"E_学习笔记/Linux/Linux_实验楼/4-四、文件系统操作与磁盘管理","date":"2022-12-27T03:12:54.025Z","updated":"2022-12-27T03:12:54.025Z","comments":true,"path":"posts/2f64ad03.html","link":"","permalink":"https://www.mingsrc.work/posts/2f64ad03","excerpt":"文件系统与磁盘操作一、实验内容1. 实验内容本节实验的文件系统操作的内容十分简单，只会包含几个命令的几个参数的讲解，但掌握这些也将对你在学习 Linux 和实验楼后续其他课程的过程中有极大帮助。","text":"文件系统与磁盘操作一、实验内容1. 实验内容本节实验的文件系统操作的内容十分简单，只会包含几个命令的几个参数的讲解，但掌握这些也将对你在学习 Linux 和实验楼后续其他课程的过程中有极大帮助。 因为本课程的定位为入门基础，尽快上手，故没有打算涉及太多理论内容，前面省略了关于 Linux 文件系统的一些基本知识，也因为我们是在线实验环境，所以也避开了很少一部分但又十分重要的关于硬件的内容，我们只能期待用户能够抱着提高自学能力的心态自己去补充相关的知识。 2. 实验知识点 df，du，mount命令的使用 磁盘相关知识学习 二、基本操作2.1 查看磁盘和目录的容量使用 df 命令查看磁盘的容量1df 在实验楼的环境中你将看到如下的输出内容： 但在实际的物理主机上会更像这样： 物理主机上的 &#x2F;dev&#x2F;sda2 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），你如果主机上有多块硬盘则可能还会出现 &#x2F;dev&#x2F;sdb，&#x2F;dev&#x2F;sdc 这些磁盘设备都会在 &#x2F;dev 目录下以文件的存在形式。 接着你还会看到”1k-块”这个陌生的东西，它表示以磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用和可用容量，在你了解 Linux 的文件系统之前这个就先不管吧，我们以一种你应该看得懂的方式展示： 1df -h 现在你就可以使用命令查看你主机磁盘的使用情况了。至于挂载点如果你还记得前面第 4 节介绍 Linux 目录树结构的内容，那么你就应该能很好的理解挂载的概念，这里就不再赘述。 使用 du 命令查看目录的容量这个命令前面其实已经用了很多次了： 1234# 默认同样以 块 的大小展示du# 加上`-h`参数，以更易读的方式展示du -h -d参数指定查看目录的深度 1234# 只查看1级目录的信息du -h -d 0 ~# 查看2级du -h -d 1 ~ 常用参数 1234du -h #同--human-readable 以K，M，G为单位，提高信息的可读性。du -a #同--all 显示目录中所有文件的大小。du -s #同--summarize 仅显示总计，只列出最后加总的值。来自: http://man.linuxde.net/du du（estimate file space usage）命令与df（report file system disk space usage）命令只有一字之差，希望大家注意不要弄混淆了,你可以像我这样从 man 手册中获取命令的完整描述，记全称就不会搞混了。 三、简单的磁盘管理1. 创建虚拟磁盘dd 命令简介（部分说明来自dd (Unix) wiki）dd命令用于转换和复制文件，不过它的复制不同于cp。之前提到过关于 Linux 的很重要的一点，一切即文件，在 Linux 上，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，只是在各自的驱动程序中实现了对应的功能，dd 也可以读取文件或写入这些文件。这样，dd也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。dd程序也可以在复制时处理数据，例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。 dd的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为选项=值，而不是更标准的--选项 值或-选项=值。dd默认从标准输入中读取，并写入到标准输出中，但可以用选项if（input file，输入文件）和of（output file，输出文件）改变。 我们先来试试用dd命令从标准输入读入用户的输入到标准输出或者一个文件中： 12345# 输出到文件dd of=test bs=10 count=1 # 或者 dd if=/dev/stdin of=test bs=10 count=1# 输出到标准输出dd if=/dev/stdin of=/dev/stdout bs=10 count=1# 注在打完了这个命令后，继续在终端打字，作为你的输入 上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），count用于指定块数量。如上图所示，我指定只读取总共 10 个字节的数据，当我输入了“hello shiyanlou”之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用du和cat命令看到的写入完成文件实际内容确实只有 10 个字节（那个黑底百分号表示这里没有换行符）,而其他的多余输入将被截取并保留在标准输入。 前面说到dd在拷贝的同时还可以实现数据转换，那下面就举一个简单的例子：将输出的英文字符转换为大写再写入文件： 1dd if=/dev/stdin of=test bs=10 count=1 conv=ucase 你可以在man文档中查看其他所有转换参数。 使用 dd 命令创建虚拟镜像文件通过上面一小节，你应该掌握了dd的基本使用，下面就来使用dd命令来完成创建虚拟磁盘的第一步。 从/dev/zero设备创建一个容量为 256M 的空文件： 12$ dd if=/dev/zero of=virtual.img bs=1M count=256$ du -h virtual.img 然后我们要将这个文件格式化（写入文件系统），这里我们要学到一个（准确的说是一组）新的命令来完成这个需求。 使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）你可以在命令行输入 sudo mkfs 然后按下Tab键，你可以看到很多个以 mkfs 为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统。 我们可以简单的使用下面的命令来将我们的虚拟磁盘镜像格式化为ext4文件系统： 1$ sudo mkfs.ext4 virtual.img 可以看到实际 mkfs.ext4 是使用 mke2fs 来完成格式化工作的。mke2fs 的参数很多，不过我们也不会经常格式化磁盘来玩，所以就掌握这基本用法吧，等你有特殊需求时，再查看 man 文档解决。 更多关于文件系统的知识，请查看 wiki： 文件系统 ext3,ext4 如果你想知道 Linux 支持哪些文件系统你可以输入ls -l /lib/modules/$(uname -r)/kernel/fs（我们的环境中无法查看）查看。 使用 mount 命令挂载磁盘到目录树用户在 Linux&#x2F;UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 mount 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux&#x2F;UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。 Linux&#x2F;UNIX 命令行的 mount 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。 我们先来使用mount来查看下主机已经挂载的文件系统： 1$ sudo mount 输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。 那么我们如何挂载真正的磁盘到目录树呢，mount命令的一般格式如下： 1mount [options] [source] [directory] 一些常用操作： 1mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点] 注意：由于实验楼的环境限制，mount 命令挂载及 umount 卸载都无法进行操作，可以简单了解这些步骤。 现在直接来挂载我们创建的虚拟磁盘镜像到/mnt目录： 123456$ mount -o loop -t ext4 virtual.img /mnt# 也可以省略挂载类型，很多时候 mount 会自动识别# 以只读方式挂载$ mount -o loop --ro virtual.img /mnt# 或者mount -o loop,ro virtual.img /mnt 使用 umount 命令卸载已挂载磁盘注意：由于实验楼的环境限制，mount 命令挂载及 umount 卸载都无法进行操作，可以简单了解这些步骤。 12# 命令格式 sudo umount 已挂载设备名或者挂载点，如：$ sudo umount /mnt 不过遗憾的是，由于我们环境的问题（环境中使用的 Linux 内核在编译时没有添加对 Loop device 的支持），所以你将无法挂载成功： 另外关于 loop 设备,你可能会有诸多疑问，那么请看下面来自维基百科&#x2F;dev&#x2F;loop的说明： 在类 UNIX 系统中，&#x2F;dev&#x2F;loop（或称 vnd （vnode disk）、lofi（循环文件接口））是一种伪设备，这种设备使得文件可以如同块设备一般被访问。 在使用之前，循环设备必须与现存文件系统上的文件相关联。这种关联将提供给用户一个应用程序接口，接口将允许文件视为块特殊文件（参见设备文件系统）使用。因此，如果文件中包含一个完整的文件系统，那么这个文件就能如同磁盘设备一般被挂载。 这种设备文件经常被用于光盘或是磁盘镜像。通过循环挂载来挂载包含文件系统的文件，便使处在这个文件系统中的文件得以被访问。这些文件将出现在挂载点目录。如果挂载目录中本身有文件，这些文件在挂载后将被禁止使用。 使用 fdisk 为磁盘分区（关于分区的一些概念不清楚的用户请参看主引导记录）注意：由于实验楼的环境限制，fdisk 命令无法进行操作，可以简单了解这些步骤。 同样因为环境中没有物理磁盘，也无法创建虚拟磁盘的原因我们就无法实验练习使用该命令了，下面我将以我的物理主机为例讲解如何为磁盘分区。 12# 查看硬盘分区表信息$ sudo fdisk -l 输出结果中开头显示了我主机上的磁盘的一些信息，包括容量扇区数，扇区大小，I&#x2F;O 大小等信息。 我们重点看一下中间的分区信息，&#x2F;dev&#x2F;sda1，&#x2F;dev&#x2F;sda2 为主分区分别安装了 Windows 和 Linux 操作系统，&#x2F;dev&#x2F;sda3 为交换分区（可以理解为虚拟内存），&#x2F;dev&#x2F;sda4 为扩展分区其中包含 &#x2F;dev&#x2F;sda5，&#x2F;dev&#x2F;sda6，&#x2F;dev&#x2F;sda7，&#x2F;dev&#x2F;sda8 四个逻辑分区，因为主机上有几个分区之间有空隙，没有对齐边界扇区,所以分区之间不是完全连续的。 12# 进入磁盘分区模式$ sudo fdisk virtual.img 在进行操作前我们首先应先规划好我们的分区方案，这里我将在使用 128M（可用 127M 左右）的虚拟磁盘镜像创建一个 30M 的主分区剩余部分为扩展分区包含 2 个大约 45M 的逻辑分区。 操作完成后输入p查看结果如下: 最后不要忘记输入w写入分区表。 使用 losetup 命令建立镜像与回环设备的关联注意：由于实验楼的环境限制，losetup 命令无法进行操作，可以简单了解这些步骤。 同样因为环境原因中没有物理磁盘，也没有 loop device 的原因我们就无法实验练习使用该命令了，下面我将以我的物理主机为例讲解。 12345$ sudo losetup /dev/loop0 virtual.img# 如果提示设备忙你也可以使用其它的回环设备，&quot;ls /dev/loop*&quot;参看所有回环设备# 解除设备关联$ sudo losetup -d /dev/loop0 然后再使用mkfs格式化各分区（前面我们是格式化整个虚拟磁盘镜像文件或磁盘），不过格式化之前，我们还要为各分区建立虚拟设备的映射，用到kpartx工具，需要先安装： 12345$ sudo apt-get install kpartx$ sudo kpartx -av /dev/loop0# 取消映射$ sudo kpartx -dv /dev/loop0 接着再是格式化，我们将其全部格式化为 ext4： 123$ sudo mkfs.ext4 -q /dev/mapper/loop0p1$ sudo mkfs.ext4 -q /dev/mapper/loop0p5$ sudo mkfs.ext4 -q /dev/mapper/loop0p6 格式化完成后在/media目录下新建四个空目录用于挂载虚拟磁盘： 12345678910$ mkdir -p /media/virtualdisk_&#123;1..3&#125;# 挂载磁盘分区$ sudo mount /dev/mapper/loop0p1 /media/virtualdisk_1$ sudo mount /dev/mapper/loop0p5 /media/virtualdisk_2$ sudo mount /dev/mapper/loop0p6 /media/virtualdisk_3# 卸载磁盘分区$ sudo umount /dev/mapper/loop0p1$ sudo umount /dev/mapper/loop0p5$ sudo umount /dev/mapper/loop0p6 然后： 1$ df -h","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"十三、Linux 进程管理","slug":"E_学习笔记/Linux/Linux_实验楼/13-十三、Linux进程管理","date":"2022-12-27T03:12:54.024Z","updated":"2022-12-27T03:12:54.024Z","comments":true,"path":"posts/428e1ceb.html","link":"","permalink":"https://www.mingsrc.work/posts/428e1ceb","excerpt":"","text":"Linux 进程管理一、实验介绍1.1 实验内容通过本实验我们将掌握一些 Linux 所提供的工具来进行进程的查看与控制，掌握这些工具让我们能在某些进程出现异常的时候及时查看相关的指标，从而解决问题。 1.2 实验知识点 查看进程的运行状态 进程的结束控制 进程的执行顺序 二、 进程的查看不管在测试的时候、在实际的生产环境中，还是自己的使用过程中，难免会遇到一些进程异常的情况，所以 Linux 为我们提供了一些工具来查看进程的状态信息。我们可以通过 top 实时的查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 ps 来静态查看当前的进程信息，同时我们还可以使用 pstree 来查看当前活跃进程的树形结构。 2.1 top 工具的使用top 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化: 1top top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。 我们看到 top 显示的第一排， 内容 解释 top 表示当前程序的名称 11:05:18 表示当前的系统的时间 up 8 days,17:12 表示该机器已经启动了多长时间 1 user 表示当前系统中只有一个用户 load average: 0.29,0.20,0.25 分别对应 1、5、15 分钟内 cpu 的平均负载 load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。 我们该如何看待这个 load average 数据呢？ 假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把 CPU 任务比作汽车。 load &#x3D; 0 的时候意味着这个桥上并没有车，cpu 没有任何任务； load &lt; 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足； load &#x3D; 1 的时候就意味着桥已经被车给占满了，没有一点空隙，cpu 已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已； load &gt; 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力工作，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于 2 表示进程请求超过 CPU 工作能力的 2 倍。而若是这个值大于 5 说明系统已经在超负荷运作了。 这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过以下的命令来查看 CPU 的个数与核心数 12345#查看物理 CPU 的个数cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq |wc -l#每个 cpu 的核心数cat /proc/cpuinfo | grep &quot;physical id&quot; | grep &quot;0&quot; | wc -l 通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为 0.7。这里的指数都是除以核心数以后的值，不要混淆了 若是 load &lt; 0.7 并不会去关注他； 若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了； 若是 load &#x3D; 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了； 若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了 通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。 查看 busybox 的代码可以知道，数据是每 5 秒钟就检查一次活跃的进程数，然后计算出该值，然后 load 从 /proc/loadavg 中读取的。而这个 load 的值是如何计算的呢，这是 load 的计算的源码 1234567891011121314151617181920212223242526272829#define FSHIFT 11 /* nr of bits of precision */#define FIXED_1 (1&lt;&lt;FSHIFT) /* 1.0 as fixed-point(定点) */#define LOAD_FREQ (5*HZ) /* 5 sec intervals，每隔5秒计算一次平均负载值 */#define CALC_LOAD(load, exp, n) \\ load *= exp; \\ load += n*(FIXED_1 - exp); \\ load &gt;&gt;= FSHIFT;unsigned long avenrun[3];EXPORT_SYMBOL(avenrun);/** calc_load - given tick count, update the avenrun load estimates.* This is called while holding a write_lock on xtime_lock.*/static inline void calc_load(unsigned long ticks)&#123; unsigned long active_tasks; /* fixed-point */ static int count = LOAD_FREQ; count -= ticks; if (count &lt; 0) &#123; count += LOAD_FREQ; active_tasks = count_active_tasks(); CALC_LOAD(avenrun[0], EXP_1, active_tasks); CALC_LOAD(avenrun[1], EXP_5, active_tasks); CALC_LOAD(avenrun[2], EXP_15, active_tasks); &#125;&#125; 有兴趣的朋友可以研究一下，是如何计算的。代码中的后面这部分相当于它的计算公式 我们回归正题，来看 top 的第二行数据，基本上第二行是进程的一个情况统计 内容 解释 Tasks: 26 total 进程总数 1 running 1 个正在运行的进程数 25 sleeping 25 个睡眠的进程数 0 stopped 没有停止的进程数 0 zombie 没有僵尸进程数 来看 top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了 内容 解释 Cpu(s): 1.0%us 用户空间进程占用 CPU 百分比 1.0% sy 内核空间运行占用 CPU 百分比 0.0%ni 用户进程空间内改变过优先级的进程占用 CPU 百分比 97.9%id 空闲 CPU 百分比 0.0%wa 等待输入输出的 CPU 时间百分比 0.1%hi 硬中断(Hardware IRQ)占用 CPU 的百分比 0.0%si 软中断(Software IRQ)占用 CPU 的百分比 0.0%st (Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比 CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。 来看 top 的第四行数据，这一行基本上是内存的一个使用情况的统计了： 内容 解释 8176740 total 物理内存总量 8032104 used 使用的物理内存总量 144636 free 空闲内存总量 313088 buffers 用作内核缓存的内存量 注意： 系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和。 来看 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了： 内容 解释 total 交换区总量 used 使用的交换区总量 free 空闲交换区总量 cached 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖 再下面就是进程的一个情况了 列名 解释 PID 进程 id USER 该进程的所属用户 PR 该进程执行的优先级 priority 值 NI 该进程的 nice 值 VIRT 该进程任务所使用的虚拟内存的总数 RES 该进程所使用的物理内存数，也称之为驻留内存数 SHR 该进程共享内存的大小 S 该进程进程的状态: S&#x3D;sleep R&#x3D;running Z&#x3D;zombie %CPU 该进程 CPU 的利用率 %MEM 该进程内存的利用率 TIME+ 该进程活跃的总时间 COMMAND 该进程运行的名字 注意: NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20 至 19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice 值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低。 PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0-99 是实时进程的值，而 100-139 是给用户的。 其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是 nice 值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同。 VIRT 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap 空间的页面等所占据空间的总数。 在上文我们曾经说过 top 是一个前台程序，所以是一个可以交互的： 常用交互命令 解释 q 退出程序 I 切换显示平均负载和启动时间的信息 P 根据 CPU 使用百分比大小进行排序 M 根据驻留内存大小进行排序 i 忽略闲置和僵死的进程，这是一个开关式命令 k 终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。 好好的利用 top 能够很有效的帮助我们观察到系统的瓶颈所在，或者是系统的问题所在。 2.2 ps 工具的使用ps 也是我们最常用的查看进程的工具之一，我们通过这样的一个命令来了解一下，他能给我带来哪些信息 1ps aux 1ps axjf 我们来总体了解下会出现哪些信息给我们，这些信息又代表着什么（更多的 keywords 大家可以通过 man ps 了解）。 内容 解释 F 进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限 USER 进程的拥有用户 PID 进程的 ID PPID 其父进程的 PID SID session 的 ID TPGID 前台进程组的 ID %CPU 进程占用的 CPU 百分比 %MEM 占用内存的百分比 NI 进程的 NICE 值 VSZ 进程使用虚拟内存大小 RSS 驻留内存中页的大小 TTY 终端 ID S or STAT 进程状态 WCHAN 正在等待的进程资源 START 启动进程的时间 TIME 进程消耗 CPU 的时间 COMMAND 命令的名称和参数 TPGID栏写着-1 的都是没有控制终端的进程，也就是守护进程 STAT表示进程的状态，而进程的状态有很多，如下表所示 状态 解释 R Running.运行中 S Interruptible Sleep.等待调用 D Uninterruptible Sleep.不可中断睡眠 T Stoped.暂停或者跟踪状态 X Dead.即将被撤销 Z Zombie.僵尸进程 W Paging.内存交换 N 优先级低的进程 &lt; 优先级高的进程 s 进程的领导者 L 锁定状态 l 多线程状态 + 前台进程 其中的 D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于 D 状态的进程，无论是 kill，kill -9 还是 kill -15，一般处于这种状态可能是进程 I&#x2F;O 的时候出问题了。 ps 工具有许多的参数，下面给大家解释部分常用的参数。 使用 -l 参数可以显示自己这次登录的 bash 相关的进程信息罗列出来： 1ps -l 相对来说我们更加常用下面这个命令，他将会罗列出所有的进程信息： 1ps aux 若是查找其中的某个进程的话，我们还可以配合着 grep 和正则表达式一起使用： 1ps aux | grep zsh 此外我们还可以查看时，将连同部分的进程呈树状显示出来： 1ps axjf 当然如果你觉得使用这样的此时没有把你想要的信息放在一起，我们也可以是用这样的命令，来自定义我们所需要的参数显示： 1ps -afxo user,ppid,pid,pgid,command 这是一个简单而又实用的工具，想要更灵活的使用，想要知道更多的参数我们可以使用 man 来获取更多相关的信息。 2.3 pstree 工具的使用通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。 1pstree 1pstree -up 参数选择 解释 -A 程序树之间以 ASCII 字符连接 -p 同时列出每个 process 的 PID -u 同时列出每个 process 的所属账户名称 三、进程的管理3.1 kill 命令的掌握上个实验中我们讲诉了进程之间是如何衍生，之间又有什么相关性，我们来回顾一下，当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等。 上节课程我们使用 kill 命令来管理我们的一些 job，这节课我们将尝试用 kill 来操作下一些不属于 job 范畴的进程，直接对 pid 下手。 12345678# 首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到ps aux# 使用 9 这个信号强制结束 gedit 进程kill -9 1608# 我们再查找这个进程的时候就找不到了ps aux | grep gedit 3.2 进程的执行顺序我们在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，那么该谁最先享受 CPU 的服务，后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？ 当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了 而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 -20 ~ 19，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 0 ~ 19，因为系统为了避免一般用户抢占系统资源而设置的一个限制 1234567# 这个实验在环境中无法做，因为权限不够，可以自己在本地尝试# 打开一个程序放在后台，或者用图形界面打开nice -n -5 vim &amp;# 用 ps 查看其优先级ps -afxo user,ppid,pid,stat,pri,ni,time,command | grep vim 我们还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试。 1renice -5 pid","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"十四、Linux 日志系统","slug":"E_学习笔记/Linux/Linux_实验楼/14-十四、Linux日志","date":"2022-12-27T03:12:54.024Z","updated":"2022-12-27T03:12:54.024Z","comments":true,"path":"posts/de6197c0.html","link":"","permalink":"https://www.mingsrc.work/posts/de6197c0","excerpt":"","text":"Linux 日志系统一、实验介绍1.1 实验内容日志数据可以是有价值的信息宝库，也可以是毫无价值的数据泥潭。它可以记录下系统产生的所有行为，并按照某种规范表达出来。我们可以使用日志系统所记录的信息为系统进行排错，优化系统的性能，或者根据这些信息调整系统的行为。收集你想要的数据，分析出有价值的信息，可以提高系统、产品的安全性，还可以帮助开发完善代码，优化产品。日志会成为在事故发生后查明“发生了什么”的一个很好的“取证”信息来源。日志可以为审计进行审计跟踪。 1.2 实验知识点 常见的日志 配置的日志 轮替的日志 二、常见的日志日志是一个系统管理员，一个运维人员，甚至是开发人员不可或缺的东西，系统用久了偶尔也会出现一些错误，我们需要日志来给系统排错，在一些网络应用服务不能正常工作的时候，我们需要用日志来做问题定位，日志还是过往时间的记录本，我们可以通过它知道我们是否被不明用户登录过等等。 在 Linux 中大部分的发行版都内置使用 syslog 系统日志，那么通过前期的课程我们了解到常见的日志一般存放在 /var/log 中，我们来看看其中有哪些日志 根据图中所显示的日志，我们可以根据服务对象粗略的将日志分为两类 系统日志 应用日志 系统日志主要是存放系统内置程序或系统内核之类的日志信息如 alternatives.log 、btmp 等等，应用日志主要是我们装的第三方应用所产生的日志如 tomcat7 、apache2 等等。 接下来我们来看看常见的系统日志有哪些，他们都记录了怎样的信息 日志名称 记录信息 alternatives.log 系统的一些更新替代信息记录 apport.log 应用程序崩溃信息记录 apt&#x2F;history.log 使用 apt-get 安装卸载软件的信息记录 apt&#x2F;term.log 使用 apt-get 时的具体操作，如 package 的下载、打开等 auth.log 登录认证的信息记录 boot.log 系统启动时的程序服务的日志信息 btmp 错误的信息记录 Consolekit&#x2F;history 控制台的信息记录 dist-upgrade dist-upgrade 这种更新方式的信息记录 dmesg 启动时，显示屏幕上内核缓冲信息，与硬件有关的信息 dpkg.log dpkg 命令管理包的日志。 faillog 用户登录失败详细信息记录 fontconfig.log 与字体配置有关的信息记录 kern.log 内核产生的信息记录，在自己修改内核时有很大帮助 lastlog 用户的最近信息记录 wtmp 登录信息的记录。wtmp 可以找出谁正在进入系统，谁使用命令显示这个文件或信息等 syslog 系统信息记录 而在本实验环境中没有 apport.log 是因为 apport 这个应用程序需要读取一些内核的信息来收集判断其他应用程序的信息，从而记录应用程序的崩溃信息。而在本实验环境中我们没有这个权限，所以将 apport 从内置应用值剔除，自然而然就没有它的日志信息了。 只闻其名，不见其人，我们并不能明白这些日志记录的内容。首先我们来看 alternatives.log 中的信息，在本实验环境中没有任何日志输出是因为刚刚启动的系统中并没有任何的更新迭代。我可以看看从其他地方截取过来的内容 123update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/x-www-browser x-www-browser /usr/bin/google-chrome-stable 200update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/gnome-www-browser gnome-www-browser /usr/bin/google-chrome-stable 200update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/google-chrome google-chrome /usr/bin/google-chrome-stable 200 我们可以从中得到的信息有程序作用，日期，命令，成功与否的返回码。 我们用这样的命令来看看 auth.log 中的信息： 1sudo less /var/log/auth.log 我们可以从中得到的信息有日期与 ip 地址的来源以及的用户与工具。 在 /var/log/apt 文件夹中有两个日志文件 history.log 与 term.log，两个日志文件的区别在于 history.log 主要记录了进行了哪个操作，相关的依赖有哪些，而 term.log 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。 如果是刚刚开启的新系统，那么按理说这些日志应该都是空的。 12sudo cat /var/log/apt/history.logsudo cat /var/log/apt/term.log 但是在实验环境中因为是启动的我们定制后的环境，所以两个日志中还残留了配置镜像的记录。可以先删除这两个文件然后再执行新的安装命令。 12sudo rm /var/log/apt/history.logsudo rm /var/log/apt/term.log 我们来安装 git 这个程序，因为实验环境里已经预装了 git，所以这里真正执行的操作是一个更新的操作，但这并不影响。 1sudo apt-get install git 成功的执行之后我们再来查看两个日志的内容变化： 其他的日志格式也都类似于之前我们所查看的日志，主要便是时间，操作。而这其中有两个比较特殊的日志，其查看的方式比较与众不同，因为这两个日志并不是 ASCII 文件而是被编码成了二进制文件，所以我们并不能直接使用 less、cat、more 这样的工具来查看，这两个日志文件是 wtmp，lastlog 我们查看的方法是使用 last 与 lastlog 工具来提取其中的信息 关于这两个工具的更深入使用我们可以使用前面的学习过的 man 来查看 三、配置的日志这些日志是如何产生的？通过上面的例子我们可以看出大部分的日志信息似乎格式都很类似，并且都出现在这个文件夹中。 这样的实现可以通过两种方式： 一种是由软件开发商自己来自定义日志格式然后指定输出日志位置； 一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。 syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然随着时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具 rsyslog 的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。 这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd 因为一些原因本实验环境中默认并没有打开这个服务，我们可以手动开启这项服务，然后来查看 1234sudo apt-get updatesudo apt-get install -y rsyslogsudo service rsyslog startps aux | grep syslog 既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务 首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个， 一个是 /etc/rsyslog.conf 一个是 /etc/rsyslog.d/50-default.conf。 第一个主要是配置的环境，也就是 rsyslog 加载什么模块，文件的所属者等；而第二个主要是配置的 Filter Conditions 123vim /etc/rsyslog.confvim /etc/rsyslog.d/50-default.conf 也不知道他在写什么，我们还是来看看 rsyslog 的结构框架，数据流的走向吧。 通过这个简单的流程图我们可以知道 rsyslog 主要是由 Input、Output、Parser 这样三个模块构成的，并且了解到数据的简单走向，首先通过 Input module 来收集消息，然后将得到的消息传给 Parser module，通过分析模块的层层处理，将真正需要的消息传给 Output module，然后便输出至日志文件中。 上文提到过 rsyslog 号称可以提供超过每秒一百万条消息给目标文件，怎么只是这样简单的结构。我们可以通过下图来做更深入的了解 （图片来源于http://www.rsyslog.com/doc/queues_analogy.html） Rsyslog 架构如图中所示，从图中我们可以很清楚的看见，rsyslog 还有一个核心的功能模块便是 Queue，也正是因为它才能做到如此高的并发。 第一个模块便是 Input，该模块的主要功能就是从各种各样的来源收集 messages，通过这些接口实现： 接口名 作用 im3195 RFC3195 Input Module imfile Text File Input Module imgssapi GSSAPI Syslog Input Module imjournal Systemd Journal Input Module imklog Kernel Log Input Module imkmsg &#x2F;dev&#x2F;kmsg Log Input Module impstats Generate Periodic Statistics of Internal Counters imptcp Plain TCP Syslog imrelp RELP Input Module imsolaris Solaris Input Module imtcp TCP Syslog Input Module imudp UDP Syslog Input Module imuxsock Unix Socket Input 而 Output 中也有许多可用的接口，可以通过 man 或者官方的文档查看 而这些模块接口的使用需要通过 $ModLoad 指令来加载，那么返回上文的图中，配置生效的头两行可以看懂了，默认加载了 imklog、imuxsock 这两个模块 在配置中 rsyslog 支持三种配置语法格式： sysklogd legacy rsyslog RainerScript sysklogd 是老的简单格式，一些新的语法特性不支持。而 legacy rsyslog 是以 dollar 符($)开头的语法，在 v6 及以上的版本还在支持，就如上文所说的 $ModLoad 还有一些插件和特性只在此语法下支持。而以 $ 开头的指令是全局指令，全局指令是 rsyslogd 守护进程的配置指令，每行只能有一个指令。 RainnerScript 是最新的语法。在官网上 rsyslog 大多推荐这个语法格式来配置 老的语法格式（sysklogd &amp; legacy rsyslog）是以行为单位。新的语法格式（RainnerScript）可以分割多行。 注释有两种语法: 井号 # C-style /* .. */ 执行顺序: 指令在 rsyslog.conf 文件中是从上到下的顺序执行的。 模板是 rsyslog 一个重要的属性，它可以控制日志的格式，支持类似 template() 语句的基于 string 或 plugin 的模板，通过它我们可以自定义日志格式。 legacy 格式使用 $template 的语法，不过这个在以后要移除，所以最好使用新格式 template():，以免未来突然不工作了也不知道为什么 模板定义的形式有四种，适用于不同的输出模块，一般简单的格式，可以使用 string 的形式，复杂的格式，建议使用 list 的形式，使用 list 的形式，可以使用一些额外的属性字段（property statement） 如果不指定输出模板，rsyslog 会默认使用 RSYSLOG_DEFAULT。若想更深入的学习可以查看官方文档 了解了 rsyslog 环境的配置文件之后，我们看向 /etc/rsyslog.d/50-default.conf 这个配置文件，这个文件中主要是配置的 Filter Conditions，也就是我们在流程图中所看见的 Parser &amp; Filter Engine，它的名字叫 Selectors 是过滤 syslog 的传统方法，他主要由两部分组成，facility 与 priority，其配置格式如下： 1facility.priority log_location 其中一个 priority 可以指定多个 facility，多个 facility 之间使用逗号 , 分割开 rsyslog 通过 Facility 的概念来定义日志消息的来源，以便对日志进行分类，Facility 的种类有： 类别 解释 kern 内核消息 user 用户信息 mail 邮件系统消息 daemon 系统服务消息 auth 认证系统 authpriv 权限系统 syslog 日志系统自身消息 cron 计划安排 news 新闻信息 local0~7 由自定义程序使用 而另外一部分 priority 也称之为 serverity level，除了日志的来源以外，对统一源产生日志消息还需要进行优先级的划分，而优先级的类别有以下几种： 类别 解释 emergency 系统已经无法使用了 alert 必须立即处理的问题 critical 很严重了 error 错误 warning 警告信息 notice 系统正常，但是比较重要 informational 正常 debug debug 的调试信息 panic 很严重但是已淘汰不常用 none 没有优先级，不记录任何日志消息 我们来看看系统中的配置 1auth,authpriv.* /var/log/auth.log 这里的意思是 auth 与 authpriv 的所有优先级的信息全都输出于 /var/log/auth.log 日志中 而其中有类似于这样的配置信息意思有细微的差别 1kern.* -/var/log/kern.log - 代表异步写入，也就是日志写入时不需要等待系统缓存的同步，也就是日志还在内存中缓存也可以继续写入无需等待完全写入硬盘后再写入。通常用于写入数据比较大时使用。 到此我们对 rsyslog 的配置就有了一定的了解，若想更深入学习模板，队列的高级应用，大家可去查看官网的文档，需要注意的是 rsyslog 每个版本之间差异化比较大，学习之前先查看自己所使用的版本，再去查看相关的文档 与日志相关的还有一个还有常用的命令 logger，logger 是一个 shell 命令接口，可以通过该接口使用 Syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入信息。 12345678#首先将syslog启动起来sudo service rsyslog start#向 syslog 写入数据ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp;#查看是否有数据写入sudo tail -f /var/log/syslog 从图中我们可以看到我们成功的将 ping 的信息写入了 syslog 中，格式也就是使用的 rsyslog 的默认模板 我们可以通过 man 来查看 logger 的其他用法， 参数 内容 -i 在每行都记录进程 ID -t 添加 tag 标签 -p 设置日志的 facility 与 priority 四、转储的日志在本地的机器中每天都有成百上千条日志被写入文件中，更别说是我们的服务器，每天都会有数十兆甚至更多的日志信息被写入文件中，如果是这样的话，每天看着我们的日志文件不断的膨胀，那岂不是要占用许多的空间，所以有个叫 logrotate 的东西诞生了。 logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件。我们可以根据日志文件的大小，也可以根据其天数来切割日志、管理日志，这个过程又叫做“转储”。 大多数 Linux 发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。 显而易见，logrotate 是基于 CRON 来运行的，其脚本是 &#x2F;etc&#x2F;cron.daily&#x2F;logrotate；同时我们可以在 /etc/logrotate 中找到其配置文件 1cat /etc/logrotate.conf 这其中的具体意思是什么呢？ 1234567891011121314151617# see &quot;man logrotate&quot; for details //可以查看帮助文档# rotate log files weeklyweekly //设置每周转储一次(daily、weekly、monthly当然可以使用这些参数每天、星期，月 )# keep 4 weeks worth of backlogsrotate 4 //最多转储4次# create new (empty) log files after rotating old onescreate //当转储后文件不存在时创建它# uncomment this if you want your log files compressedcompress //通过gzip压缩方式转储（nocompress可以不压缩）# RPM packages drop log rotation information into this directoryinclude /etc/logrotate.d //其他日志文件的转储方式配置文件，包含在该目录下# no packages own wtmp -- we&#x27;ll rotate them here/var/log/wtmp &#123; //设置/var/log/wtmp日志文件的转储参数 monthly //每月转储 create 0664 root utmp //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664 rotate 1 //最多转储一次&#125; 当然在 &#x2F;etc&#x2F;logrotate.d&#x2F; 中有各项应用的 logrotate 配置，还有更多的配置参数，大家可以使用 man 查看，如按文件大小转储，按当前时间格式命名等等参数配置。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"十一、Linux下的软件安装","slug":"E_学习笔记/Linux/Linux_实验楼/11-十一、Linux下的软件安装","date":"2022-12-27T03:12:54.023Z","updated":"2022-12-27T03:12:54.023Z","comments":true,"path":"posts/3f5a894e.html","link":"","permalink":"https://www.mingsrc.work/posts/3f5a894e","excerpt":"","text":"Linux下的软件安装一、实验介绍1.1 实验内容介绍 Ubuntu 下软件安装的几种方式，及 apt，dpkg 工具的使用。 1.2 实验知识点通常 Linux 上的软件安装主要有四种方式： 在线安装 从磁盘安装 deb 软件包 从二进制软件包安装 从源代码编译安装 这几种安装方式各有优劣，而大多数软件包会采用多种方式发布软件，所以我们常常需要全部掌握这几种软件安装方式，以便适应各种环境。下面将介绍前三种安装方式，从源码编译安装你将在 Linux 程序设计中学习到。 二、开始试想一下，平时我们在使用 Windows 的时候，想要安装一个软件，我们需要在网上去下载对应软件的安装包，接着安装的时候就是不断的去点击下一步，这些流程想必大家已经经历无数回了，但是在 Linux 下，一个命令加回车，等待一下，软件就安装好了，这就是方便的在线安装软件的方式。在学习这种安装方式之前有一点需要说明的是，**在不同的 linux 发行版上面在线安装方式会有一些差异包括使用的命令及它们的包管理工具，因为我们的开发环境是基于 ubuntu 的，所以这里我们涉及的在线安装方式将只适用于 ubuntu 发行版，或其它基于 ubuntu 的发行版如国内的 ubuntukylin(优麒麟)，ubuntu 又是基于 debian 的发行版，它使用的是 debian 的包管理工具 dpkg，所以一些操作也适用于 debian。而在一些采用其它包管理工具的发行版如 redhat，centos,fedora 等将不适用(redhat 和 centos 使用 rpm)**。 2.1 先体验一下比如我们想安装一个软件，名字叫做 w3m(w3m 是一个命令行的简易网页浏览器)，那么输入如下命令： 1sudo apt-get install w3m 这样的操作你应该在前面的章节中看到过很多次了，它就表示将会安装一个软件包名为w3m的软件 我们来看看命令执行后的效果： 1w3m https://www.lanqiao.cn/faq 注意:如果你在安装一个软件之后，无法立即使用Tab键补全这个命令，你可以尝试先执行source ~/.zshrc，然后你就可以使用补全操作。 2.2 apt 包管理工具介绍 APT 是 Advance Packaging Tool（高级包装工具）的缩写，是 Debian 及其派生发行版的软件包管理器，APT 可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了 Unix 系统上管理软件的过程。APT 最早被设计成 dpkg 的前端，用来处理 deb 格式的软件包。现在经过 APT-RPM 组织修改，APT 已经可以安装在支持 RPM 的系统管理 RPM 包。这个包管理器包含以 apt- 开头的多个工具，如 apt-get apt-cache apt-cdrom 等，在 Debian 系列的发行版中使用。 当你在执行安装操作时，首先apt-get 工具会在本地的一个数据库中搜索关于 w3m 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装，这里大家可能会一个疑问：既然是在线安装软件，为啥会在本地的数据库中搜索？要解释这个问题就得提到几个名词了： 软件源镜像服务器 软件源 我们需要定期从服务器上下载一个软件包列表，使用 sudo apt-get update 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有软件依赖信息的记录，对于软件依赖，我举个例子：我们安装 w3m 软件的时候，而这个软件需要 libgc1c2 这个软件包才能正常工作，这个时候 apt-get 在安装软件的时候会一并替我们安装了，以保证 w3m 能正常的工作。 2.3 apt-getapt-get 是用于处理 apt包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些apt-get包含的常用的一些工具： 工具 说明 install 其后加上软件包名，用于安装一个软件包 update 从软件源镜像服务器上下载&#x2F;更新用于更新本地软件源的软件包列表 upgrade 升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次update dist-upgrade 解决依赖关系并升级(存在一定危险性) remove 移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件 autoremove 移除之前被其他软件包依赖，但现在不再被使用的软件包 purge 与 remove 相同，但会完全移除软件包，包含其配置文件 clean 移除下载到本地的已经安装的软件包，默认保存在&#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F; autoclean 移除已安装的软件的旧版本软件包 下面是一些apt-get常用的参数： 参数 说明 -y 自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用 -s 模拟安装 -q 静默安装方式，指定多个q或者-q=#,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用 -f 修复损坏的依赖关系 -d 只下载不安装 --reinstall 重新安装已经安装但可能存在问题的软件包 --install-suggests 同时安装 APT 给出的建议安装的软件包 2.4 安装软件包关于安装，如前面演示的一样你只需要执行apt-get install &lt;软件包名&gt;即可，除了这一点，你还应该掌握的是如何重新安装软件包。 很多时候我们需要重新安装一个软件包，比如你的系统被破坏，或者一些错误的配置导致软件无法正常工作。 你可以使用如下方式重新安装： 1sudo apt-get --reinstall install w3m 另一个你需要掌握的是，如何在不知道软件包完整名的时候进行安装。通常我们是使用Tab键补全软件包名，后面会介绍更好的方法来搜索软件包。有时候你需要同时安装多个软件包，你还可以使用正则表达式匹配软件包名进行批量安装。 2.5 软件升级12345678# 更新软件源sudo apt-get update# 升级没有依赖问题的软件包sudo apt-get upgrade# 升级并解决依赖关系sudo apt-get dist-upgrade 2.6 卸载软件如果你现在觉得 w3m 这个软件不合自己的胃口或者是找到了更好的，你需要卸载它。那么简单！同样是一个命令加回车 sudo apt-get remove w3m，系统会有一个确认的操作，之后这个软件便“滚蛋了”。 或者，你可以执行 12345# 不保留配置文件的移除$ sudo apt-get purge w3m# 或者 sudo apt-get --purge remove# 移除不再需要的被依赖的软件包$ sudo apt-get autoremove 2.7 软件搜索当自己刚知道了一个软件，想下载使用，需要确认软件仓库里面有没有，就需要用到搜索功能了，命令如下： 1sudo apt-cache search softname1 softname2 softname3…… apt-cache 命令则是针对本地数据进行相关操作的工具，search 顾名思义在本地的数据库中寻找有关 softname1 softname2 相关软件的信息。现在我们试试搜索一下之前我们安装的软件 w3m ，如图： 结果显示了 4 个 w3m 相关的软件，并且有相关软件的简介。 关于在线安装的内容我们就介绍这么多，想了解更多关于 APT 的内容，你可以参考： APT HowTo 三、使用 dpkg本节讲解如何使用 dpkg 从本地磁盘安装 deb 软件包。 3.1 dpkg 介绍 dpkg 是 Debian 软件包管理器的基础，它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似，同样被用于安装、卸载和供给和 .deb 软件包相关的信息。 dpkg 本身是一个底层的工具。上层的工具，像是 APT，被用于从远程获取软件包以及处理复杂的软件包关系。”dpkg”是”Debian Package”的简写。 我们经常可以在网络上见到以deb形式打包的软件包，就需要使用dpkg命令来安装。 dpkg常用参数介绍： 参数 说明 -i 安装指定 deb 包 -R 后面加上目录名，用于安装该目录下的所有 deb 安装包 -r remove，移除某个已安装的软件包 -I 显示deb包文件的信息 -s 显示已安装软件的信息 -S 搜索已安装的软件包 -L 显示已安装软件包的目录信息 3.2 使用 dpkg 安装 deb 软件包我们先使用apt-get加上-d参数只下载不安装，下载 emacs 编辑器的 deb 包： 12sudo apt-get updatesudo apt-get -d install -y emacs 下载完成后，我们可以查看&#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;目录下的内容，如下图： 然后我们将第一个deb拷贝到 &#x2F;home&#x2F;shiyanlou 目录下，并使用dpkg安装 123cp /var/cache/apt/archives/emacs24_24.5+1-6ubuntu1.1_amd64.deb ~# 安装之前参看deb包的信息sudo dpkg -I emacs24_24.5+1-6ubuntu1.1_amd64.deb 如你所见，这个包还额外依赖了一些软件包，这意味着，如果主机目前没有这些被依赖的软件包，直接使用 dpkg 安装可能会存在一些问题，因为dpkg并不能为你解决依赖关系。 12# 使用dpkg安装sudo dpkg -i emacs24_24.5+1-6ubuntu1.1_amd64.deb 跟前面预料的一样，这里你可能出现了一些错误： 我们将如何解决这个错误呢？这就要用到apt-get了，使用它的-f参数了，修复依赖关系的安装 12sudo apt-get updatesudo apt-get -f install -y 没有任何错误，这样我们就安装成功了，然后你可以运行 emacs 程序 3.3 查看已安装软件包的安装目录如果你依然在纠结到底 linux 将软件安装到了什么地方，那么很幸运你将可以通过dpkg找到答案 使用dpkg -L查看deb包目录信息 1sudo dpkg -L emacs24 dpkg还有一些其他的参数，这里将作为练习题由你自己来学习 四、从二进制包安装二进制包的安装比较简单，我们需要做的只是将从网络上下载的二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加进PATH环境变量即可，如果你不知道该放到什么位置，请重新复习第四节关于 Linux 目录结构的内容。","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"十、正则表达式","slug":"E_学习笔记/Linux/Linux_实验楼/10-十、正则表达式","date":"2022-12-27T03:12:54.023Z","updated":"2022-12-27T03:12:54.023Z","comments":true,"path":"posts/1e5548e0.html","link":"","permalink":"https://www.mingsrc.work/posts/1e5548e0","excerpt":"","text":"十、正则表达式1.1 实验内容虽然我们这一节的标题是正则表达式，但实际这一节实验只是介绍grep，sed，awk这三个命令，而正则表达式作为这三个命令的一种使用方式（命令输出中可以包含正则表达式）。正则表达式本身的内容很多，要把它说明清楚需要单独一门课程来实现，不过我们这一节中涉及到的相关内容通常也能够满足很多情况下的需求了。 1.2 实验知识点 掌握基本命令：sed ,grep ,awk的用法 掌握正则表达式符号和语法 想要更深入地学习使用正则表达式，在这里 正则表达式基础。 二、正则表达式什么是正则表达式呢？ 正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。 许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在 Perl 中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由 UNIX 中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有 regexp、regex，复数有 regexps、regexes、regexen。 简单的说形式和功能上正则表达式和我们前面讲的通配符很像，不过它们之间又有很大差别，特别在于一些特殊的匹配字符的含义上，希望初学者注意不要将两者弄混淆。 2.1 举例 假设我们有这样一个文本文件，包含”shiyanlou”，和”shilouyan”这两个字符串，同样一个表达式： 1shi* 如果这作为一个正则表达式，它将只能匹配 shi，而如果不是作为正则表达式*作为一个通配符，则将同时匹配这两个字符串。这是为什么呢？因为在正则表达式中*表示匹配前面的子表达式（这里就是它前面一个字符）零次或多次，比如它可以匹配”sh”,”shii”,”shish”,”shiishi”等等，而作为通配符表示匹配通配符后面任意多个任意字符，所以它可以匹配”shiyanlou”，和”shilouyan”两个字符。 体验完了，下面就来开始正式学习正则表达式吧。 2.2 基本语法一个正则表达式通常被称为一个模式（pattern），为用来描述或者匹配一系列符合某个句法规则的字符串。 选择|竖直分隔符表示选择，例如”boy|girl”可以匹配”boy”或者”girl” 数量限定数量限定除了我们举例用的*,还有+加号,?问号,如果在一个模式中不加数量限定符则表示出现一次且仅出现一次： +表示前面的字符必须出现至少一次(1 次或多次)，例如，”goo+gle”,可以匹配”gooogle”,”goooogle”等； ?表示前面的字符最多出现一次(0 次或 1 次)，例如，”colou?r”,可以匹配”color”或者”colour”; *星号代表前面的字符可以不出现，也可以出现一次或者多次（0 次、或 1 次、或多次），例如，“0*42”可以匹配 42、042、0042、00042 等。 范围和优先级()圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，”gr(a|e)y”等价于”gray|grey”，（这里体现了优先级，竖直分隔符用于选择 a 或者 e 而不是 gra 和 ey），”(grand)?father”匹配 father 和 grandfather（这里体现了范围，?将圆括号内容作为一个整体匹配）。 语法（部分）正则表达式有多种不同的风格，下面列举一些常用的作为 PCRE 子集的适用于perl和python编程语言及grep或egrep的正则表达式匹配规则：(由于 markdown 表格解析的问题，下面的竖直分隔符用全角字符代替，实际使用时请换回半角字符) PCRE（Perl Compatible Regular Expressions 中文含义：perl 语言兼容正则表达式）是一个用 C 语言编写的正则表达式函数库，由菲利普.海泽(Philip Hazel)编写。PCRE 是一个轻量级的函数库，比 Boost 之类的正则表达式库小得多。PCRE 十分易用，同时功能也很强大，性能超过了 POSIX 正则表达式库和一些经典的正则表达式库。 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。序列“\\”匹配“\\”而“(”则匹配“(”。 ^ 匹配输入字符串的开始位置。 $ 匹配输入字符串的结束位置。 {n} n 是一个非负整数。匹配确定的 n 次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个 o。 {n,} n 是一个非负整数。至少匹配 n 次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有 o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m 和 n 均为非负整数，其中 n&lt;&#x3D;m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}”将匹配“fooooood”中的前三个 o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”、“zo”以及“zoo”。等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“(.｜\\n)”的模式。 (pattern) 匹配 pattern 并获取这一匹配的子字符串。该子字符串用于向后引用。要匹配圆括号字符，请使用“(”或“)”。 x ｜ y 匹配 x 或 y。例如，“z ｜ food”能匹配“z”或“food”。“(z ｜ f)ood”则匹配“zood”或“food”。 [xyz] 字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线\\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果出现在首位则仅作为普通字符。 [^xyz] 排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 优先级优先级为从上到下从左到右，依次降低： 运算符 说明 \\ 转义符 (), (?:), (?&#x3D;), [] 括号和中括号 *、+、?、{n}、{n,}、{n,m} 限定符 ^、$、\\任何元字符 定位点和序列 ｜ 选择 更多正则表达式的内容可以参考以下链接： 正则表达式 wiki 几种正则表达式引擎的语法差异 各语言各平台对正则表达式的支持 regex 的思导图： 三、grep 模式匹配命令上面空谈了那么多正则表达式的内容也并没有提及具体该如何使用它，实在枯燥，如果说正则表达式是一门武功，那它也只能算得上一些口诀招式罢了，要把它真正练起来还得需要一些兵器在手才行，这里我们要介绍的grep命令以及后面要讲的sed,awk这些就该算作是这样的兵器了。 3.1 基本操作grep命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。grep支持三种正则表达式引擎，分别用三个参数指定： 参数 说明 -E POSIX 扩展正则表达式，ERE -G POSIX 基本正则表达式，BRE -P Perl 正则表达式，PCRE 不过在你没学过 perl 语言的大多数情况下你将只会使用到ERE和BRE,所以我们接下来的内容都不会讨论到 PCRE 中特有的一些正则表达式语法（它们之间大部分内容是存在交集的，所以你不用担心会遗漏多少重要内容） 在通过grep命令使用正则表达式之前，先介绍一下它的常用参数： 参数 说明 -b 将二进制文件作为文本来进行匹配 -c 统计以模式匹配的数目 -i 忽略大小写 -n 显示匹配文本所在行的行号 -v 反选，输出不匹配行的内容 -r 递归匹配查找 -A n n 为正整数，表示 after 的意思，除了列出匹配行之外，还列出后面的 n 行 -B n n 为正整数，表示 before 的意思，除了列出匹配行之外，还列出前面的 n 行 --color=auto 将输出中的匹配项设置为自动颜色显示 注：在大多数发行版中是默认设置了 grep 的颜色的，你可以通过参数指定或修改GREP_COLOR环境变量。 3.2 使用正则表达式使用基本正则表达式，BRE 位置 查找/etc/group文件中以”shiyanlou”为开头的行 12$ grep &#x27;shiyanlou&#x27; /etc/group$ grep &#x27;^shiyanlou&#x27; /etc/group 数量 123456# 将匹配以&#x27;z&#x27;开头以&#x27;o&#x27;结尾的所有字符串$ echo &#x27;zero\\nzo\\nzoo&#x27; | grep &#x27;z.*o&#x27;# 将匹配以&#x27;z&#x27;开头以&#x27;o&#x27;结尾，中间包含一个任意字符的字符串$ echo &#x27;zero\\nzo\\nzoo&#x27; | grep &#x27;z.o&#x27;# 将匹配以&#x27;z&#x27;开头,以任意多个&#x27;o&#x27;结尾的字符串$ echo &#x27;zero\\nzo\\nzoo&#x27; | grep &#x27;zo*&#x27; 注意：其中\\n为换行符 选择 1234567891011121314# grep默认是区分大小写的，这里将匹配所有的小写字母$ echo &#x27;1234\\nabcd&#x27; | grep &#x27;[a-z]&#x27;# 将匹配所有的数字$ echo &#x27;1234\\nabcd&#x27; | grep &#x27;[0-9]&#x27;# 将匹配所有的数字$ echo &#x27;1234\\nabcd&#x27; | grep &#x27;[[:digit:]]&#x27;# 将匹配所有的小写字母$ echo &#x27;1234\\nabcd&#x27; | grep &#x27;[[:lower:]]&#x27;# 将匹配所有的大写字母$ echo &#x27;1234\\nabcd&#x27; | grep &#x27;[[:upper:]]&#x27;# 将匹配所有的字母和数字，包括0-9,a-z,A-Z$ echo &#x27;1234\\nabcd&#x27; | grep &#x27;[[:alnum:]]&#x27;# 将匹配所有的字母$ echo &#x27;1234\\nabcd&#x27; | grep &#x27;[[:alpha:]]&#x27; 下面包含完整的特殊符号及说明： 特殊符号 说明 [:alnum:] 代表英文大小写字母及数字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小写字母，亦即 A-Z, a-z [:blank:] 代表空白键与 [Tab] 按键两者 [:cntrl:] 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等 [:digit:] 代表数字而已，亦即 0-9 [:graph:] 除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键 [:lower:] 代表小写字母，亦即 a-z [:print:] 代表任何可以被列印出来的字符 [:punct:] 代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $… [:upper:] 代表大写字母，亦即 A-Z [:space:] 任何会产生空白的字符，包括空白键, [Tab], CR 等等 [:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节 注意：之所以要使用特殊符号，是因为上面的[a-z]不是在所有情况下都管用，这还与主机当前的语系有关，即设置在LANG环境变量的值，zh_CN.UTF-8 的话[a-z]，即为所有小写字母，其它语系可能是大小写交替的如，”a A b B…z Z”，[a-z]中就可能包含大写字母。所以在使用[a-z]时请确保当前语系的影响，使用[:lower:]则不会有这个问题。 12# 排除字符$ $ echo &#x27;geek\\ngood&#x27; | grep &#x27;[^o]&#x27; **注意:**当^放到中括号内为排除字符，否则表示行首。 使用扩展正则表达式，ERE要通过grep使用扩展正则表达式需要加上-E参数，或使用egrep。 数量 1234# 只匹配&quot;zo&quot;$ echo &#x27;zero\\nzo\\nzoo&#x27; | grep -E &#x27;zo&#123;1&#125;&#x27;# 匹配以&quot;zo&quot;开头的所有单词$ echo &#x27;zero\\nzo\\nzoo&#x27; | grep -E &#x27;zo&#123;1,&#125;&#x27; 注意：推荐掌握&#123;n,m&#125;即可，+,?,*，这几个不太直观，且容易弄混淆。 选择 1234# 匹配&quot;www.shiyanlou.com&quot;和&quot;www.google.com&quot;$ echo &#x27;www.shiyanlou.com\\nwww.baidu.com\\nwww.google.com&#x27; | grep -E &#x27;www\\.(shiyanlou|google)\\.com&#x27;# 或者匹配不包含&quot;baidu&quot;的内容$ echo &#x27;www.shiyanlou.com\\nwww.baidu.com\\nwww.google.com&#x27; | grep -Ev &#x27;www\\.baidu\\.com&#x27; 注意：因为.号有特殊含义，所以需要转义。 关于正则表达式和grep命令的内容就介绍这么多，下面会介绍两个更强大的工具sed和awk，但同样也正是因为这两个工具的强大，我们的内容无法包含它们的全部，这里将只对基本内容作介绍。 四、sed 流编辑器sed工具在 man 手册里面的全名为”sed - stream editor for filtering and transforming text “，意即，用于过滤和转换文本的流编辑器。 在 Linux&#x2F;UNIX 的世界里敢称为编辑器的工具，大都非等闲之辈，比如前面的”vi&#x2F;vim(编辑器之神)”,”emacs(神的编辑器)”,”gedit”这些个编辑器。sed与上述的最大不同之处在于它是一个非交互式的编辑器，下面我们就开始介绍sed这个编辑器。 4.1 sed 常用参数介绍sed 命令基本格式： 123sed [参数]... [执行命令] [输入文件]...# 形如：$ sed -i &#x27;s/sad/happy/&#x27; test # 表示将test文件中的&quot;sad&quot;替换为&quot;happy&quot; 参数 说明 -n 安静模式，只打印受影响的行，默认打印输入数据的全部内容 -e 用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数 -f filename 指定执行 filename 文件中的命令 -r 使用扩展正则表达式，默认为标准正则表达式 -i 将直接修改输入文件内容，而不是打印到标准输出设备 4.2 sed 编辑器的执行命令（这里”执行“解释为名词）sed 执行命令格式： 12345[n1][,n2]command[n1][~step]command# 其中一些命令可以在后面加上作用范围，形如：$ sed -i &#x27;s/sad/happy/g&#x27; test # g表示全局范围$ sed -i &#x27;s/sad/happy/4&#x27; test # 4表示指定行中的第四个匹配字符串 其中 n1,n2 表示输入内容的行号，它们之间为,逗号则表示从 n1 到 n2 行，如果为～波浪号则表示从 n1 开始以 step 为步进的所有行；command 为执行动作，下面为一些常用动作指令： 命令 说明 s 行内替换 c 整行替换 a 插入到指定行的后面 i 插入到指定行的前面 p 打印指定行，通常与-n参数配合使用 d 删除指定行 4.3 sed 操作举例我们先找一个用于练习的文本文件： 1$ cp /etc/passwd ~ 打印指定行1234# 打印2-5行$ nl passwd | sed -n &#x27;2,5p&#x27;# 打印奇数行$ nl passwd | sed -n &#x27;1~2p&#x27; 行内替换12# 将输入文本中&quot;shiyanlou&quot; 全局替换为&quot;hehe&quot;,并只打印替换的那一行，注意这里不能省略最后的&quot;p&quot;命令$ sed -n &#x27;s/shiyanlou/hehe/gp&#x27; passwd 注意： 行内替换可以结合正则表达式使用。 删除某行123$ nl passwd | grep &quot;shiyanlou&quot;# 删除第30行$ sed -i &#x27;30d&#x27; passwd 关于 sed 命令就介绍这么多，你如果希望了解更多 sed 的高级用法，你可以参看如下链接： sed 简明教程 sed 单行脚本快速参考 sed 完全手册 五、awk 文本处理语言看到上面的标题，你可能会感到惊异，难道我们这里要学习的是一门“语言”么，确切的说，我们是要在这里学习awk文本处理语言，只是我们并不会在这里学习到比较完整的关于awk的内容，还是因为前面的原因，它太强大了，它的应用无处不在，我们无法在这里以简短的文字描述面面俱到，如果你有目标成为一个 linux 系统管理员，确实想学好 awk，不用担心，实验楼会在之后陆续上线 linux 系统管理员的学习路径，里面会有单独的关于正则表达式,awk,sed等相关课程，敬请期待吧。下面的内容，我们就作为一个关于awk的入门体验章节吧，其中会介绍一些awk的常用操作。 5.1 awk 介绍 AWK是一种优良的文本处理工具，Linux 及 Unix 环境中现有的功能最强大的数据处理引擎之一.其名称得自于它的创始人 Alfred Aho（阿尔佛雷德·艾侯）、Peter Jay Weinberger（彼得·温伯格）和 Brian Wilson Kernighan（布莱恩·柯林汉)姓氏的首个字母.AWK 程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，AWK 是一种用于处理文本的编程语言工具。 在大多数 linux 发行版上面，实际我们使用的是 gawk（GNU awk，awk 的 GNU 版本），在我们的环境中 ubuntu 上，默认提供的是 mawk，不过我们通常可以直接使用 awk 命令（awk 语言的解释器），因为系统已经为我们创建好了 awk 指向 mawk 的符号链接。 1$ ll /usr/bin/awk nawk： 在 20 世纪 80 年代中期，对 awk 语言进行了更新，并不同程度地使用一种称为 nawk(new awk) 的增强版本对其进行了替换。许多系统中仍然存在着旧的 awk 解释器，但通常将其安装为 oawk (old awk) 命令，而 nawk 解释器则安装为主要的 awk 命令，也可以使用 nawk 命令。Dr. Kernighan 仍然在对 nawk 进行维护，与 gawk 一样，它也是开放源代码的，并且可以免费获得; gawk： 是 GNU Project 的 awk 解释器的开放源代码实现。尽管早期的 GAWK 发行版是旧的 AWK 的替代程序，但不断地对其进行了更新，以包含 NAWK 的特性; mawk 也是 awk 编程语言的一种解释器，mawk 遵循 POSIX 1003.2 （草案 11.3）定义的 AWK 语言，包含了一些没有在 AWK 手册中提到的特色，同时 mawk 提供一小部分扩展,另外据说 mawk 是实现最快的 awk 5.2 awk 的一些基础概念awk 所有的操作都是基于 pattern(模式)—action(动作)对来完成的，如下面的形式： 1$ pattern &#123;action&#125; 你可以看到就如同很多编程语言一样，它将所有的动作操作用一对&#123;&#125;花括号包围起来。其中 pattern 通常是表示用于匹配输入的文本的“关系式”或“正则表达式”，action 则是表示匹配后将执行的动作。在一个完整 awk 操作中，这两者可以只有其中一个，如果没有 pattern 则默认匹配输入的全部文本，如果没有 action 则默认为打印匹配内容到屏幕。 awk处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，awk 以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符，下面将告诉你如何做到这一点。 5.3 awk 命令基本格式1awk [-F fs] [-v var=value] [-f prog-file | &#x27;program text&#x27;] [file...] 其中-F参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式） ，-v用于预先为awk程序指定变量，-f参数用于指定awk命令要执行的程序文件，或者在不加-f参数的情况下直接将程序语句放在这里，最后为awk需要处理的文本输入，且可以同时输入多个文本文件。现在我们还是直接来具体体验一下吧。 5.4 awk 操作体验先用 vim 新建一个文本文档 1$ vim test 包含如下内容： 12I like linuxwww.shiyanlou.com 使用 awk 将文本内容打印到终端 123456# &quot;quote&gt;&quot; 不用输入$ awk &#x27;&#123;&gt; print&gt; &#125;&#x27; test# 或者写到一行$ awk &#x27;&#123;print&#125;&#x27; test 说明:在这个操作中我是省略了pattern，所以awk会默认匹配输入文本的全部内容，然后在”{}”花括号中执行动作，即print打印所有匹配项，这里是全部文本内容 将 test 的第一行的每个字段单独显示为一行 123456789101112131415$ awk &#x27;&#123;&gt; if(NR==1)&#123;&gt; print $1 &quot;\\n&quot; $2 &quot;\\n&quot; $3&gt; &#125; else &#123;&gt; print&#125;&gt; &#125;&#x27; test# 或者$ awk &#x27;&#123;&gt; if(NR==1)&#123;&gt; OFS=&quot;\\n&quot;&gt; print $1, $2, $3&gt; &#125; else &#123;&gt; print&#125;&gt; &#125;&#x27; test 说明:你首先应该注意的是，这里我使用了awk语言的分支选择语句if,它的使用和很多高级语言如C/C++语言基本一致，如果你有这些语言的基础，这里将很好理解。另一个你需要注意的是NR与OFS，这两个是awk内建的变量，NR表示当前读入的记录数，你可以简单的理解为当前处理的行数，OFS表示输出时的字段分隔符，默认为” “空格，如上图所见，我们将字段分隔符设置为\\n换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是$N其中 N 为相应的字段号，这也是awk的内建变量，它表示引用相应的字段，因为我们这里第一行只有三个字段，所以只引用到了$3。除此之外另一个这里没有出现的$0，它表示引用当前记录（当前行）的全部内容。 将 test 的第二行的以点为分段的字段换成以空格为分隔 1234567891011121314$ awk -F&#x27;.&#x27; &#x27;&#123;&gt; if(NR==2)&#123;&gt; print $1 &quot;\\t&quot; $2 &quot;\\t&quot; $3&gt; &#125;&#125;&#x27; test# 或者$ awk &#x27;&gt; BEGIN&#123;&gt; FS=&quot;.&quot;&gt; OFS=&quot;\\t&quot; # 如果写为一行，两个动作语句之间应该以&quot;;&quot;号分开&gt; &#125;&#123;&gt; if(NR==2)&#123;&gt; print $1, $2, $3&gt; &#125;&#125;&#x27; test 说明：这里的-F参数，前面已经介绍过，它是用来预先指定待处理记录的字段分隔符。我们需要注意的是除了指定OFS我们还可以在print 语句中直接打印特殊符号如这里的\\t，print 打印的非变量内容都需要用””一对引号包围起来。上面另一个版本，展示了实现预先指定变量分隔符的另一种方式，即使用BEGIN，就这个表达式指示了，其后的动作将在所有动作之前执行，这里是FS赋值了新的”.”点号代替默认的” “空格 注意:首先说明一点，我们在学习和使用 awk 的时候应该尽可能将其作为一门程序语言来理解，这样将会使你学习起来更容易，所以初学阶段在练习awk时应该尽量按照我那样的方式分多行按照一般程序语言的换行和缩进来输入，而不是全部写到一行（当然这在你熟练了之后是没有任何问题的）。 5.5 awk 常用的内置变量 变量名 说明 FILENAME 当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串 $0 当前记录的内容 $N N 表示字段号，最大值为NF变量的值 FS 字段分隔符，由正则表达式表示，默认为” “空格 RS 输入记录分隔符，默认为”\\n”，即一行为一个记录 NF 当前记录字段数 NR 已经读入的记录数 FNR 当前输入文件的记录数，请注意它与 NR 的区别 OFS 输出字段分隔符，默认为” “空格 ORS 输出记录分隔符，默认为”\\n” 关于awk的内容本课程将只会包含这些内容，如果你想了解更多，请期待后续课程，或者参看一下链接内容： awk 程序设计语言 awk 简明教程 awk 用户指南","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"十二、Linux进程概念","slug":"E_学习笔记/Linux/Linux_实验楼/12-十二、Linux 进程概念","date":"2022-12-27T03:12:54.023Z","updated":"2022-12-27T03:12:54.023Z","comments":true,"path":"posts/bc91e4b2.html","link":"","permalink":"https://www.mingsrc.work/posts/bc91e4b2","excerpt":"","text":"Linux 进程概念一、实验介绍1.1 实验内容Linux 中也难免遇到某个程序无响应的情况，可以通过一些命令来帮助我们让系统能够更流畅的运行。 而在此之前，我们需要对进程的基础知识有一定的了解，才能更好、更有效率的使用 Linux 提供的工具。 1.2 实验知识点 进程与程序 进程的衍生 工作管理 二、概念的理解首先程序与进程是什么？程序与进程又有什么区别？ 程序（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。 进程（process）：进程是程序在一个数据集合上的一次执行过程，在早期的 UNIX、Linux 2.4 及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。 简单来说，程序是为了完成某种任务而设计的软件，比如 vim 是程序。什么是进程呢？进程就是运行中的程序。 程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性： 动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。 并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。 独立性：进程可以独立分配资源，独立接受调度，独立地运行。 异步性：进程以不可预知的速度向前推进。 结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。 并发：在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过） 并行：在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行 引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。 而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6 及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。 线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。就如下图所示： 三、进程的属性了解基础概念后，下面我们将详细的讲解进程的属性。 3.1 进程的分类大概明白进程是个什么样的存在后，我们需要进一步了解的就是进程分类。可以从两个角度来分： 以进程的功能与服务的对象来分； 以应用程序的服务类型来分； 第一个角度来看，我们可以分为&#x3D;&#x3D;用户进程与系统进程&#x3D;&#x3D;： 用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。 系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。 第二角度来看，我们可以将进程分为&#x3D;&#x3D;交互进程&#x3D;&#x3D;、&#x3D;&#x3D;批处理进程&#x3D;&#x3D;、&#x3D;&#x3D;守护进程&#x3D;&#x3D; 交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。 批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。 守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。 3.2 进程的衍生进程有这么多的种类，那么进程之间定是有相关性的，而这些有关联性的进程又是如何产生的，如何衍生的？ 就比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间又是个什么关系？ 我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？ 关于父进程与子进程便会提及这两个系统调用 fork() 与 exec() fork-exec是由 Dennis M. Ritchie 创造的 fork() 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等 exec() 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段 子进程就是父进程通过系统调用 fork() 而产生的复制品，fork() 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 exec() 之后才会不同，而早先的 fork() 比较消耗资源后来进化成 vfork(),效率高了不少，感兴趣的同学可以查查为什么。 这就是子进程产生的由来。简单的实现逻辑就如下方所示： 123456789pid_t p;p = fork();if (p == (pid_t) -1) /* ERROR */else if (p == 0) /* CHILD */else /* PARENT */ 既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 main() 会执行 exit(n); 或者 return n，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。 在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。 如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。（ ps 命令将在后续详解） 正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 reason for termination 。之后，父进程会使用 wait(&amp;status) 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。 虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。 另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。 进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 fork() 创建出一个子进程运行 /sbin/init 可执行文件,而该进程就是 PID&#x3D;1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。 通过以下的命令我们可以很明显的看到这样的结构 1pstree 或者从此图我们可以更加形象的看清子父进程的关系 通过以上的显示结果我们可以看的很清楚，init 为所有进程的父进程或者说是祖先进程 我们还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的 1ps －fxo user,ppid,pid,pgid,command 可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的 使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建出来的子进程,而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解） 就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶 3.3 进程组与 Sessions每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。 一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 getpgrp() 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的 PGID，直到进程组中最后一个进程终结。 与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的， Session 主要是针对一个 tty 建立 ，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。 前台（foreground）就是在终端中运行，能与你有交互的 后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程 3.4 工作原理bash(Bourne-Again shell)支持工作控制（job control）,而 sh（Bourne shell）并不支持。 并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job 我们都知道当一个进程在前台运作时我们可以用 ctrl + c 来终止它，但是若是在后台的话就不行了。 我们可以通过 &amp; 这个符号，让我们的命令在后台中运行 1ls &amp; 图中所显示的 [1] 236分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。 我们还可以通过 ctrl + z 使我们的当前工作停止并丢到后台中去 被停止并放置在后台的工作我们可以使用这个命令来查看 1jobs 其中第一列显示的为被放置后台 job 的编号，而第二列的 ＋ 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，- 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令 我们可以通过这样的一个命令将后台的工作拿到前台来 123# 后面不加参数提取预设工作，加参数提取指定工作的编号# ubuntu 在 zsh 中需要 %，在 bash 中不需要 %fg [%jobnumber] 之前我们通过 ctrl + z 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令 12#与fg类似，加参则指定，不加参则取预设bg [%jobnumber] 既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等 12345# kill的使用格式如下kill -signal %jobnumber# signal从1-64个信号值可以选择，可以这样查看kill －l 其中常用的有这些信号值 信号值 作用 -1 重新读取参数运行，类似与 restart -2 如同 ctrl+c 的操作退出 -9 强制终止该任务 -15 正常的方式终止该任务 注意 若是在使用 kill ＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作 若是在使用 kill+信号值然后 ％jobnumber，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID 下一步","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"Linux—从创建用户开始","slug":"E_学习笔记/Linux/Linux_实验楼/0-零、实验楼","date":"2022-12-27T03:12:54.022Z","updated":"2022-12-27T03:12:54.022Z","comments":true,"path":"posts/ae600674.html","link":"","permalink":"https://www.mingsrc.work/posts/ae600674","excerpt":"","text":"Linux—从创建用户开始跟着实验楼做完了Linux的实验，一步一步整理下来的实验流程。 1. 创建用户12345678sudo adduser lilei #创建用户ls /home #默认新用户在/home目录下创建一个工作目录同时 添加用户到系统su -l lilei #登录用户 #以下命令查看用户信息 $ who am i $ whoami $ pwdexit #该命令退出当前用户，相当于（Ctrl+D） 2. 用户组123#查询用户组$ groups shiyanlou shiyanlou:shiyanlou #冒号之前表示用户，之后表示该用户所属用户组 1234#默认情况下在sudo用户组，使用sudo命令获得root权限#查看用户信息$ cat /etc/group | sort #sort讲读取文本进行一个字典排序再输出 12#使用grep命令过滤cat /etc/group | grep -E&quot;shiyanlou&quot; 1/etc/group ​ /etc/group 的内容包括用户组（Group）、用户组口令、GID（组ID）及该用户组所包含的用户（User），每个用户组一条记录。 将其他用户组加入sudo用户组12su -l lilei #log insudo ls 12#更改用户密码sudo passwd 用户名 1234567#将lilei添加到实验楼#登录实验楼账户su -l shiyanlou #输入密码groups lileisudo usermod -G sudo lileigroups lilei 1234#验证lilei用户是否有权限#登录lilei用户#为验证lilei用户是否添加成功，创建了mign用户作为比较sudo ls 用户lilei(此时，用户已经获得root权限) 用户mign 在CentOS中添加用户到su1234567suvim /etc/sudoers# 在以下段落后root ALL=(ALL) ALL# 添加# 形如（用户名 ALL=(ALL) ALLming ALL=(ALL) ALL 3.删除用户和用户组12345#删除用户#--remove-home参数在删除用户时会一并删除工作目录sudo deluser lilei --remove-home#删除用户组sudo groupdel 用户组 --remove-home 4. 用户及文件权限 (ls命令)​ 1. 使用较长格式列出文件 12#使用较长格式列出文件ls -l 具体含义如下： 123456789#查看隐藏文件$ ls -a#同时使用-a -l参数$ ls -al#查看某个目录的完整属性$ ls -dl&lt;目录名&gt;#显示所有文件大小，常规呈现# 小写s显示文件大小 大S为按文件大小排序 $ ls -asSh ​ 可以使用==man ls==命令查询 5. 变更文件所有者在==lilei==用户下新建文件，命名为==iPhone 11== 1234567su - lilepwd #创建iPhone11文件touch iphone11#查看iphone11文件# -h with -l and/or -s,print human readable sizes(e.g., 1K 234M 2G)ls -alh iphone11 切换到==shiyanlou==，使用以下命令修改文件所有者： 123cd /home/lileils iphone11sudo chown shiyanlou iphone11 可见，iPhone11文件所有者为==shiyanlou== 变更文件所有者12345#login 查看或创建一个文件su - usernamepwd #查看当前路径touch iPhone11#文件名ls -alh ihpne11 #查看iPhone11的权限 1. 修改文件所有者操作12345#切换到目标用户su - shiyanloucd /home/lileils iphone11sudo chown shiyanlou iphone11 2. 修改文件权限 方法一 每个文件有三组固定的权限，分别对应拥有者，所属用户组，其他用户，记住这个顺序是固定的。文件的读写执行对应字母 rwx，以二进制表示就是 111，用十进制表示就是 7，对进制转换不熟悉的同学可以看看 进制转换。例如我们刚刚新建的文件 iphone11 的权限是 rw-rw-rw-，换成对应的十进制表示就是 666，这就表示这个文件的拥有者，所属用户组和其他用户具有读写权限，不具有执行权限。 方法二 g、o 还有 u 分别表示 group（用户组）、others（其他用户） 和 user（用户），+ 和 - 分别表示增加和去掉相应的权限。 3.向文件中添加内容(echo)1234# 重写echo 添加内容 &gt; 文件名# 追加echo 添加内容 &gt;&gt; 文件名 adduser和useradd的区别是什么？ 答：useradd 只创建用户，不会创建用户密码和工作目录，创建完了需要使用 passwd &lt;username&gt; 去设置新用户的密码。adduser在创建用户的同时，会创建工作目录和密码（提示你设置），做这一系列的操作。其实 useradd、userdel 这类操作更像是一种命令，执行完了就返回。而 adduser 更像是一种程序，需要你输入、确定等一系列操作。 Linux 还有一些关于隐藏权限和特殊权限的内容，想全面了解 Linux 权限管理这部分内容的用户可以通过其它方式学习","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"一、Linux目录结构及文件基本操作","slug":"E_学习笔记/Linux/Linux_实验楼/1-一、Linux目录结构及文件基本操作","date":"2022-12-27T03:12:54.022Z","updated":"2022-12-27T03:12:54.022Z","comments":true,"path":"posts/ed589a8.html","link":"","permalink":"https://www.mingsrc.work/posts/ed589a8","excerpt":"","text":"支持互联网的开源技术——LAMP：Linux、Apache、Mysql、PHP 1. 新建1. 新建空白文件(touch)使用&#x3D;&#x3D;touch&#x3D;&#x3D;命令创建空白文件 12cd ~ #切换到根目录touch test #创建test文件 2. 新建目录(mkdir)使用&#x3D;&#x3D;mkdir&#x3D;&#x3D;(make directoriese)命令可以创建一个空目录，也可以同时制定创建目录的权限属性 1mkdir mydir #创建名为mydir的空目录 使用 &#x3D;&#x3D;-p&#x3D;&#x3D; 参数，同时创建父目录（如果不存在该父目录），如下我们同时创建一个多级目录（这在安装软件、配置安装路径时非常有用）： 1mkdir -p father/son/grandson 当目录中已经存在同名文件时，再次使用&#x3D;&#x3D;touch&#x3D;&#x3D;按钮不会新建一个同名文件，但是会改变原文件的时间戳 2. 复制1. 复制文件（cp）1cp test father/son/grandson #cp 文件名 目标地址 2. 复制目录（cp）123cd /home/shiyanloumkdir familycp -r father family #cp -r 文件名 目的地文件名 要成功复制目录需要加上 -r 或者 -R 参数，表示递归复制 3. 删除1.删除文件（rm）1234rm test #当遇到权限问题时，需要加上-f参数#删除目录时，使用 -r 或者 -R参数rm -rf family 4. 移动文件与文件重命名1. 移动文件（mv-move or rename files）使用mv命令移动文件（剪切）。命令格式是mv 原目录文件 目的目录 123mkdir Documentstouch file1mv file1 Documents # mv 原目录文件 目的目录 2. 重命名文件（mv）1mv file1 myfile 3. 批量重命名首先安装&#x3D;&#x3D;rename&#x3D;&#x3D;命令 12# 安装rename命令sudo apt-get install rename 使用了通配符和正则表达式： 12345678910cd /home/shiyanlou/#使用通配符批量创建5个文件touch file&#123;1..5&#125;.txt#批量将这5个文件重命名为.c文件rename &#x27;s/\\.txt/\\.c&#x27; *.txt# 批量将这五个文件，文件名改为大写rename &#x27;y/a-z/A-Z/&#x27; *.c 5. 查看文件1. 使用cat,tac和nl命令查看文件前两个命令都是用来打印文件内容到标准输出（终端），其中cat为正序显示，tac为倒序显示 标准输入输出：当我们执行一个 shell 命令行时通常会自动打开三个标准文件，即标准输入文件（stdin），默认对应终端的键盘、标准输出文件（stdout）和标准错误输出文件（stderr），后两个文件都对应被重定向到终端的屏幕，以便我们能直接看到输出内容。进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。 12345678910#查看/etc目录下拷贝的passwd文件cd /home/shiyanloucp /etc/passwd passwdcat passwd# -n 参数可以显示行号cat -n passwd#nl 命令比cat-n更专业nl -b a passwd &#x3D;&#x3D;nl&#x3D;&#x3D;的几种用法： 使用&#x3D;&#x3D;more&#x3D;&#x3D;命令打开passwd文件： 1more passwd 使用&#x3D;&#x3D;head&#x3D;&#x3D;和&#x3D;&#x3D;tail&#x3D;&#x3D;命令查看文件，默认只看文件前几（10）行或者后几行 1tail passwd 1head passwd 甚至更直接的只看一行，加上&#x3D;&#x3D;-n&#x3D;&#x3D;参数就行 1tail -n 数字 /etc/passwd 6. 查看文件类型1. 查看文件（file)1file shiyanlou.txt # file命令查看文件 文件类型有： 符号 含义 - 普通文件 d directory l 软链接（快捷方式） l 硬链接（相当于拷贝） p 管道（管道文件主要用于进程间通信） 7. 编辑文件1. 编辑器（emacs，vim，nano）1vimtutor #打开vim编辑器","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"Linux","slug":"学习笔记/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Linux/"},{"name":"Linux","slug":"实验楼/Linux","permalink":"https://www.mingsrc.work/categories/%E5%AE%9E%E9%AA%8C%E6%A5%BC/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mingsrc.work/tags/Linux/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"(Golang)链表学习记录","slug":"E_学习笔记/Go/链表(Go)","date":"2022-12-27T03:12:54.021Z","updated":"2022-12-27T03:12:54.021Z","comments":true,"path":"posts/85980731.html","link":"","permalink":"https://www.mingsrc.work/posts/85980731","excerpt":"","text":"[toc] 141. 环形链表给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回 true 。 否则，返回 false 。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 10&lt;sup&gt;4&lt;/sup&gt;] -10&lt;sup&gt;5&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt; pos 为 -1 或者链表中的一个 有效索引 。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ Solution#快慢指针 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func hasCycle(head *ListNode) bool &#123; // 快慢指针 if head == nil || head.Next == nil &#123; return false &#125; slow, fast := head, head.Next for fast != slow &#123; if fast == nil || fast.Next == nil &#123; return false &#125; slow = slow.Next fast = fast.Next.Next &#125; return true&#125; 142. 环形链表 II给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 10&lt;sup&gt;4&lt;/sup&gt;] 内 -10&lt;sup&gt;5&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt; pos 的值为 -1 或者链表中的一个有效索引 进阶：你是否可以使用 O(1) 空间解决此题？ Solution123456789101112131415161718/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func detectCycle(head *ListNode) *ListNode &#123; seen := map[*ListNode]struct&#123;&#125;&#123;&#125; for head != nil &#123; if _,ok := seen[head]; ok &#123; return head &#125; seen[head] = struct&#123;&#125;&#123;&#125; head = head.Next &#125; return nil&#125; #快慢指针 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func detectCycle(head *ListNode) *ListNode &#123; slow, fast := head, head for fast != nil &#123; slow = slow.Next if fast.Next == nil &#123; return nil &#125; fast = fast.Next.Next if fast == slow &#123; p := head for p != slow &#123; p = p.Next slow = slow.Next &#125; return p &#125; &#125; return nil&#125; 160. 相交链表图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 自定义评测： 评测系统 的输入如下（你设计的程序 不适用 此输入）： intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0 listA - 第一个链表 listB - 第二个链表 skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数 skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数 评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。 示例 1： 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at &#x27;8&#x27;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 12345输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at &#x27;2&#x27;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 m listB 中节点数目为 n 1 &lt;= m, n &lt;= 3 * 10&lt;sup&gt;4&lt;/sup&gt; 1 &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt; 0 &lt;= skipA &lt;= m 0 &lt;= skipB &lt;= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB] 进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？ Solution12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func getIntersectionNode(headA, headB *ListNode) *ListNode &#123; if headA == nil || headB == nil &#123; return nil &#125; pa,pb := headA, headB for pa != pb &#123; if pa == nil &#123; pa = headB &#125; else &#123; pa = pa.Next &#125; if pb == nil &#123; pb = headA &#125; else &#123; pb = pb.Next &#125; &#125; return pa&#125; 19. 删除链表的倒数第 N 个结点Difficulty: **给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2 输出：[1,2,3,5] 示例 2： 输入：head &#x3D; [1], n &#x3D; 1 输出：[] 示例 3： 输入：head &#x3D; [1,2], n &#x3D; 1 输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;&#x3D; sz &lt;&#x3D; 30 0 &lt;&#x3D; Node.val &lt;&#x3D; 100 1 &lt;&#x3D; n &lt;&#x3D; sz 进阶：你能尝试使用一趟扫描实现吗？ ** 给你一个链表，删除链表的倒数第 n个结点，并且返回链表的头结点。 示例 1： 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 12输入：head = [1], n = 1输出：[] 示例 3： 12输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 进阶：你能尝试使用一趟扫描实现吗？ Solution#双指针 1234567891011121314151617181920212223/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */var cur int = 0func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; dummy := &amp;ListNode&#123;0,head&#125; first, second := head, dummy for i := 0; i &lt; n; i++ &#123; first = first.Next &#125; for ; first != nil; first = first.Next &#123; second = second.Next &#125; second.Next = second.Next.Next return dummy.Next&#125;","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"学习笔记/Go","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.mingsrc.work/tags/Go/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mingsrc.work/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"https://www.mingsrc.work/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"力扣高效算法入门","slug":"E_学习笔记/Go/力扣高效算法入门","date":"2022-12-27T03:12:54.021Z","updated":"2022-12-27T03:12:54.021Z","comments":true,"path":"posts/8cb5320c.html","link":"","permalink":"https://www.mingsrc.work/posts/8cb5320c","excerpt":"","text":"1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 123输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 12输入：nums = [3,2,4], target = 6输出：[1,2] 示例 3： 12输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt; -10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt; -10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt; 只会存在一个有效答案 进阶：你可以想出一个时间复杂度小于 O(n&lt;sup&gt;2&lt;/sup&gt;) 的算法吗？ Solution12345678910func twoSum(nums []int, target int) []int &#123; for i,x := range nums &#123; for j := i + 1; j &lt; len(nums); j++ &#123; if x+nums[j] == target &#123; return []int&#123;i,j&#125; &#125; &#125; &#125; return nil&#125; 167. 两数之和 II - 输入有序数组给定一个已按照**非递减顺序排列 ** 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值_。_numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。 示例 1： 123输入：numbers = [2,7,11,15], target = 9输出：[1,2]解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 示例 2： 12输入：numbers = [2,3,4], target = 6输出：[1,3] 示例 3： 12输入：numbers = [-1,0], target = -1输出：[1,2] 提示： 2 &lt;= numbers.length &lt;= 3 * 10&lt;sup&gt;4&lt;/sup&gt; -1000 &lt;= numbers[i] &lt;= 1000 numbers 按 非递减顺序 排列 -1000 &lt;= target &lt;= 1000 仅存在一个有效答案 Solution#双指针 12345678910111213141516func twoSum(numbers []int, target int) []int &#123; left,right := 0, len(numbers) - 1 for left &lt; right &#123; sum := numbers[left] + numbers [right] if sum == target &#123; return []int&#123;left + 1, right + 1&#125; &#125; else if sum &lt; target &#123; left++ &#125; else &#123; right-- &#125; &#125; return []int&#123;-1,-1&#125; &#125; 15. 三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 _a，b，c ，_使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 12输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]] 示例 2： 12输入：nums = []输出：[] 示例 3： 12输入：nums = [0]输出：[] 提示： 0 &lt;= nums.length &lt;= 3000 -10&lt;sup&gt;5&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt; Solution#三指针 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; // 先排序 int n = nums.size(); sort(nums.begin(), nums.end()); // 定义首指针==target for (int i = 0; i &lt; n; i++) &#123; if ( i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; int k = n - 1; // 内层首指针 int target = -nums[i]; for (int j = i + 1; j &lt; n; j++) // 内层尾指针 &#123; if( j &gt; i + 1 &amp;&amp; nums[j] == nums[j-1]) continue; while (j &lt; k &amp;&amp; nums[j] + nums[k] &gt; target) &#123; // 遍历尾指针，找合适序列 --k; &#125; // 当前i不满足 if(j == k) &#123; break; &#125; // 得到符合条件序列 if(nums[j] + nums[k] == target) &#123; ans.push_back(&#123;nums[i],nums[j],nums[k]&#125;); &#125; &#125; &#125; return ans; &#125;&#125;; 18. 四数之和给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 示例 1： 12输入：nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2： 12输入：nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]] 提示： 1 &lt;= nums.length &lt;= 200 -10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt; -10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt; Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ans; int n = nums.size(); if(n &lt; 4) return ans; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; n - 3; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123; break; &#125; if ((long) nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] &lt; target) &#123; continue; &#125; for (int j = i + 1; j &lt; n - 2; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j-1]) continue; if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) &#123; break; &#125; if ((long) nums[i] + nums[j] + nums[n - 2] + nums[n - 1] &lt; target) &#123; continue; &#125; // 最内层首尾指针 int m = n - 1, k = j + 1; while(k &lt; m) &#123; int sum = nums[i] + nums[j] + nums[k] + nums[m]; if (sum == target) &#123; ans.push_back(&#123;nums[i], nums[j], nums[k], nums[m]&#125;); while (k &lt; m &amp;&amp; nums[k] == nums[k + 1]) &#123; k++; &#125; k++; while (k &lt; m &amp;&amp; nums[m] == nums[m - 1]) &#123; m--; &#125; m--; &#125; else if (sum &lt; target) &#123; k++; &#125; else &#123; m--; &#125; &#125; &#125; &#125; return ans; &#125;&#125;; 509. 斐波那契数斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0，F(1) = 1F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你 n ，请计算 F(n) 。 示例 1： 123输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 123输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 123输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 &lt;= n &lt;= 30 Solution123456789func fib(n int) int &#123; if n == 0 &#123; return 0 &#125; else if n == 1 &#123; return 1 &#125; else &#123; return fib(n-2) + fib(n-1) &#125;&#125; 70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1\\. 1 阶 + 1 阶2\\. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1\\. 1 阶 + 1 阶 + 1 阶2\\. 1 阶 + 2 阶3\\. 2 阶 + 1 阶 Solution12345678910111213func climbStairs(n int) int &#123; if n &lt;= 2 &#123; return n &#125; pre1,pre2 := 2,1 for i := 2; i &lt; n; i++ &#123; cur := pre1 + pre2 pre2 = pre1 pre1 = cur &#125; return pre1&#125; 53. 最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 123输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 12输入：nums = [1]输出：1 示例 3： 12输入：nums = [5,4,-1,7,8]输出：23 提示： 1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt; -10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt; 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 Solution#动态规划 123456789101112func maxSubArray(nums []int) int &#123; sum := nums[0] for i := 1; i &lt; len(nums); i++ &#123; if nums[i] + nums[i-1] &gt; nums[i] &#123; nums[i] += nums[i-1] &#125; if nums[i] &gt; sum &#123; sum = nums[i] &#125; &#125; return sum&#125; 416. 分割等和子集给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 123输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2： 123输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i] &lt;= 100 Solution#动态规划 #背包问题 #difficult 1234567891011121314151617181920212223242526272829303132333435func canPartition(nums []int) bool &#123; n := len(nums) if n &lt; 2 &#123; return false &#125; sum, maxNum := 0,0 for _,num := range nums &#123; sum += num if num &gt; maxNum &#123; maxNum = num &#125; &#125; // 判断总和是不是奇数 if sum%2 != 0 &#123; return false &#125; target := sum / 2 if target &lt; maxNum &#123; return false &#125; dp := make([]bool, target+1) dp[0] = true for i := 0; i &lt; n; i++ &#123; v := nums[i] for j := target; j &gt;= v; j-- &#123; dp[j] = dp[j] || dp[j-v] &#125; &#125; return dp[target]&#125; 322. 零钱兑换给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 123输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1 示例 2： 12输入：coins = [2], amount = 3输出：-1 示例 3： 12输入：coins = [1], amount = 0输出：0 示例 4： 12输入：coins = [1], amount = 1输出：1 示例 5： 12输入：coins = [1], amount = 2输出：2 提示： 1 &lt;= coins.length &lt;= 12 1 &lt;= coins[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1 0 &lt;= amount &lt;= 10&lt;sup&gt;4&lt;/sup&gt; Solution#动态规划 1234567891011121314151617181920212223242526272829func coinChange(coins []int, amount int) int &#123; dp := make([]int, amount + 1) dp[0] = 0 // 初始化为math.MaxInt32 for j := 1; j &lt;= amount; j++ &#123; dp[j] = math.MaxInt32 &#125; for i := 0; i &lt; len(coins); i++ &#123; for j := coins[i]; j &lt;= amount ; j++ &#123; if dp[j-coins[i]] != math.MaxInt32 &#123; dp[j] = min(dp[j], dp[j-coins[i]]+1) &#125; &#125; &#125; // 没找到能装满背包的, 就返回-1 if dp[amount] == math.MaxInt32 &#123; return -1 &#125; return dp[amount]&#125;func min(a, b int) int &#123; if a &lt; b&#123; return a &#125; return b&#125; 20. 有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 12输入：s = &quot;()&quot;输出：true 示例 2： 12输入：s = &quot;()[]&#123;&#125;&quot;输出：true 示例 3： 12输入：s = &quot;(]&quot;输出：false 示例 4： 12输入：s = &quot;([)]&quot;输出：false 示例 5： 12输入：s = &quot;&#123;[]&#125;&quot;输出：true 提示： 1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt; s 仅由括号 &#39;()[]&#123;&#125;&#39; 组成 Solution#栈 12345678910111213141516171819202122232425func isValid(s string) bool &#123; n := len(s) if n % 2 == 1 &#123; return false &#125; pairs := map[byte]byte &#123; &#x27;)&#x27;:&#x27;(&#x27;, &#x27;]&#x27;:&#x27;[&#x27;, &#x27;&#125;&#x27;:&#x27;&#123;&#x27;, &#125; stack := []byte&#123;&#125; for i := 0; i &lt; n; i++ &#123; if pairs[s[i]] &gt; 0 &#123; if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] &#123; return false &#125; stack = stack[:len(stack)-1] &#125; else &#123; stack = append(stack,s[i]) &#125; &#125; return len(stack) == 0&#125; 20. 有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 12输入：s = &quot;()&quot;输出：true 示例 2： 12输入：s = &quot;()[]&#123;&#125;&quot;输出：true 示例 3： 12输入：s = &quot;(]&quot;输出：false 示例 4： 12输入：s = &quot;([)]&quot;输出：false 示例 5： 12输入：s = &quot;&#123;[]&#125;&quot;输出：true 提示： 1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt; s 仅由括号 &#39;()[]&#123;&#125;&#39; 组成 Solution#栈 12345678910111213141516171819202122232425func isValid(s string) bool &#123; n := len(s) if n % 2 == 1 &#123; return false &#125; pairs := map[byte]byte &#123; &#x27;)&#x27;:&#x27;(&#x27;, &#x27;]&#x27;:&#x27;[&#x27;, &#x27;&#125;&#x27;:&#x27;&#123;&#x27;, &#125; stack := []byte&#123;&#125; for i := 0; i &lt; n; i++ &#123; if pairs[s[i]] &gt; 0 &#123; if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] &#123; return false &#125; stack = stack[:len(stack)-1] &#125; else &#123; stack = append(stack,s[i]) &#125; &#125; return len(stack) == 0&#125; 496. 下一个更大元素 Inums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x大的元素。 给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。 对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。 返回一个长度为 nums1.length 的数组ans作为答案，满足ans[i]是如上所述的 下一个更大元素 。 示例 1： 123456输入：nums1 = [4,1,2], nums2 = [1,3,4,2].输出：[-1,3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 示例 2： 12345输入：nums1 = [2,4], nums2 = [1,2,3,4].输出：[3,-1]解释：nums1 中每个值的下一个更大元素如下所述：- 2 ，用加粗斜体标识，nums2 = [1,2,3,4]。下一个更大元素是 3 。- 4 ，用加粗斜体标识，nums2 = [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。 提示： 1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000 0 &lt;= nums1[i], nums2[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt; nums1和nums2中所有整数 互不相同 nums1 中的所有整数同样出现在 nums2 中 进阶：你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？ Solution&#x2F;#暴力解 12345678910111213141516171819202122func nextGreaterElement(nums1 []int, nums2 []int) []int &#123; m,n := len(nums1),len(nums2) res := make([]int, m) for i := 0; i &lt; m; i++ &#123; j := 0 for j &lt; n &amp;&amp; nums2[j] != nums1[i] &#123; j++ &#125; k := j + 1 for k &lt; n &amp;&amp; nums2[k] &lt; nums2[j] &#123; k++ &#125; if k &lt; n &#123; res[i] = nums2[k] &#125; else &#123; res[i] = -1 &#125; &#125; return res&#125; 456. 132 模式给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。 示例 1： 123输入：nums = [1,2,3,4]输出：false解释：序列中不存在 132 模式的子序列。 示例 2： 123输入：nums = [3,1,4,2]输出：true解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。 示例 3： 123输入：nums = [-1,3,2,0]输出：true解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。 提示： n == nums.length 1 &lt;= n &lt;= 2 * 10&lt;sup&gt;5&lt;/sup&gt; -10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt; Solution#栈 #单调栈 12345678910111213141516171819202122func find132pattern(nums []int) bool &#123; n := len(nums) candidateK := []int&#123;nums[n-1]&#125; maxK := math.MinInt64 for i := n - 2; i &gt;= 0; i-- &#123; if nums[i] &lt; maxK &#123; return true &#125; for len(candidateK) &gt; 0 &amp;&amp; nums[i] &gt; candidateK[len(candidateK)-1] &#123; maxK = candidateK[len(candidateK)-1] candidateK = candidateK[:len(candidateK)-1] &#125; if nums[i] &gt; maxK &#123; candidateK = append(candidateK, nums[i]) &#125; &#125; return false&#125; 119. 杨辉三角 II给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。 示例 1: 12输入: rowIndex = 3输出: [1,3,3,1] 示例 2: 12输入: rowIndex = 0输出: [1] 示例 3: 12输入: rowIndex = 1输出: [1,1] 提示: 0 &lt;= rowIndex &lt;= 33 进阶： 你可以优化你的算法到 _O_(_rowIndex_) 空间复杂度吗？ Solution#数学 1234567891011func getRow(rowIndex int) []int &#123; C := make([][]int, rowIndex+1) for i := range C &#123; C[i] = make([]int,i+1) C[i][0],C[i][i] = 1,1 for j := 1; j &lt; i; j++ &#123; C[i][j] = C[i-1][j-1] + C[i-1][j] &#125; &#125; return C[rowIndex]&#125; 279. 完全平方数给定正整数 _n_，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 _n_。你需要让组成和的完全平方数的个数最少。 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 123输入：n = 12输出：3 解释：12 = 4 + 4 + 4 示例 2： 123输入：n = 13输出：2解释：13 = 4 + 9 提示： 1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt; Solution#动态规划 123456789101112131415161718func numSquares(n int) int &#123; f := make([]int, n+1) for i := 1; i &lt;= n; i++ &#123; minn := math.MaxInt32 for j := 1; j*j &lt;= i; j++ &#123; minn = min(minn, f[i-j*j]) &#125; f[i] = minn + 1 &#125; return f[n]&#125;func min(a,b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125; 112. 路径总和给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例 1： 123输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2： 123456输入：root = [1,2,3], targetSum = 5输出：false解释：树中存在两条根节点到叶子节点的路径：(1 --&gt; 2): 和为 3(1 --&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。 示例 3： 123输入：root = [], targetSum = 0输出：false解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示： 树中节点的数目在范围 [0, 5000] 内 -1000 &lt;= Node.val &lt;= 1000 -1000 &lt;= targetSum &lt;= 1000 Solution#广度搜索 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func hasPathSum(root *TreeNode, targetSum int) bool &#123; if root == nil &#123; return false &#125; queNode := []*TreeNode&#123;&#125; queVal := []int&#123;&#125; queNode = append(queNode,root) queVal = append(queVal,root.Val) for len(queNode) != 0 &#123; now := queNode[0] queNode = queNode[1:] temp := queVal[0] queVal = queVal[1:] if now.Left == nil &amp;&amp; now.Right == nil &#123; if temp == targetSum &#123; return true &#125; continue &#125; if now.Left != nil &#123; queNode = append(queNode,now.Left) queVal = append(queVal,now.Left.Val + temp) &#125; if now.Right != nil &#123; queNode = append(queNode, now.Right) queVal = append(queVal, now.Right.Val + temp) &#125; &#125; return false&#125; 720. 词典中最长的单词给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。 若无答案，则返回空字符串。 示例 1： 12345输入：words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]输出：&quot;world&quot;解释： 单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;添加一个字母组成。 示例 2： 12345输入：words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]输出：&quot;apple&quot;解释：&quot;apply&quot;和&quot;apple&quot;都能由词典中的单词组成。但是&quot;apple&quot;的字典序小于&quot;apply&quot;。 提示： 所有输入的字符串都只包含小写字母。 words数组长度范围为[1,1000]。 words[i]的长度范围为[1,30]。 SolutionLanguage: **** 123456789101112131415161718192021222324func longestWord(words []string) string &#123; // 排序哈希 sort.Strings(words) // 字符串/是否出现 wordsMap := make(map[string]bool) res := &quot;&quot; for _,word := range words &#123; wlen, reslen := len(word), len(res) // 字符串前缀 if wlen == 1 || wordsMap[word[:wlen-1]] &#123; wordsMap[word] = true // 更新res为最长的单词 if reslen == 0 || reslen &lt; wlen &#123; res = word &#125; &#125; &#125; return res&#125; 3. 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 **最长子串 **的长度。 示例 1: 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 示例 4: 12输入: s = &quot;&quot;输出: 0 提示： 0 &lt;= s.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt; s 由英文字母、数字、符号和空格组成 Solution1234567891011121314151617181920212223242526func lengthOfLongestSubstring(s string) int &#123; m := map[byte]int&#123;&#125; n := len(s) rk, ans := -1, 0 for i := 0; i &lt; n; i++ &#123; if i != 0 &#123; delete(m,s[i-1]) &#125; for rk + 1 &lt; n &amp;&amp; m[s[rk+1]] == 0 &#123; m[s[rk+1]]++ rk++ &#125; ans = max(ans, rk - i + 1) &#125; return ans&#125;func max(x, y int) int &#123; if x &lt; y &#123; return y &#125; return x&#125; 28. 实现 strStr()实现 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 以及 Java 的 定义相符。 示例 1： 12输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出：2 示例 2： 12输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出：-1 示例 3： 12输入：haystack = &quot;&quot;, needle = &quot;&quot;输出：0 提示： 0 &lt;= haystack.length, needle.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt; haystack 和 needle 仅由小写英文字符组成 Solution12345678910111213func strStr(haystack string, needle string) int &#123; n,m := len(haystack), len(needle)outer: for i := 0; i + m &lt;= n; i++ &#123; for j:= range needle &#123; if haystack[i+j] != needle[j] &#123; continue outer &#125; &#125; return i &#125; return -1&#125; 121. 买卖股票的最佳时机给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt; 0 &lt;= prices[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt; Solution#贪心 12345678910111213141516func maxProfit(prices []int) (max int) &#123; min := prices[0] max = 0 for _,price := range prices &#123; if price &lt; min &#123; min = price &#125; else &#123; if max &gt; price - min &#123; continue &#125; else &#123; max = price - min &#125; &#125; &#125; return&#125;","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"学习笔记/Go","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.mingsrc.work/tags/Go/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.mingsrc.work/tags/LeetCode/"}]},{"title":"Go学习笔记（实验楼）","slug":"E_学习笔记/Go/GO_实验楼笔记","date":"2022-12-27T03:12:54.020Z","updated":"2022-12-27T03:12:54.020Z","comments":true,"path":"posts/aa7a6db9.html","link":"","permalink":"https://www.mingsrc.work/posts/aa7a6db9","excerpt":"","text":"[TOC] 一、Go语言介绍Go语言的特性并发编程*Go 语言引入了 goroutine，它是 Go 实现快速高效的并发编程的关键。通过调用 go 关键字，我们就可以让函数以 goroutine 的方式进行运行，也就是以协程为单位进行运行。 协程比线程更加的轻量级，也更节省系统资源，这使得我们可以创建大量的 goroutine，从而进行轻松且高质量的并发编程。同时，goroutine 内部采用管道 channel 进行消息传递，从而实现共享内存。在第五章我们还将对 Go 并发编程进行详细的讲解。 错误处理Go 语言中的错误处理的哲学和 C 语言一样，函数通过返回错误类型 (error) 或者 bool 类型（不需要区分多种错误状态时）表明函数的执行结果，调用检查返回的错误类型值是否是 nil 来判断调用结果。并引入了 defer 关键字用于标准的错误处理流程，并提供了内置函数 panic、recover 完成异常的抛出与捕捉。 垃圾回收Go 语言自带垃圾自动回收的功能，让 Go 语言不需要 delete 关键字，也不需要 free() 来释放内存。因此开发者无需考虑何时需要释放之前分配的内存的问题，系统会自动帮我们判断，并在适当的时候进行垃圾处理。垃圾自动回收是 Go 语言的一个特点，也是一大亮点。 多返回值Go 语言和 Python 一样也支持函数的多返回值功能，这个特性让开发者可以从原来用各种比较别扭的方式返回多个值得痛苦中解脱出来，不需要为了一次返回多个值而专门定义一个结构体。并且每个返回值都有自己的名字，开发者还可以选择具体需要返回的值，只需要使用下划线作为占位符来丢掉不要的返回值即可。 匿名函数Go 语言支持常规的匿名函数和闭包，开发者可以随意对匿名函数变量进行传递和调用，下面就是一个匿名函数样例： 123f := func(x,y int) int &#123; return x+y&#125; Go语言可以做什么Go 语言是谷歌发布的第二款开源编程语言。专门针对多处理器系统应用程序的编程进行了优化，使用 Go 编译的程序可以媲美 C 或 C++ 代码的速度，而且更加安全、支持并行进程。 Go 的目标是希望提升现有编程语言对程序库等依赖性 (dependency) 的管理，这些软件元素会被应用程序反复调用。由于存在并行编程模式，因此也被设计用来解决多处理器的任务。目前，已经有很多公司开始使用 Go 语言开发自己的服务，甚至完全转向 Go 开发，也诞生了很多基于 Go 的服务和应用，比如 Dokcer、k8s 等，现在我们看下，有哪些大公司在用 Go 语言了。 Google 对 Go 寄予厚望。旗下 App Engine 和其他部分产品已经开始使用 Go 语言来编写。作为开发 Go 语言的公司，当仁不让。 Facebook 也在用 GO，还专门在 GitHub 上建立了一个开源组织 Facebookgo，大家可以通过 GitHub 访问查看 Facebook 开源的项目，比如著名的——平滑升级的 grace。 此外，百度、阿里都在招 GO。京东云消息推送系统、云存储以及京东商城等都有使用 Go 做开发。 360 对 Golang 的使用主要是开源的日志搜索系统 Poseidon。而且，360 直播在招聘 Golang 开发工程师。 小米对 Golang 的支持，莫过于运维监控系统的开源，也就是 open-falcon 。此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用 Golang。 二、Go语言基础常量常量使用关键字 const 声明，下面有几个例子： 1234const limit = 512const top uint16 = 1421const Pi float64 = 3.1415926const x,y int = 1,3 //多重赋值 Go 的常量定义可以限定常量类型，但不是必需的。如果定义常量时没有指定类型，那么该常量就是无类型常量，也叫字面常量。 当需要设置多个常量的时候，不必重复使用 const 关键字，可以使用以下语法： 12345const ( Cyan = 0 Black = 1 White = 2) Go 语言还预定义了这些常量：true、false、iota。 iota 是一个可以被编译器修改的常量，在 const 关键字出现时被重置为 0，在下一个 const 出现之前，每出现一次 iota，其所代表的数字自动加 1。下面通过一个例子讲解 iota 的用法： 1234567const ( a = iota //a == 0 b = iota //b ==1 c = iota //c == 2)const d = iota //d==0,因为const的出现，iota被重置为0 操作符算术运算符 +：相加； -：相减； *：相乘； /：相除； %：求余； ++：自增； --：自减； 其中，++ 与 -- 不能用于赋值表达式, 如: count2 := count++；并且在 Go 语言中，不存在如：++count 表达式。 关系运算符 ==：检查两个值是否相等，如果相等返回 true，否则返回 false； !=：检查两个值是否不相等，如果不相等返回 true，否则返回 false； &gt;：检查左边值是否大于右边值，如果是返回 true，否则返回 false； &lt;：检查左边值是否小于右边值，如果是返回 true，否则返回 false； &gt;=：检查左边值是否大于等于右边值，如果是返回 true，否则返回 false； &lt;=：检查左边值是否小于等于右边值，如果是返回 true，否则返回 false； 逻辑运算符 &amp;&amp;：逻辑 AND 运算符。如果两边的操作数都是 true，则条件为 true，否则为 false； ||：逻辑 OR 运算符。如果两边的操作数有一个 true，则条件为 true，否则为 false； !：逻辑 NOT 运算符。如果条件为 true，则逻辑 NOT 添加为 true，否则为 false； 位运算符 &amp;：按位与运算符。其功能是参与运算的两个数的二进制按位对齐，当对应位都为 1 时，才返回 1； |：按位或运算符。其功能是参与运算的两个数的二进制按位对齐，当对应位中只要有一位是 1，就返回 1； ^：按位异或运算符。其是参与运算的两个数的二进制按位对齐，当对应位有一位是 1，就返回 1；如果对应两位都是 1 或 0，就返回 0； &lt;&lt;：左移运算符。其功能是将数值的二进制所有位向左移动指定的位数； &gt;&gt;：右移运算符。其功能是将数值的二进制所有位向右移动指定的位数； 赋值运算法 =：简单的赋值运算符，将一个表达式的值赋给一个左值; +=：相加后再赋值; -=：相减后再赋值； *=：相乘后再赋值； /=：相除后再赋值； %=：取余后再赋值； &amp;=：按位与后赋值； |=：按位或后赋值； ^=：按位异或后赋值； &lt;&lt;=：左位移后赋值； &gt;&gt;=：右位移后赋值； *和&amp; &amp;是取地址符号 , 即取得某个变量的地址 , 如 ：&amp;a *是指针运算符 , 可以表示一个变量是指针类型 , 也可以表示一个指针变量所指向的存储单元 , 也就是这个地址所存储的值 . 变量变量是所有语言最基本和最重要的组成部分。Go 语言引入了关键字 var 对变量进行声明，也可以使用 := 来对变量直接进行初始化，Go 编译器会自动推导出该变量的类型，这大大的方便了开发者的工作。但是需要注意的是 := 左侧的变量不能是已经被声明过的，否则会导致编译器错误。 以下是 Go 声明和初始化变量的各种方法： 123456789var a intvar b stringvar c float64var d [5] int //数组var e [] int //数组切片var f * int //正确var v1 int = 5 //正确var v2 = 5 //正确，编译器自动推导出V2类型v3 := 5 //正确，编译器自动推导出V3的类型 多重赋值Go 语言提供了大多数语言不支持的多重赋值，这使得变量的交换变得十分简单。下面通过一个例子来了解 Go 语言的多重赋值： 123i := 2j := 3i, j = j, i //交换i和j的值，此时i == 3，j == 2 这样的方式可以一行代码实现变量的交换，明显的减少代码的行数，而不需要像 C&#x2F;C++ 那样引入一个中间变量。 数据类型*整型Go 语言提供了 11 种整型，如下列表所示。 类型 说明 byte 等同于 uint8 int 依赖于不同平台下的实现，可以是 int32 或者 int64 int8 [-128, 127] int16 [-32768, 32767] int32 [-2147483648, 2147483647] int64 [-9223372036854775808, 9223372036854775807] rune 等同于 int32 uint 依赖于不同平台下的实现，可以是 uint32 或者 uint64 uint8 [0, 255] uint16 [0, 65535] uint32 [0, 4294967295] uint64 [0, 18446744073709551615] uintptr 一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64） 在 C 语言中我们可以通过 sizeof 操作符查看类型的字节长度，在 Go 语言中可以通过 unsafe.Sizeof 函数进行，创建源文件 type_length.go，输入以下代码： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;unsafe&quot;)func main() &#123; a := 12 fmt.Println(&quot;length of a: &quot;, unsafe.Sizeof(a)) var b int = 12 fmt.Println(&quot;length of b(int): &quot;, unsafe.Sizeof(b)) var c int8 = 12 fmt.Println(&quot;length of c(int8): &quot;, unsafe.Sizeof(c)) var d int16 = 12 fmt.Println(&quot;length of d(int16): &quot;, unsafe.Sizeof(d)) var e int32 = 12 fmt.Println(&quot;length of e(int32): &quot;, unsafe.Sizeof(e)) var f int64 = 12 fmt.Println(&quot;length of f(int64): &quot;, unsafe.Sizeof(f))&#125; 以上代码中，首先声明了目前的源文件属于 main 包，然后导入了 fmt 和 unsafe 包，fmt 包用于格式化字符串，unsafe 包含了用于获取 Go 语言类型信息的方法。然后在 main() 函数中，我们分别声明了几种类型的整型变量，并通过 unsafe.Sizeof 方法获取该类型的字节长度。最后我们通过以下方法运行 type_length.go，同时打印出了输出： 1234567$ go run type_length.golength of a: 8length of b(int): 8length of c(int8): 1length of d(int16): 2length of e(int32): 4length of f(int64): 8 浮点型Go 语言提供了两种浮点类型和两种复数类型，具体如下： 类型 说明 float32 ±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数 float64 ±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数 complex32 复数，实部和虚部都是 float32 complex64 复数，实部和虚部都是 float64 布尔类型Go 语言提供了内置的布尔值 true 和false。Go 语言支持标准的逻辑和比较操作，这些操作的结果都是布尔值。值得注意的地方是可以通过 !b 的方式反转变量 b 的真假。需要注意的是布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。实例代码如下： 12345678var a boola = trueb := (2 == 3) //b也会被推导为bool类型//错误示范var b boolb = 1 //编译错误b = bool(1) //编译错误 字符串Go 语言中的字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串也可能根据需要占用 1 至 4 个字节，这与其它语言如 C++、Java 或者 Python 不同。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。 Go 语言中字符串的可以使用双引号 (&quot;) 或者反引号 (&#96;&#96;&#96;) 来创建。双引号用来创建可解析的字符串字面量，所谓可解析的是指字符串中的一些符号可以被格式化为其他内容，如 \\n 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。以下是几个例子： 123t1 := &quot;\\&quot;hello\\&quot;&quot; //内容： &quot;hello&quot;t2 := `&quot;hello&quot;` //内容：和t1一致t3 := &quot;\\u6B22\\u8FCE&quot; //内容：欢迎 Go 语言中的部分转义字符如下表所示： 转义字符 含义 \\\\ 表示反斜线 \\&#39; 单引号 \\&quot; 双引号 \\n 换行符 \\uhhhh 4 个 16 进制数字给定的 Unicode 字符 在 Go 语言中单个字符可以使用单引号 (&#39;) 来创建。之前的课程中，我们有学习过 rune 类型，它等同于 int32，在 Go 语言中，一个单一的字符可以用一个单一的 rune 来表示。这也是容易理解的，因为 Go 语言的字符串是 UTF-8 编码，其底层使用 4 个字节表示，也就是 32 bit。 在 Go 语言中，字符串支持切片操作，但是需要注意的是如果字符串都是由 ASCII 字符组成，那可以随便使用切片进行操作，但是如果字符串中包含其他非 ASCII 字符，直接使用切片获取想要的单个字符时需要十分小心，因为对字符串直接使用切片时是通过字节进行索引的，但是非 ASCII 字符在内存中可能不是由一个字节组成。如果想对字符串中字符依次访问，可以使用 range 操作符。另外获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。字符串支持以下操作： 语法 描述 s += t 将字符串 t 追加到 s 末尾 s + t 将字符串 s 和 t 级联 s[n] 从字符串 s 中索引位置为 n 处的原始字节 s[n:m] 从位置 n 到位置 m-1 处取得的字符（字节）串 s[n:] 从位置 n 到位置 len(s)-1 处取得的字符（字节）串 s[:m] 从位置 0 到位置 m-1 处取得的字符（字节）串 len(s) 字符串 s 中的字节数 len([]rune(s)) 字符串 s 中字符的个数，可以使用更快的方法 utf8.RuneCountInString() []rune(s) 将字符串 s 转换为一个 unicode 值组成的串 string(chars) chars 类型是 []rune 或者 []int32, 将之转换为字符串 []byte(s) 无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节 让我们尝试一个例子，创建源文件 string_t.go，然后输入以下源代码： 1234567891011121314151617package mainimport ( &quot;fmt&quot;)func main() &#123; t0 := &quot;\\u6B22\\u8FCE\\u6765\\u5230&quot; // t0内容：欢迎来到 t1 := &quot;\\u5B9E\\u9A8C\\u697C&quot; // t1内容：实验楼 t2 := t0 + t1 for index, char := range t2 &#123; fmt.Printf(&quot;%-2d %U &#x27;%c&#x27; %X %d\\n&quot;, index, char, char, []byte(string(char)), len([]byte(string(char)))) &#125; fmt.Printf(&quot;length of t0: %d, t1: %d, t2: %d\\n&quot;, len(t0), len(t1), len(t2)) fmt.Printf(&quot;content of t2[0:2] is: %X\\n&quot;, t2[0:2])&#125; 然后通过以下方式运行，在这里一起显示了程序的输出： 12345678910$ go run string_t.go0 U+6B22 &#x27;欢&#x27; E6ACA2 33 U+8FCE &#x27;迎&#x27; E8BF8E 36 U+6765 &#x27;来&#x27; E69DA5 39 U+5230 &#x27;到&#x27; E588B0 312 U+5B9E &#x27;实&#x27; E5AE9E 315 U+9A8C &#x27;验&#x27; E9AA8C 318 U+697C &#x27;楼&#x27; E6A5BC 3length of t0: 12, t1: 9, t2: 21content of t2[0:2] is: E6AC 说明： 通过前面的课程我们知道通过 \\uhhhh 的方式我们可以通过创建 Unicode 字符。 在以上程序中，首先通过 := 符号创建了变量 t0，其值为 \\u6B22\\u8FCE\\u6765\\u5230，是 欢迎来到 中文字符的 unicode 编码，然后以同样的方式创建了变量 t1，其值为 实验楼，然后通过 + 操作符将 t0 和t1 拼接赋值给 t2。然后我们通过 range 操作符号对 unicode 字符串 t2 中的每一个 unicode 字符依次操作，我们这里只是简单的打印出每个字符在 t2 中的位置，每个字符的 unicode 码值，每个字符的字面量，每个字符的十六进制值，以及每个字符的字节长度。 这里我们使用 fmt 包种支持的格式指令，如果读者学习过 C 语言的话就一目了然。接着，我们通过 len 操作符计算出了每个字符串的字节长度。最后，我们使用切片访问了字符串 t2 的第 0-1 个字节，也就是前两个字节，其内容为 E6AC。前面我们说到不能使用切片的方式访问非 ASCII 字符串中的字符，原因在这里一目了然。字符 欢 其底层使用了三个字节表示，内容是 E6ACA2，如果只是简单的使用切片（只取切片中的一项）访问的是不能访问到整个字符的，因为字符的切片是通过字节数来索引的。 格式化字符串Go 语言标准库中的 fmt 包提供了打印函数将数据以字符串形式输出到控制台，文件，其他满足 io.Writer 接口的值以及其他字符串。目前为止我们使用了 fmt.Printf 和 fmt.Println，对于前者的使用，就像 C 语言中的 printf 函数一样，我们可以提供一些格式化指令，让 Go 语言对输出的字符串进行格式化。同样的我们可以使用一些格式化修饰符，改变格式化指令的输出结果， 如左对齐等。常用的格式化指令如下： 格式化指令 含义 %% % 字面量 %b 一个二进制整数，将一个整数格式化为二进制的表达方式 %c 一个 Unicode 的字符 %d 十进制数值 %o 八进制数值 %x 小写的十六进制数值 %X 大写的十六进制数值 %U 一个 Unicode 表示法表示的整形码值，默认是 4 个数字字符 %s 输出以原生的 UTF-8 字节表示的字符，如果 console 不支持 UTF-8 编码，则会输出乱码 %t 以 true 或者 false 的方式输出布尔值 %v 使用默认格式输出值，或者使用类型的 String() 方法输出的自定义值，如果该方法存在的话 %T 输出值的类型 常用的格式化指令修饰符如下： 空白 如果输出的数字为负，则在其前面加上一个减号 -。如果输出的是整数，则在前面加一个空格。使用 %x 或者 %X 格式化指令输出时，会在结果之间添加一个空格。例如 fmt.Printf(&quot;% X&quot;, &quot;实&quot;) 输出 E5 AE 9E。 # %#o 输出以 0 开始的八进制数据。 %#x 输出以 0x 开始的十六进制数据。 + 让格式化指令在数值前面输出 + 号或者 - 号，为字符串输出 ASCII 字符（非 ASCII 字符会被转义），为结构体输出其字段名。 - 让格式化指令将值向左对齐（默认值为像右对齐）。 0 让格式指令以数字 0 而非空白进行填充。 让我们练习一下，创建源文件 fmt_t.go，输入以下源码： 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)func main() &#123; text := &quot;\\u5B9E\\u9A8C\\u697C&quot; fmt.Printf(&quot;bool output:\\n%t\\n%t\\n\\n&quot;, true, false) fmt.Println(&quot;number output, origin value: 64&quot;) fmt.Printf(&quot;|%b|%8b|%-8b|%08b|% 8b|\\n&quot;, 64, 64, 64, 64, 64) fmt.Printf(&quot;|%x|%8x|%-8x|%08X|% 8X|\\n\\n&quot;, 64, 64, 64, 64, 64) fmt.Println(`text output, origin value: \\u5B9E\\u9A8C\\u697C`) fmt.Printf(&quot;content: %s\\n&quot;, text) fmt.Printf(&quot;hex value: % X\\nUnicode value: &quot;, text) for _, char := range text &#123; fmt.Printf(&quot;%U &quot;, char) &#125; fmt.Println() bytes := []byte(text) fmt.Printf(&quot;value of bytes: %s\\n&quot;, bytes) fmt.Printf(&quot;hex value of bytes: % X\\n&quot;, bytes) fmt.Printf(&quot;origin value of bytes: %v\\n&quot;, bytes)&#125; 运行代码，输出如下： 12345678910111213141516$ go run fmt_t.gobool output:truefalsenumber output, origin value: 64|1000000| 1000000|1000000 |01000000| 1000000||40| 40|40 |00000040| 40|text output, origin value: \\u5B9E\\u9A8C\\u697Ccontent: 实验楼hex value: E5 AE 9E E9 AA 8C E6 A5 BCUnicode value: U+5B9E U+9A8C U+697Cvalue of bytes: 实验楼hex value of bytes: E5 AE 9E E9 AA 8C E6 A5 BCorigin value of bytes: [229 174 158 233 170 140 230 165 188] 字符类型在 Go 语言中支持两个字符类型， UTF-8：一个是 Byte（实际上是 Unit8 的别名），代表 UTF-8 字符串的单个字节的值； Unicode:另一个是 rune，代表单个 Unicode 字符。 处于简化语言的考虑，Go 语言的多数 API 都假设字符串为 UTF-8 编码。尽管 Unicode 字符在标准库中有支持，但实际很少使用。 数组Go 语言的数组是一个定长的序列，其中的元素类型相同。多维数组可以简单地使用自身为数组的元素来创建。数组的元素使用操作符号 [ ] 来索引，索引从 0 开始，到 len(array)-1 结束。数组使用以下语法创建： [length]Type [N]Type&#123;value1, value2, ..., valueN&#125; [...]Type&#123;value1, value2, ..., valueN&#125; 如果使用了 ...（省略符）操作符，Go 语言会为我们自动计算数组的长度。在任何情况下，一个数组的长度都是固定的并且不可修改。数组的长度可以使用 len() 函数获得。由于数组的长度是固定的，因此数组的长度和容量都是一样的，因此对于数组而言 cap() 和 len() 函数返回值都是一样的。数组也可以使用和切片一样的语法进行切片，只是其结果为一个切片，而非数组。同样的，数组也可以使用 range 进行索引访问。 切片一般而言，Go 语言的切片比数组更加灵活，强大而且方便。数组是按值传递的（即是传递的副本），而切片是引用类型，传递切片的成本非常小，而且是不定长的。而且数组是定长的，而切片可以调整长度。创建切片的语法如下： make([ ]Type, length, capacity) make([ ]Type, length) [ ]Type&#123;&#125; [ ]Type&#123;value1, value2, ..., valueN&#125; 内置函数 make() 用于创建切片、映射和通道。当用于创建一个切片时，它会创建一个隐藏的初始化为零值的数组，然后返回一个引用该隐藏数组的切片。该隐藏的数组与 Go 语言中的所有数组一样，都是固定长度，如果使用第一种语法创建，那么其长度为切片的容量 capacity；如果是第二种语法，那么其长度记为切片的长度 length。一个切片的容量即为隐藏数组的长度，而其长度则为不超过该容量的任意值。另外可以通过内置的函数 append() 来增加切片的容量。切片可以支持以下操作： 我们练习下，创建源文件 slice_array.go，输入以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( &quot;fmt&quot;)func main() &#123; a := [...]int&#123;1, 2, 3, 4, 5, 6, 7&#125; fmt.Printf(&quot;len and cap of array %v is: %d and %d\\n&quot;, a, len(a), cap(a)) fmt.Printf(&quot;item in array: %v is:&quot;, a) for _, value := range a &#123; fmt.Printf(&quot;% d&quot;, value) &#125; fmt.Println() s1 := a[3:6] fmt.Printf(&quot;len and cap of slice: %v is: %d and %d\\n&quot;, s1, len(s1), cap(s1)) fmt.Printf(&quot;item in slice: %v is:&quot;, s1) for _, value := range s1 &#123; fmt.Printf(&quot;%d&quot;, value) &#125; fmt.Println() s1[0] = 456 fmt.Printf(&quot;item in array changed after changing slice: %v is:&quot;, s1) for _, value := range a &#123; fmt.Printf(&quot;%d&quot;, value) &#125; fmt.Println() s2 := make([]int, 10, 20) s2[4] = 5 fmt.Printf(&quot;len and cap of slice: %v is: %d and %d\\n&quot;, s2, len(s2), cap(s2)) fmt.Printf(&quot;item in slice %v is:&quot;, s2) for _, value := range s2 &#123; fmt.Printf(&quot;%d&quot;, value) &#125; fmt.Println()&#125; 以上代码中，我们首先创建了一个数组，数组的长度是由 Go 语言自动计算出的（省略号语法），然后通过切片操作从数组 a 中创建了切片 s1，接着我们修改了该切片的第一个位置的数值，然后发现数组 a 中的值也发生了变化。最后我们通过 make() 函数创建了一个切片，该切片的长度和容量分别为 10 和 20，还可以发现 Go 语言将未初始化的项自动赋予零值。运行代码输出如下： 12345678$ go run slice_array.golen and cap of array [1 2 3 4 5 6 7] is: 7 and 7item in array: [1 2 3 4 5 6 7] is: 1 2 3 4 5 6 7len and cap of slice: [4 5 6] is: 3 and 4item in slice: [4 5 6] is: 4 5 6item in array changed after changing slice: [456 5 6] is: 1 2 3 456 5 6 7len and cap of slice: [0 0 0 0 5 0 0 0 0 0] is: 10 and 20item in slice [0 0 0 0 5 0 0 0 0 0] is: 0 0 0 0 5 0 0 0 0 0 包 包是各种类型和函数的集合。在包中，如果标示符（类型名称，函数名称，方法名称）的首字母是大写，那这些标示符是可以被导出的，也就是说可以在包以外直接使用。 $GOPATH ：环境变量（指向一个或多个目录），以及其子目录 src 目录的，当我们使用 import 关键字导入包的时候，Go 语言会在 $GOPATH 和 GOROOT 目录中搜索包。 三、Go语言顺序编程流程控制 Go 语言提供的流程控制语句包括 if、switch、for、goto、select，其中 select 用于监听 channel（通道）在讲解通道的时候再详细介绍。 if 语句语法： 1234567if optionalStatement1; booleanExpression1 &#123; block1&#125; else if optionalStatement2; booleanExpression2 &#123; block2&#125; else &#123; block3&#125; 其中 optionalStatement 是可选的表达式，真正决定分支走向的是 booleanExpression1 的值。 for 语句Go 语言的 for 语句可以遍历数组，切片，映射等类型，也可以用于无限循环。以下是其语法： 123456789101112131415for &#123; // 无限循环 block&#125;for booleanExpression &#123; // while循环，在Go语言中没有while关键字&#125;for index, char := range aString &#123; // 迭代字符串&#125;for item := range aChannel &#123; // 迭代通道&#125; 跳转语句gotoGo 语言中使用 goto 关键字实现跳转。goto 语句的语义非常简单，就是跳转到本函数内的某个标签，例如： 123456789func myfunc()&#123; i := 0 THIS: //定义一个THIS标签 fmt.Println(i) i++ if i &lt; 1 &#123; goto THIS //跳转到THIS标签 &#125;&#125; switch分支Go 语言中 switch 分支既可用于常用的分支就像 C 语言中的 switch 一样，也可以用于类型开关，所谓类型开关就是用于判断变量属于什么类型。但是需要注意的是 Go 语言的 switch 语句不会自动贯穿，相反，如果想要贯穿需要添加 fallthrough 语句。表达式开关 switch 的语法如下： 123456switch optionalStatement; optionalExpression &#123; case expression1: block1 ... case expressionN: blockN default: blockD&#125; 下面是个例子： 12345678switch &#123; // 没有表达式，默认为True值，匹配分支中值为True的分支 case value &lt; minimum: return minimum case value &gt; maximum: return maximum default: return value&#125; 在上面的例子中，switch 后面没有默认的表达式，这个时候 Go 语言默认其值为 True。 在前面我们提到过类型断言，如果我们知道变量的类型就可以使用类型断言，但是当我们知道类型可能是许多类型中的一种时候，我们就可以使用类型开关。其语法如下： 123456switch optionalStatement; typeSwitchGuard &#123; case type1: block1 ... case typeN: blockN default: blockD&#125; 说了这么多，让我们进行下练习，创建源文件 switch_t.go，输入以下代码： 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot;)func classchecker(items ...interface&#123;&#125;) &#123; // 创建一个函数，该函数可以接受任意多的任意类型的参数 for i, x := range items &#123; switch x := x.(type) &#123; // 创建了影子变量 case bool: fmt.Printf(&quot;param #%d is a bool, value: %t\\n&quot;, i, x) case float64: fmt.Printf(&quot;param #%d is a float64, value: %f\\n&quot;, i, x) case int, int8, int16, int32, int64: fmt.Printf(&quot;param #%d is a int, value: %d\\n&quot;, i, x) case uint, uint8, uint16, uint32, uint64: fmt.Printf(&quot;param #%d is a uint, value: %d\\n&quot;, i, x) case nil: fmt.Printf(&quot;param #%d is a nil\\n&quot;, i) case string: fmt.Printf(&quot;param #%d is a string, value: %s\\n&quot;, i, x) default: fmt.Printf(&quot;param #%d&#x27;s type is unknow\\n&quot;, i) &#125; &#125;&#125;func main() &#123; classchecker(5, -17.98, &quot;AIDEN&quot;, nil, true, complex(1, 1))&#125; 以上代码中我们首先创建了一个接收任意数量任意类型参数的函数，然后使用 for ... range aSlice 的语法迭代了每一个在切片 items 中的元素，接着使用了 switch 类型开关判断了每一个参数的类型，并打印了其值和类型。程序运行输出如下： 1234567$ go run switch_t.goparam #0 is a int, value: 5param #1 is a float64, value: -17.980000param #2 is a string, value: AIDENparam #3 is a nilparam #4 is a bool, value: trueparam #5&#x27;s type is unknow 函数Go 语言可以很方便的自定义函数，其中有特殊的函数 main 函数。main 函数必须出现在 main 包里，且只能出现一次。当 Go 程序运行时候会自动调用 main 函数开始整个程序的执行。main 函数不可接收任何参数，也不返回任何结果。 函数的定义在 Go 语言中，函数的基本组成包括：关键字 func、函数名、参数列表、返回值、函数体和返回语句，这里我们用一个简单的加法函数来对函数的定义进行说明。 12345package addfunc Add(a int, b int) (num int)&#123; return a + b&#125; 函数的调用函数调用非常简单，先将被调用函数所在的包导入，就可以直接使用该函数了。注意需要把包文件夹放到 $GOPATH 目录中，实例如下： 1234567891011package mainimport ( &quot;add&quot; //导入 add 包 &quot;fmt&quot;)func main()&#123; c := add.Add(1, 2) //调用 add 包中的 add 函数 fmt.Println(c)&#125; 函数的多返回值与 C&#x2F;C++ 和 JAVA 不同，Go 语言的函数和方法可以有多个返回值，这是 Go 提供的一个优美的特性，示例如下： 12345678910package Divideimport &quot;errors&quot;func divide (a int, b int) (num int, err error)&#123; //定义两个返回值 if b == 0 &#123; err = errors.New(&quot;被除数不能为零！&quot;) return &#125; return a / b, nil //支持多个返回值&#125; 匿名函数在 Go 语言中，你可以在代码里随时定义匿名函数，匿名函数由一个不带函数名的函数声明和函数体组成，示例如下： 123func (a, b, c int) bool &#123; return a * b &lt; c&#125; 你可以将匿名函数直接赋值给一个变量，也可以直接调用运行，示例如下： 1234567x := func (a, b, c int) bool &#123; return a * b &lt; c&#125;func (a, b, c int) bool &#123; return a * b &lt; c&#125; (1, 2, 3) //小括号内直接给参数列表表示函数调用 类型转换类型转换Go 语言提供了一种在不同但相互兼容的类型之间相互转换的方式，这种转换非常有用并且是安全的。但是需要注意的是在数值之间进行转换可能造成其他问题，如精度丢失或者错误的结果。以下是类型转换的语法： resultOfType := Type(expression) 几个例子： 1234x := int16(2345) // 声明一个类型为int16的整数，其值为2345y := int32(x) // 将int16类型的整数转换为int32类型a := uint16(65000) // 声明一个类型为uint16类型的整数b := int16(a) // 转换为int16类型，虽然能转换成功，但是由于65000超过in16类型的范围，会导致结果错误，b的值为 -536 另外在 Go 语言中可以通过 type 关键字声明类型，如 type StringsSlice []string 将 []string（string 类型的切片）声明为 StringSlice 类型。 类型断言说到类型断言就需要先了解下 Go 语言中的接口。在 Go 语言中接口是一个自定义类型。它声明了一个或者多个方法。任何实现了这些方法的对象（类型）都满足这个接口。 接口是完全抽象的，不能实例化。interface&#123;&#125; 类型表示一个空接口，任何类型都满足空接口。也就是说 interface&#123;&#125; 类型的值可以用于表示任意 Go 语言类型的值。 这里的空接口有点类似于 Python 语言中的 object 实例。既然 interface&#123;&#125; 可以用于表示任意类型，那有的时候我们需要将 interface&#123;&#125; 类型转换为我们需要的类型，这个操作称为类型断言。 一般情况下只有我们希望表达式是某种特定类型的值时才使用类型断言。Go 语言中可以使用以下语法： resultOfType, boolean := expression.(Type)：安全的类型断言。 resultOfType := expression.(Type)：非安全的类型断言，失败时程序会产生异常。 创建源文件 type_t.go，输入以下源文件： 123456789101112131415161718192021package mainimport ( &quot;fmt&quot;)func main() &#123; x := uint16(65000) y := int16(x) // 将 x转换为int16类型 fmt.Printf(&quot;type and value of x is: %T and %d\\n&quot;, x, x) // %T 格式化指令的作用是输出变量的类型 fmt.Printf(&quot;type and value of y is: %T and %d\\n&quot;, y, y) var i interface&#123;&#125; = 99 // 创建一个interface&#123;&#125;类型，其值为99 var s interface&#123;&#125; = []string&#123;&quot;left&quot;, &quot;right&quot;&#125; j := i.(int) // 我们假设i是兼容int类型，并使用类型断言将其转换为int类型 fmt.Printf(&quot;type and value of j is: %T and %d\\n&quot;, j, j) if s, ok := s.([]string); ok &#123; // 创建了影子变量，if的作用域中覆盖了外部的变量s fmt.Printf(&quot;%T -&gt; %q\\n&quot;, s, s) &#125;&#125; 运行程序： 12345$ go run type_t.gotype and value of x is: uint16 and 65000type and value of y is: int16 and -536type and value of j is: int and 99[]string -&gt; [&quot;left&quot; &quot;right&quot;] 错误处理* 错误处理是任何语言都需要考虑到的问题，而 Go 语言在错误处理上解决得更为完善，优雅的错误处理机制是 Go 语言的一大特点。 errorGo 语言引入了一个错误处理的标准模式，即 error 接口，该接口定义如下： 123type error interface &#123; Error() string&#125; 对于大多数函数，如果要返回错误，可以将 error 作为多返回值的最后一个： 1234func foo(param int)(ret int, err error)&#123; ...&#125; 调用时的代码： 123456n, err := foo(0)if err != nil &#123; // 错误处理&#125; else &#123; // 使用返回值n&#125; 我们还可以自定义错误类型，创建源文件 error.go，输入以下代码： 1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;import &quot;errors&quot;//自定义的出错结构type myError struct &#123; arg int errMsg string&#125;//实现Error接口func (e *myError) Error() string &#123; return fmt.Sprintf(&quot;%d - %s&quot;, e.arg, e.errMsg)&#125;//两种出错func error_test(arg int) (int, error) &#123; if arg &lt; 0 &#123; return -1, errors.New(&quot;Bad Arguments - negtive!&quot;) &#125;else if arg &gt;256 &#123; return -1, &amp;myError&#123;arg, &quot;Bad Arguments - too large!&quot;&#125; &#125; return arg*arg, nil&#125;//相关的测试func main() &#123; for _, i := range []int&#123;-1, 4, 1000&#125; &#123; if r, e := error_test(i); e != nil &#123; fmt.Println(&quot;failed:&quot;, e) &#125; else &#123; fmt.Println(&quot;success:&quot;, r) &#125; &#125;&#125; defer 你可以在 Go 函数中添加多个 defer 语句，当函数执行到最后时，这些 defer 语句会按照逆序执行（即最后一个 defer 语句将最先执行），最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。 如下代码所示，我们一般写打开一个资源是这样操作的： 1234567891011121314151617func CopyFile(dst, src string) (w int64, err error) &#123; srcFile, err := os.Open(src) if err != nil &#123; return &#125; defer srcFile.Close() dstFile, err := os.Create(dst) if err != nil &#123; return &#125; defer dstFile.Close() return io.Copy(dstFile, srcFile)&#125; 如果 defer 后面一条语句干不完清理工作，也可以使用一个匿名函数： 123defer func()&#123; ...&#125;() 注意，defer 语句是在 return 之后执行的，新建源文件 defer.go 输入以下代码： 12345678910func test() (result int) &#123; defer func() &#123; result = 12 &#125;() return 10&#125;func main() &#123; fmt.Println(test()) // 12&#125; panic 和 recoverpanic() 函数用于抛出异常，recover() 函数用于捕获异常，这两个函数的原型如下： 12func panic(interface&#123;&#125;)func recover() interface&#123;&#125; 当在一个函数中调用 panic() 时，正常的函数执行流程将立即终止，但函数中之前使用 defer 关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致逐层向上执行 panic() 流程，直至所属的 goroutine 中所有正在执行的函数被终止。错误信息将被报告，包括在调用 panic() 函数时传入的参数，这个过程称为错误流程处理。 panic() 接受一个 interface&#123;&#125; 参数，可支持任意类型，例如： 123panic(404)panic(&quot;network broken&quot;)panic(Error(&quot;file not exists&quot;)) 在 defer 语句中，可以使用 recover() 终止错误处理流程，这样可以避免异常向上传递，但要注意 recover() 之后，程序不会再回到 panic() 那里，函数仍在 defer 之后返回。新建一个源文件 error1.go，输入以下代码： 12345678910111213141516171819func foo() &#123; panic(errors.New(&quot;i&#x27;m a bug&quot;)) return&#125;func test() (result int) &#123; defer func() &#123; if r := recover(); r != nil &#123; err := r.(error) fmt.Println(&quot;Cache Exception:&quot;, err) &#125; &#125;() foo() return 10&#125;func main() &#123; fmt.Println(test()) // 0&#125; 四、面向对象编程 Go 语言的代码是以包结构来组织的，且如果标示符（变量名，函数名，自定义类型等）***如果以大写字母开头那么这些标示符是可以导出的**，可以在任何导入了定义该标示符的包的包中直接使用。Go 语言中的面向对象和 C++，Java 中的面向对象不同，因为 Go 语言不支持继承，Go 语言只支持组合。 自定义类型及结构体 Go 语言的中结构体 struct 与 C++、JAVA 中的类 class 相似，但 Go 放弃了传统面向对象的诸多特性，只保留了组合。 1type typeName typeSpecification 其中，typeName 可以是一个包或者函数内唯一合法的 Go 标示符。typeSpecification 可以是任何内置的类型，一个接口或者是一个结构体。所谓结构体，它的字段是由其他类型或者接口组成。例如我们通过结构体定义了一下类型： 1234type ColorPoint struct &#123; color.Color // 匿名字段(嵌入) x, y int // 具名字段(聚合)&#125; 以上代码我们通过结构体自定义了类型 ColorPoint，结构体中 color.Color 字段是 Color 包的类型 color，这个字段没有名字，所以被称为匿名的，也是嵌入字段。字段 x 和 y 是有变量名的，所以被称为具名字段。假如我们创建了类型 ColorPoint 的一个值 point（通过语法：point := ColorPoint&#123;&#125; 创建），那么这些字段可以通过 point.Color、point.x、point.y 访问。其他面向对象语言中的”类 (class)”、”对象 (object)”、”实例 (instance)”在 Go 语言中我们完全避开使用。相反的我们使用”类型 (type)”和其对应的”值”，其中自定义类型的值可以包含方法。 定义了结构体后如何创建并初始化一个对象实例呢？Go 语言支持以下几种方法进行实现： 12345678910//先定义一个结构体Mantype Man struct&#123; name string age int&#125;//对象创建与初始化man := new(Man)man := &amp;Man&#123;&#125;man := &amp;Man&#123;&quot;Tom&quot;, 18&#125;man := &amp;Man&#123;name: &quot;Tom&quot;, age: 18&#125; 为了更加方便的创建对象，我们一般会使用一个全局函数来完成对象的创建，这和传统的“构造函数”类似。 123func NewMan(name string, age int) *Man &#123; return &amp;Man&#123;name, age&#125;&#125; 方法 方法是作用在自定义类型上的一类特殊函数，通常自定义类型的值会被传递给该函数，该值可能是以指针或者复制值的形式传递。定义方法和定义函数几乎相同，只是需要在 func 关键字和方法名之间必须写上接接受者。例如我们给类型 Count 定义了以下方法： 12345type Count intfunc (count *Count) Increment() &#123; *count++ &#125; // 接受者是一个 `Count` 类型的指针func (count *Count) Decrement() &#123; *count-- &#125;func (count Count) IsZero() bool &#123; return count == 0 &#125; 以上代码中，我们在内置类型 int 的基础上定义了自定义类型 Count，然后给该类型添加了 Increment()、Decrement() 和 IsZero() 方法，其中前两者的接受者为 Count 类型的指针，后一个方法接收 Count 类型的值。 Demo: 类型的方法集是指可以被该类型的值调用的所有方法的集合。 一个指向自定义类型的值的指针，它的方法集由该类型定义的所有方法组成，无论这些方法接受的是一个值还是一个指针。如果在指针上调用一个接受值的方法，Go 语言会聪明地将该指针解引用。 一个自定义类型值的方法集合则由该类型定义的接收者为值类型的方法组成，但是不包括那些接收者类型为指针的方法。 其实这些限制 Go 语言帮我们解决的非常好，结果就是我们可以在值类型上调用接收者为指针的方法。假如我们只有一个值，仍然可以调用一个接收者为指针类型的方法，这是因为 Go 语言会自动获取值的地址传递给该方法，前提是该值是可寻址的。 在以上定义的类型 Count 中，*Count 方法集是 Increment(), Decrement() 和 IsZero()，Count 的值的方法集是 IsZero()。但是因为 Count 类型的是可寻址的，所以我们可以使用 Count 的值调用全部的方法。 另外如果结构体的字段也有方法，我们也可以直接通过结构体访问字段中的方法。下面让我们练习下，创建源文件 struct_t.go，输入以下代码： 123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;fmt&quot;type Count int // 创建自定义类型 Countfunc (count *Count) Increment() &#123; *count++ &#125; // Count类型的方法func (count *Count) Decrement() &#123; *count-- &#125;func (count Count) IsZero() bool &#123; return count == 0 &#125;type Part struct &#123; // 基于结构体创建自定义类型 Part stat string Count // 匿名字段&#125;func (part Part) IsZero() bool &#123; // 覆盖了匿名字段Count的IsZero()方法 return part.Count.IsZero() &amp;&amp; part.stat == &quot;&quot; // 调用了匿名字段的方法&#125;func (part Part) String() string &#123; // 定义String()方法，自定义了格式化指令%v的输出 return fmt.Sprintf(&quot;&lt;&lt;%s, %d&gt;&gt;&quot;, part.stat, part.Count)&#125;func main() &#123; var i Count = -1 fmt.Printf(&quot;Start \\&quot;Count\\&quot; test:\\nOrigin value of count: %d\\n&quot;, i) i.Increment() fmt.Printf(&quot;Value of count after increment: %d\\n&quot;, i) fmt.Printf(&quot;Count is zero t/f? : %t\\n\\n&quot;, i.IsZero()) fmt.Println(&quot;Start: \\&quot;Part\\&quot; test:&quot;) part := Part&#123;&quot;232&quot;, 0&#125; fmt.Printf(&quot;Part: %v\\n&quot;, part) fmt.Printf(&quot;Part is zero t/f? : %t\\n&quot;, part.IsZero()) fmt.Printf(&quot;Count in Part is zero t/f?: %t\\n&quot;, part.Count.IsZero()) // 尽管覆盖了匿名字段的方法，单还是可以访问&#125; 以上代码中，我们创建了 Count 类型，然后在其基础上又创建了结构体类型 Part。我们为 Count 类型定义了 3 个方法，并在 Part 类型中创建了方法 IsZero() 覆盖了其匿名字段 Count 中 IsZero() 方法。但是我们还是可以二次访问到匿名字段中被覆盖的方法。执行代码，输出如下： 123456789101112$ go run struct_t.goStart &quot;Count&quot; test:Origin value of count: -1Value of count after increment: 0Count is zero t/f? : trueStart: &quot;Part&quot; test:Part: &lt;&lt;232, 0&gt;&gt;Part is zero t/f? : falseCount in Part is zero t/f?: true 组合 Go 语言虽然抛弃了继承，但是却提供了一个更加方便的组合特性。相对于继承的编译期确定实现，组合的运行态指定实现，更加灵活。下面通过一段代码来了解组合的基本属性以及它与继承的不同之处。 先定义一个结构体 Base, 并为它添加两个方法 Foo() 和 Bar()： 1234567891011121314151617type Base struct&#123; Name string&#125;func (b *Base) Foo() &#123;...&#125;func (b *Base) Bar() &#123;...&#125;type Seed struct &#123; Base ...&#125;func (s *Seed) Foo() &#123; s.Base.Foo() s.Bar() ...&#125; 上面代码先定义了一个 Base 类，然后定义了一个 Seed 类。Seed 类“继承”了 Base 类的所有成员属性和方法并重写了 Foo() 方法。同时在重写 Foo() 方法时调用了 Base 类的 Foo() 方法和 Bar() 方法。需要注意的是，若此时 Seed 的对象通过 s.Foo() 调用 Foo() 方法时，实际调用的是 Seed 重写过后的 Foo() 方法，而不是基类 Base 的 Foo() 方法，若想调用 Base 类的 Foo() 方法则要使用 s.Base.Foo，而调用没有重写的 Bar() 方法时，使用 s.Bar() 和s.Base.Bar() 效果是一样的。 接口在 Go 中，接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。它与 oop 非常相似。接口指定类型应具有的方法，类型决定如何实现这些方法。 接口基础之所以说 Go 语言的面向对象很灵活，很大一部分原因是由于接口的存在。接口是一个自定义类型，它声明了一个或者多个方法签名，任何实现了这些方法的类型都实现这个接口。infterface&#123;&#125; 类型是声明了空方法集的接口类型。任何一个值都满足 interface&#123;&#125; 类型，也就是说如果一个函数或者方法接收 interface&#123;&#125; 类型的参数，那么任意类型的参数都可以传递给该函数。接口是完全抽象的，不能实例化。接口能存储任何实现了该接口的类型。直接看例子吧，创建源文件 interface_t.go，输入以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport &quot;fmt&quot;type Human struct &#123; // 结构体 name string age int phone string&#125;//Human实现SayHi方法func (h Human) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s you can call me on %s\\n&quot;, h.name, h.phone)&#125;//Human实现Sing方法func (h Human) Sing(lyrics string) &#123; fmt.Println(&quot;La la la la...&quot;, lyrics)&#125;type Student struct &#123; Human //匿名字段 school string loan float32&#125;type Employee struct &#123; Human //匿名字段 company string money float32&#125;// Employee重载Human的SayHi方法func (e Employee) SayHi() &#123; fmt.Printf(&quot;Hi, I am %s, I work at %s. Call me on %s\\n&quot;, e.name, e.company, e.phone)&#125;// Interface Men被Human,Student和Employee实现// 因为这三个类型都实现了这两个方法type Men interface &#123; SayHi() Sing(lyrics string)&#125;func main() &#123; mike := Student&#123;Human&#123;&quot;Mike&quot;, 25, &quot;222-222-XXX&quot;&#125;, &quot;MIT&quot;, 0.00&#125; paul := Student&#123;Human&#123;&quot;Paul&quot;, 26, &quot;111-222-XXX&quot;&#125;, &quot;Harvard&quot;, 100&#125; sam := Employee&#123;Human&#123;&quot;Sam&quot;, 36, &quot;444-222-XXX&quot;&#125;, &quot;Golang Inc.&quot;, 1000&#125; Tom := Employee&#123;Human&#123;&quot;Tom&quot;, 37, &quot;222-444-XXX&quot;&#125;, &quot;Things Ltd.&quot;, 5000&#125; //定义Men类型的变量i var i Men //i能存储Student i = mike fmt.Println(&quot;This is Mike, a Student:&quot;) i.SayHi() i.Sing(&quot;November rain&quot;) //i也能存储Employee i = Tom fmt.Println(&quot;This is Tom, an Employee:&quot;) i.SayHi() i.Sing(&quot;Born to be wild&quot;) //定义了slice Men fmt.Println(&quot;Let&#x27;s use a slice of Men and see what happens&quot;) x := make([]Men, 3) //这三个都是不同类型的元素，但是他们实现了interface同一个接口 x[0], x[1], x[2] = paul, sam, mike for _, value := range x &#123; value.SayHi() &#125;&#125; 接口变量值的类型* 接口类型声明的变量里能存储任何实现了该接口的类型的值。 有的时候我们需要知道这个变量里的值的类型，那么需要怎么做呢？可以使用类型断言，或者是 switch 类型判断分支。以下的例子 interface_t1.go 我们使用了 switch 类型判断分支。 123456789101112131415161718192021222324252627282930313233343536373839404142/*使用了switch 类型判断分支*/package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)type Element interface&#123;&#125;type List []Elementtype Person struct &#123; name string age int&#125;// 实现了fmt.Stringer接口func (p Person) String() string &#123; return &quot;(name: &quot; + p.name + &quot;- age: &quot; + strconv.Itoa(p.age) + &quot; years)&quot;&#125;func main() &#123; list := make(List, 4) list[0] = 1 list[1] = &quot;Hello&quot; list[2] = Person&#123;&quot;Dennis&quot;, 70&#125; list[3] = 1 + 2i for index, element := range list &#123; switch value := element.(type) &#123; case int: fmt.Printf(&quot;list[%d] is an int and its value is %d\\n&quot;, index, value) case string: fmt.Printf(&quot;list[%d] is an int and its value is %s\\n&quot;, index, value) case Person: fmt.Printf(&quot;list[%d] is an int and its value is %s\\n&quot;, index, value) default: fmt.Printf(&quot;list[%d] is of a different type&quot;, index) &#125; &#125;&#125; 嵌入interface结构体中可以嵌入匿名字段，其实在接口里也可以再嵌入接口。如果一个 interface1 作为 interface2 的一个嵌入字段，那么 interface2 隐式的包含了 interface1 里的方法。如下例子中，Interface2 包含了 Interface1 的所有方法。 123456789type Interface1 interface &#123; Send() Receive()&#125;type Interface2 interface &#123; Interface1 Close()&#125; 五、并发编程 并发与并行并发指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，通过 CPU 时间片轮转使多个进程快速交替的执行。而并行的关键是你有同时处理多个任务的能力。并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）CPU 执行，如果可以就说明是并行，而并发是多个线程被（一个）CPU 轮流切换着执行。一个经典且通俗易懂的例子这样解释并发与并行的区别：并发是两个队列，使用一台咖啡机；并行是两个队列，使用两台咖啡机。如果串行，一个队列使用一台咖啡机，那么哪怕前面那个人有事出去了半天，后面的人也只能等着他回来才能去接咖啡，这效率无疑是最低的。图解： 协程*协程也叫轻量级线程。与传统的进程和线程相比，协程最大的优点就在于其足够“轻”，操作系统可以轻松创建上百万个协程而不会导致系统资源枯竭，而线程和进程通常最多不过近万个。而多数语言在语法层面上是不支持协程的，一般都是通过库的方式进行支持，但库的支持方式和功能不够完善，经常会引发阻塞等一系列问题，而 Go 语言在语法层面上支持协程，也叫 goroutine。这让协程变得非常简单，让轻量级线程的切换管理不再依赖于系统的进程和线程，也不依赖 CPU 的数量。 goroutine*goroutine 是 Go 语言并行设计的核心。goroutine 是一种比线程更轻量的实现，十几个 goroutine 可能在底层就是几个线程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。要使用 goroutine 只需要简单的在需要执行的函数前添加 go 关键字即可。当执行 goroutine 时候，Go 语言立即返回，接着执行剩余的代码，goroutine 不阻塞主线程。下面我们通过一小段代码来讲解 go 的使用： 1234567//首先我们先实现一个 Add()函数func Add(a, b int) &#123; c := a + b fmt.Println(c)&#125;go Add(1, 2) //使用go关键字让函数并发执行 Go 的并发执行就是这么简单，当在一个函数前加上 go 关键字，该函数就会在一个新的 goroutine 中并发执行，当该函数执行完毕时，这个新的 goroutine 也就结束了。不过需要注意的是，如果该函数具有返回值，那么返回值会被丢弃。所以什么时候用 go 还需要酌情考虑。 接着我们通过一个案例来体验一下 Go 的并发到底是怎么样的。新建源文件 goroutine.go，输入以下代码： 1234567891011121314package mainimport &quot;fmt&quot;func Add(a, b int) &#123; c := a + b fmt.Println(c)&#125;func main() &#123; for i := 0; i &lt; 10; i++ &#123; go Add(i, i) &#125;&#125; 执行 goroutine.go 文件会发现屏幕上什么都没有，但程序并不会报错，这是什么原因呢？原来当主程序执行到 for 循环时启动了 10 个 goroutine，然后主程序就退出了，而启动的 10 个 goroutine 还没来得及执行 Add() 函数，所以程序不会有任何输出。也就是说主 goroutine 并不会等待其他 goroutine 执行结束。那么如何解决这个问题呢？Go 语言提供的信道（channel）就是专门解决并发通信问题的 channelchannel 是goroutine 之间互相通讯的东西。类似我们 Unix 上的管道（可以在进程间传递消息），用来 goroutine 之间发消息和接收消息。其实，就是在做 goroutine 之间的内存共享。channel 是类型相关的，也就是说一个 channel 只能传递一种类型的值，这个类型需要在 channel 声明时指定。 声明与初始化channel 的一般声明形式：var chanName chan ElementType。 与普通变量的声明不同的是在类型前面加了 channel 关键字，ElementType 则指定了这个 channel 所能传递的元素类型。示例： 123var a chan int //声明一个传递元素类型为int的channelvar b chan float64var c chan string 初始化一个 channel 也非常简单，直接使用 Go 语言内置的 make() 函数，示例： 123a := make(chan int) //初始化一个int型的名为a的channelb := make(chan float64)c := make(chan string) channel 最频繁的操作就是写入和读取，这两个操作也非常简单，示例： 123a := make(chan int)a &lt;- 1 //将数据写入channelz := &lt;-a //从channel中读取数据 selectselect 用于处理异步 IO 问题，它的语法与 switch 非常类似。由 select 开始一个新的选择块，每个选择条件由 case 语句来描述，并且每个 case 语句里必须是一个 channel 操作。它既可以用于 channel 的数据接收，也可以用于 channel 的数据发送。如果 select 的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。 新建源文件 channel.go，输入以下代码： 1234567891011121314151617181920212223package mainimport &quot;time&quot;import &quot;fmt&quot;func main() &#123; c1 := make(chan string) c2 := make(chan string) go func() &#123; time.Sleep(time.Second * 1) c1 &lt;- &quot;one&quot; &#125;() go func() &#123; time.Sleep(time.Second * 2) c2 &lt;- &quot;two&quot; &#125;() for i := 0; i &lt; 2; i++ &#123; select &#123; case msg1 := &lt;-c1: fmt.Println(&quot;received&quot;, msg1) case msg2 := &lt;-c2: fmt.Println(&quot;received&quot;, msg2) &#125; &#125;&#125; 以上代码先初始化两个 channel c1 和 c2，然后开启两个 goroutine 分别往 c1 和 c2 写入数据，再通过 select 监听两个 channel，从中读取数据并输出。 运行结果如下： 123$ go run channel.goreceived onereceived two 关于 for select 和 channel 的用法：select 语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行。select 语句的分支分为两种，一种叫做候选分支，另一种叫做默认分支。候选分支总是以关键字 case 开头，后跟一个 case 表达式和一个冒号，然后我们可以从下一行开始写入当分支被选中时需要执行的语句。 由于 select 语句是专为通道而设计的，所以每个 case 表达式中都只能包含操作通道的表达式，比如接收表达式。使用一个接收值可以接收通道里的值，使用两个接收值可以判断通道是否已经关闭了。 对于 select 语句的执行规则如下： 每个 case 都必须是一个通信。 所有 Channel 表达式都会被求值。 所有被发送的表达式都会被求值。 如果任意某个通信可以进行，它就执行，其他被忽略。 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 否则： 如果有 default 子句，则执行该语句。 如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 Channel 或值进行求值。 注意这里是和 switch 的操作是不一样的，switch 操作中，只要从上到下有一个满足条件了，就会执行相应的那一个 case，select 中，我们是全部计算一遍，然后再从可满足条件的 case 中公平的执行其中一个。这是为了防止有些通道长期得不到执行。 超时机制通过前面的内容我们了解到，channel 的读写操作非常简单，只需要通过 &lt;- 操作符即可实现，但是 channel 的使用不当却会带来大麻烦。我们先来看之前的一段代码： 123a := make(chan int)a &lt;- 1z := &lt;-a 观察上面三行代码，第 2 行往 channel 内写入了数据，第 3 行从 channel 中读取了数据，如果程序运行正常当然不会出什么问题，可如果第二行数据写入失败，或者 channel 中没有数据，那么第 3 行代码会因为永远无法从 a 中读取到数据而一直处于阻塞状态。相反的，如果 channel 中的数据一直没有被读取，那么写入操作也会一直处于阻塞状态。如果不正确处理这个情况，很可能会导致整个 goroutine 锁死，这就是超时问题。Go 语言没有针对超时提供专门的处理机制，但是我们却可以利用 select 来巧妙地实现超时处理机制，下面看一个示例： 1234567891011t := make(chan bool)go func &#123; time.Sleep(1e9) //等待1秒 t &lt;- true&#125;select &#123; case &lt;-ch: //从ch中读取数据 case &lt;-t: //如果1秒后没有从ch中读取到数据，那么从t中读取，并进行下一步操作&#125; 这样的方法就可以让程序在等待 1 秒后继续执行，而不会因为 ch 读取等待而导致程序停滞，从而巧妙地实现了超时处理机制，这种方法不仅简单，在实际项目开发中也是非常实用的。 channel 的关闭channel 的关闭非常简单，使用 Go 语言内置的 close() 函数即可关闭 channel，示例： 12ch := make(chan int)close(ch) 关闭了 channel 后如何查看 channel 是否关闭成功了呢？很简单，我们可以在读取 channel 时采用多重返回值的方式，示例： 1x, ok := &lt;-ch 通过查看第二个返回值的 bool 值即可判断 channel 是否关闭，若为 false 则表示 channel 被关闭，反之则没有关闭。 六、词频统计综合案例实现词频统计的程序逻辑很简单。我们首先会创建一个映射，然后读取文件的每一行，提取单词，然后更新映射中单词所对应的数量即可。 为了演示面向对象和 goroutine 的使用，我们将基础映射类型封装成了一个统计单词频率的包。我们在基础映射类型上创建了类型 WordCound，然后为该类型了实现了关键方法 UpdateFreq() 和 WordFreqCounter()，其中前者会读取一个文件并统计该文件中的所有单词的词频，后者通过 goroutine 实现了并发统计。 其并发逻辑是：对于每一个文件，创建一个 goroutine，在这个 goroutine 内部调用 UpdateFreq() 方法统计对应文件的词频，当统计完成以后会将映射中每一对键值转化为 Pair 结构发送到 results 通道，并在发送完成时候发送一个空结构体的值到 done 通道以表示自己的任务已经完成。由于 map 映射结构不支持并发写操作，所以我们通过 result 通道来保证每次只有一个 goroutine 能更新映射。又因为当所有的 goroutine 结束以后，有可能 results 通道中还有没来得及处理的数据，所以在 WordFreqCounter() 的结尾我们又开启了一个 for 循环处理 results 通道中的剩余数据。说了这么多，我们直接写代码吧。 在 $GOPATH/src/wordcount 目录中创建文件 wordcount.go，输入以下源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package wordcountimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;io&quot; &quot;log&quot; &quot;os&quot; &quot;sort&quot; &quot;strings&quot; &quot;unicode&quot; &quot;unicode/utf8&quot;)type Pair struct &#123; Key string Value int&#125;// PariList实现了sort接口，可以使用sort.Sort对其排序type PairList []Pairfunc (p PairList) Swap(i, j int) &#123; p[i], p[j] = p[j], p[i] &#125;func (p PairList) Len() int &#123; return len(p) &#125;func (p PairList) Less(i, j int) bool &#123; return p[j].Value &lt; p[i].Value &#125; // 逆序// 提取单词func SplitOnNonLetters(s string) []string &#123; notALetter := func(char rune) bool &#123; return !unicode.IsLetter(char) &#125; return strings.FieldsFunc(s, notALetter)&#125;/* 基于map实现了类型WordCount, 并对期实现了Merge(), Report(), SortReport(), UpdateFreq(), WordFreqCounter() 方法*/type WordCount map[string]int// 用于合并两个WordCountfunc (source WordCount) Merge(wordcount WordCount) WordCount &#123; for k, v := range wordcount &#123; source[k] += v &#125; return source&#125;// 打印词频统计情况func (wordcount WordCount) Report() &#123; words := make([]string, 0, len(wordcount)) wordWidth, frequencyWidth := 0, 0 for word, frequency := range wordcount &#123; words = append(words, word) if width := utf8.RuneCountInString(word); width &gt; wordWidth &#123; wordWidth = width &#125; if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth &#123; frequencyWidth = width &#125; &#125; sort.Strings(words) gap := wordWidth + frequencyWidth - len(&quot;Word&quot;) - len(&quot;Frequency&quot;) fmt.Printf(&quot;Word %*s%s\\n&quot;, gap, &quot; &quot;, &quot;Frequency&quot;) for _, word := range words &#123; fmt.Printf(&quot;%-*s %*d\\n&quot;, wordWidth, word, frequencyWidth, wordcount[word]) &#125;&#125;// 从多到少打印词频func (wordcount WordCount) SortReport() &#123; p := make(PairList, len(wordcount)) i := 0 for k, v := range wordcount &#123; // 将wordcount map转换成PairList p[i] = Pair&#123;k, v&#125; i++ &#125; sort.Sort(p) // 因为PairList实现了排序接口，所以可以使用sort.Sort()对其排序 wordWidth, frequencyWidth := 0, 0 for _, pair := range p &#123; word, frequency := pair.Key, pair.Value if width := utf8.RuneCountInString(word); width &gt; wordWidth &#123; wordWidth = width &#125; if width := len(fmt.Sprint(frequency)); width &gt; frequencyWidth &#123; frequencyWidth = width &#125; &#125; gap := wordWidth + frequencyWidth - len(&quot;Word&quot;) - len(&quot;Frequency&quot;) fmt.Printf(&quot;Word %*s%s\\n&quot;, gap, &quot; &quot;, &quot;Frequency&quot;) for _, pair := range p &#123; fmt.Printf(&quot;%-*s %*d\\n&quot;, wordWidth, pair.Key, frequencyWidth, pair.Value) &#125;&#125;// 从文件中读取单词，并更新其出现的次数func (wordcount WordCount) UpdateFreq(filename string) &#123; var file *os.File var err error if file, err = os.Open(filename); err != nil &#123; log.Println(&quot;failed to open the file: &quot;, err) return &#125; defer file.Close() // 本函数退出之前时，关闭文件 reader := bufio.NewReader(file) for &#123; line, err := reader.ReadString(&#x27;\\n&#x27;) for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) &#123; if len(word) &gt; utf8.UTFMax || utf8.RuneCountInString(word) &gt; 1 &#123; wordcount[strings.ToLower(word)] += 1 &#125; &#125; if err != nil &#123; if err != io.EOF &#123; log.Println(&quot;failed to finish reading the file: &quot;, err) &#125; break &#125; &#125;&#125;// 并发统计单词频次func (wordcount WordCount) WordFreqCounter(files []string) &#123; results := make(chan Pair, len(files)) // goroutine 将结果发送到该channel done := make(chan struct&#123;&#125;, len(files)) // 每个goroutine工作完成后，发送一个空结构体到该channel，表示工作完成 for i := 0; i &lt; len(files); &#123; // 有多少个文件就开启多少个goroutine, 使用匿名函数的方式 go func(done chan&lt;- struct&#123;&#125;, results chan&lt;- Pair, filename string) &#123; wordcount := make(WordCount) wordcount.UpdateFreq(filename) for k, v := range wordcount &#123; pair := Pair&#123;k, v&#125; results &lt;- pair &#125; done &lt;- struct&#123;&#125;&#123;&#125; &#125;(done, results, files[i]) i++ &#125; for working := len(files); working &gt; 0; &#123; // 监听通道，直到所有的工作goroutine完成任务时才退出 select &#123; case pair := &lt;-results: // 接收发送到通道中的统计结果 wordcount[pair.Key] += pair.Value case &lt;-done: // 判断工作goroutine是否全部完成 working-- &#125; &#125;DONE: // 再次启动for循环处理通道中还未处理完的值 for &#123; select &#123; case pair := &lt;-results: wordcount[pair.Key] += pair.Value default: break DONE &#125; &#125; close(results) close(done)&#125; 然后在 $GOPATH 目录中创建文件 wordfreq.go，输入以下源码： 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;path/filepath&quot; &quot;wordcount&quot;)func main() &#123; if len(os.Args) == 1 || os.Args[1] == &quot;-h&quot; || os.Args[1] == &quot;--help&quot; &#123; fmt.Printf(&quot;usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\\n&quot;, filepath.Base(os.Args[0])) os.Exit(1) &#125; wordcounter := make(wordcount.WordCount) // for _, filename := range os.Args[1:] &#123; // wordcount.UpdateFreq(filename) // &#125; wordcounter.WordFreqCounter(os.Args[1:]) wordcounter.SortReport()&#125; 七、IDE及环境配置1","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"学习笔记/Go","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.mingsrc.work/tags/Go/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"}]},{"title":"Zinx","slug":"E_学习笔记/Go/Zinx","date":"2022-12-27T03:12:54.020Z","updated":"2022-12-27T03:12:54.021Z","comments":true,"path":"posts/67527f52.html","link":"","permalink":"https://www.mingsrc.work/posts/67527f52","excerpt":"","text":"[Toc] go环境变量设置 export GOPATH=/home/project Zinx架构设计客户端请求服务器响应的过程 要有一个客户端对服务器发起请求。 我们的服务器应该去启动对客户端的处理模块并打开工作池来提升并发量。 处理客户端的模块开启两个模块，一个负责读客户端请求，一个负责写客户端请求。 用于读的功能模块，去任务的消息队列里去请求读数据。用于写的功能模块，通过 API 接口，当然我们的 API 不可能只有一个，所以这里肯定是 APIS。 其过程如下所示： Zinx功能模块 v0.1Zinx目录结构如下所示： iserver.go1234567891011package ziface// 定义服务器接口type IServer interface &#123; // 启动服务器 Start() // 停止服务器 Stop() // 开启业务服务方法 Server()&#125; server.go *123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package znetimport ( &quot;fmt&quot; &quot;net&quot; &quot;zinx/ziface&quot;)// IServer 接口实现，定义一个Server服务类type Server struct &#123; //服务器的名称 Name string //tcp4 or other IPVersion string //服务绑定的IP地址 IP string //服务绑定的端口 Port int&#125;/* 创建一个服务器句柄*/func NewServer (name string) ziface.IServer &#123; s := &amp;Server &#123; Name: name, IPVersion:&quot;tcp4&quot;, IP:&quot;0.0.0.0&quot;, Port:7777, &#125; return s&#125;// 开启网络服务func (s *Server) Start() &#123; fmt.Printf(&quot;[START] Server listenner at IP: %s, Port %d, is starting\\n&quot;, s.IP, s.Port) // 开启一个go去做服务端Linster业务 go func() &#123; // 1. 获取一个tcp的Addr addr, err := net.ResolveTCPAddr(s.IPVersion, fmt.Sprintf(&quot;%s,%d&quot;, s.IP, s. Port)) if err != nil &#123; fmt.Println(&quot;resolve tcp addr err: &quot;, err) &#125; // 2. 监听服务器地址 listenner, err := net.ListenTCP(s.IPVersion, addr) if err != nil &#123; fmt.Println(&quot;listen&quot;, s.IPVersion, &quot;err&quot;, err) return &#125; // 已经监听成功 fmt.Println(&quot;Start zinx Server &quot;, s.Name, &quot; succ, now listenning……&quot;) // 3 启动server网络连接业务 for &#123; // 3.1 阻塞等待客户端建立连接请求 conn, err := listenner.AcceptTCP() if err != nil &#123; fmt.Println(&quot;Accept err &quot;, err) continue &#125; // 3.2 TODO Server.Start() 设置服务器最大连接控制，如果超过最大连接，那么关闭此新的连接 // 3.3 TODO Server.Start() 处理该新连接请求的 *业务* 方法，此时应该有handler和conn是绑定的 // 我们这里暂时做一个最大512字节的回显服务 go func() &#123; // 不断地循环从客户端获取数据 for &#123; buf := make([]byte, 512) cnt, err := conn.Read(buf) if err != nil &#123; fmt.Println(&quot;recv bug err &quot;, err) continue &#125; // 回显 if _, err := conn.Write(buf[:cnt]); err != nil &#123; fmt.Println(&quot;write back buf err&quot;, err) continue &#125; &#125; &#125;() &#125; &#125;()&#125;// 停止func (s *Server) Stop() &#123; fmt.Println(&quot;[STOP] Zinx server, name&quot;, s.Name)&#125;// 开启业务func (s *Server) Server() &#123; &#125; server_test.go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package znetimport ( &quot;fmt&quot; &quot;net&quot; &quot;testing&quot; &quot;time&quot;)/* 模拟客户端*/func ClientTest() &#123; fmt.Println(&quot;Client Test ... start&quot;) // 3秒之后发起测试请求，给服务端开启服务的机会 time.Sleep(3 * time.Second) conn,err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:7777&quot;) if err != nil &#123; fmt.Println(&quot;client start err, exit!&quot;) return &#125; for &#123; _, err = conn.Write([]byte(&quot;Hello ZINX&quot;)) if err != nil &#123; fmt.Println(&quot;Write error err &quot;, err) return &#125; buf := make([]byte, 512) cnt, err := conn.Read(buf) if err != nil &#123; fmt.Println(&quot;read buf err&quot;, err) return &#125; fmt.Printf(&quot; server call back: %s, cnt = %d\\n&quot;, buf, cnt) time.Sleep(1 * time.Second) &#125;&#125;// Server 模块的测试函数func TestServer(t *testing.T) &#123; /* 服务端测试 */ // 1 创建一个server句柄 s s := NewServer(&quot;[zinx V0.1]&quot;) /* 客户端测试 */ go ClientTest() // 2 开启服务 s.Server() &#125; [v0.2] 实现链接封装业务与业务绑定功能如思维导图所示： 文件结构 代码iconnection.go12345678910111213141516171819package zifaceimport &quot;net&quot;// 定义连接接口type IConnection interface &#123; // 启动连接，让电气概念连接开始工作 Start() // 停止连接，结束当前链接状态 Stop() // 从当前链接获取原始的socket TCPConn GetTCPConnection() *net.TCPConn // 获取当前链接ID GetConnID() uint32 // 获取远程客户端地址信息 RemoteAddr() net.Addr&#125;// 定义一个统一处理链接业务的接口type HandFunc func(*net.TCPConn, []byte, int) error connection.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package znetimport ( &quot;fmt&quot; &quot;net&quot; &quot;zinx/ziface&quot;)type Connection struct &#123; // 当前链接的socket TCP套接字 Conn *net.TCPConn // 当前连接的ID 也可以称作为SessionID， ID全局唯一 ConnID uint32 // 当前连接的关闭状态 isClosed bool // 该链接的处理方法api handleAPI ziface.HandFunc // 告知该链接已经退出/停止的channel ExitBufferChan chan bool&#125;// 创建连接的方法func NewConntion(conn *net.TCPConn, connID uint32, callBack_api ziface.HandFunc) *Connection &#123; c := &amp;Connection&#123; Conn: conn, ConnID: connID, isClosed: false, handleAPI: callBack_api, ExitBufferChan: make(chan bool, 1), &#125; return c&#125;/* 处理conn读数据的Goroutine */func (c *Connection) StartReader() &#123; fmt.Println(&quot;Reader Goroutine is running&quot;) defer fmt.Println(c.Conn.RemoteAddr().String(), &quot;conn reader exit&quot;) defer c.Stop() for &#123; // 读取我们最大的数据到buf中 buf := make([]byte,512) cnt, err := c.Conn.Read(buf) if err != nil &#123; fmt.Println(&quot;recv bug err &quot;, err) c.ExitBufferChan &lt;- true continue &#125; // 调用当前链接业务（这里执行的是当前conn的绑定的handle方法） if err := c.handleAPI(c.Conn, buf, cnt); err != nil &#123; fmt.Println(&quot;connID &quot;, c.ConnID, &quot; handle is error&quot;) c.ExitBufferChan &lt;- true return &#125; &#125;&#125;// 启动链接，让当前连接开始工作func (c *Connection) Start() &#123; // 开启处理该链接读取客户端数据之后的请求业务 go c.StartReader() for &#123; select &#123; case &lt;- c.ExitBufferChan: // 得到退出消息，不再阻塞 return &#125; &#125;&#125;// 停止连接，结束当前连接状态Mfunc (c *Connection) Stop() &#123; // 1. 如果当前链接已经关闭 if c.isClosed == true &#123; return &#125; c.isClosed = true // TODO Connection Stop() 如果用户注册了该链接的关闭毁掉业务，那么在此刻应该显示调用 // 关闭socket链接 c.Conn.Close() // 通知从缓冲队列读取数据的业务，该链接已经关闭 c.ExitBufferChan &lt;- true // 关闭该链接全部管道 close(c.ExitBufferChan)&#125;// 从当前连接获取原始的socket TCPConnfunc (c *Connection) GetTCPConnection() *net.TCPConn &#123; return c.Conn&#125;// 获取当前IDfunc (c *Connection) GetConnID() uint32 &#123; return c.ConnID&#125;// 获取远程客户端地址信息func (c *Connection) RemoteAddr() net.Addr &#123; return c.Conn.RemoteAddr() &#125; server.go 代码修改1234567891011121314151617181920// TODO server.go 应该有一个自动生成ID的方法+ var cid uint32 = 0 // 3 启动server网络连接业务 for &#123; // 3.1 阻塞等待客户端建立连接请求 conn, err := listenner.AcceptTCP() if err != nil &#123; fmt.Println(&quot;Accept err &quot;, err) continue &#125; // 3.2 TODO Server.Start() 设置服务器最大连接控制，如果超过最大连接，那么关闭此新的连接 // 3.3 TODO Server.Start() 处理该新连接请求的 *业务* 方法，此时应该有handler和conn是绑定的+ dealConn := NewConntion(conn, cid, CallBackToClient)+ cid ++ //3.4 启动当前链接的处理业务 go dealConn.Start() &#125; &#125;() [v0.3] 实现基础路由模块 通俗讲就是实现一个类，系统地去回调一些用户的操作 功能 涉及知识点： 路由功能模块 目录结构 IRequest消息请求抽象类 把客户端请求的连接信息和请求的数据，放在一个叫 Request 的请求类里，这样的好处是我们可以从 Request 里得到全部客户端的请求信息，也为我们之后拓展框架有一定的作用，一旦客户端有额外的含义的数据信息，都可以放在这个 Request 里。可以理解为每次客户端的全部请求数据，Zinx 都会把它们一起放到一个 Request 结构体里。 创建抽象IRequest层 123456789package ziface/* IRequest 接口： 实际上是把客户端请求的链接信息 和 请求的数据 包装到了 Request里*/type IRequest interface&#123; GetConnection() IConnection //获取请求连接信息 GetData() []byte //获取请求消息的数据&#125; 当前的抽象层只提供了两个 Getter 方法，所以有个成员应该是必须的，一个是客户端连接，一个是客户端传递进来的数据，当然随着 Zinx 框架的功能丰富，这里面还应该继续添加新的成员。 实现Requeset类 12345678910111213141516package znetimport &quot;zinx/ziface&quot;type Request struct &#123; conn ziface.IConnection //已经和客户端建立好的 链接 data []byte //客户端请求的数据&#125;//获取请求连接信息func(r *Request) GetConnection() ziface.IConnection &#123; return r.conn&#125;//获取请求消息的数据func(r *Request) GetData() []byte &#123; return r.data&#125; IRouter路由配置抽象类* 实现一个非常简单基础的路由功能，目的当然就是为了快速的让 Zinx 步入到路由的阶段。 创建抽象的IRouter层 我们知道 router 实际上的作用就是，服务端应用可以给 Zinx 框架配置当前链接的处理业务方法，之前的 Zinx-V0.2 我们的 Zinx 框架处理链接请求的方法是固定的，现在是可以自定义，并且有 3 种接口可以重写。 Handle：是处理当前链接的主业务函数 PreHandle：如果需要在主业务函数之前有前置业务，可以重写这个方法 PostHandle:如果需要在主业务函数之后又后置业务，可以重写这个方法 当然每个方法都有一个唯一的形参 IRequest 对象，也就是客户端请求过来的连接和请求数据，作为我们业务方法的输入数据。 12345678910package ziface/* 路由接口， 这里面路由是 使用框架者给该链接自定的 处理业务方法 路由里的IRequest 则包含用该链接的链接信息和该链接的请求数据信息*/type IRouter interface&#123; PreHandle(request IRequest) //在处理conn业务之前的钩子方法 Handle(request IRequest) //处理conn业务的方法 PostHandle(request IRequest) //处理conn业务之后的钩子方法&#125; 实现Router类 123456789101112package znetimport &quot;zinx/ziface&quot;//实现router时，先嵌入这个基类，然后根据需要对这个基类的方法进行重写type BaseRouter struct &#123;&#125;//这里之所以BaseRouter的方法都为空，// 是因为有的Router不希望有PreHandle或PostHandle// 所以Router全部继承BaseRouter的好处是，不需要实现PreHandle和PostHandle也可以实例化func (br *BaseRouter)PreHandle(req ziface.IRequest)&#123;&#125;func (br *BaseRouter)Handle(req ziface.IRequest)&#123;&#125;func (br *BaseRouter)PostHandle(req ziface.IRequest)&#123;&#125; IServer增添路由添加功能 这一步需要修改原有的链接结构体，同时对服务中的方法进行修改 server类 iserver.go 123456789101112package ziface//定义服务器接口type IServer interface&#123; //启动服务器方法 Start() //停止服务器方法 Stop() //开启业务服务方法 Serve() //路由功能：给当前服务注册一个路由业务方法，供客户端链接处理使用 AddRouter(router IRouter)&#125; server.go 12345678910111213//iServer 接口实现，定义一个Server服务类type Server struct &#123; //服务器的名称 Name string //tcp4 or other IPVersion string //服务绑定的IP地址 IP string //服务绑定的端口 Port int //当前Server由用户绑定的回调router,也就是Server注册的链接对应的处理业务 Router ziface.IRouter&#125; NewServer()方法中的成员初始化 12345678910111213/* 创建一个服务器句柄 */func NewServer (name string) ziface.IServer &#123; s:= &amp;Server &#123; Name :name, IPVersion:&quot;tcp4&quot;, IP:&quot;0.0.0.0&quot;, Port:7777, Router: nil, &#125; return s&#125; Connection类 connection.go 123456789101112type Connection struct &#123; //当前连接的socket TCP套接字 Conn *net.TCPConn //当前连接的ID 也可以称作为SessionID，ID全局唯一 ConnID uint32 //当前连接的关闭状态 isClosed bool //该连接的处理方法router Router ziface.IRouter //告知该链接已经退出/停止的channel ExitBuffChan chan bool&#125; 123456789101112131415161718192021222324252627func (c *Connection) StartReader() &#123; fmt.Println(&quot;Reader Goroutine is running&quot;) defer fmt.Println(c.RemoteAddr().String(), &quot; conn reader exit!&quot;) defer c.Stop() for &#123; //读取我们最大的数据到buf中 buf := make([]byte, 512) _, err := c.Conn.Read(buf) if err != nil &#123; fmt.Println(&quot;recv buf err &quot;, err) c.ExitBuffChan &lt;- true continue &#125; //得到当前客户端请求的Request数据 req := Request&#123; conn:c, data:buf, &#125; //从路由Routers 中找到注册绑定Conn的对应Handle go func (request ziface.IRequest) &#123; //执行注册的路由方法 c.Router.PreHandle(request) c.Router.Handle(request) c.Router.PostHandle(request) &#125;(&amp;req) &#125;&#125; AddRouter在server类要实现添加路由的方法AddRouter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package znetimport ( &quot;fmt&quot; &quot;net&quot; &quot;time&quot; &quot;zinx/ziface&quot;)//iServer 接口实现，定义一个Server服务类type Server struct &#123; //服务器的名称 Name string //tcp4 or other IPVersion string //服务绑定的IP地址 IP string //服务绑定的端口 Port int //当前Server由用户绑定的回调router,也就是Server注册的链接对应的处理业务 Router ziface.IRouter&#125;/* 创建一个服务器句柄 */func NewServer (name string) ziface.IServer &#123; s:= &amp;Server &#123; Name :name, IPVersion:&quot;tcp4&quot;, IP:&quot;0.0.0.0&quot;, Port:7777, Router: nil, &#125; return s&#125;//============== 实现 ziface.IServer 里的全部接口方法 ========//开启网络服务func (s *Server) Start() &#123; fmt.Printf(&quot;[START] Server listenner at IP: %s, Port %d, is starting\\n&quot;, s.IP, s.Port) //开启一个go去做服务端Linster业务 go func() &#123; //1 获取一个TCP的Addr addr, err := net.ResolveTCPAddr(s.IPVersion, fmt.Sprintf(&quot;%s:%d&quot;, s.IP, s.Port)) if err != nil &#123; fmt.Println(&quot;resolve tcp addr err: &quot;, err) return &#125; //2 监听服务器地址 listenner, err:= net.ListenTCP(s.IPVersion, addr) if err != nil &#123; fmt.Println(&quot;listen&quot;, s.IPVersion, &quot;err&quot;, err) return &#125; //已经监听成功 fmt.Println(&quot;start Zinx server &quot;, s.Name, &quot; succ, now listenning...&quot;) //TODO server.go 应该有一个自动生成ID的方法 var cid uint32 cid = 0 //3 启动server网络连接业务 for &#123; //3.1 阻塞等待客户端建立连接请求 conn, err := listenner.AcceptTCP() if err != nil &#123; fmt.Println(&quot;Accept err &quot;, err) continue &#125; //3.2 TODO Server.Start() 设置服务器最大连接控制,如果超过最大连接，那么则关闭此新的连接 //3.3 处理该新连接请求的 业务 方法， 此时应该有 handler 和 conn是绑定的 dealConn := NewConntion(conn, cid, s.Router) cid ++ //3.4 启动当前链接的处理业务 go dealConn.Start() &#125; &#125;()&#125;func (s *Server) Stop() &#123; fmt.Println(&quot;[STOP] Zinx server , name &quot; , s.Name) //TODO Server.Stop() 将其他需要清理的连接信息或者其他信息 也要一并停止或者清理&#125;func (s *Server) Serve() &#123; s.Start() //TODO Server.Serve() 是否在启动服务的时候 还要处理其他的事情呢 可以在这里添加 //阻塞,否则主Go退出， listenner的go将会退出 for &#123; time.Sleep(10*time.Second) &#125;&#125;//路由功能：给当前服务注册一个路由业务方法，供客户端链接处理使用func (s *Server)AddRouter(router ziface.IRouter) &#123; s.Router = router fmt.Println(&quot;Add Router succ! &quot; )&#125; 在connnection同样要加上相应的路由对应的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package znetimport ( &quot;fmt&quot; &quot;net&quot; &quot;zinx/ziface&quot;)type Connection struct &#123; //当前连接的socket TCP套接字 Conn *net.TCPConn //当前连接的ID 也可以称作为SessionID，ID全局唯一 ConnID uint32 //当前连接的关闭状态 isClosed bool //该连接的处理方法router Router ziface.IRouter //告知该链接已经退出/停止的channel ExitBuffChan chan bool&#125;//创建连接的方法func NewConntion(conn *net.TCPConn, connID uint32, router ziface.IRouter) *Connection&#123; c := &amp;Connection&#123; Conn: conn, ConnID: connID, isClosed: false, Router: router, ExitBuffChan: make(chan bool, 1), &#125; return c&#125;func (c *Connection) StartReader() &#123; fmt.Println(&quot;Reader Goroutine is running&quot;) defer fmt.Println(c.RemoteAddr().String(), &quot; conn reader exit!&quot;) defer c.Stop() for &#123; //读取我们最大的数据到buf中 buf := make([]byte, 512) _, err := c.Conn.Read(buf) if err != nil &#123; fmt.Println(&quot;recv buf err &quot;, err) c.ExitBuffChan &lt;- true continue &#125; //得到当前客户端请求的Request数据 req := Request&#123; conn:c, data:buf, &#125; //从路由Routers 中找到注册绑定Conn的对应Handle go func (request ziface.IRequest) &#123; //执行注册的路由方法 c.Router.PreHandle(request) c.Router.Handle(request) c.Router.PostHandle(request) &#125;(&amp;req) &#125;&#125;//启动连接，让当前连接开始工作func (c *Connection) Start() &#123; //开启处理该链接读取到客户端数据之后的请求业务 go c.StartReader() for &#123; select &#123; case &lt;- c.ExitBuffChan: //得到退出消息，不再阻塞 return &#125; &#125;&#125;//停止连接，结束当前连接状态Mfunc (c *Connection) Stop() &#123; //1. 如果当前链接已经关闭 if c.isClosed == true &#123; return &#125; c.isClosed = true //TODO Connection Stop() 如果用户注册了该链接的关闭回调业务，那么在此刻应该显示调用 // 关闭socket链接 c.Conn.Close() //通知从缓冲队列读数据的业务，该链接已经关闭 c.ExitBuffChan &lt;- true //关闭该链接全部管道 close(c.ExitBuffChan)&#125;//从当前连接获取原始的socket TCPConnfunc (c *Connection) GetTCPConnection() *net.TCPConn &#123; return c.Conn&#125;//获取当前连接IDfunc (c *Connection) GetConnID() uint32&#123; return c.ConnID&#125;//获取远程客户端地址信息func (c *Connection) RemoteAddr() net.Addr &#123; return c.Conn.RemoteAddr()&#125; 测试Server.go 我们这里自定义了一个类似 Ping 操作的路由，就是当客户端发送数据，我们的处理业务就是返回给客户端”ping..ping..ping..”, 为了测试，当前路由也同时实现了 PreHandle 和 PostHandle 两个方法。实际上 Zinx 会利用模板的设计模式，依次在框架中调用PreHandle、Handle、PostHandle三个方法。 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;zinx/ziface&quot; &quot;zinx/znet&quot;)//ping test 自定义路由type PingRouter struct &#123; znet.BaseRouter //一定要先基础BaseRouter&#125;//Test PreHandlefunc (this *PingRouter) PreHandle(request ziface.IRequest) &#123; fmt.Println(&quot;Call Router PreHandle&quot;) _, err := request.GetConnection().GetTCPConnection().Write([]byte(&quot;before ping ....\\n&quot;)) if err !=nil &#123; fmt.Println(&quot;call back ping ping ping error&quot;) &#125;&#125;//Test Handlefunc (this *PingRouter) Handle(request ziface.IRequest) &#123; fmt.Println(&quot;Call PingRouter Handle&quot;) _, err := request.GetConnection().GetTCPConnection().Write([]byte(&quot;ping...ping...ping\\n&quot;)) if err !=nil &#123; fmt.Println(&quot;call back ping ping ping error&quot;) &#125;&#125;//Test PostHandlefunc (this *PingRouter) PostHandle(request ziface.IRequest) &#123; fmt.Println(&quot;Call Router PostHandle&quot;) _, err := request.GetConnection().GetTCPConnection().Write([]byte(&quot;After ping .....\\n&quot;)) if err !=nil &#123; fmt.Println(&quot;call back ping ping ping error&quot;) &#125;&#125;func main()&#123; //创建一个server句柄 s := znet.NewServer(&quot;[zinx V0.3]&quot;) s.AddRouter(&amp;PingRouter&#123;&#125;) //2 开启服务 s.Serve()&#125; Client.go代码不变 [v0.4] 全局配置模块 增加一个配置文件zinx.json，保存服务器的各项属性，方便修改服务器的参数 功能 涉及知识点： json格式问题 全局配置文件的好处 在zinx目录下新建utils文件夹，在utils文件夹下新建globalobj.go文件，这个go文件就是实现配置文件读取与输出的功能。 配置文件在zinx下新建conf文件下，在其下新建zinx.json配置文件，内容如下： 123456&#123; &quot;Name&quot;: &quot;demo server&quot;, &quot;Host&quot;: &quot;127.0.0.1&quot;, &quot;TcpPort&quot;: 7777, &quot;MaxConn&quot;: 3 &#125; 从globalobj.go的功能来看，这里可以设置你所有的需要加入到服务器的配置，以GlobalObj结构体中的数据成员为主。 globalobj.go对新手来讲，这个文件的代码中需要关注的两个函数： ioutil.ReadFile json.Unmarshal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package utilsimport ( &quot;encoding/json&quot; &quot;io/ioutil&quot; &quot;zinx/ziface&quot; &quot;fmt&quot;)/* 存储一些有关Zinx框架的全局参数，供其他模块使用 一些参数也可以通过用户根据zinx.json来配置*/type GlobalObj struct &#123; tcpServer ziface.IServer // 当前Zinx的全局Server对象 Host string // 当前服务器主机IP TcpPort int // 当前服务器主机监听端口号 Name string // 当前服务器名称 Version string // 当前Zinx版本 MaxPacketSize uint32 // 都需数据包的最大值 MaxConn int // 当前服务器主机允许的最大链接个数&#125;/* 定义一个全局的对象*/var GlobalObject *GlobalObj// 读取用户的配置文件func (g *GlobalObj) Reload() &#123; data, err := ioutil.ReadFile(&quot;D:/Program Files/Go/src/zinx/conf/zinx.json&quot;) if err != nil &#123; panic(err) &#125; // 将 json 数据解析到struct中 // fmt.Printf(&quot;json: %s\\n&quot;, data) err = json.Unmarshal(data, &amp;GlobalObject) if err != nil &#123; panic(err) &#125; fmt.Println(fmt.Sprintf(&quot;%+v&quot;,*GlobalObject))&#125;/* 提供init方法，默认加载*/func init() &#123; // 初始化GlobalObject变量，设置一些默认值 GlobalObject = &amp; GlobalObj&#123; Name: &quot;ZinxServerApp&quot;, Version: &quot;V0.4&quot;, TcpPort: 7777, Host: &quot;0.0.0.0&quot;, MaxConn: 12000, MaxPacketSize: 4096, &#125; // 从配置文件中加载一些用户配置的参数 GlobalObject.Reload()&#125; [V0.5] 消息封装功能0.5版本要做的就是把服务器的全部数据都放在一个Request里： 涉及知识点： tcp封包拆包 消息封装 创建消息封装类型当前的Request结构如下： 1234type Request struct &#123; conn ziface.IConnection //已经和客户端建立好的链接 data []byte //客户端请求的数据&#125; 创建消息封装的结构体以及相关方法： imessage.go在zinx/ziface/下创建imessage.go文件: 将请求的一个消息封装到 message 中，定义抽象层接口，定义好 Getter 方法和 Setter 方法。 1234567891011121314package ziface/* 将请求的一个消息封装到message中，定义抽象层接口*/type IMessage interface &#123; GetDataLen() uint32 // 获取消息数据段长度 GetMsgId() uint32 // 获取消息ID GetData() []byte // 获取消息内容 SetMsgId(uint32) // 设置消息ID SetData([]byte) // 设置消息内容 SetDataLen(uint32) // 设置消息数据段长度&#125; message.go同时创建实例 message 类，在zinx/znet/下，创建message.go文件。 整理一个基本的 message 包，会包含消息 ID，数据，数据长度三个成员，提供基本的 setter 和 getter 方法，目的是为了以后做封装优化的作用。同时也提供了一个创建一个 message 包的初始化方法NewMegPackage。 这里我们只需要要实现 Message 类，写出构造函数，实现接口中对应的方法，比较的简单，大家可以试试先自己尝试实现。 1234567891011121314151617181920212223242526272829303132333435363738394041package znettype Message struct &#123; Id uint32 // 消息的ID DataLen uint32 // 消息的长度 Data []byte // 消息的内容&#125;// 创建一个Message的消息包func NewMsgPackage(id uint32, data []byte) *Message &#123; return &amp;Message&#123; Id: id, DataLen: uint32(len(data)), Data: data, &#125;&#125;// 获取消息数据段长度func (msg *Message) GetDataLen() uint32 &#123; return msg.DataLen;&#125;//获取消息IDfunc (msg *Message) GetMsgId() uint32 &#123; return msg.Id&#125;//获取消息内容func (msg *Message) GetData() []byte &#123; return msg.Data&#125;//设置消息数据段长度func (msg *Message) SetDataLen(len uint32) &#123; msg.DataLen = len&#125;//设计消息IDfunc (msg *Message) SetMsgId(msgId uint32) &#123; msg.Id = msgId&#125;//设计消息内容func (msg *Message) SetData(data []byte) &#123; msg.Data = data&#125; 拆包与封包*采用TCL(Type-Len-Value)封包格式解决TCP粘包问题 创建拆包封包抽象类在zinx/ziface下，创建idatapack.go文件 我们需要三个方法： 封包数据。 拆包数据。 得到头部长度。 12345678910package ziface/* 封包数据和拆包数据 直接面向TCP连接中的数据流,为传输数据添加头部信息，用于处理TCP粘包问题。 */type IDataPack interface&#123; GetHeadLen() uint32 //获取包头长度方法 Pack(msg IMessage)([]byte, error) //封包方法 Unpack([]byte)(IMessage, error) //拆包方法&#125; 实现拆包封包类在zinx/znet/下，创建datapack.go文件. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package znetimport ( &quot;bytes&quot; &quot;encoding/binary&quot; &quot;errors&quot; &quot;zinx/utils&quot; &quot;zinx/ziface&quot;)//封包拆包类实例，暂时不需要成员type DataPack struct &#123;&#125;//封包拆包实例初始化方法func NewDataPack() *DataPack &#123; return &amp;DataPack&#123;&#125;&#125;//获取包头长度方法func(dp *DataPack) GetHeadLen() uint32 &#123; //Id uint32(4字节) + DataLen uint32(4字节) return 8&#125;//封包方法(压缩数据)func(dp *DataPack) Pack(msg ziface.IMessage)([]byte, error) &#123; //创建一个存放bytes字节的缓冲 dataBuff := bytes.NewBuffer([]byte&#123;&#125;) //写dataLen if err := binary.Write(dataBuff, binary.LittleEndian, msg.GetDataLen()); err != nil &#123; return nil, err &#125; //写msgID if err := binary.Write(dataBuff, binary.LittleEndian, msg.GetMsgId()); err != nil &#123; return nil, err &#125; //写data数据 if err := binary.Write(dataBuff, binary.LittleEndian, msg.GetData()); err != nil &#123; return nil ,err &#125; return dataBuff.Bytes(), nil&#125;//拆包方法(解压数据)func(dp *DataPack) Unpack(binaryData []byte)(ziface.IMessage, error) &#123; //创建一个从输入二进制数据的ioReader dataBuff := bytes.NewReader(binaryData) //只解压head的信息，得到dataLen和msgID msg := &amp;Message&#123;&#125; //读dataLen if err := binary.Read(dataBuff, binary.LittleEndian, &amp;msg.DataLen); err != nil &#123; return nil, err &#125; //读msgID if err := binary.Read(dataBuff, binary.LittleEndian, &amp;msg.Id); err != nil &#123; return nil, err &#125; //判断dataLen的长度是否超出我们允许的最大包长度 if (utils.GlobalObject.MaxPacketSize &gt; 0 &amp;&amp; msg.DataLen &gt; utils.GlobalObject.MaxPacketSize) &#123; return nil, errors.New(&quot;Too large msg data recieved&quot;) &#125; //这里只需要把head的数据拆包出来就可以了，然后再通过head的长度，再从conn读取一次数据 return msg, nil&#125; 需要注意的是整理的Unpack方法，因为我们从上图可以知道，我们进行拆包的时候是分两次过程的，第二次是依赖第一次的 dataLen 结果，所以Unpack只能解压出包头 head 的内容，得到 msgId 和 dataLen。之后调用者再根据 dataLen 继续从 io 流中读取 body 中的数据。 测试拆包与封包类型客户端与服务端的代码如下所示： Server.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;net&quot; &quot;zinx/znet&quot;)//只是负责测试datapack拆包，封包功能func main() &#123; //创建socket TCP Server listener, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:7777&quot;) if err != nil &#123; fmt.Println(&quot;server listen err:&quot;, err) return &#125; //创建服务器gotoutine，负责从客户端goroutine读取粘包的数据，然后进行解析 for &#123; conn, err := listener.Accept() if err != nil &#123; fmt.Println(&quot;server accept err:&quot;, err) &#125; //处理客户端请求 go func(conn net.Conn) &#123; //创建封包拆包对象dp dp := znet.NewDataPack() for &#123; //1 先读出流中的head部分 headData := make([]byte, dp.GetHeadLen()) _, err := io.ReadFull(conn, headData) //ReadFull 会把msg填充满为止 if err != nil &#123; fmt.Println(&quot;read head error&quot;) break &#125; //将headData字节流 拆包到msg中 msgHead, err := dp.Unpack(headData) if err != nil &#123; fmt.Println(&quot;server unpack err:&quot;, err) return &#125; if msgHead.GetDataLen() &gt; 0 &#123; //msg 是有data数据的，需要再次读取data数据 //`*`是指针运算符 , 可以表示一个变量是**指针类型** , 也可以表示**一个指针变量所指向的存储单元** , 也就是这个地址所存储的值 . msg := msgHead.(*znet.Message) msg.Data = make([]byte, msg.GetDataLen()) //根据dataLen从io中读取字节流 _, err := io.ReadFull(conn, msg.Data) if err != nil &#123; fmt.Println(&quot;server unpack data err:&quot;, err) return &#125; fmt.Println(&quot;==&gt; Recv Msg: ID=&quot;, msg.Id, &quot;, len=&quot;, msg.DataLen, &quot;, data=&quot;, string(msg.Data)) &#125; &#125; &#125;(conn) &#125;&#125; Client.go 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( &quot;fmt&quot; &quot;net&quot; &quot;zinx/znet&quot;)func main() &#123; //客户端goroutine，负责模拟粘包的数据，然后进行发送 conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:7777&quot;) if err != nil &#123; fmt.Println(&quot;client dial err:&quot;, err) return &#125; //创建一个封包对象 dp dp := znet.NewDataPack() //封装一个msg1包 msg1 := &amp;znet.Message&#123; Id: 0, DataLen: 5, Data: []byte&#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;, &#125; sendData1, err := dp.Pack(msg1) if err != nil &#123; fmt.Println(&quot;client pack msg1 err:&quot;, err) return &#125; msg2 := &amp;znet.Message&#123; Id: 1, DataLen: 7, Data: []byte&#123;&#x27;w&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;!&#x27;, &#x27;!&#x27;&#125;, &#125; sendData2, err := dp.Pack(msg2) if err != nil &#123; fmt.Println(&quot;client temp msg2 err:&quot;, err) return &#125; //将sendData1，和 sendData2 拼接一起，组成粘包 sendData1 = append(sendData1, sendData2...) //向服务器端写数据 conn.Write(sendData1) //客户端阻塞 select &#123;&#125;&#125; Request字段修改首先我们要将我们之前的 Request 中的[]byte类型的 data 字段改成 Message 类型.。并且我们需要把 irequest 的方法新增一个 GetMsgID。 12345678910111213141516171819202122232425262728package znetimport &quot;zinx/ziface&quot;type Request struct &#123; conn ziface.IConnection //已经和客户端建立好的 链接 msg ziface.IMessage //客户端请求的数据&#125;//获取请求连接信息func(r *Request) GetConnection() ziface.IConnection &#123; return r.conn&#125;//获取请求消息的数据func(r *Request) GetData() []byte &#123; return r.msg.GetData()&#125;//获取请求的消息的IDfunc (r *Request) GetMsgID() uint32 &#123; return r.msg.GetMsgId()&#125;package ziface/* IRequest 接口： 实际上是把客户端请求的链接信息 和 请求的数据 包装到了 Request里*/type IRequest interface&#123; GetConnection() IConnection //获取请求连接信息 GetData() []byte //获取请求消息的数据 GetMsgID() uint32 //hu获取消息的id&#125; 集成拆包过程接下来我们需要在 Connection 的StartReader()方法中,修改之前的读取客户端的这段代码： 1234567891011121314func (c *Connection) StartReader() &#123; //... for &#123; //读取我们最大的数据到buf中 buf := make([]byte, utils.GlobalObject.MaxPacketSize) _, err := c.Conn.Read(buf) if err != nil &#123; fmt.Println(&quot;recv buf err &quot;, err) c.ExitBuffChan &lt;- true continue &#125; //... &#125;&#125; 将这个函数做出如下改造： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func (c *Connection) StartReader() &#123; fmt.Println(&quot;Reader Goroutine is running&quot;) defer fmt.Println(c.RemoteAddr().String(), &quot; conn reader exit!&quot;) defer c.Stop() for &#123; // 创建拆包解包的对象 dp := NewDataPack() //读取客户端的Msg head headData := make([]byte, dp.GetHeadLen()) if _, err := io.ReadFull(c.GetTCPConnection(), headData); err != nil &#123; fmt.Println(&quot;read msg head error &quot;, err) c.ExitBuffChan &lt;- true continue &#125; //拆包，得到msgid 和 datalen 放在msg中 msg , err := dp.Unpack(headData) if err != nil &#123; fmt.Println(&quot;unpack error &quot;, err) c.ExitBuffChan &lt;- true continue &#125; //根据 dataLen 读取 data，放在msg.Data中 var data []byte if msg.GetDataLen() &gt; 0 &#123; data = make([]byte, msg.GetDataLen()) if _, err := io.ReadFull(c.GetTCPConnection(), data); err != nil &#123; fmt.Println(&quot;read msg data error &quot;, err) c.ExitBuffChan &lt;- true continue &#125; &#125; msg.SetData(data) //得到当前客户端请求的Request数据 req := Request&#123; conn:c, msg:msg, //将之前的buf 改成 msg &#125; //从路由Routers 中找到注册绑定Conn的对应Handle go func (request ziface.IRequest) &#123; //执行注册的路由方法 c.Router.PreHandle(request) c.Router.Handle(request) c.Router.PostHandle(request) &#125;(&amp;req) &#125;&#125; 提供封包方法现在我们已经将拆包的功能集成到 Zinx 中了，但是使用 Zinx 的时候，如果我们希望给用户返回一个 TLV 格式的数据，总不能每次都经过这么繁琐的过程，所以我们应该给 Zinx 提供一个封包的接口，供 Zinx 发包使用。 我们在 iconnection.go 中新增 SendMsg()方法。 1234567891011121314151617package zifaceimport &quot;net&quot;//定义连接接口type IConnection interface &#123; //启动连接，让当前连接开始工作 Start() //停止连接，结束当前连接状态M Stop() //从当前连接获取原始的socket TCPConn GetTCPConnection() *net.TCPConn //获取当前连接ID GetConnID() uint32 //获取远程客户端地址信息 RemoteAddr() net.Addr //直接将Message数据发送数据给远程的TCP客户端 SendMsg(msgId uint32, data []byte) error&#125; 然后，我们到 connection.go 中实现这个方法。 1234567891011121314151617181920//直接将Message数据发送数据给远程的TCP客户端func (c *Connection) SendMsg(msgId uint32, data []byte) error &#123; if c.isClosed == true &#123; return errors.New(&quot;Connection closed when send msg&quot;) &#125; //将data封包，并且发送 dp := NewDataPack() msg, err := dp.Pack(NewMsgPackage(msgId, data)) if err != nil &#123; fmt.Println(&quot;Pack error msg id = &quot;, msgId) return errors.New(&quot;Pack error msg &quot;) &#125; //写回客户端 if _, err := c.Conn.Write(msg); err != nil &#123; fmt.Println(&quot;Write msg id &quot;, msgId, &quot; error &quot;) c.ExitBuffChan &lt;- true return errors.New(&quot;conn Write error&quot;) &#125; return nil&#125; 注意，做出修改后，我们需要在 connection.go 中将 io 和 errors 包引入进来。 zinx 0.5 测试 Server.go 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;zinx/ziface&quot; &quot;zinx/znet&quot;)//ping test 自定义路由type PingRouter struct &#123; znet.BaseRouter&#125;//Test Handlefunc (this *PingRouter) Handle(request ziface.IRequest) &#123; fmt.Println(&quot;Call PingRouter Handle&quot;) //先读取客户端的数据，再回写ping...ping...ping fmt.Println(&quot;recv from client : msgId=&quot;, request.GetMsgID(), &quot;, data=&quot;, string(request.GetData())) //回写数据 err := request.GetConnection().SendMsg(1, []byte(&quot;ping...ping...ping&quot;)) if err != nil &#123; fmt.Println(err) &#125;&#125;func main() &#123; //创建一个server句柄 s := znet.NewServer() //配置路由 s.AddRouter(&amp;PingRouter&#123;&#125;) //开启服务 s.Serve()&#125; Client.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;net&quot; &quot;time&quot; &quot;zinx/znet&quot;)/* 模拟客户端 */func main() &#123; fmt.Println(&quot;Client Test ... start&quot;) //3秒之后发起测试请求，给服务端开启服务的机会 time.Sleep(3 * time.Second) conn,err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:7777&quot;) if err != nil &#123; fmt.Println(&quot;client start err, exit!&quot;) return &#125; for &#123; //发封包message消息 dp := znet.NewDataPack() msg, _ := dp.Pack(znet.NewMsgPackage(0,[]byte(&quot;Zinx V0.5 Client Test Message&quot;))) _, err := conn.Write(msg) if err !=nil &#123; fmt.Println(&quot;write error err &quot;, err) return &#125; //先读出流中的head部分 headData := make([]byte, dp.GetHeadLen()) _, err = io.ReadFull(conn, headData) //ReadFull 会把msg填充满为止 if err != nil &#123; fmt.Println(&quot;read head error&quot;) break &#125; //将headData字节流 拆包到msg中 msgHead, err := dp.Unpack(headData) if err != nil &#123; fmt.Println(&quot;server unpack err:&quot;, err) return &#125; if msgHead.GetDataLen() &gt; 0 &#123; //msg 是有data数据的，需要再次读取data数据 msg := msgHead.(*znet.Message) msg.Data = make([]byte, msg.GetDataLen()) //根据dataLen从io中读取字节流 _, err := io.ReadFull(conn, msg.Data) if err != nil &#123; fmt.Println(&quot;server unpack data err:&quot;, err) return &#125; fmt.Println(&quot;==&gt; Recv Msg: ID=&quot;, msg.Id, &quot;, len=&quot;, msg.DataLen, &quot;, data=&quot;, string(msg.Data)) &#125; time.Sleep(1*time.Second) &#125;&#125; [v0.6] 多路由模式功能 涉及知识点 多路由模式 单元测试 创建消息管理模块 创建消息管理模块抽象类 在zinx/ziface下创建imsghandler.go文件， 定义出我们之前图片中的方法。 12345678package ziface/* 消息管理抽象层 */type IMsgHandle interface&#123; DoMsgHandler(request IRequest) //马上以非阻塞方式处理消息 AddRouter(msgId uint32, router IRouter) //为消息添加具体的处理逻辑&#125; 这里面有两个方法，AddRouter()就是添加一个 msgId 和一个路由关系到 Apis 中，那么DoMsgHandler()则是调用 Router 中具体Handle()等方法的接口。 实现消息管理模块 在zinx/znet下创建msghandler.go文件。 123456789101112131415161718192021222324252627282930313233343536package znetimport ( &quot;fmt&quot; &quot;strconv&quot; &quot;zinx/ziface&quot;)type MsgHandle struct&#123; Apis map[uint32] ziface.IRouter //存放每个MsgId 所对应的处理方法的map属性&#125;func NewMsgHandle() *MsgHandle &#123; return &amp;MsgHandle &#123; Apis:make(map[uint32]ziface.IRouter), &#125;&#125;//马上以非阻塞方式处理消息func (mh *MsgHandle) DoMsgHandler(request ziface.IRequest) &#123; handler, ok := mh.Apis[request.GetMsgID()] if !ok &#123; fmt.Println(&quot;api msgId = &quot;, request.GetMsgID(), &quot; is not FOUND!&quot;) return &#125; //执行对应处理方法 handler.PreHandle(request) handler.Handle(request) handler.PostHandle(request)&#125;//为消息添加具体的处理逻辑func (mh *MsgHandle) AddRouter(msgId uint32, router ziface.IRouter) &#123; //1 判断当前msg绑定的API处理方法是否已经存在 if _, ok := mh.Apis[msgId]; ok &#123; panic(&quot;repeated api , msgId = &quot; + strconv.Itoa(int(msgId))) &#125; //2 添加msg与api的绑定关系 mh.Apis[msgId] = router fmt.Println(&quot;Add api msgId = &quot;, msgId)&#125; zinx其他模块的相应修改 首先iserver的AddRouter()的接口要稍微改一下，增添 MsgId 参数. iserver.go: 123456789101112package ziface//定义服务器接口type IServer interface&#123; //启动服务器方法 Start() //停止服务器方法 Stop() //开启业务服务方法 Serve() //路由功能：给当前服务注册一个路由业务方法，供客户端链接处理使用 AddRouter(msgId uint32, router IRouter)&#125; 其次，Server类中 之前有一个Router成员 ，代表唯一的处理方法，现在应该替换成MsgHandler成员。 zinx&#x2F;znet&#x2F;server.go 123456789101112type Server struct &#123; //服务器的名称 Name string //tcp4 or other IPVersion string //服务绑定的IP地址 IP string //服务绑定的端口 Port int //当前Server的消息管理模块，用来绑定MsgId和对应的处理方法 msgHandler ziface.IMsgHandle&#125; 初始化 Server 自然也要更正，增加 msgHandler 初始化。 1234567891011121314/* 创建一个服务器句柄 */func NewServer () ziface.IServer &#123; utils.GlobalObject.Reload() s:= &amp;Server &#123; Name :utils.GlobalObject.Name, IPVersion:&quot;tcp4&quot;, IP:utils.GlobalObject.Host, Port:utils.GlobalObject.TcpPort, msgHandler: NewMsgHandle(), //msgHandler 初始化 &#125; return s&#125; 然后当 Server 在处理 conn 请求业务的时候，创建 conn 的时候也需要把 msgHandler 作为参数传递给 Connection 对象。也就是在我们 server.go 的 Start() 方法中的 3.3 注释下进行如下修改： 123//...dealConn := NewConntion(conn, cid, s.msgHandler)//... 最后，我们的 AddRouter 方法做了修改，所以要重新实现接口方法： 1234//路由功能：给当前服务注册一个路由业务方法，供客户端链接处理使用func (s *Server)AddRouter(msgId uint32, router ziface.IRouter) &#123; s.msgHandler.AddRouter(msgId,router)&#125; 那么接下来就是 Connection 对象了。固然在 Connection 对象中应该有 MsgHandler 的成员，来查找消息对应的回调路由方法。 zinx&#x2F;znet&#x2F;connection.go 1234567891011121314151617181920212223type Connection struct &#123; //当前连接的socket TCP套接字 Conn *net.TCPConn //当前连接的ID 也可以称作为SessionID，ID全局唯一 ConnID uint32 //当前连接的关闭状态 isClosed bool //消息管理MsgId和对应处理方法的消息管理模块 MsgHandler ziface.IMsgHandle //告知该链接已经退出/停止的channel ExitBuffChan chan bool&#125;//创建连接的方法func NewConntion(conn *net.TCPConn, connID uint32, msgHandler ziface.IMsgHandle) *Connection&#123; c := &amp;Connection&#123; Conn: conn, ConnID: connID, isClosed: false, MsgHandler: msgHandler, ExitBuffChan: make(chan bool, 1), &#125; return c&#125; 最后，在 conn 已经拆包之后，需要调用路由业务的时候，我们只需要让 conn 调用 MsgHandler 中的DoMsgHander()方法就好了。 zinx&#x2F;znet&#x2F;connection.go 1234567891011121314151617181920212223242526272829303132333435363738func (c *Connection) StartReader() &#123; fmt.Println(&quot;[Reader Goroutine is running]&quot;) defer fmt.Println(c.RemoteAddr().String(), &quot;[conn Reader exit!]&quot;) defer c.Stop() for &#123; // 创建拆包解包的对象 dp := NewDataPack() //读取客户端的Msg head headData := make([]byte, dp.GetHeadLen()) if _, err := io.ReadFull(c.GetTCPConnection(), headData); err != nil &#123; fmt.Println(&quot;read msg head error &quot;, err) break &#125; //拆包，得到msgid 和 datalen 放在msg中 msg , err := dp.Unpack(headData) if err != nil &#123; fmt.Println(&quot;unpack error &quot;, err) break &#125; //根据 dataLen 读取 data，放在msg.Data中 var data []byte if msg.GetDataLen() &gt; 0 &#123; data = make([]byte, msg.GetDataLen()) if _, err := io.ReadFull(c.GetTCPConnection(), data); err != nil &#123; fmt.Println(&quot;read msg data error &quot;, err) continue &#125; &#125; msg.SetData(data) //得到当前客户端请求的Request数据 req := Request&#123; conn:c, msg:msg, &#125; //从绑定好的消息和对应的处理方法中执行对应的Handle方法 go c.MsgHandler.DoMsgHandler(&amp;req) &#125;&#125; 好了，大功告成，我们来测试一下 Zinx 的多路由设置功能吧。 zinx测试这里我们既然完成了多路由模式，那么就可以进行一个服务端，多个客户端的方式进行测试我们的功能模块了。 我们这里在 zinx 文件夹下新建 Client01.go 文件。 我们在 Server 端设置 2 个路由，一个是 MsgId 为 0 的消息会执行 PingRouter{}重写的Handle()方法，一个是 MsgId 为 1 的消息会执行 HelloZinxRouter{}重写的Handle()方法。 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;zinx/ziface&quot; &quot;zinx/znet&quot;)//ping test 自定义路由type PingRouter struct &#123; znet.BaseRouter&#125;//Ping Handlefunc (this *PingRouter) Handle(request ziface.IRequest) &#123; fmt.Println(&quot;Call PingRouter Handle&quot;) //先读取客户端的数据，再回写ping...ping...ping fmt.Println(&quot;recv from client : msgId=&quot;, request.GetMsgID(), &quot;, data=&quot;, string(request.GetData())) err := request.GetConnection().SendMsg(0, []byte(&quot;ping...ping...ping&quot;)) if err != nil &#123; fmt.Println(err) &#125;&#125;//HelloZinxRouter Handletype HelloZinxRouter struct &#123; znet.BaseRouter&#125;func (this *HelloZinxRouter) Handle(request ziface.IRequest) &#123; fmt.Println(&quot;Call HelloZinxRouter Handle&quot;) //先读取客户端的数据，再回写ping...ping...ping fmt.Println(&quot;recv from client : msgId=&quot;, request.GetMsgID(), &quot;, data=&quot;, string(request.GetData())) err := request.GetConnection().SendMsg(1, []byte(&quot;Hello Zinx Router V0.6&quot;)) if err != nil &#123; fmt.Println(err) &#125;&#125;func main() &#123; //创建一个server句柄 s := znet.NewServer() //配置路由 s.AddRouter(0, &amp;PingRouter&#123;&#125;) s.AddRouter(1, &amp;HelloZinxRouter&#123;&#125;) //开启服务 s.Serve()&#125; 我们现在写两个客户端，分别发送 0 消息和 1 消息来进行测试 Zinx 是否能够处理 2 个不同的消息业务。 Client.go: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;net&quot; &quot;time&quot; &quot;zinx/znet&quot;)/* 模拟客户端 */func main() &#123; fmt.Println(&quot;Client Test ... start&quot;) //3秒之后发起测试请求，给服务端开启服务的机会 time.Sleep(3 * time.Second) conn,err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:7777&quot;) if err != nil &#123; fmt.Println(&quot;client start err, exit!&quot;) return &#125; for &#123; //发封包message消息 dp := znet.NewDataPack() msg, _ := dp.Pack(znet.NewMsgPackage(0,[]byte(&quot;Zinx V0.6 Client0 Test Message&quot;))) _, err := conn.Write(msg) if err !=nil &#123; fmt.Println(&quot;write error err &quot;, err) return &#125; //先读出流中的head部分 headData := make([]byte, dp.GetHeadLen()) _, err = io.ReadFull(conn, headData) //ReadFull 会把msg填充满为止 if err != nil &#123; fmt.Println(&quot;read head error&quot;) break &#125; //将headData字节流 拆包到msg中 msgHead, err := dp.Unpack(headData) if err != nil &#123; fmt.Println(&quot;server unpack err:&quot;, err) return &#125; if msgHead.GetDataLen() &gt; 0 &#123; //msg 是有data数据的，需要再次读取data数据 msg := msgHead.(*znet.Message) msg.Data = make([]byte, msg.GetDataLen()) //根据dataLen从io中读取字节流 _, err := io.ReadFull(conn, msg.Data) if err != nil &#123; fmt.Println(&quot;server unpack data err:&quot;, err) return &#125; fmt.Println(&quot;==&gt; Recv Msg: ID=&quot;, msg.Id, &quot;, len=&quot;, msg.DataLen, &quot;, data=&quot;, string(msg.Data)) &#125; time.Sleep(1*time.Second) &#125;&#125; Client01.go: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;net&quot; &quot;time&quot; &quot;zinx/znet&quot;)/* 模拟客户端 */func main() &#123; fmt.Println(&quot;Client Test ... start&quot;) //3秒之后发起测试请求，给服务端开启服务的机会 time.Sleep(3 * time.Second) conn,err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:7777&quot;) if err != nil &#123; fmt.Println(&quot;client start err, exit!&quot;) return &#125; for &#123; //发封包message消息 dp := znet.NewDataPack() msg, _ := dp.Pack(znet.NewMsgPackage(1,[]byte(&quot;Zinx V0.6 Client1 Test Message&quot;))) _, err := conn.Write(msg) if err !=nil &#123; fmt.Println(&quot;write error err &quot;, err) return &#125; //先读出流中的head部分 headData := make([]byte, dp.GetHeadLen()) _, err = io.ReadFull(conn, headData) //ReadFull 会把msg填充满为止 if err != nil &#123; fmt.Println(&quot;read head error&quot;) break &#125; //将headData字节流 拆包到msg中 msgHead, err := dp.Unpack(headData) if err != nil &#123; fmt.Println(&quot;server unpack err:&quot;, err) return &#125; if msgHead.GetDataLen() &gt; 0 &#123; //msg 是有data数据的，需要再次读取data数据 msg := msgHead.(*znet.Message) msg.Data = make([]byte, msg.GetDataLen()) //根据dataLen从io中读取字节流 _, err := io.ReadFull(conn, msg.Data) if err != nil &#123; fmt.Println(&quot;server unpack data err:&quot;, err) return &#125; fmt.Println(&quot;==&gt; Recv Msg: ID=&quot;, msg.Id, &quot;, len=&quot;, msg.DataLen, &quot;, data=&quot;, string(msg.Data)) &#125; time.Sleep(1*time.Second) &#125;&#125; 然后我们点击命令行右上角的分隔按钮，启动三个命令行窗口。值得注意的是，每启动一个窗口，都需要在里面先执行 export GOPATH=/home/project 这道命令。 测试结果： [v0.7] 读写分离功能 接下来我们就要对 Zinx 做一个小小的改变，就是与客户端进修数据交互的 Gouroutine 由一个变成两个，一个专门负责从客户端读取数据，一个专门负责向客户端写数据。这么设计有什么好处，当然是目的就是高内聚，模块的功能单一，对于我们今后扩展功能更加方便。 知识点 Golang并发模型 读写分离 准备工作 Server 依然是处理客户端的响应，主要关键的几个方法是 Listen、Accept 等。当建立与客户端的套接字后，那么就会开启两个 Goroutine 分别处理读数据业务和写数据业务，读写数据之间的消息通过一个 Channel 传递。下面我们就开始进行实际的实现。 1. 添加读写模块交互数据的管道 connection.go 1234567891011121314151617181920212223242526type Connection struct &#123; //当前连接的socket TCP套接字 Conn *net.TCPConn //当前连接的ID 也可以称作为SessionID，ID全局唯一 ConnID uint32 //当前连接的关闭状态 isClosed bool //消息管理MsgId和对应处理方法的消息管理模块 MsgHandler ziface.IMsgHandle //告知该链接已经退出/停止的channel ExitBuffChan chan bool //无缓冲管道，用于读、写两个goroutine之间的消息通信 msgChan chan []byte&#125;//创建连接的方法func NewConntion(conn *net.TCPConn, connID uint32, msgHandler ziface.IMsgHandle) *Connection&#123; c := &amp;Connection&#123; Conn: conn, ConnID: connID, isClosed: false, MsgHandler: msgHandler, ExitBuffChan: make(chan bool, 1), msgChan:make(chan []byte), //msgChan初始化 &#125; return c&#125; 2. 创建 Writer Goroutine zinx&#x2F;znet&#x2F;connection.go 1234567891011121314151617181920/* 写消息Goroutine， 用户将数据发送给客户端 */ func (c *Connection) StartWriter() &#123; fmt.Println(&quot;[Writer Goroutine is running]&quot;) defer fmt.Println(c.RemoteAddr().String(), &quot;[conn Writer exit!]&quot;) for &#123; select &#123; case data := &lt;-c.msgChan: //有数据要写给客户端 if _, err := c.Conn.Write(data); err != nil &#123; fmt.Println(&quot;Send Data error:, &quot;, err, &quot; Conn Writer exit&quot;) return &#125; case &lt;- c.ExitBuffChan: //conn已经关闭 return &#125; &#125; &#125; 关于 for select 和 channel 的用法： select 语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行。select 语句的分支分为两种，一种叫做候选分支，另一种叫做默认分支。候选分支总是以关键字 case 开头，后跟一个 case 表达式和一个冒号，然后我们可以从下一行开始写入当分支被选中时需要执行的语句。 由于 select 语句是专为通道而设计的，所以每个 case 表达式中都只能包含操作通道的表达式，比如接收表达式。使用一个接收值可以接收通道里的值，使用两个接收值可以判断通道是否已经关闭了。 对于 select 语句的执行规则如下： 每个 case 都必须是一个通信。 所有 Channel 表达式都会被求值。 所有被发送的表达式都会被求值。 如果任意某个通信可以进行，它就执行，其他被忽略。 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 否则： 如果有 default 子句，则执行该语句。 如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 Channel 或值进行求值。 注意这里是和 switch 的操作是不一样的，switch 操作中，只要从上到下有一个满足条件了，就会执行相应的那一个 case，select 中，我们是全部计算一遍，然后再从可满足条件的 case 中公平的执行其中一个。这是为了防止有些通道长期得不到执行。 3. Reader 将发送客户端的数据改为发送至Channel修改 Reader 调用的SendMsg()方法 zinx&#x2F;znet&#x2F;connection.go 12345678910111213141516//直接将Message数据发送数据给远程的TCP客户端func (c *Connection) SendMsg(msgId uint32, data []byte) error &#123; if c.isClosed == true &#123; return errors.New(&quot;Connection closed when send msg&quot;) &#125; //将data封包，并且发送 dp := NewDataPack() msg, err := dp.Pack(NewMsgPackage(msgId, data)) if err != nil &#123; fmt.Println(&quot;Pack error msg id = &quot;, msgId) return errors.New(&quot;Pack error msg &quot;) &#125; //写回客户端之前是写到客户端，现在是写到channel就可以 c.msgChan &lt;- msg //将之前直接回写给conn.Write的方法 改为 发送给Channel 供Writer读取 return nil&#125; 修改Start()方法 zinx&#x2F;znet&#x2F;connection.go 1234567891011121314//启动连接，让当前连接开始工作func (c *Connection) Start() &#123; //1 开启用户从客户端读取数据流程的Goroutine go c.StartReader() //2 开启用于写回客户端数据流程的Goroutine go c.StartWriter() for &#123; select &#123; case &lt;- c.ExitBuffChan: //得到退出消息，不再阻塞 return &#125; &#125;&#125; Zinx测试0.7版本的测试与0.6一致，因为只修改了内部消息发送的机制，对外的消息接口并没有发生变化 [v0.8] 实现工作池功能给Zinx添加消息队列和多任务Worker机制。 知识点 消息队列 工作池 这一步我们要实现的是，可以通过 worker 的数量来限定处理业务的固定goroutine数量，而不是无限制的开辟Goroutine，随谈我们知道go的调度算法已经做的很极致了，但是大数量的Goroutine依然会带来一些不必要的环境切换成本，这些本应该是服务器应该节省掉的成本。我们可以用消息队列来缓冲worker工作的数据。 设计结构如下： 步骤1. 创建消息队列首先，处理消息队列的部分，我们应该集成到MsgHandler模块下，因为属于我们消息模块范畴内的。 zinx&#x2F;znet&#x2F;msghandler.go 12345678910111213type MsgHandle struct &#123; Apis map[uint32]ziface.IRouter //存放每个MsgId 所对应的处理方法的map属性 WorkerPoolSize uint32 //业务工作Worker池的数量 TaskQueue []chan ziface.IRequest //Worker负责取任务的消息队列&#125;func NewMsgHandle() *MsgHandle &#123; return &amp;MsgHandle&#123; Apis: make(map[uint32]ziface.IRouter), WorkerPoolSize:utils.GlobalObject.WorkerPoolSize, //一个worker对应一个queue TaskQueue:make([]chan ziface.IRequest, utils.GlobalObject.WorkerPoolSize), &#125;&#125; 这里添加两个成员: WokerPoolSize:作为工作池的数量，因为 TaskQueue 中的每个队列应该是和一个 Worker 对应的，所以我们在创建 TaskQueue 中队列数量要和 Worker 的数量一致。 TaskQueue真是一个 Request 请求信息的 channel 集合。用来缓冲提供 worker 调用的 Request 请求信息，worker 会从对应的队列中获取客户端的请求数据并且处理掉。 当然WorkerPoolSize最好也可以从GlobalObject获取，并且zinx.json配置文件可以手动配置。 zinx&#x2F;utils&#x2F;globalobj.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 存储一切有关Zinx框架的全局参数，供其他模块使用 一些参数也可以通过 用户根据 zinx.json来配置*/type GlobalObj struct &#123; /* Server */ TcpServer ziface.IServer //当前Zinx的全局Server对象 Host string //当前服务器主机IP TcpPort int //当前服务器主机监听端口号 Name string //当前服务器名称 /* Zinx */ Version string //当前Zinx版本号 MaxPacketSize uint32 //都需数据包的最大值 MaxConn int //当前服务器主机允许的最大链接个数 WorkerPoolSize uint32 //业务工作Worker池的数量 MaxWorkerTaskLen uint32 //业务工作Worker对应负责的任务队列最大任务存储数量 /* config file path */ ConfFilePath string&#125;//...//.../* 提供init方法，默认加载*/func init() &#123; //初始化GlobalObject变量，设置一些默认值 GlobalObject = &amp;GlobalObj&#123; Name: &quot;ZinxServerApp&quot;, Version: &quot;V0.4&quot;, TcpPort: 7777, Host: &quot;0.0.0.0&quot;, MaxConn: 12000, MaxPacketSize: 4096, ConfFilePath: &quot;conf/zinx.json&quot;, WorkerPoolSize: 10, MaxWorkerTaskLen: 1024, &#125; //从配置文件中加载一些用户配置的参数 GlobalObject.Reload()&#125; 2. 创建及启动Worker工作池现在添加 Worker 工作池，先定义一些启动工作池的接口。 zinx&#x2F;ziface&#x2F;imsghandler.go 123456789/* 消息管理抽象层 */type IMsgHandle interface&#123; DoMsgHandler(request IRequest) //马上以非阻塞方式处理消息 AddRouter(msgId uint32, router IRouter) //为消息添加具体的处理逻辑 StartWorkerPool() //启动worker工作池 SendMsgToTaskQueue(request IRequest) //将消息交给TaskQueue,由worker进行处理&#125; zinx&#x2F;znet&#x2F;msghandler.go 123456789101112131415161718192021222324// 注意，头文件中要引入 zinx/utils//启动一个Worker工作流程func (mh *MsgHandle) StartOneWorker(workerID int, taskQueue chan ziface.IRequest) &#123; fmt.Println(&quot;Worker ID = &quot;, workerID, &quot; is started.&quot;) //不断的等待队列中的消息 for &#123; select &#123; //有消息则取出队列的Request，并执行绑定的业务方法 case request := &lt;-taskQueue: mh.DoMsgHandler(request) &#125; &#125;&#125;//启动worker工作池func (mh *MsgHandle) StartWorkerPool() &#123; //遍历需要启动worker的数量，依此启动 for i:= 0; i &lt; int(mh.WorkerPoolSize); i++ &#123; //一个worker被启动 //给当前worker对应的任务队列开辟空间 mh.TaskQueue[i] = make(chan ziface.IRequest, utils.GlobalObject.MaxWorkerTaskLen) //启动当前Worker，阻塞的等待对应的任务队列是否有消息传递进来 go mh.StartOneWorker(i, mh.TaskQueue[i]) &#125;&#125; StartWorkerPool()方法是启动 Worker 工作池，这里根据用户配置好的WorkerPoolSize的数量来启动，然后分别给每个 Worker 分配一个TaskQueue，然后用一个 goroutine 来承载一个 Worker 的工作业务。 StartOneWorker()方法就是一个 Worker 的工作业务，每个 worker 是不会退出的(目前没有设定 worker 的停止工作机制)，会永久的从对应的 TaskQueue 中等待消息，并处理。 3. 发送消息给消息队列现在，worker 工作池已经准备就绪了，那么就需要有一个给到 worker 工作池消息的入口，我们再定义一个方法 zinx&#x2F;znet&#x2F;msghandler.go 12345678910//将消息交给TaskQueue,由worker进行处理func (mh *MsgHandle)SendMsgToTaskQueue(request ziface.IRequest) &#123; //根据ConnID来分配当前的连接应该由哪个worker负责处理 //轮询的平均分配法则 //得到需要处理此条连接的workerID workerID := request.GetConnection().GetConnID() % mh.WorkerPoolSize fmt.Println(&quot;Add ConnID=&quot;, request.GetConnection().GetConnID(),&quot; request msgID=&quot;, request.GetMsgID(), &quot;to workerID=&quot;, workerID) //将请求消息发送给任务队列 mh.TaskQueue[workerID] &lt;- request&#125; SendMsgToTaskQueue()作为工作池的数据入口，这里面采用的是轮询的分配机制，因为不同链接信息都会调用这个入口，那么到底应该由哪个 worker 处理该链接的请求处理，整理用的是一个简单的求模运算。用余数和 workerID 的匹配来进行分配。 最终将 request 请求数据发送给对应 worker 的 TaskQueue，那么对应的 worker 的 Goroutine 就会处理该链接请求了。 4. 工作池代码调用好了，现在需要将消息队列和多任务 worker 机制集成到我们 Zinx 的中了。我们在 Server 的Start()方法中，在服务端 Accept 之前，启动 Worker 工作池。 zinx&#x2F;znet&#x2F;server.go 123456789101112131415161718//开启网络服务,只需要修改这里所提到的部分，对于打了 //... 的部分的意思是原来的代码不需要做修改func (s *Server) Start() &#123; //... //开启一个go去做服务端Linster业务 go func() &#123; //0 启动worker工作池机制 s.msgHandler.StartWorkerPool() //1 获取一个TCP的Addr addr, err := net.ResolveTCPAddr(s.IPVersion, fmt.Sprintf(&quot;%s:%d&quot;, s.IP, s.Port)) if err != nil &#123; fmt.Println(&quot;resolve tcp addr err: &quot;, err) return &#125; //... //... &#125; &#125;()&#125; 其次，当我们已经得到客户端的连接请求过来数据的时候，我们应该将数据发送给 Worker 工作池进行处理。 所以应该在 Connection 的StartReader()方法中修改： zinx&#x2F;znet&#x2F;connection.go 1234567891011121314151617181920212223// 注意，头文件中要引入 zinx/utils/* 读消息Goroutine，用于从客户端中读取数据 */func (c *Connection) StartReader() &#123; fmt.Println(&quot;Reader Goroutine is running&quot;) defer fmt.Println(c.RemoteAddr().String(), &quot; conn reader exit!&quot;) defer c.Stop() for &#123; //... req := Request&#123; conn:c, msg:msg, &#125; if utils.GlobalObject.WorkerPoolSize &gt; 0 &#123; //已经启动工作池机制，将消息交给Worker处理 c.MsgHandler.SendMsgToTaskQueue(&amp;req) &#125; else &#123; //从绑定好的消息和对应的处理方法中执行对应的Handle方法 go c.MsgHandler.DoMsgHandler(&amp;req) &#125; &#125;&#125; 这里并没有强制使用多任务 Worker 机制，而是判断用户配置WorkerPoolSize的个数，如果大于 0，那么我就启动多任务机制处理链接请求消息，如果&#x3D;0 或者&lt;0 那么，我们依然只是之前的开启一个临时的 Goroutine 处理客户端请求消息。 [v0.9] 实现链接控制功能 知识点 链接管理 数量限制 步骤","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Go","slug":"学习笔记/Go","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.mingsrc.work/tags/Go/"},{"name":"实验楼","slug":"实验楼","permalink":"https://www.mingsrc.work/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/"},{"name":"服务器","slug":"服务器","permalink":"https://www.mingsrc.work/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Zinx","slug":"Zinx","permalink":"https://www.mingsrc.work/tags/Zinx/"}]},{"title":"迭代（顿开）","slug":"E_学习笔记/DunKai/顿开教育-正则表达式","date":"2022-12-27T03:12:54.019Z","updated":"2022-12-27T03:12:54.019Z","comments":true,"path":"posts/cd58c827.html","link":"","permalink":"https://www.mingsrc.work/posts/cd58c827","excerpt":"","text":"正则表达式在很多技术领域（如：自然语言处理，数据存储等），正则表达式可以很方便的提取我们想要的信息，所以正则表达式是一个很重要的知识点！ 一，概念正则表达式（Regular Expression）是用于描述一组字符串特征的模式，用来匹配特定的字符串。通过特殊字符+普通字符来进行模式描述，从而达到文本匹配目的工具。 正则表达式目前被集成到了各种文本编辑器&#x2F;文本处理工具当中 二、应用场景（1）验证：表单提交时，进行用户名密码的验证。 （2）查找：从大量信息中快速提取指定内容，在一批url中，查找指定url。 （3）替换：将指定格式的文本进行正则匹配查找，找到之后进行特定替换。 三、基本要素（1）字符类 （2）数量限定符 （3）位置限定符 （4）特殊符号 注意：正则表达式基本是与语言无关的，我们可以结合语言&#x2F;工具与正则表达式进行文本处理 1，字符类 字符 含义 举例 . 匹配任意一个字符 adc.可以匹配abcd或abc6等 [] 匹配括号中的任意一个字符 [abc]d可以匹配ad,bd,cd - 在[]内表示字符范围 [0-9a-zA-Z]可以匹配任意大写、小写和数字字符 ^ 位于括号内的开头，匹配除括号内的字符之外的任意字符 [^xy]z匹配xy之外的任意字符，可以匹配az、bz,但是不可以匹配xz、yz 2，数量限定符 字符 含义 举例 ？ 紧跟在它前面的单元应匹配零次或一次 [0-9]?.[0-9]匹配0.0、5.2、.3,匹配.需要使用\\转义 + 紧跟在它前面的单元应匹配一次或多次 [a-zA-Z0-9_]+@[a-zA-Z0-9]+.[a-zA-Z0-9_]+ 匹配email地址 * 紧跟在它前面的单元应匹配匹配零次或多次 [0-9] [0-9]*至少匹配一位数 {N} 紧跟在它前面的单元应精准匹配N次 [1-9] [0-9]{2}匹配从100到999的整数 {N,} 紧跟在它前面的单元应匹配至少一N次 [1-9] [0-9]{2,}匹配大于等于三位数的整数 {,M} 紧跟在它前面的单元应匹配最多M次 [0-9]{,2}匹配空或者匹配小于99的整数 {N,M} 紧跟在它前面的单元应匹配至少N次，最多M次 [0-9]{1,3}. [0-9]. [0-9]. [0-9]匹配IP地址 3，位置限定符 字符 含义 举例 ^ 匹配行首的位置 ^maye匹配一行开头的maye $ 匹配行末的位置 ;$匹配位于一行结尾的；号、^$匹配空行 \\b 匹配单词开头或结尾的位置 \\bat 匹配 \\B 匹配非单词开头或结尾的位置 4，特殊符号 字符 含义 举例 \\ 转义字符 () 将正则表达式的一部分括起来组成一个单元，可以对整个单元使用数量限定符 | 连接两个子表达式，表示或的关系 n(o|ot)匹配no或not 5，其他普通字符及其替换 符号 替换正则 匹配 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\w [a-zA-Z0-9] 数字、字母、下划线 \\W [^\\w] 非数字、字母、下划线 \\s [\\r\\t\\n\\f] 表格、换行等空白区域 \\S [^\\s] 非空白区域 四、简单练习1，手机号码 2，非零开头的最多带两位小数的数字 五、C++regex常用函数regex_match全文匹配，要求整个字符串符合正则表达式的匹配规则。用来判断一个字符串和一个正则表达式是否模式匹配，如果匹配成功则返回true，否则返回false。 1,使用方法1234567891011regex re(&quot;&lt;.*&gt;.*&lt;/.*&gt;&quot;);string name = &quot;&lt;title&gt;maye25&lt;/title&gt;&quot;;bool isok=regex_match(name, re);if (isok)&#123; cout &lt;&lt; &quot;匹配&quot; &lt;&lt; endl;&#125;else&#123; cout &lt;&lt; &quot;不匹配&quot; &lt;&lt; endl;&#125; 2，匹配结果更多的时候我们希望能够获得匹配结果（字符串），对结果进行操作。这时就需要对匹配结果进行存储 123456789101112cmatch m;regex_match(name.data(), m, re);//1种for (auto &amp;i : m)&#123; cout &lt;&lt; i.str() &lt;&lt; endl;&#125;//2种for (int i = 0; i &lt; m.size(); i++)&#123; cout &lt;&lt; m[i].str() &lt;&lt; &quot; \\n&quot;;;&#125; regex_search搜索匹配，根据正则表达式来搜索字符串中是否存在符合规则的子字符串。 1，使用方法12string name = &quot;maye666&quot;;//查找连续的三个数字字符cout &lt;&lt;boolalpha&lt;&lt; regex_search(name,regex(&quot;[\\\\d]&#123;3&#125;&quot;)) &lt;&lt; endl; regex_replace替换匹配，即可以将符合匹配规则的子字符串替换为其他字符串。要求输入一个正则表达式，以及一个用于替换匹配子字符串的格式化字符串。 1,使用方法12string name = &quot;maye666&quot;;//把maye替换成撸破天cout &lt;&lt;&quot; -&quot; &lt;&lt; regex_replace(name, regex(&quot;maye&quot;), &quot;撸破天&quot;) &lt;&lt; endl;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"顿开教育学习笔记","slug":"E_学习笔记/DunKai/09-07-Lambda表达式","date":"2022-12-27T03:12:54.018Z","updated":"2022-12-27T03:12:54.018Z","comments":true,"path":"posts/298f7eb8.html","link":"","permalink":"https://www.mingsrc.work/posts/298f7eb8","excerpt":"","text":"Lambda表达式[](){}123456789101112131415161718//求最大值的函数auto pfun=[](int a,int b)-&gt;int&#123; int sum = a + b;&#125;;//调用方式cout &lt;&lt; pfun(2,3);//第二种调用方式cout &lt;&lt; [](int a,int b)-&gt;int&#123; int sum = a + b;&#125;(6,1);//最简单的lamba表达式[]&#123;cout&lt;&lt;&quot;最简单的lambda表达式&quot;&lt;&lt;endl;&#125;();//加()调用 lambda表达式用法： 1. 回调函数 2. [说明符] 1. = 按值传入外部变量 `不能修改` 在内部捕获之后，相当于const修饰 此时就可使用mutable修饰[]\\(\\)mutable&#123;&#125; 2. &amp; 按引用导入外部变量 1. = 和 &amp; 的区别 2. 3. this 导入this指针 用在类里面","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"Lambda表达式","slug":"Lambda表达式","permalink":"https://www.mingsrc.work/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"顿开教育学习笔记","slug":"E_学习笔记/DunKai/09-07-正则表达式regex","date":"2022-12-27T03:12:54.018Z","updated":"2022-12-27T03:12:54.018Z","comments":true,"path":"posts/298f7eb8.html","link":"","permalink":"https://www.mingsrc.work/posts/298f7eb8","excerpt":"","text":"C++中使用正则表达式添加头文件 &#x3D;&#x3D;#include&#x3D;&#x3D; 使用场景： 1. 检测登录账号是否符合格式 2. 提取读取信息中需要的部分 3. 变量名的匹配 1、 regex_match()函数123456789101112#include &lt;iostream&gt;#include &lt;regex&gt;using namespace std;int main()&#123; string str = &quot;abbb&quot;; regex re(&quot;.b*$&quot;); bool result = regex_match(str , re); cout &lt;&lt; boolalpha &lt;&lt; result &lt;&lt; endl; return 0;&#125; 输出 true 2、 regex_search(）函数1regex_search(&quot;sdasdasffgerdf&quot;,regex(&quot;.*&quot;));","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.mingsrc.work/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"强制类型转换","slug":"E_学习笔记/DunKai/09-11-STL标准模板","date":"2022-12-27T03:12:54.018Z","updated":"2022-12-27T03:12:54.018Z","comments":true,"path":"posts/1750eb3e.html","link":"","permalink":"https://www.mingsrc.work/posts/1750eb3e","excerpt":"","text":"1234567891011//强制转换类型static_cast&lt;&gt;();reinterpret_cast&lt;&gt;();//cast关键字const int ease = 81;const char str[20] =&quot;dsjaid&quot;;cahr * ps = const_cast&lt;char *&gt;(str); //ps指针就可以修改str的值 父类指针转换为子类对象123456789101112131415void show(Animal *base)&#123; base-&gt;cry(); Cat* pc = dynamic_cast&lt;Dog *&gt;(base); if(pc) &#123; pc-&gt;catchMouse(); &#125; Dog* pd = dynamic_cast&lt;Cat *&gt;(bash); if(pd) &#123; pd-&gt;seeHome(); &#125;&#125;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"Try Catch异常处理","slug":"E_学习笔记/DunKai/09-20-Try-Catch语句","date":"2022-12-27T03:12:54.018Z","updated":"2022-12-27T03:12:54.018Z","comments":true,"path":"posts/dafbb8fa.html","link":"","permalink":"https://www.mingsrc.work/posts/dafbb8fa","excerpt":"Trty Catch\n异常处理的一些操作和步骤\n","text":"Trty Catch 异常处理的一些操作和步骤 一个try可以对应对个catch 1234567891011f(int a)&#123; if( a &lt; 1 ) throw a;&#125;try&#123; &#125;catch(int)&#123; cout &lt;&lt; &quot;a小于1&quot;;&#125; 可以单独写一个类处理和接受异常 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;//异常类class listException&#123;pubilc: listException(string str):str(str)&#123;&#125; void print() &#123; cout &lt;&lt; str &lt;&lt;endl; &#125;protected: string str;&#125;;void deleteList()&#123; if(size == 0) throw listException(&quot;链表为空&quot;); cout &lt;&lt; &quot;链表正常删除！&quot;;&#125;int main ()&#123; try &#123; deleteList(); &#125; catch(listException object) &#123; object.print(); &#125; system(&quot;pause&quot;); return 0;&#125; C++有专门的一个类用以异常处理 1#include &lt;exception&gt; bad_alloc 内存处理：防止溢出与内存超出 bad_cast bad_typeid","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"异常处理","slug":"异常处理","permalink":"https://www.mingsrc.work/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"设计实例（顿开）","slug":"E_学习笔记/DunKai/设计实例","date":"2022-12-27T03:12:54.018Z","updated":"2022-12-27T03:12:54.019Z","comments":true,"path":"posts/aeb1f9a9.html","link":"","permalink":"https://www.mingsrc.work/posts/aeb1f9a9","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;class Worker&#123;public: Worker(string name,int salary,int age,string tel):_name(name),_tel(tel),_age(age),_salary(salary)&#123;&#125; void show() &#123; cout &lt;&lt; _name &lt;&lt; &#x27;\\t&#x27; &lt;&lt; _age &lt;&lt; &#x27;\\t&#x27; &lt;&lt; _tel &lt;&lt; &#x27;\\t&#x27; &lt;&lt; _salary &lt;&lt;endl; &#125;private: string _name; int _salary; int _age; string _tel;&#125;;int main()&#123; Worker w1(&quot;p1&quot;,2000,20,&quot;17790017583&quot;), w2(&quot;p2&quot;,3000,60,&quot;17790017587&quot;), w3(&quot;p7&quot;,4000,70,&quot;17790017589&quot;), w4(&quot;p4&quot;,5000,30,&quot;17790017512&quot;); w4(&quot;p9&quot;,5050,120,&quot;17790412512&quot;); multimap&lt;string , Worker&gt; mm; mm.insert(pair&lt;string , Worker&gt;(&quot;sale&quot;,w1)); mm.insert(pair&lt;string , Worker&gt;(&quot;sale&quot;,w2)) mm.insert(pair&lt;string , Worker&gt;(&quot;financial&quot;,w3)) mm.insert(air&lt;string , Worker&gt;(&quot;technology&quot;,w4)) mm.insert(air&lt;string , Worker&gt;(&quot;finanical&quot;,w5))&#125;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"map","slug":"map","permalink":"https://www.mingsrc.work/tags/map/"}]},{"title":"顿开教育学习笔记","slug":"E_学习笔记/DunKai/08-26-第五课-","date":"2022-12-27T03:12:54.017Z","updated":"2022-12-27T03:12:54.017Z","comments":true,"path":"posts/298f7eb8.html","link":"","permalink":"https://www.mingsrc.work/posts/298f7eb8","excerpt":"","text":"一、多态多态成立三要素 要有继承 虚函数重写 要有父类指针指向子类对象 多态是框架的基础","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"多态","slug":"多态","permalink":"https://www.mingsrc.work/tags/%E5%A4%9A%E6%80%81/"}]},{"title":"顿开教育学习笔记","slug":"E_学习笔记/DunKai/09-04-第九节 模板","date":"2022-12-27T03:12:54.017Z","updated":"2022-12-27T03:12:54.017Z","comments":true,"path":"posts/298f7eb8.html","link":"","permalink":"https://www.mingsrc.work/posts/298f7eb8","excerpt":"","text":"template123456//重载&lt;&lt;(左移)运算符friend ostream&amp; operate&lt;&lt;(ostream const&amp; out,people worker)&#123; out &lt;&lt; worker.name &lt;&lt; worker.age; return out;&#125; 类模板有一处重点，涉及类的构造函数，构造函数时类模板会识别定义的结构体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; //类模板不是完整的一个类型/* 1.类中用到了未知类型 2.类名不是一个完整的类型，又有用到类名的地方：类名&lt;未知类型&gt; 3.类模板必须显示调用 4.类中的静态数据成员需要在类外初始化 5.模板在多文件中不能分开写，实现和声明必须在同一文件中 .h || .cpp*/struct student &#123; int age; bool male; student(int age, int male) &#123; this-&gt;age = age; this-&gt;male = male; &#125; student() &#123; this-&gt;age = 0; this-&gt;male = 0; &#125;&#125;;//结构体运算符重载ostream&amp; operator&lt;&lt;(ostream&amp; out , student stu) &#123; out &lt;&lt; &quot;age:&quot; &lt;&lt; stu.age &lt;&lt; &#x27;\\t&#x27;&lt;&lt; &quot;male:&quot; &lt;&lt; stu.male; return out;&#125;//定义一个模板类之后template &lt;typename dataType&gt;class Info&#123;public: Info(dataType a,int b) &#123; this-&gt;num = b; this-&gt;data = a; &#125;; void print();protected: int num; dataType data; static int flag;&#125;;//print()函数定义template &lt;class Type&gt;void Info&lt;Type&gt;::print()&#123; cout &lt;&lt; data &lt;&lt; &#x27;\\t&#x27; &lt;&lt; num;&#125;//静态数据成员初始化template &lt;typename T&gt;int Info&lt;T&gt;::flag = 1;template &lt;typename data1,typename data2&gt;class infoPlus &#123;public: infoPlus(data1 a,data2 b) &#123; cout &lt;&lt; &quot;调用第一个构造函数!&quot;; this-&gt;name1 = a; this-&gt;age2 = b; &#125; infoPlus(student&amp; a, int b) &#123; this-&gt;age2 = a.age; this-&gt;name1 = a.male; &#125; void print();protected: data1 name1; data2 age2;&#125;;template &lt;class data1, class data2&gt;void infoPlus&lt;data1, data2&gt;::print()&#123; cout&lt;&lt; age2 &lt;&lt; &#x27;\\t&#x27; &lt;&lt; name1 ;&#125;//该类所产生的子类一定是要一个模板template &lt;typename Type,typename Type1&gt;class son : public infoPlus&lt;Type,Type1&gt;&#123;public: void print();protected:&#125;;//在实现过程中，同样需要加模板定义template &lt;typename Type,typename Type1&gt;void son&lt;Type,Type1&gt;::print()&#123; cout &lt;&lt; &quot;hello world!&quot;;&#125;int main()&#123; /* Info&lt;int&gt; *pObject = new Info&lt;int&gt;(2, 5); pObject-&gt;print(); cout &lt;&lt; endl; Info&lt;string&gt; object(&quot;name&quot;,1002); object.print(); */ //类模板传自定义类型 infoPlus&lt;string,int&gt; nObject(&quot;nihao&quot;,12); nObject.print(); printf(&quot;\\n&quot;); infoPlus&lt;student, int&gt; studentFir(student(21,1),190); studentFir.print(); cout &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 特化——简而言之就是模板的重载 优先调用类型匹配强的模板","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"模板","slug":"模板","permalink":"https://www.mingsrc.work/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"顿开教育学习笔记","slug":"E_学习笔记/DunKai/09-06-第七节-IO流","date":"2022-12-27T03:12:54.017Z","updated":"2022-12-27T03:12:54.017Z","comments":true,"path":"posts/298f7eb8.html","link":"","permalink":"https://www.mingsrc.work/posts/298f7eb8","excerpt":"","text":"C++IO流 通过#include 提供的控制符，进行输入输出格式控制 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;标准错误&quot; &lt;&lt; endl; clog &lt;&lt; &quot;标准信息&quot; &lt;&lt; endl; cout.put(&#x27;a&#x27;); cout.put(&#x27;\\n&#x27;); //不够不空格，多了就截取 cout.write(&quot;LOVEYOU\\n&quot;, 10); // 10可现实元素个数 bool b = 1.1; cout &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; endl; b = false; cout.width(8); //serw(8)默认方式是右对齐 cout.unsetf(ios::boolalpha); cout &lt;&lt; setw(8) &lt;&lt; b &lt;&lt; 12 &lt;&lt; &quot;Love&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 文件读取与输出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;struct girl &#123; char name[20]; int age; int num; /*girl(const char name[20],int age, int num) &#123; this-&gt;name = (char*)name; this-&gt;age = age; this-&gt;num = num; &#125; */&#125;;int main()&#123; fstream fileOut; //位或操作组合打开文件 fileOut.open(&quot;test.txt&quot;,ios::out | ios::in | ios_base::binary | ios::app); if (!fileOut) //file.eof() 文件末尾标记 &#123; cout &lt;&lt; &quot;文件打开失败~&quot; &lt;&lt; endl; &#125; fileOut &lt;&lt; &quot;这是写入的内容：&quot; &lt;&lt; &quot;\\n&quot; &lt;&lt; &quot;Hello new file!&quot; &lt;&lt; &quot;\\n&quot; &lt;&lt; &quot;这是最后一行&quot;; fileOut.close(); //fstream ofstream ifstream //子类对象去操作 struct girl MM[3] = &#123; &quot;girlbaby&quot; ,12 ,23, &quot;girlanni&quot; ,12 ,23 ,&quot;girlthird&quot; ,12 ,23 &#125;; ofstream out; out.open(&quot;test.txt&quot;, ios::binary | ios::app); for (int i =0; i &lt; 3; i++) &#123; //必须做强制转换 out.write((char*)&amp;MM[i],sizeof(MM[i])); &#125; out.close(); //从文件中读取 //fseek //seekg操作输入流对象get //seekp put //操作函数的改变 cout &lt;&lt; &quot;操作文件输出：&quot; &lt;&lt; endl; ifstream file; file.open(&quot;test.txt&quot;, ios::in); file.seekg(ios::beg); //ios::cur ios::end ios::beg char strFile[1024]; while (!file.eof()) &#123; file.getline(strFile, 1024); //file.getline(strFile, 1024); cout &lt;&lt; strFile; &#125; file.close(); system(&quot;pause&quot;); return 0;&#125;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"IO流","slug":"IO流","permalink":"https://www.mingsrc.work/tags/IO%E6%B5%81/"}]},{"title":"迭代（顿开）","slug":"E_学习笔记/DunKai/08-17-第一课-迭代遍历","date":"2022-12-27T03:12:54.016Z","updated":"2022-12-27T03:12:54.016Z","comments":true,"path":"posts/cd58c827.html","link":"","permalink":"https://www.mingsrc.work/posts/cd58c827","excerpt":"","text":"迭代遍历12345678910111213141516171819//数组int arr[]&#123;1,2,3,4,5,6&#125;;cout &lt;&lt; &quot;size(arr)&quot; &lt;&lt; size(arr) &lt;&lt; endl; //6cout &lt;&lt; &quot;sizeof(arr[0])&quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; //4cout &lt;&lt; &quot;sizeof(arr)&quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; //24//新用法——迭代cout &lt;&lt; &quot;arr遍历：&quot; &lt;&lt; endl;for(int i : arr) &#123; cout &lt;&lt; i &lt;&lt; &quot;\\t&quot;;&#125;//简单用法autofor(auto i : arr) &#123; cout &lt;&lt; i &lt;&lt; &quot;\\t&quot;; &#125; 常量存在于常量区 细节隐藏：编译过程中若发现对const使用了&amp;操作符，则给对应的常量分配对应的常量分配存储空间（为了兼容c） ​ C++中的const常量，存在符号表中， 没有存储空间，当对常量取地址符时，会另外开辟内存空间","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"内联函数（顿开）","slug":"E_学习笔记/DunKai/08-19-第二课-内联参数重载","date":"2022-12-27T03:12:54.016Z","updated":"2022-12-27T03:12:54.016Z","comments":true,"path":"posts/e1371b1d.html","link":"","permalink":"https://www.mingsrc.work/posts/e1371b1d","excerpt":"","text":"一、内联函数123456//内联函数 //inline fun()&#123; &#125; 二、默认参数和占位参数 默认参数：必须从右往左写（一旦出现默认参数，后边的参数必须都是默认的） 12345678//占位参数 /* 1.占位但是不调用 2.为之后的函数扩充留下线索 */void print(int)&#123; cout &lt;&lt; &quot;PRINT()&quot;;&#125; 三、函数重载1234567int fun(int ,int)&#123; &#125;int fun(char , char)&#123; &#125; 四、string12345678910string name = &quot;mingming&quot;;for(auto i : name)&#123; cout &lt;&lt; i ; // mingming&#125;//转c风格字符串const char* cname = name.data();","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"顿开教育学习笔记","slug":"E_学习笔记/DunKai/08-21-第三课-构造与析构","date":"2022-12-27T03:12:54.016Z","updated":"2022-12-27T03:12:54.016Z","comments":true,"path":"posts/298f7eb8.html","link":"","permalink":"https://www.mingsrc.work/posts/298f7eb8","excerpt":"","text":"1、构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//构造函数的几种形式class circle&#123;private: int x; int y; int r;public: //无参构造 //有参构造 circle(int a,int b,int c)&#123; x=a; y=b; r=c; &#125; circel()&#123; &#125;&#125;;// 定义了一个Stu类实现构造与析构//同时，当内存不再使用的时候，应使用free()函数将内存块释放掉。#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class Stu &#123;public: Stu() &#123; m_age = 0; //动态申请的使用free释放 //同时，当内存不再使用的时候，应使用free()函数将内存块释放掉。 name = (char*)malloc(sizeof(char) * 5); strcpy(name, &quot; &quot;); &#125; ~Stu() &#123; if (name != NULL) &#123; free(name); name = NULL; &#125; &#125;private: int m_age; char* name;&#125;;int main() &#123; //生命周期取决于如何处理（怎么去接） Stu(15,&quot;mingmin&quot;); return 0;&#125; 2、构造与析构的顺序（栈） 先构造的后析构 ​ 1、当没写构造函数时，会自动生成一个默认的构造函数（便可以构造一个空对象） ​ 2、 3、拷贝构造函数用一个对象初始化另一个对象 1. 编译器会提供默认的拷贝构造函数 2. 参数必须使用==`&amp;`==否则会无限递归 3. 123456789//声明class Stu&#123;public: Stu(Stu&amp; a)&#123; m_age = a.m_age; name = a.name; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"构造与析构","slug":"构造与析构","permalink":"https://www.mingsrc.work/tags/%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84/"}]},{"title":"顿开教育学习笔记","slug":"E_学习笔记/DunKai/08-24-第四课-动态内存分配","date":"2022-12-27T03:12:54.016Z","updated":"2022-12-27T03:12:54.017Z","comments":true,"path":"posts/298f7eb8.html","link":"","permalink":"https://www.mingsrc.work/posts/298f7eb8","excerpt":"","text":"C++使用new和delete替代malloc和free 一、&#x3D;&#x3D;static&#x3D;&#x3D;静态函数 一个类中可以有一个或者多个静态成员变量，所有对象都共享这些静态成员变量，都可以引用他 静态成员必须初始化 不属于任何一个对象 静态成员存在与全局区，但是作用域有限制 123456789101112//静态成员访问的两种方式class stu&#123; public: static int age = 0;&#125;int main()&#123; stu s1; //方法一 stu::age; //方法二 s1.age;&#125; 二、友元类 123456789101112131415//静态成员访问的两种方式class stu&#123; friend class tea；//类tea声明为类stu的友元类，在tea中就可以访问a的私有成员 public: static int age = 0;&#125;；class tea&#123;&#125;；int main()&#123; stu s1; //方法一 stu::age; //方法二 s1.age;&#125;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"DunKaiStudy","slug":"C-笔记/DunKaiStudy","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/DunKaiStudy/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"动态","slug":"动态","permalink":"https://www.mingsrc.work/tags/%E5%8A%A8%E6%80%81/"}]},{"title":"函数指针与指针函数","slug":"E_学习笔记/C++/一些自己的想法","date":"2022-12-27T03:12:54.015Z","updated":"2022-12-27T03:12:54.015Z","comments":true,"path":"posts/a4d65dab.html","link":"","permalink":"https://www.mingsrc.work/posts/a4d65dab","excerpt":"","text":"函数指针和指针函数参考了@函数指针和指针函数用法和区别_luoyayun361的专栏-CSDN博客_指针函数 指针函数：简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。 123456789101112131415161718192021222324252627int *fun(int x,int y);int * fun(int x,int y);int* fun(int x,int y); // 使用typedef struct _Data&#123; int a; int b;&#125;Data; //指针函数Data* f(int a,int b)&#123; Data * data = new Data; data-&gt;a = a; data-&gt;b = b; return data;&#125; int main(int argc, char *argv[])&#123; QApplication a(argc, argv); //调用指针函数 Data * myData = f(4,5); qDebug() &lt;&lt; &quot;f(4,5) = &quot; &lt;&lt; myData-&gt;a &lt;&lt; myData-&gt;b; return a.exec();&#125; 函数指针：其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。 1234567891011121314151617181920212223int (*fun)(int x,int y); // 使用int add(int x,int y)&#123; return x+y;&#125;int sub(int x,int y)&#123; return x-y;&#125;//函数指针int (*fun)(int x,int y); int main(int argc, char *argv[])&#123; QApplication a(argc, argv); //第一种写法 fun = add; qDebug() &lt;&lt; &quot;(*fun)(1,2) = &quot; &lt;&lt; (*fun)(1,2) ; //第二种写法 fun = &amp;sub; qDebug() &lt;&lt; &quot;(*fun)(5,3) = &quot; &lt;&lt; (*fun)(5,3) &lt;&lt; fun(5,3)； return a.exec();&#125; 如果你对这两个概念的区分不是很清晰也可以这么记： 指针函数与整型函数一样，都是返回一个东西，不同的是指针函数返回的是一个指针。","raw":null,"content":null,"categories":[],"tags":[{"name":"C++易混点","slug":"C-易混点","permalink":"https://www.mingsrc.work/tags/C-%E6%98%93%E6%B7%B7%E7%82%B9/"}]},{"title":"《Effective C++》条款50~59","slug":"E_学习笔记/C++/Effective_C++/条款50~59","date":"2022-12-27T03:12:54.015Z","updated":"2022-12-27T03:12:54.015Z","comments":true,"path":"posts/60f246a3.html","link":"","permalink":"https://www.mingsrc.work/posts/60f246a3","excerpt":"","text":"条款54：让自己熟悉包括TR1在内的标准程序库 TR1指的是Technical Report 1，是C++程序库工作小组对该份文档的称呼。 主要说明了C++标准程序库的各个成分：STL、Iostream、国际化支持（wchar_t、wstring）、数值处理、异常阶层体系。C89标准程序库。 条款54则就命名空间tr1内的部分新组件的使用进行了详尽的介绍。 智能指针（smart pointers）：嵌套在tr1命名空间内，TR1组件shared_ptr的全名是std::tr1::shared_ptr，使用时std::shared_ptr即可. tr1::shared_ptr和 tr1::weak_ptr。前者的作用有如内置指针，但会记录有多少个tr1::shared_ptrs共同指向同一个对象。这便是所谓的reference couming（引用计数）。一旦最后一个这样的指针被销毁，也就是一旦某对象的引用次数变成 0，这个对象会被自动删除。这在非环形（acyclic）数据结构中防止资源泄漏很有帮助，但如果两个或多个对象内含tr1::shared_ptrs并形成环状（cycle），这个环形会造成每个对象的引用次数都超过 0——即使指向这个环形的所有指针都已被销毁（也就是这一群对象整体看来己无法触及）。这就是为什么又有个tr1::weak_ptr的原因。tr1::weak_ptr的设计使其表现像是”非环形tr1::shared_ptr-based数据结构”中的环形感生指针（cycle-inducing pointers）。tr1::weak_ptr并不参与引用计数的计算∶当最后一个指向某对象的 tr1::shared_ptr被销毁，纵使还有个trl∶∶weak_ptrs继续指向同一对象，该对象仍旧会被删除。这种情况下的tr1∶∶weak_ptrs会被自动标示无效，tr1∶∶shared_ptr或许是拥有最广泛用途的 TR1 组件 在《C++ Primer Plus》中指出“智能指针是行为类似于指针的类对象”。其存在的最重要的一点就是可帮助管理动态内存分配的智能指针模板。原理就是“析构函数的应用”。当一个对象过期时，让他的析构函数删除指向的内存即可。 auto_ptr（C++98的方案，c++11已经摒弃该指针，auto_ptr最大的弊端在于允许很多几乎没有实际用处又不符合常规认知的行为，用scoped_ptr和unique_ptr可以利用静态检查早早地指出这些无意义操作的存在。文中会略谈） unique_ptr shared_ptr 为什么要使用智能指针？ 答：因为内存管理是一件非常麻烦的事，在开发过程中会经常性的因为内存泄露问题出现严重的后果。如下所示： 12345void remodel() &#123; double *ps = new double; *ps = 25.5; return;&#125; 上述代码的问题就是进入remodel()后申请了堆内存*ps，但是return的时候又没有释放改内存空间，因为很可能会出现程序错误，当然即使你使用了delete ps;，也不一定就能让程序不出现该类错误。 12345678void remodel() &#123; double *ps = new double; *ps = 25.5; if(weird_thing()) throw exception(); delete ps; return;&#125; 如上，在抛出异常的时候，依然会出现堆内存未释放的问题。 使用1234567891011121314///**************************************************************************** /// @brief : 创建一个分配堆内存的函数，但是无释放空间操作 ///****************************************************************************void demo1() &#123; double *pd = new double; *pd = 25; return; //删除pd，值被保留在动态内存中&#125;///****************************************************************************/// @brief : 创建一个分配堆内存的函数，调用auto_ptr管理内存空间///****************************************************************************void demo2() &#123; auto_ptr&lt;double&gt; ap(new double); *ap = 25.5; return; //删除ap，ap的析构函数释放动态内存。&#125; 智能指针的几种声明与使用方式： 12345shared_ptr&lt;double&gt; pd;double *p_reg =new double;pd = shared&lt;double&gt;(p_reg); //#1 shared_ptr&lt;double&gt; psahred(p_reg); //#2shared_ptr&lt;double&gt; sd(new double); //#3 #1:所有智能指针类都有一个explicit构造函数，该函数将指针作为参数。因此不需要将指针转换为智能对象。 关于shared_ptr的详细使用可以看这篇文章📑 Post not found: 学习笔记/C++_Primer_Plus/shared_ptr 如何创建智能指针对象创建智能指针对象必须包含头文件memory，然后通过模板类实现auot_ptr()的调用与实现。 12345678910#include &lt;memory&gt;#include &lt;string&gt;template &lt;class X&gt; class auto_ptr &#123;public: /* 1. explicit 避免隐式转换 2. throw() 意味着构造函数不会引发异常 */ explicit auto_ptr(X *p = 0) throw();&#125;; 因为使用了模板，因此可以通过使用X类型的auto_ptr来获得指向X类型的auto_ptr。 12auto_ptr&lt;double&gt; ad(new double); //auto_ptr to doubleauto_ptr&lt;string&gt; as(new string); //auto_ptr to string 并且可以使用你的自定义类型,同时还可以对智能指针执行解除引用操作，用它来访问结构成员： 123456789101112class myType &#123;private: std::string str;public: int date; myType() &#123;&#125; myType(const std::string s):str(s) &#123; std::cout &lt;&lt; &quot;create a myType~&quot; &lt;&lt; std::endl; &#125;&#125;;auto_ptr&lt;myType&gt; pmt(new myType); //auto_ptr to myTypepmt-&gt;date; //访问myType中date成员 为什么摒弃auto_ptr使用《C++ primer plus》中的一个案例，顺便说明为什么会有shred_ptr，以及与auto_ptr的区别。 123auto_ptr&lt;string&gt; tableau(new string(&quot;这里有一个小姐姐，单身可撩~&quot;));auot_ptr&lt;string&gt; rt;rt = tableau; 上述语句声明了两个变量，tableau和rt，如果这两个变量是常规指针，则两个变量都指向同一个地址，意即在程序结束时或者析构函数调用时，该地址会被删除两次，一次是tableau过期时，一次是rt过期时。解决这种问题的方法有多种，使share_ptr就可以解决这种所有权问题。 定义赋值运算符，进行深拷贝操作，这样两个指针指向不同的地址。 建立所有权（ownership）概念，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的构造函数会删除该对象。然后，让赋值操作转让所有权。这就是auto_ptr和unique_ptr的策略。 123unique_ptr&lt;string&gt; tableau(new string(&quot;这里有一个小姐姐，单身可撩~&quot;)); //声明一个unique_ptrunique_ptr&lt;string&gt; rt; rt = tableau; //非法，编译报错 创建智能更高的指针，跟踪引用特定对象的智能指针数，也即引用计数（reference counting）。也就是shared_ptr的实现策略，当引用计数为0时，才会执行删除操作。 123auto_ptr&lt;string&gt; tableau(new string(&quot;这里有一个小姐姐，单身可撩~&quot;));shared_ptr&lt;string&gt; rt; // 在这一步只需将rt声明为shared_ptr即可rt = tableau; //tableau的引用计数变为2 在程序执行末尾，后声明的rt先调用析构函数，引用计数变为1；然后tableau地阿勇析构函数，引用计数变为0，该地址指向的空间被释放。 相比于auto_ptr，unique_ptr还有另外一个优点。就是可以用于数组的变体。在C++中，必须将delete和new配对，将delete[]和new[]配对使用。模板auto——ptr使用delete而不是delete[]，因此，只能与new一起使用，而不能与new[]一起使用。但unique_ptr有使用new[]和delete[]的版本。 1std::unique_ptr&lt;double[]&gt;pda(new double(5)); //使用delete[]删除 关于容器与智能指针的一个很好的demo： 1234567891011121314151617181920212223242526272829303132333435///****************************************************************************/// @data : 2021/1/17/// @input : 随机整型变量/// @output : 返回一个unique_ptr/// @brief : ///****************************************************************************unique_ptr&lt;int&gt; make_int(int n) &#123; return unique_ptr&lt;int&gt;(new int(n));&#125;// 这里必须按引用传值，unique_ptr所有权的问题：因为如果使用值传递，// 编译器会认为vui[i]不再指向有效的数据,会出现编译错误。void show(unique_ptr&lt;int&gt; &amp;pi) &#123; cout &lt;&lt; *pi &lt;&lt; &quot; &quot;;&#125;int main()&#123; ////指向容器的智能指针 //auto_ptr&lt;vector&lt;int&gt;&gt; avi(new vector&lt;int&gt;); //avi-&gt;push_back(5); //cout&lt;&lt;&quot;打印容器第一个数：&quot; &lt;&lt; avi-&gt;front(); // 存储智能指针的容器 vector&lt;unique_ptr&lt;int&gt; &gt; vui(10); for (size_t i = 0; i &lt; vui.size(); i++) &#123; vui[i] = make_int(rand() % 1000); &#125; vui.push_back(make_int(rand() % 1000)); for_each(vui.begin(),vui.end(),show); system(&quot;pause&quot;); return 0;&#125; 但是，unique_ptr却可以作为右值转换为shared_ptr，还是上边的代码： 123unique_ptr&lt;int&gt; pup(make_int(rand() % 1000)); //okshared_ptr&lt;int&gt; spp(pup); // not allowed，pup是左值shared_ptr&lt;int&gt; spr(make_int(rand() % 1000)); //ok","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"Effective C++","slug":"C-笔记/Effective-C","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/Effective-C/"}],"tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://www.mingsrc.work/tags/Effective-C/"}]},{"title":"explicit关键字","slug":"E_学习笔记/C++/使用类/explicit关键字","date":"2022-12-27T03:12:54.015Z","updated":"2022-12-27T03:12:54.015Z","comments":true,"path":"posts/58412853.html","link":"","permalink":"https://www.mingsrc.work/posts/58412853","excerpt":"","text":"说明如下代码收拾 12345678910111213141516171819class Weight &#123; Weight(int wh, double lbs); Weight(double lbs);private: int m_wh; double m_lbs;&#125;;Weight::Weight(int wh, double lbs)&#123; m_wh = wh; m_lbs = lbs;&#125;Weight::Weight(double lbs)&#123; m_wh = lbs / 2; m_lbs = lbs;&#125; Weight类并非真的需要声明构造函数，因为自动生成的默认构造函数就很好。但是Weight类提供了两个构造函数。一个是int,double类型的，一个是double类型的，每个构造函数都给私有成员全部赋了值。因为创建Weight对象时，将会自动设置这两种重量表示。 因为Weight对象表示一个重量，因为可以提供一种整数值或者浮点值转换为Weight对象的方法。即： 12Weight wh;wh = 19.6; 程序将使用构造函数Weight(double)来创建一个临时的Weight对象。随后采用逐成员赋值方式将该临时对象的内容复制到wh中。这一过程称为隐式转换，因为它是自动进行的，而不需要显式强制类型转换。 但情况是，只有接受一个参数的构造函数才能作为转换函数。如Weight(int,double)就不可以。 然而，如果第二个参数提供了&#x3D;&#x3D;默认值&#x3D;&#x3D;，它便可以用于转换int。 Weight(int, double lbs = 0); 在这个时候，便会导致意外的类型转换。因此，C++新增了关键字explicit，用于关闭这种特性。也就是在声明构造函数时加上explicit关键字。 1234567class Weight &#123; explicit Weight(int wh, double lbs); explicit Weight(double lbs);private: int m_wh; double m_lbs;&#125;; 添加explicit关键字之后，便可以关闭上述中的隐式转换，但仍然允许显式转换，即显式强制类型转换。 1234Weight weight; // create a Stonewt objectweight = 19.6; // not valid if Stonevt(double) is declared as explicltweight = Weight(19.61); // ok,an explicit corversionweight = (Weight)19.6; //ok,old form for explicit typecat","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"学习笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"《Effective C++》","slug":"E_学习笔记/C++/Effective_C++/Effective_C++","date":"2022-12-27T03:12:54.014Z","updated":"2022-12-27T03:12:54.014Z","comments":true,"path":"posts/b7419768.html","link":"","permalink":"https://www.mingsrc.work/posts/b7419768","excerpt":"","text":"《Effective C++》我不知道我是否能快速把这本书读完，但我一定尽快，并整理自己的感悟！ 有人说C+ +程序员可以分成两类,读过Effective C+ +的和没读过的。世界顶级C+ +大师Scott Meyers成名之作的第三版的确当得起这样的评价。当您读过这本书之后，就获得了迅速提升自己C++功力的一个契机。 在国际上.本书所引起的反响,波及整个计算技术出版领域,余音至今未绝。几乎在所有C++书籍的推荐名单上,本书都会位于前三名。作者高超的技术把握力、独特的视角、诙谐轻松的写作风格、独具匠心的内容组织，都受到极大的推崇和仿效。这种奇特的现象,只能解释为人们对这本书衷心的赞美和推崇。这本书不是读完一遍就可以束之 高阁的快餐读物，也不是用以解决手边问题的参考手册，而是需要您去反复阅读体会的，C++是真正程序员的语言，背后有着精深的思想与无与伦比的表达能力，这使得它具有类似宗教般的魅力。希望这本书能够帮助您跨越C++的重重险阻，领略高处才有的壮美风光，做-一个成功而快乐的C++程序员。 ——引言","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"Effective C++","slug":"C-笔记/Effective-C","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/Effective-C/"}],"tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://www.mingsrc.work/tags/Effective-C/"}]},{"title":"《Effective C++》中的一些命名习惯","slug":"E_学习笔记/C++/Effective_C++/命名习惯","date":"2022-12-27T03:12:54.014Z","updated":"2022-12-27T03:12:54.014Z","comments":true,"path":"posts/ef83a37.html","link":"","permalink":"https://www.mingsrc.work/posts/ef83a37","excerpt":"","text":"命名习惯在阅读这本开始之际，作者就一些命名习惯（不是命名空间哦）做了详细阐述，以方便我们平时阅读过程以及开发过程中如何命名变量名，甚觉对个人编程上一些基础的东西有极大的帮助，整理如下： 用途 含义 变量名 二元操作符 左手端（left-hand side） lhs 二元操作符 右手短（right-hand side） rhs 指向一个T型对象 pointer to T pt 指向一个Widget的指针 ptr to Wodget pw 指向一个airplane的指针 ptr to Airplane pa 指向一个GameCharacter的指针 ptr to GameCharacter pgc 对于引用（reference），则习惯以r*的形式命名。例如reference to widget，变量名为rw,ra则是reference to Airplane。 而对于成员函数，则可以以mf为名。","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"Effective C++","slug":"C-笔记/Effective-C","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/Effective-C/"}],"tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://www.mingsrc.work/tags/Effective-C/"}]},{"title":"《Effective C++》条款20~21","slug":"E_学习笔记/C++/Effective_C++/条款20~21","date":"2022-12-27T03:12:54.014Z","updated":"2022-12-27T03:12:54.014Z","comments":true,"path":"posts/93488446.html","link":"","permalink":"https://www.mingsrc.work/posts/93488446","excerpt":"","text":"条款20：宁以pass-by-reference-to-const替换pass-by-value 条款21：必须返回对象时，别往相反其reference pass-by-value和pass-by-reference 20、21章 讲了函数传参过程引用传值和值传递应该以什么样的形式去处理。从函数的入口和出口两个方面讲了","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"Effective C++","slug":"C-笔记/Effective-C","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/Effective-C/"}],"tags":[{"name":"Effective C++","slug":"Effective-C","permalink":"https://www.mingsrc.work/tags/Effective-C/"}]},{"title":"STL和C++11","slug":"E_学习笔记/C++/C++_Primer_Plus/附录G 标准模板库方法和函数/STL和C++11","date":"2022-12-27T03:12:54.013Z","updated":"2022-12-27T03:12:54.013Z","comments":true,"path":"posts/136ce074.html","link":"","permalink":"https://www.mingsrc.work/posts/136ce074","excerpt":"","text":"STL和C++11 参考《C++ primer Plus 第六版》 1 array容器array容易一旦声明，其长度就是固定的，他使用静态（栈）内存，而不是动态分配的内存。提供它旨在替代数组；array受到的显示比vector多，但效率更高。","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"},{"name":"附录G 标准模板库方法和函数","slug":"C-笔记/C-Primer-Plus/附录G-标准模板库方法和函数","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/%E9%99%84%E5%BD%95G-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://www.mingsrc.work/tags/STL/"}]},{"title":"类型转换","slug":"E_学习笔记/C++/C++_Primer_Plus/类型转换","date":"2022-12-27T03:12:54.012Z","updated":"2022-12-27T03:12:54.013Z","comments":true,"path":"posts/61165acd.html","link":"","permalink":"https://www.mingsrc.work/posts/61165acd","excerpt":"","text":"标准类型转换太不严格。例如： 12345678struct Doof &#123; double feeb; double steeb; char sgif[10];&#125;;Doof leam;shart * ps = (short *) &amp; leam;int * pi = int * (&amp;leam); 《C++ Prime Plus》中的例子。C语言不能防止将一种类型的指针转换为另一种完全不相关的类型的指针。 因此，C++中使用了： dynamic_cast static_cast const_cast reinterpret_cast 四种类型转换运算符来执行涉及指针的类型转换。 1. dynamic_cast该运算符的用途是，使得能够在类层次结构中进行向上转换（由于is-a关系，这样的类型转换是安全的），而不允许其他转换。用法如下: 1dynamic_cast &lt;type-name&gt; (expression) 用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化是，如果是非法的对于指针返回NULL,对于引用跑一场。要深入了解内部转换的原理。 向上转换：指的是子类向基类的转换 向下转换：指的是基类想子类的转换 它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够向下转换。 2. const_castconst_cast运算符用于执行只有一种用途的类型转换，及改变值为const为volatile，其语法与dynamic_cast运算符相同： 1const_cast&lt;type-name&gt; (expression) 通俗讲，就是const_cast用于（is-a）关系中将const转换为非const。 提供该运算符的原因是，有时候可能需要这样一个值，它在大多数时候是常量，而有时又是可以修改的。在这种情况下，可以将这个值声明为const，并在需要修改它的时候，使用const_cast。 此外，还用于将const变量转为非const 12345678910111213int main()&#123; int age = 40; const int agep = age; cout &lt;&lt; &quot;const of age:&quot; &lt;&lt; agep &lt;&lt; endl; int &amp;nConstAge = const_cast&lt;int&amp;&gt;(agep); // 修改nConstAge的值看看是否能成功修改age的值 nConstAge = 18; cout &lt;&lt; &quot;new const of age：&quot; &lt;&lt; agep &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 3. static_caststatic_cast运算符的语法与其它运算符一致,用于将const变量转为非const： 1static_cast &lt;type-name&gt; (expression) 仅当type_name可被隐式转换为expression所属的类型或expression可被隐式转换为type_name所属类型时，上述转换才是合法的，否则将出错。 假设High是Low的基类，而Pond是一个无关的类，则从High到Low的转换、从Low到High的转换都是合法的，而从Low到Pond的转换是不允许的： 4. reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[]},{"title":"C++成“神”之路—浮点数","slug":"E_学习笔记/C++/C++_Primer_Plus/第四章、数据类型/浮点数","date":"2022-12-27T03:12:54.012Z","updated":"2022-12-27T03:12:54.012Z","comments":true,"path":"posts/1bbee39e.html","link":"","permalink":"https://www.mingsrc.work/posts/1bbee39e","excerpt":"本篇为基础浮点数用法学习记录","text":"本篇为基础浮点数用法学习记录 wchar_t 类型 大小 表示范围 char 4字节 -128~127 signed char 4字节 -128~127 unsiged char 4字节 0~255 wchar_t(整数类型、宽字符类型) 8字节 wcahr_t：可以拜师扩展字符集，iostream头文件的最新版提供了作用相似的工具——wcin和wcout，可用于处理wchar_t流，&#x3D;&#x3D;可以通过加上前缀L来指示宽字符常量和宽字符串 12wcahr_t bob = L&#x27;P&#x27;;wcout &lt;&lt; L&quot;tall&quot;; C++11新增的类型char16_t和char32_t（两者均是无符号的） char16_t 使用前缀u表示 char16_t ch1 &#x3D;u’q’; char32_t 使用前缀U表示 char32_t ch2 &#x3D; U’\\U000022B’; 原始（raw）字符串 使用前缀R来标识原值字符串 12345cout &lt;&lt; R&quot;(Jim &quot;Kingt Tutt uses·&quot;\\n&quot; inatead of endl)&quot; &lt;&lt;&#x27;\\n&#x27;;//也可以使用cout &lt;&lt; R&quot;+*(此处输入原始字符串)+*&quot; &lt;&lt; endl;//输出：Jim &quot;Kingt Tutt uses·&quot;\\n&quot; inatead of endl const 如果程序在多个地方使用同一个常量，则需要修改该常量时，只需修改一个符号定义即可(const)。 g++将指出程序试图给一个只读变量赋值。 关键字 const 叫做限定符，因为它限定了声明的含义。 123//creat &#x27;const&#x27;//const type name = value;const int Months = 12; ​ 即：在声明中对const进行初始化。 ​ 一种常见的做法是将名称的首字母大写，以提醒您 Months是个常量。这决不是一种通用约定，但在阅读程序时有助于区分常量和变量。另一种约定是将整个名称大写，使用Wdefime 创建常量时通常使用这种约定。还有一种约定是以字母k打头，如kmonths。当然，还有其他约定。许多组织都有特殊的编码约定，要求其程序员遵守。 C++ 浮点数 计算机将(2.5、3.64564)这样的值分成两部分存储。一部分表示值，另一部分（缩放因子）用于对值进行放大或缩小。 浮点数的两种表示方法 #### 1. 使用常用的标准小数点表示法（如3.1415926） 2. E表示法（如2.52e+8&#x3D;&#x3D;252 000 000）​ 需要注意的是: 1. 既可以使用E，也可以使用e 2. 指数可以是正数，也可以是负数 3. 数字中间不能有空格（7.2 E6是错误的） 123456789101112131415161718int main()&#123; float f1 = 3834e-10; float f2 = 3834/1e10,f3 = f1; //输出f1 std::cout &lt;&lt; &quot;当前输出为f1：&quot; &lt;&lt; f1 &lt;&lt; std::endl; //输出f2 std::printf(&quot;当前输出为f2：%.10f\\n&quot;,f2); //输出f3 std::printf(&quot;当前输出为f3：%.10f\\n&quot;, f3); //int 隐式转换 float f4 = 10 / 3; //10和3 被默认为两个int型变量 赋值操作向下取整 std::printf(&quot;当前输出为f4：%.10f\\n&quot;, f4); //f4=3.0 float f5 = 10.0 / 3.0; std::printf(&quot;当前输出为f5：%.10f\\n&quot;, f5); // 10.0/3 = 10/3.0 = 3.33&#125; 输出结果如下所示： 浮点数优缺点 优势 可以表示整数之间的值 由于有缩放因此，表示范围较大 不足 浮点运算的速度比整数运算慢 精度降低（如下所示） 123456789void main()&#123; //该程序将f6加1，然后减去1 float f6 = 2.34E+22f; float f7 = f6 + 1.0f; std::cout &lt;&lt; &quot;f6:&quot; &lt;&lt; f6 &lt;&lt; std::endl &lt;&lt; &quot;f7-f6:&quot; &lt;&lt; f7 - f6 &lt;&lt; std::endl; std::printf(&quot;当前输出为f6：%.1f\\n当前输出为f7-f6：%.1f\\n&quot;, f6, f7-f6);&#125; 输出结果如下： 复合类型","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"},{"name":"第四章、数据类型","slug":"C-笔记/C-Primer-Plus/第四章、数据类型","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"浮点型","slug":"浮点型","permalink":"https://www.mingsrc.work/tags/%E6%B5%AE%E7%82%B9%E5%9E%8B/"}]},{"title":"共用体（union）","slug":"E_学习笔记/C++/C++_Primer_Plus/第四章、数据类型/共用体（union）","date":"2022-12-27T03:12:54.011Z","updated":"2022-12-27T03:12:54.011Z","comments":true,"path":"posts/c63335c7.html","link":"","permalink":"https://www.mingsrc.work/posts/c63335c7","excerpt":"","text":"共用体定义用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也 就是说，结构可以同时存储int、long 和double，共用体只能存储 int、long或double。共用体的句法与结 构相似，但含义不同。例： 12345union one4all &#123; int int_val; long long_val; double double_val;&#125;; 具体使用如下所示： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &quot;main.h&quot;using namespace std;//创建一个共用体union one4all &#123; int int_val; long long_val; double double_val;&#125;;int main()&#123; //在同一时间只能之勇union中变量的一种 one4all temp; temp.int_val = 10; cout &lt;&lt; temp.int_val &lt;&lt; endl; temp.double_val = 3.1415926; cout &lt;&lt; temp.double_val &lt;&lt; endl; cout &lt;&lt; &amp;temp.double_val &lt;&lt; endl; cout &lt;&lt; &amp;temp.long_val &lt;&lt; endl; cout &lt;&lt; &amp;temp.int_val &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 为什么每次只能使用一个，直接打印地址可以发现，union中变量共同使用一个地址，所以每次也只能存储一种类型的值。那么，共用体在什么时候才会用到呢？ 《C++ primer 第六版》中给的定义是： 共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。 匿名共用体 (anonymous union)没有名称的共同体，启程苑将成为位于相同地址处的变量。每次只有一个成员是当前的成员。 1234567891011121314struct worker &#123; char name[20]; bool gender; union &#123; long id_num; char id_char[20]; &#125;;&#125;;worker programmer;if(programmer.gender == 1) cout &lt;&lt; programmer.id_num;else cout &lt;&lt; programmer.id_char; id_num和id_char[20]使用的还是同一个地址。使用中只需确定当前是哪个成员活动就行。 小结共用体常用语节省内存。尤其是嵌入式系统编程，对内存要求较为严格。另外，共用体常用于操作系统数据结构或硬件数据结构。","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"},{"name":"第四章、数据类型","slug":"C-笔记/C-Primer-Plus/第四章、数据类型","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"union","slug":"union","permalink":"https://www.mingsrc.work/tags/union/"}]},{"title":"枚举（enum）","slug":"E_学习笔记/C++/C++_Primer_Plus/第四章、数据类型/枚举enum","date":"2022-12-27T03:12:54.011Z","updated":"2022-12-27T03:12:54.011Z","comments":true,"path":"posts/9e0a28a8.html","link":"","permalink":"https://www.mingsrc.work/posts/9e0a28a8","excerpt":"","text":"枚举C++的枚举工具提供了另一种创建符号常量的方式，这种方式可以代替const。还允许定义新类型，但必须按严格的限制执行。使用enum的句法与struct类似。 enum color &#123; red, orange, blue, green, red, black&#125; 这条语句定义了一个名为color的新类型，它的取值范围为red, orange, blue, green, red, black，称为符号常量，同时将0~5分别对应于red~black。在默认情况下，0对应的是red,5对应的是black,其他以此类推。 声明与使用1234color cor1; //定义了一个类型为color的变量cor1//枚举变量的赋值cor1 = red; //正常赋值cor1 = 20; //非法，20不是枚举变量 由此可以看出，枚举变量的赋值受到限制，与程序员的定义有关。 对枚举而言，它的操作符只有赋值运算符=，这就意味着枚举变量不能执行++、--、+、—等等号以外的操作。 枚举量是整形，可被提升为int类型，但int类型不能自动转换为枚举类型 枚举可以进行强制类型转换，但不确定其结果，如cor1 = spectrum(100); 如果只打算使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称 enum &#123;red,orange&#125;； 设置枚举的值可以使用赋值运算符显式地来设置枚举量的值： 1enum bits &#123;one = 1, two = 2, three = 3&#125;; 但是，指定的值必须是整数。也可以只显式的设置其中一部分的值，默认情况下，枚举的 第一个常量始终是从0开始的，这一点需要注意。 1enum digits &#123;zero, one = 0, two, three = 1&#125;; 这里，zero和one的枚举量都为0,two和three都是1。 除了可以将int类型的值赋值给枚举量，还可以使用long和long long类型的值。 枚举的取值范围现在有指定了枚举量的枚举如下所示： 123enum bits(one = 1, two = 2,four = 4,eight = 8&#125;;bits myflag;myflag = bits(6); 问： 上述赋值是否合法 答案合法，虽然6不是枚举量，但它位于枚举定义的取值范围内。 关于取值范围的定义（参考C++ primer 第六版）： 1enum bigstep(firat,second = 100, third&#125;; 首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。例如，定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0∶否则，采用与寻找上限方式相同的方式，但加上负号。 例如，如果最小的枚举量为-6，而比它小的、最大的2的幂是-8（加上负号），因此下限为-7。选择用多少空间来存储枚举由编译器决定。对于取值范围较小的枚举，使用一个字节或更少的空间∶而对于包含 long类型值的枚举，则使用4个字节。 应用实例1234567891011121314151617#include &lt;iostream&gt;#include &quot;main.h&quot;using namespace std;enum myFlag &#123; one, two = 0, three, four = 1&#125;;int main()&#123; cout &lt;&lt; three &lt;&lt; endl; myFlag flag = myFlag(0); cout &lt;&lt; flag &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 输出结果： 10 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; enum color &#123; red=1, green, blue &#125;; enum color favorite_color; /* 用户输入数字来选择颜色 */ printf(&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;); scanf(&quot;%u&quot;, &amp;favorite_color); /* 输出结果 */ switch (favorite_color) &#123; case red: printf(&quot;你喜欢的颜色是红色&quot;); break; case green: printf(&quot;你喜欢的颜色是绿色&quot;); break; case blue: printf(&quot;你喜欢的颜色是蓝色&quot;); break; default: printf(&quot;你没有选择你喜欢的颜色&quot;); &#125; return 0;&#125; 请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1 你喜欢的颜色是红色","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"},{"name":"第四章、数据类型","slug":"C-笔记/C-Primer-Plus/第四章、数据类型","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"enum","slug":"enum","permalink":"https://www.mingsrc.work/tags/enum/"}]},{"title":"string函数的用法","slug":"E_学习笔记/C++/C++_Primer_Plus/第四章、数据类型/string函数的用法","date":"2022-12-27T03:12:54.010Z","updated":"2022-12-27T03:12:54.010Z","comments":true,"path":"posts/17269114.html","link":"","permalink":"https://www.mingsrc.work/posts/17269114","excerpt":"本篇教程为基础string用法","text":"本篇教程为基础string用法 1、sizeof（）与strlen（）get（）与getline（）的区别 两者都能读取一行输入，知道到达换行符，但是getline()将丢弃换行符，而get()会将换行符保留在输入序列中 1long totals[500] = &#123;0&#125;; //只要显式地将第一个元素初始化为0，然后让编译器将其他元素都初始化为0；如果初始化为1）而不是&#123;0&#125;，则第一个元素被设置为1.其他元素都被设置为 再确定存储字符串所需的最短数组时，别忘了将结尾的空字符串计算在内 1&quot;S&quot; = &#x27;S&#x27; + &#x27;\\0&#x27; &#x3D;&#x3D;sizeof&#x3D;&#x3D;运算符指出整个数组的长度，但&#x3D;&#x3D;strlen()&#x3D;&#x3D;函数返回的是当前存储在数组中的字符串长度，而不是数组本身的长度。 1234const int Arsize = 15;char name2[Arsize] = &quot;C++OWboy&quot;;//通过设置符号常量的地址即可对数组长度进行修改name2[3] = &#x27;\\0&#x27;; strlen()对于未被初始化的数据， 第一个空字符的出现位置是随机的，因此您在运行该程序时，得到的数据长度很可能与此不同 面向行的输入：getline()getline是istream类的一个类方法 getline（）函数每次读取一行。它通过&#x3D;&#x3D;换行符&#x3D;&#x3D;来确定行尾，但不保存&#x3D;&#x3D;换行符&#x3D;&#x3D;。相反，在存储字符串时，它用空字符来替换换行符。 12345#include &lt;istream&gt;//设要使用gtline（（）将姓名读入到一个包含20个元素的nme数组中//第一个参数是目标数组;第二个参数数组长度//长度‘20’包含\\0cin.getling(name,20); 面向行的输入：get()get()会读取换行符（&#x3D;&#x3D;所输入的[enter]需要一个get()消化&#x3D;&#x3D;）；用不带任何参数的cin.get（）调用可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。 如何消化换行符1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(int argc,const char* argv[]) &#123; char charr[20]; string str; int year; cout &lt;&lt; &quot;请输入年份：&quot;; cin &gt;&gt; year; cout &lt;&lt; &quot;获取char字符串：&quot;; cin.getline(charr, 20); cout &lt;&lt; &quot;获取string字符串：&quot;; getline(cin, str); cout &lt;&lt; &quot;第一次输入为：&quot; &lt;&lt; charr &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;第二次输入为：&quot; &lt;&lt; str; return 0;&#125; 运行上述代码可以发现：在输入1997以及回车确定之后，第一个字符串，也就是代码中的cin.getline(charr,20)将回车键吸收并保留，导致第一次getline()直接被调用。所以可以使用get()函数吸收1997之后的换行符； 1234567//以下两种方式均可以//---1---cin &gt;&gt; year;cin.get();//句点表示法//---2---(cin&gt;&gt;yeat).get(); 在添加上述语句之后：便可以正常输入charr与str两个字符串。 2、string类1.注意点123//string类位于命名空间std中#include &lt;string&gt;using namespace std; 可以使用C-风格字符串来初始化sring 对象。 可以使用cin来将键盘输入存储到sring对象中。 可以使用cout 来显示 string对象。 可以使用数组表示法来访问存储在string对象中的字符。 在未输入之前，string对象的长度被自动设置为0 ~~~ C++&#x2F;&#x2F;使用以下方法获取string对象的输入char charr[20];int length &#x3D; strlen(charr);cout &lt;&lt; “strlen（charr）：” &lt;&lt; length &lt;&lt; endl;getline(cin,str);&#x2F;&#x2F;此时getline()不是istream中的类方法 1234567891011123. 上述代码中的charr由于定义时未初始化，第一个空字符的出现位置是随机的吗，因此在运行上述strlen(charr)时，会得到一个不确定的数值&lt;img src=&quot;https://tvax1.sinaimg.cn/large/0072YHp3ly1gjvu4tpiw6j3083011we9.jpg&quot; alt=&quot;String函数用法4&quot; width=&quot;291&quot; data-width=&quot;291&quot; data-height=&quot;37&quot;&gt;### 2.string类的赋值、拼接和附加~~~ C++string str1=&quot;hello &quot;;string str2=&quot;world!&quot;;string str3 = str1+str2;//str3 = &quot;hello world!&quot;str1 += str2; //str1 = &quot;hello world!&quot; 3.其他形式的字符串字面值除了char类型，C++还有wchar_t；并且C++11新增了char16_t和char32_t 可以创建这些类型的数组和这些类型的字符串面值。C++11分别使用前缀L、u和U表示上述三种字符 123wchar_t c1[] = L&quot;first&quot;;char16_t c2[] = u&quot;second&quot;;char32_t c3[] = U&quot;third&quot;; &#x3D;&#x3D;除了上述之外，C++11还支持Unicode编码，使用前缀u8表示这种类型的字符串面值&#x3D;&#x3D; 在不使用转移字符时，即保留\\n的原样输出是，常规的做法就是“\\\\\\n”输出\\n到序列中，但原始字符串将”（和）”用作定界符，并使用前缀 R来标识原始字符串 1cout &lt;&lt; R&quot;(i am a &quot;big&quot;one .)&quot; 上述代码输出为: i am “big” one. 就不必使用\\来表示转义序列。 同时也可以使用自定义定界符控制开始和结尾R”+*(输出内容)+*“ 1cout &lt;&lt; R&quot;+*(&quot;(how are you?)&quot;,i&#x27;m fine. )+*&quot; 上述代码输出为： “(how are you?)”,i’m fine. 需要注意的是，在默认定界符之间可以添加任意数量额基本的字符，但是不包括(空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）)，还可以结合着字符串前缀使用，如Ru、UR等 substr(size_type pos,size_type n &#x3D; npos)函数返回一个字符串——这是从pos开始，复制n个字符（或到字符串尾部）得到的。 12string messgae (&quot;this is a test string!&quot;);string firstWord(message.substr(0,4)) 3、结构体1.定义123456789101112131415161718192021222324//创建结构体//定义一个student结构体，包括三种类型的变量struct student&#123; char name[20]; int age; bool gender;&#125;;//还可以在创建的结构体的时候就创建结构变量，同时也可以对变量初始化struct student&#123; char name[20]; int age; bool gender;&#125;ming_xiao,hua_li=&#123; &quot;lihua&quot;, 18, 0&#125;;//还可以声明没有名称的结构体，省略名称就行struct&#123; char name[20]; int age; bool gender;&#125; Danny; //这样就创建了一个Danny的结构体变量，可以使用Danny.name调用成员变量 2.结构数组12345678910111213//创建结构体student stu[100];//stu中的每个元素都是stu对象，可以与成员运算符一起使用cin &gt;&gt; stu[0].name;cout &lt;&lt; stu[99].age;//结构数组在定义的时候也可以初始化student stu[2] =&#123; &#123;&quot;LiMing&quot;，19,1&#125;, &#123;&quot;Danny&quot;,21,0&#125;&#125;;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"},{"name":"第四章、数据类型","slug":"C-笔记/C-Primer-Plus/第四章、数据类型","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"string","slug":"string","permalink":"https://www.mingsrc.work/tags/string/"}]},{"title":"C++“内联函数”","slug":"E_学习笔记/C++/C++_Primer_Plus/内联函数","date":"2022-12-27T03:12:54.009Z","updated":"2022-12-27T03:12:54.009Z","comments":true,"path":"posts/fb55278d.html","link":"","permalink":"https://www.mingsrc.work/posts/fb55278d","excerpt":"","text":"参考文章：[c++] 用宏定义一个函数 - 推杯问盏 - 博客园 内联函数对于一个频繁使用的短小函数，在C语言中应该用宏定义实现，在C++中用inline实现。宏定义与内联函数的不同用法000。 宏定义在c语言中，写一手漂亮的宏定义是非常有必要的，方式出错；提高代码的移植性和可读性等。尤其是一些常用或通用的功能函数或者代码段，这些功能既可以写成函数，也可以封装为宏定义。就功能性上来讲，用宏定义自然有函数无法比拟的优势所在。 要点：变量都用括号括起来，防止出错，结尾不需要;。在实际编程中，不推荐把复杂的函数使用宏，不容易调试。多行用\\ 1#define max(a,b) ((a)&gt;(b)？(a):(b)) //一个简单的大小比较的宏定义函数 但是如果用函数实现的话，你可能得先声明，并且定义，尤其是对变量类型的局限性上： 12345int max(int a ,int b); //声明//定义int max(int a, int b) &#123; return a&gt;b?a:b;&#125; 比较明显，宏定义简单又方便；同时，函数地调用会带来额外的开销，他需要开辟一片栈空间，记录返回地址，函数返回还要释放。这种开销很明显地会降低代码效率，而且代码量也会大大增加，而使用宏定义则在代码规模和速度方面都有优势。其次就是变量类型上，在C++中因为有模板还可以实现多类型变量的比较，但是在上述代码中仅仅支持int类型的变量进行比较。但宏定义就有所不同，可以用于整形、长整型、单浮点型、双浮点型以及其他一些可以用&gt;操作符进行比较的变量类型，就是说，宏定义是不需要考虑类型的。 在具体使用中，较多场合会因为使用宏定义重命名函数名以及定义一些变量。 12#define MALLOC(n, type) \\((type *) malloc((n)* sizeof(type)) 利用这个宏，我们就可以简单的为任何类型分配一段我们指定的空间大小，并返回指向这段空间的指针。 12int *ptr;ptr = MALLOC( 5, int );//申请5int大小的空间 关于宏定义还会有一些小问题，可能也会导致你使用上的错误，例如： 12345678910#define SQUARE_SUM(x,y) x*x+y*y#include &lt;stdio.h&gt; int main()&#123; int i = 1,j = 2,k ; k = SQUARE_SUM(i+1,j); printf(&quot;%d&quot;,k); return 0;&#125; 上述代码真实的调用是1+1*1+1+2*2=7，这一点需要注意，所以如果有需要的话，建议给变量小括号带上。 宏定义小结 属性 #define宏 函数 代码长度 每次使用时，宏代码都被插入到程序中。除了非常小的宏之外，程序的长度将大幅度增长。 函数代码只出现于一个地方：每次使用这个函数时，都调用那个地方的同一份代码 执行速度 更快 存在函数调用、返回的额外开销 操作符优先级 宏参数的求值是在所有周围表达式的上下文环境里，除非它们加上括号，否则邻近操作符的优先级可能产生不可预料的结果。 函数参数只在函数调用时求值一次，它的结果值传递给函数。表达式的求值结果更容易预测。 参数求值 参数用于宏定义时，每次都将重新求值，由于多次求值，具有副作用的参数可能会产生不可预测的结果。 参数在函数调用前只求值一次，在函数中多次使用参数并不会导致多次求值过程，参数的副作用并不会造成任何特殊问题。 参数类型 宏与类型无关，只要参数的操作是合法的，它可以用于任何参数类型。 函数的参数是与类型有关系的，如果参数的类型不同，就需要使用不同的函数，即使它们执行的任务是相同的。 inline函数在系统下，栈空间是有限的，加入频繁大量的使用就会造成因栈空间不足所造成的程序出错的问题，内联函数的引入也是为了解决一些频繁调用的小函数大量消耗栈空间的问题。 看一个例子： 123456789101112#include &lt;stdio.h&gt; //函数定义为inline即:内联函数 inline char* dbtest(int a) &#123; return (i % 2 &gt; 0) ? &quot;奇&quot; : &quot;偶&quot;; &#125; int main() &#123; int i = 0; for (i=1; i &lt; 100; i++) &#123; printf(&quot;i:%d 奇偶性:%s /n&quot;, i, dbtest(i)); &#125; &#125; 在这种情况时当在下表调用函数时，会变成(i%2&gt;0)?&quot;奇&quot;:&quot;偶&quot;；避免了函数的重复调用对栈内存重复开辟所带来的消耗；当然，inline函数不是在任何条件下都可以使用的，只有函数本身没有调用本身并且函数不是复杂函数（当函数中存在while循环或swich语句时为复杂函数，但是不是复杂函数还要看编译器对它的判断）时，才可以使用； 注意点：inline函数仅仅是一个建议,对编译器的建议,所以最后能否真正内联,看编译器的意思,它如果认为函数不复杂,能在调用点展开,就会真正内联,并不是说声明了内联就会内联,声明内联只是一个建议而已。 其次,因为内联函数要在调用点展开,所以编译器必须随处可见内联函数的定义,要不然,就成了非内联函数的调用了.所以,这要求每个调用了内联函数的文件都出现了该内联函数的定义。因此,将内联函数放在头文件里实现是合适的,省却你为每个文件实现一次的麻烦.而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为,即是说,如果不是每个文件里的定义都一样,那么,编译器展开的是哪一个,那要看具体的编译器而定.所以,最好将内联函数定义放在头文件中.而类中的成员函数缺省都是内联的,如果在类定义时就在类内给出函数,那当然最好;如果在类中未给出成员函数定义,而又想内联该函数的话,那在类外要加上inline,否则就认为不是内联的.为了方便,将内联函数直接声明时就定义,放在头文件中.这样其它文件包含了该头文件,就在每个文件都出现了内联函数的定义.就可以内联了.","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"内联函数","slug":"内联函数","permalink":"https://www.mingsrc.work/tags/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"}]},{"title":"易混点😖：函数指针与指针函数","slug":"E_学习笔记/C++/C++_Primer_Plus/函数指针与指针函数","date":"2022-12-27T03:12:54.009Z","updated":"2022-12-27T03:12:54.009Z","comments":true,"path":"posts/3e98108d.html","link":"","permalink":"https://www.mingsrc.work/posts/3e98108d","excerpt":"","text":"函数指针与指针函数","raw":null,"content":null,"categories":[],"tags":[]},{"title":"C++“多态”","slug":"E_学习笔记/C++/C++_Primer_Plus/多态","date":"2022-12-27T03:12:54.009Z","updated":"2022-12-27T03:12:54.009Z","comments":true,"path":"posts/fc3d8b80.html","link":"","permalink":"https://www.mingsrc.work/posts/fc3d8b80","excerpt":"","text":"本篇是自己阅读加上自己对“多态”的理解，若有不足之处，感谢指出~ 多态多态最常见的用法就是声明基类类型的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是固定的，因此将始终调用到同一个函数，这就无法实现“一个接口，多种方法”的目的了。 在C++ Primer有关于OOP编程的描述是这样的。 OOP不仅仅是将数据和方法合并为类定义；还有助于创建可重用的代码，这将减少大量的工作（继承、类的复用）。 封装（信息隐藏）可以保护数据，使其免遭不适当的访问（使得代码模块化）； 多态让您能够为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义； 编译时多态：通过重载函数实现 运行时多态性：通过虚函数实现 继承让您能够使用旧类派生出新类(扩展已存在的代码)。 这些都是面向对象（OOP)所指的特性。还包括： 抽象 代码的可重用性 在C++面试中很有可能会问你C++的三个特性：封装、继承、多态。 有关于这三点特性，从设计模式中会受益许多，一个好的建议就是去学习设计模式。推荐《Easy搞定设计模式》这本PDF，网上可以搜到。 关于多态，C++ primer给的定义包括多个方面： 函数重载 函数多态是C++在C语言的基础上新增的功能，默认参数让您能够使用不同数目的参数调用同一个函数，而函数多态（函数重载）让您能够使用多个同名的函数。术语“多态”指的是拥有多种形式，因此函数多态允许函数可以有多种形式。类似地，术语“函数重载”指的是可以有多个同名的含糊，因此对名称进行了重载。 类继承：有些继承关系是多态的，这意味着相同的方法名称可能导致依赖于对象类型的行为。（如下代码所示） 运算符重载 12345678910111213141516171819202122232425262728293031323334353637383940414243class Fruit &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;一种水果&quot; &lt;&lt; endl;; &#125; void getColor() &#123; cout &lt;&lt; &quot;水果的颜色&quot; &lt;&lt; endl; &#125;&#125;;/* 还可以声明其他的类和添加您所需要的方法以满足业务需求 您可以尝试创建一个Pear类来更加了解多态行为，更多的可以去了解纯虚函数、抽象等*/class Apple : public Fruit &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;我是苹果&quot; &lt;&lt; endl; &#125; virtual void getColor() &#123; cout &lt;&lt; &quot;红色苹果&quot; &lt;&lt; endl;; &#125;&#125;;int main()&#123; //声明父类和子类的对象 Fruit fruit; Apple apple; //声明一个指向父类的父类指针 Fruit *anotherFruit = &amp;fruit; anotherFruit-&gt;getName(); anotherFruit-&gt;getColor(); //令父类指针指向子类对象 anotherFruit = &amp;apple; anotherFruit-&gt;getName(); //由于fetName()是虚函数，因此调用时指向虚函数表中该函数所在的位置 /* 有virtual才能发生多态现象，没有virtual就按类型调用。 而getColor()不是虚函数，因此调用基类的getColor() */ anotherFruit-&gt;getColor(); system(&quot;pause&quot;); return 0;&#125; 输出如下： 再谈“接口”不同对象调用使用相同方法实现不同操作，也即，方法完成的行为取决于调用该方法的对象。说着有点拗口，我自己理解就是类层面的“重载”。怎么去理解？代码！还是刚才的两个类，额外添加一个Pear类。 123456789101112//先修改基类，使其变为抽象类// 1. 抽象类不用定义，只需声明即可// 2. 抽象类方法前必须有virtual声明// 3. 抽象类不能实例化对象，但是可以创建对象指针 /* 定义一个水果类抽象基类。用于定操作和规定函数，提供方法*/class Fruit &#123;public: virtual void getName() = 0; virtual void getColor() = 0;&#125;; 但凡是纯虚函数，子类继承必须全部重定义！ 12345678910111213141516171819// 定义苹果类和犁类class Apple : public Fruit &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;我是苹果&quot; &lt;&lt; endl; &#125; virtual void getColor() &#123; cout &lt;&lt; &quot;红色苹果&quot; &lt;&lt; endl;; &#125;&#125;;class Pear : public Fruit &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;我是犁&quot; &lt;&lt; endl; &#125; virtual void getColor() &#123; cout &lt;&lt; &quot;黄犁&quot; &lt;&lt; endl;; &#125;&#125;; 创建指针对象指向不同的子类，实现不同的操作。 12345678910int main() &#123; // 通过创建基类的指针对象可以实现多台，就不用访问具体的类，只需要根据基类知道其中的操作即可 Fruit *apple = new Apple; Fruit *pear = new Pear; apple-&gt;getName(); apple-&gt;getColor(); pear-&gt;getName(); pear-&gt;getColor(); return 0;&#125; 输出如下：","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"多态","slug":"多态","permalink":"https://www.mingsrc.work/tags/%E5%A4%9A%E6%80%81/"}]},{"title":"头文件(.h)","slug":"E_学习笔记/C++/C++_Primer_Plus/头文件","date":"2022-12-27T03:12:54.009Z","updated":"2022-12-27T03:12:54.009Z","comments":true,"path":"posts/524b4b01.html","link":"","permalink":"https://www.mingsrc.work/posts/524b4b01","excerpt":"","text":"头文件(header files)定义C++&#x2F;C程序的头文件以.h为后缀。使用时需要在.cpp文件中意#include&lt;fileName.h&gt;的方式引入。头文件作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明，而定义文件用于保存程序的实现。 头文件中常包含的内容 函数原型 使用#define或const定义的符号常量 结构声明 将结构声明放在头文件中是可以的，因为它们不创建变量，而只是在源代码文件中声明结构变量时，告诉编译器如何创建该结构变量。 类声明 内联函数(inline)","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"Pointer And Const","slug":"E_学习笔记/C++/C++_Primer_Plus/pointer and const","date":"2022-12-27T03:12:54.008Z","updated":"2022-12-27T03:12:54.008Z","comments":true,"path":"posts/7d0efebf.html","link":"","permalink":"https://www.mingsrc.work/posts/7d0efebf","excerpt":"","text":"一文搞懂指针常量与常量指针指针常量通俗点，你可以理解为const *，声明一个指针常量就是 const int* a，如果你容易混淆它只能修改指向的位置，可以试着按这种方式去理解。 常量指针const int* ptr或者int const* ptr，两者都表示常量指针。表示一个指针指向常量地址，使用就是可以修改指针指向的位置，但是不能修改指针指向位置的值。定义时可以不赋初值。 那么如何在以后的使用中更加准确地记住？倒着读！ 上述两个定义方式可以理解为： const int *ptr：a ptr is pointer to int const，一个变量ptr指向常整型 int const* ptr: a ptr is pointer to const int，含义同上 指针常量int * const ptr,即指针常量，表示一个常指针指向整型变量。使用就是可以修改指针指向位置的值，但是不能修改指针的指向。 同上，定义方式可以倒着理解： int * const ptr：a ptr is a const pointer to int，ptr是一个指向整型变量的常指针 代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main()&#123; int i = 100; //常量指针 const int* ptr; //指针指向的地址所存储的值不可以被修改 //可以理解为pointer to const int ptr = &amp;i; int i_2 = 120; // *a = 1090; // 这里会报错，因为a是一个常量指针，不可以修改指向位置的值 ptr = &amp;i_2; //但是可以修改常量指针a所指向的位置 cout &lt;&lt; &amp;ptr &lt;&lt; &quot;:&quot; &lt;&lt; *ptr &lt;&lt; endl; //指针常量 int* const ptr2 = &amp;i_2; //可以理解为a const pointer to int,必须赋初值 //ptr2 = &amp;i; //因为ptr2是一个const pointer to int。就是指针指向的位置不能改变，但是指针指向的值可以改变 *ptr2 = 10000; //修改指针指向位置的值 cout &lt;&lt; &amp;a &lt;&lt; &quot;:&quot; &lt;&lt; *a &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 附上运行结果（vs2017）： ![image-20210202090917363](..&#x2F;..&#x2F;..&#x2F;images&#x2F;pointer and const&#x2F;image-20210202090917363.png)","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"杂记","slug":"学习笔记/杂记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9D%82%E8%AE%B0/"}],"tags":[]},{"title":"shared_ptr详细用法","slug":"E_学习笔记/C++/C++_Primer_Plus/shared_ptr","date":"2022-12-27T03:12:54.008Z","updated":"2022-12-27T03:12:54.008Z","comments":true,"path":"posts/e340a684.html","link":"","permalink":"https://www.mingsrc.work/posts/e340a684","excerpt":"","text":"shared_ptr#include&lt;memory&gt; 要确保用 new 动态分配的内存空间在程序的各条执行路径都能被释放是一件麻烦的事情。C++ 11 模板库的 头文件中定义的智能指针，即 shared _ptr 模板，就是用来部分解决这个问题的。 只要将 new 运算符返回的指针 p 交给一个 shared_ptr 对象“托管”，就不必担心在哪里写delete p语句——实际上根本不需要编写这条语句，托管 p 的 shared_ptr 对象在消亡时会自动执行delete p。而且，该 shared_ptr 对象能像指针 p —样使用，即假设托管 p 的 shared_ptr 对象叫作 ptr，那么 *ptr 就是 p 指向的对象。 通过 shared_ptr 的构造函数，可以让 shared_ptr 对象托管一个 new 运算符返回的指针，写法如下： 1shared_ptr&lt;T&gt; ptr(new T); // T 可以是 int、char、类等各种类型 此后，ptr 就可以像 T* 类型的指针一样使用，即 *ptr 就是用 new 动态分配的那个对象。 多个 shared_ptr 对象可以共同托管一个指针 p，当所有曾经托管 p 的 shared_ptr 对象都解除了对其的托管时，就会执行delete p。 例如下面的程序 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class A&#123;public: int i; A(int n):i(n) &#123; &#125;; ~A() &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;destructed&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; shared_ptr&lt;A&gt; sp1(new A(2)); //A(2)由sp1托管， shared_ptr&lt;A&gt; sp2(sp1); //A(2)同时交由sp2托管 shared_ptr&lt;A&gt; sp3; sp3 = sp2; //A(2)同时交由sp3托管 cout &lt;&lt; sp1-&gt;i &lt;&lt; &quot;,&quot; &lt;&lt; sp2-&gt;i &lt;&lt;&quot;,&quot; &lt;&lt; sp3-&gt;i &lt;&lt; endl; A * p = sp3.get(); // get返回托管的指针，p 指向 A(2) cout &lt;&lt; p-&gt;i &lt;&lt; endl; //输出 2 sp1.reset(new A(3)); // reset导致托管新的指针, 此时sp1托管A(3) sp2.reset(new A(4)); // sp2托管A(4) cout &lt;&lt; sp1-&gt;i &lt;&lt; endl; //输出 3 sp3.reset(new A(5)); // sp3托管A(5),A(2)无人托管，被delete cout &lt;&lt; &quot;end&quot; &lt;&lt; endl; return 0;&#125; 程序的输出结果如下：2,2,2232 destructedend5 destructed4 destructed3 destructed 可以用第 14 行及第 16 行的形式让多个 sharecLptr 对象托管同一个指针。这多个 shared_ptr 对象会共享一个对共同托管的指针的“托管计数”。有 n 个 shared_ptr 对象托管同一个指针 p，则 p 的托管计数就是 n。当一个指针的托管计数减为 0 时，该指针会被释放。shared_ptr 对象消亡或托管了新的指针，都会导致其原托管指针的托管计数减 1。 第 20、21 行，shared_ptr 的 reset 成员函数可以使得对象解除对原托管指针的托管（如果有的话），并托管新的指针。原指针的托管计数会减 1。 输出的第 4 行说明，用 new 创建的动态对象 A(2) 被释放了。程序中没有写 delete 语句，而 A(2) 被释放，是因为程序的第 23 行执行后，已经没有 shared_ptr 对象托管 A(2)，于是 A(2) 的托管计数变为 0。最后一个解除对 A(2) 托管的 shared_ptr 对象会释放 A(2)。 main 函数结束时，sp1、sp2、sp3 对象消亡，各自将其托管的指针的托管计数减为 0，并且释放其托管的指针，于是会有以下输出： 1235 destructed4 destructed3 destructed 只有指向动态分配的对象的指针才能交给 shared_ptr 对象托管。将指向普通局部变量、全局变量的指针交给 shared_ptr 托管，编译时不会有问题，但程序运行时会出错，因为不能析构一个并没有指向动态分配的内存空间的指针。 注意，不能用下面的方式使得两个 shared_ptr 对象托管同一个指针： 12A* p = new A(10);shared_ptr &lt;A&gt; sp1(p), sp2(p); sp1 和 sp2 并不会共享同一个对 p 的托管计数，而是各自将对 p 的托管计数都记为 1（sp2 无法知道 p 已经被 sp1 托管过）。这样，当 sp1 消亡时要析构 p，sp2 消亡时要再次析构 p，这会导致程序崩溃。","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"C++关键字——extern","slug":"E_学习笔记/C++/C++_Primer_Plus/关键字/extern","date":"2022-12-27T03:12:54.008Z","updated":"2022-12-27T03:12:54.008Z","comments":true,"path":"posts/510cef8a.html","link":"","permalink":"https://www.mingsrc.work/posts/510cef8a","excerpt":"","text":"C&#x2F;C++中extern关键字详解 一个很容易忽略的关键字 基本解释extern可以放在变量或者函数前。表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找定义。此外exrtern也可以用来进行链接指定。 1. 用作外部变量的声明与使用如果在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用extern声明它： 12345678//file01.cppextern int cat = 20; //定一个flag变量并初始化int dog = 22;int fleas;//file02.cpp//使用file01的cat和dogextern int cat;extern int dog; 在上述例子中，因为file02并没有声明fleas变量，因此无法使用，但是声明了cat和dog，因此可以使用这两个变量。由此可见，关键字extern并非必不可少的，因为即使省略它，效果也相同。 2、函数的声明函数的声明中extern关键字是可有可无的，因为函数本身不加修饰的话就是extern。但是引用的时候一样需要声明。 3、可以多次声明，但是定义只能一次12extern int i; //声明，不是定义int i; //声明，也是定义","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"关键字","slug":"C-笔记/关键字","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/%E5%85%B3%E9%94%AE%E5%AD%97/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"内存分配","slug":"E_学习笔记/C++/C++_Primer_Plus/7-存储空间","date":"2022-12-27T03:12:54.007Z","updated":"2022-12-27T03:12:54.007Z","comments":true,"path":"posts/d5b66195.html","link":"","permalink":"https://www.mingsrc.work/posts/d5b66195","excerpt":"自动存储、静态存储和动态存储\n存储区域主要为栈和自由存储区，栈多服务于临时变量和一些非动态申请的数据类型\n自由存储区或堆通常为一个概念，存储动态申请的变量和数据类型（new）、vector\n","text":"自动存储、静态存储和动态存储 存储区域主要为栈和自由存储区，栈多服务于临时变量和一些非动态申请的数据类型 自由存储区或堆通常为一个概念，存储动态申请的变量和数据类型（new）、vector 1、自动存储（栈） 自动存储的为自动变量，自动变量一般都是程序云心过程中函数的局部变量，常存储在栈中，所以在执行代码时，是按照后进先出进行变量存储，这也就意味着，在程序执行过程中，栈的大小是不断变化的。 2、静态存储（堆）​ 静态存储的两种方式： 1. 在函数外面定义 2. 在声明变量时，加上关键字static 3、动态存储（堆）&#x3D;&#x3D;new和delete&#x3D;&#x3D;的应用，其管理着一个内存池（在C++中也被称为自由存储空间或堆），所创建的变量同存储静态存储的内存是分开的。","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"C++常识与通识","slug":"E_学习笔记/C++/C++_Primer_Plus/C++常识与通识","date":"2022-12-27T03:12:54.007Z","updated":"2022-12-27T03:12:54.007Z","comments":true,"path":"posts/9d0d833e.html","link":"","permalink":"https://www.mingsrc.work/posts/9d0d833e","excerpt":"","text":"将引用作为返回值的通常原因是避免创建副本以提高效率，包括其他的函数传参亦是如此 std::nothrow可以消除抛出异常123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;new&gt; int main()&#123; try &#123; while (true) &#123; new int[100000000ul]; // throwing overload &#125; &#125; catch (const std::bad_alloc&amp; e) &#123; std::cout &lt;&lt; e.what() &lt;&lt; &#x27;\\n&#x27;; &#125; while (true) &#123; int* p = new(std::nothrow) int[100000000ul]; // non-throwing overload if (p == nullptr) &#123; std::cout &lt;&lt; &quot;Allocation returned nullptr\\n&quot;; break; &#125; &#125;&#125; 输出： 12std::bad_allocAllocation returned nullptr 枚举用法——类静态成员1234class year &#123; private: enum &#123;MONTH = 12&#125;; // 可以当做一个 static const&#125;; 具体使用场景自己探索哦~ 可以通过terminate()（默认行为）、abort()、exit()来终止程序 虽然算法、数据结构是基础，但是设计模式也一定要看","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"C++文件操作","slug":"E_学习笔记/C++/C++_Primer_Plus/C++文件操作","date":"2022-12-27T03:12:54.007Z","updated":"2022-12-27T03:12:54.007Z","comments":true,"path":"posts/a83ff634.html","link":"","permalink":"https://www.mingsrc.work/posts/a83ff634","excerpt":"","text":"一个最简单的打开文件写的demo1234567891011121314151617181920212223242526272829303132333435363738/** @fn ReadJson* @brief 从制定路径的文件中读取Json字符串保存到sJson中* @param[in] wsFilePath: 读取Json文件的路径 sJson: 保存读取文件内容的字符串* @param[out] * @return * * @detail * @author mingming.shi* @date 2021-09-16*/BOOL ReadJson(__in tstring wsFilePath, __out std::string&amp; sJson, int *pErr)&#123; FILE* fp_read = NULL; fp_read = _wfopen(wsFilePath.c_str(), _T(&quot;w+&quot;)); int size = 0; if( fp_read == NULL) &#123; if (pErr) &#123; _get_errno(pErr); &#125; return FALSE; &#125; size = ftell(fp_read) /* 查找文件的开头 */ fseek(fp_read, 0, SEEK_SET); fread(sJson.c_str(), size, 1, fp_read); fclose(fp_read); return TRUE;&#125;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"class与struct的区别与用法","slug":"E_学习笔记/C++/C++_Primer_Plus/3-struct与class的区别","date":"2022-12-27T03:12:54.006Z","updated":"2022-12-27T03:12:54.006Z","comments":true,"path":"posts/79effa92.html","link":"","permalink":"https://www.mingsrc.work/posts/79effa92","excerpt":"本篇讲述class与struct的区别与用法","text":"本篇讲述class与struct的区别与用法 命名常识 struct与class的区别 C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。 struct能包含成员函数吗？ 能！ struct能继承吗？ 能！！ struct能实现多态吗？ 能！！！ 1）默认的继承访问权限。struct是public的，class是private的。2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。 coutpu（）函数，该函数显示一个字符 decltype类似于typedef，但是typedef加类型，decltype加变量 12345678910111213141516int n = 0;decltype(n) n2;//n2是int类型typedef int INT;INT n3;//n3也是int类型typedef void(*pfun)();//类外声明auto add（int a,int b）&#123; return a+b;&#125;itn (*p)(int ,int) = add;using PFUN = void (*)(); typedef 重定义类型时不能用于vector 此时就需要using 1234typedef vector&lt;int&gt; int_vec;//此时就会报错using int_vec = vector&lt;int&gt;;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"class","slug":"class","permalink":"https://www.mingsrc.work/tags/class/"},{"name":"struct","slug":"struct","permalink":"https://www.mingsrc.work/tags/struct/"}]},{"title":"虚函数与纯虚函数","slug":"E_学习笔记/C++/C++_Primer_Plus/5-虚函数与纯虚函数","date":"2022-12-27T03:12:54.006Z","updated":"2022-12-27T03:12:54.006Z","comments":true,"path":"posts/5dd98e7e.html","link":"","permalink":"https://www.mingsrc.work/posts/5dd98e7e","excerpt":"本篇讲述虚函数与纯虚函数的区别与用法","text":"本篇讲述虚函数与纯虚函数的区别与用法 对于抽象类来说，它无法实例化对象，而对于抽象类的子类来说，只有把抽象类中的纯虚函数全部实现之后，那么这个子类才可以实例化对象 12345678910class person&#123;private: int age; bool gender;public: void work(); void printInfo(); &#125;; 简单理解就是父类定义了一个群体将会有的动作以及行为：如Worker类，我们仅知道工人们会工作，但是我们不知道具体是什么工人以及从事于什么样的工作，因此，可以把worker类定义为抽象类，用以规定可能会有的行为以及操作。 12345678910class worker：public person&#123;private: int age; bool gender;public: //定义为抽象基类是避免实例化造成的编译报错，并且基类的定义时1为了规定大致的行为操作，具体的内容实现是基于继承类 virtual void work() = 0; virtual void printInfo() = 0; &#125;; 同时，对于抽象类的子类也可以是抽象类， 12345678910class dustMan：public worker&#123;private: int age; bool gender;public: //定义为抽象基类是避免实例化造成的编译报错，并且基类的定义时1为了规定大致的行为操作，具体的内容实现是基于继承类 virtual void work()&#123;cout &lt;&lt; &quot;扫地&quot;;&#125; virtual void printInfo()&#123;cout &lt;&lt; &quot;我是清洁工&quot;;&#125; &#125;; 需要注意的是，如果基类中有纯虚函数（该类为抽象类，不能实例化对象），那么子类实现过程中必须重新定义纯虚函数，编译器才不会报错。 虚函数是动态绑定的，也就是说。使用虚函数的指针和引用能够正确找到实际类的相应函数，而不是运行定义类的函数。 这是虚函数的基本功能，就不再解释了。 构造函数不能是虚函数。并且，在构造函数中调用虚函数，实际运行的是父类的相应函数。由于自己还没有构造好, 多态是被disable的。 析构函数能够是虚函数。并且，在一个复杂类结构中。这往往是必须的。 将一个函数定义为纯虚函数。实际上是将这个类定义为抽象类，不能实例化对象。 纯虚函数通常未定义体，但也全然能够拥有, 甚至能够显示调用。 **析构函数能够是纯虚的，但纯虚析构函数必须有定义体，*由于析构函数的调用是在子类中隐含的***。 非纯的虚函数必须有定义体，不然是一个错误。 派生类的override虚函数定义必须和父类全然一致(c++11中使用override进行编译器检查)。除了一个特例，假设父类中返回值是一个指针或引用。子类override时能够返回这个指针（或引用）的派生。 比如，在上面的样例中，在Base中定义了 virtual Base* clone(); 在Derived中能够定义为 virtual Derived* clone()。","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"浮点型","slug":"浮点型","permalink":"https://www.mingsrc.work/tags/%E6%B5%AE%E7%82%B9%E5%9E%8B/"}]},{"title":"共用体（union）","slug":"E_学习笔记/C++/C++_Primer_Plus/5、共用体（union）","date":"2022-12-27T03:12:54.006Z","updated":"2022-12-27T03:12:54.006Z","comments":true,"path":"posts/c63335c7.html","link":"","permalink":"https://www.mingsrc.work/posts/c63335c7","excerpt":"","text":"共用体定义用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也 就是说，结构可以同时存储int、long 和double，共用体只能存储 int、long或double。共用体的句法与结 构相似，但含义不同。例： 12345union one4all &#123; int int_val; long long_val; double double_val;&#125;; 具体使用如下所示： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &quot;main.h&quot;using namespace std;//创建一个共用体union one4all &#123; int int_val; long long_val; double double_val;&#125;;int main()&#123; //在同一时间只能之勇union中变量的一种 one4all temp; temp.int_val = 10; cout &lt;&lt; temp.int_val &lt;&lt; endl; temp.double_val = 3.1415926; cout &lt;&lt; temp.double_val &lt;&lt; endl; cout &lt;&lt; &amp;temp.double_val &lt;&lt; endl; cout &lt;&lt; &amp;temp.long_val &lt;&lt; endl; cout &lt;&lt; &amp;temp.int_val &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 为什么每次只能使用一个，直接打印地址可以发现，union中变量共同使用一个地址，所以每次也只能存储一种类型的值。那么，共用体在什么时候才会用到呢？ 《C++ primer 第六版》中给的定义是： 共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。 匿名共用体 (anonymous union)没有名称的共同体，启程苑将成为位于相同地址处的变量。每次只有一个成员是当前的成员。 1234567891011121314struct worker &#123; char name[20]; bool gender; union &#123; long id_num; char id_char[20]; &#125;;&#125;;worker programmer;if(programmer.gender == 1) cout &lt;&lt; programmer.id_num;else cout &lt;&lt; programmer.id_char; id_num和id_char[20]使用的还是同一个地址。使用中只需确定当前是哪个成员活动就行。 小结共用体常用语节省内存。尤其是嵌入式系统编程，对内存要求较为严格。另外，共用体常用于操作系统数据结构或硬件数据结构。","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"},{"name":"第四章、复合类型","slug":"C-笔记/C-Primer-Plus/第四章、复合类型","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"union","slug":"union","permalink":"https://www.mingsrc.work/tags/union/"}]},{"title":"C++操作符","slug":"E_学习笔记/C++/C++_Primer_Plus/6-操作符","date":"2022-12-27T03:12:54.006Z","updated":"2022-12-27T03:12:54.007Z","comments":true,"path":"posts/2c746baa.html","link":"","permalink":"https://www.mingsrc.work/posts/2c746baa","excerpt":"","text":"1 操作符~(补码运算符)1234int x = 1;int y = ~x; //1.cout &lt;&lt; y;//输出&#x27;254&#x27; 解释： x = 0000 0001~x = 1111 1110,-x为负数，负数在计算机中用补码表示，所以符号位不变，取反加1y = 1 0000 0010,1000 0010(BIN) = -2(DEX) ++操作符1234int i1 = 4；int y1 = i1++; //如大家所知，点调用、再自增 y1 = 4 , i1 = 5; int i2 = 4;int y2 = ++i2; //先自增再调用 y2 = 5 , i2 = 5; 大体上是类似的，但是i++在计算时会用到中间变量，会占用更多的内存和时间，所以++i更好 2 C++不能重载的操作符12345678910（1） &quot;.&quot;（类成员访问运算符） （2）&quot; .*&quot;（类成员指针访问运算符） （3） &quot;::&quot;（域运算符） （4）&quot;sizeof&quot;（长度运算符） （5） &quot; ?:&quot;（条件运算符/三目运算符）（6） dynamic_cast（7） static_cast（8） reinterpret_cast (9) const_cast (10) typeid(获取类型信息) 3 运算符重载后，优先级和结合性怎么办？用户重载新定义运算符，不改变元运算符的优先级和结合性。这就是说，对运算符重载不改变运算的优先级和结合性，并且运算符重载后，也不改变运算符的语法结构，即单目运算符的语法结构只能冲仔尾单目运算符，双目运算符只能重载为双目运算符。 4 编译程序如何选用那一个运算符函数？运算符重载实际是一个函数，所以运算符的重载实际上是函数的重载。编译程序对运算符重载的选择，遵循着函数重载的算则原则。当遇到不很明显的运算时，编译程序将去寻找参数相匹配的运算符函数。 5 重载你算符有哪些限制？ 不可臆造新的运算符。必须把重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中。 重载运算符坚持4个“不能改变” 不能改变运算符操作数的个数； 不能改变运算符原有的优先级； 不能改变运算符原有的结核性； 不能改变运算符原有的语法结构。 6 运算符重载时必须遵循哪些原则？ 运算符重载可以是程序更加简洁，是表达式更加直观，增加可读性。但是运算符重载使用不宜过多，否则会带来一定麻烦。 使用重载运算符是应遵循如下原则： 重载运算符含义必须清楚 重载运算符不能有二义性 以下是C++编程语言中的所有运算符的优先级和结合性列表。 优先级 运算符 叙述 示例 重载性 结合性 1 :: 作用域解析(C++专有) Class::age = 2; 否 由左至右 2 ++ 后缀递增 i++ 2 -- 后缀递减 i— 2 &#123;&#125; 组合 {i++;a*=i;} 2 () 函数调用或变量初始化 c_tor(int x, int y) : _x(x), _y(y * 10) {} 2 [] 数组访问 array[4] = 2; 2 . 以对象方式访问成员 obj.age = 34; 否 2 -&gt; 以指针方式访问成员 ptr-&gt;age = 34; 2 dynamic_cast 运行时检查类型转换(C++专有) Y&amp; y = dynamic_cast(x); 否 2 static_cast 未经检查的类型转换(C++专有) Y&amp; y = static_cast(x); 否 2 reinterpret_cast 重定义类型转换(C++专有) int const p = reinterpret_cast&lt;int const&gt;(0x1234); 否 2 const_cast 更改非常量属性(C++专有) int q = const_cast&lt;int&gt;(p); 否 2 typeid 获取类型信息(C++专有) std::type_info const&amp; t = typeid(x); 否 3 ++ 前缀递增 ++i 由右至左 3 -- 前缀递减 —i 3 + 一元正号 int i = +1; 3 - 一元负号 int i = -1; 3 ! not 逻辑非 !的备用拼写 if (!done) … 3 ~ compl 按位取反 ~的备用拼写 flag1 = ~flag2; 3 (*type*) 强制类型转换 int i = (int)floatNum; 3 * 取指针指向的值 int data = *intPtr; 3 &amp; 取变量的地址 int *intPtr = &data; 3 sizeof 某某的大小 size_t s = sizeof(int); 否 3 new 动态内存分配(C++专有) long* pVar = new long; 3 new[] 动态数组内存分配(C++专有) long* array = new long[20]; 3 delete 动态内存释放(C++专有) delete pVar; 3 delete[] 动态数组内存释放(C++专有) delete [] array; 4 .* 成员对象选择(C++专有) obj.*var = 24; 否 由左至右 -&gt;* 成员指针选择(C++专有) ptr-&gt;*var = 24; 5 * 乘法 int i = 2 * 4; / 除法 float f = 10.0 / 3.0; % 模数(取余) int rem = 4 % 3; 6 + 加法 int i = 2 + 3; - 减法 int i = 5 - 1; 7 &lt;&lt; 比特左移 int flags = 33 &lt;&lt; 1; &gt;&gt; 比特右移 int flags = 33 &gt;&gt; 1; 8 &lt; 小于关系 if (i &lt; 42) … &lt;= 小于等于关系 if (i &lt;= 42) … &gt; 大于关系 if (i &gt; 42) … &gt;= 大于等于关系 if (i &gt;= 42) … 9 == eq 等于关系 ==的备用拼写 if (i == 42) … != not_eq 不等于关系 !=的备用拼写 if (i != 42) … 10 &amp; bitand 比特 AND &amp;的备用拼写 flag1 = flag2 &amp; 42; 11 ^ xor 比特 XOR(独占or) ^的备用拼写 flag1 = flag2 ^ 42; 12 ` `bitor 比特 OR(包含or) ` `的备用拼写 flag1 = flag2 \\ 42; 13 &amp;&amp; and 逻辑 AND &amp;&amp;的备用拼写 if (conditionA &amp;&amp; conditionB) … 14 ` `or 逻辑 OR ` `的备用拼写 if (conditionA \\ \\ conditionB) … 15 *c*?*t*:*f* 三元条件运算 int i = a &gt; b ? a : b; 否 由右至左 16 = 直接赋值 int a = b; 16 += 以和赋值 a += 3; 16 -= 以差赋值 b -= 4; 16 *= 以乘赋值 a *= 5; 16 /= 以除赋值 a /= 2; 16 %= 以取余数赋值 a %= 3; 16 &lt;&lt;= 以比特左移赋值 flags &lt;&lt;= 2; 16 &gt;&gt;= 以比特右移赋值 flags &gt;&gt;= 2; 16 &amp;= and_eq 以比特AND赋值 &amp;=的备用拼写 flags &amp;= new_flags; 16 ^= xor_eq 以比特XOR赋值 ^=的备用拼写 flags ^= new_flags; 16 ` =`or_eq 以比特OR赋值 ` =`的备用拼写 flags \\ = new_flags; 17 throw 抛出异常 throw EClass(“Message”); 否 18 , 逗号运算符 for (i = 0, j = 0; i &lt; 10; i++, j++) … 由左至右","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[{"name":"操作符","slug":"操作符","permalink":"https://www.mingsrc.work/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"}]},{"title":"就业实录-信息系统与信息管理专业","slug":"C_面试/面试实录","date":"2022-12-27T03:12:54.005Z","updated":"2022-12-27T03:44:43.242Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://www.mingsrc.work/posts/undefined","excerpt":"\n\n面试日记📚\n\n{% note blue 'no-icon' flat %}\n\n没想到的是，offer是有了。虽然是格力的，但是体检不合格。从小到大都没犯过什么毛病，却在入职体检查出来预激综合征。来年春招再战了！\n\n{% endnote %}\n\n\n\n博客仅用于记录20年下半年的面试记录与学习记录~~给自己加油","text":"面试日记📚 {% note blue 'no-icon' flat %} 没想到的是，offer是有了。虽然是格力的，但是体检不合格。从小到大都没犯过什么毛病，却在入职体检查出来预激综合征。来年春招再战了！ {% endnote %} 博客仅用于记录20年下半年的面试记录与学习记录~~给自己加油 一、天马面试记录🐴Data：20年9月23日 先说一下没能成功签的因素，在无领导小组讨论环节，也不知道是怎么想的，就想表达自己认为的观点，但我对别人的也是认同的，只是纠结于目标，期间说了这么一句“只要我们给考官一个满意的答案就行！”。我觉得这句话对考官来说比较刺耳，同时也有限制别的组员发挥的意思，尤其不好，不过我是想从事于C++开发岗位的工作，但是此次面试的经验还是记录下来比较好，吸取一点教训！希望下次还能有这样碰壁的机会~ 先是准备自我介绍，室友比我早一点时间，所以在室友那取经后，还是稍稍准备了一下自我介绍： 以下贴上准备的稿子，实际对话的时候可能会为了场合和地点以及面试官的问题稍作修改，首先表明在校期间表现不是特别优异，但也不是差的那批，处于中上游的水平，参加过几次比赛，但是名次都一般。 天马面试自我介绍您好！ 😃😃我是经济管理学院信息系统与信息管理专业的XXX，学习期间担任班长和学生会网络媒体部副部长一职。在校活动中多次荣获优秀志愿者称号。竞赛方面，参加过两次三创赛，一次互联网＋，申请并独自完成了一个大创项目。18年末开始学习并使用Qt进行项目开发，其中大创项目就是基于Qt平台开发的一款PC端应用程序。现在主要期望能参与到C&#x2F;C++方面的开发工作当中。 您好！ 😃😃我是经济管理学院信息系统与信息管理专业的XXX,课程内容以管理与计算机为主，18年末开始学习并使用Qt进行项目开发，其中大创项目就是基于Qt平台开发的一款PC端应用程序。现在主要期望能参与到C&#x2F;C++方面的开发工作当中。 1️⃣天马一面一面主要是自我介绍的环节与面试官的一些问答环节：问一下大学期间的学习情况以及参加的项目，面试官可能会细致的问一下你对某一课程的学习情况，除此之外，会着重问一下你大学期间参加的项目、担任的角色、负责的任务。 一面的同时，面试官也会思考你是适合哪一岗位，所以你要尽可能的把自己说明白，这一点不管是在哪个面试上，我觉得都是个人最重要的一点。 珠海格力面试IBM面试面试技巧 {% note orange 'fa fa-battery-quarter' flat %} 这篇文章还在编辑中······ {% endnote %}","raw":null,"content":null,"categories":[{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"存储空间","slug":"E_学习笔记/C++/C++_Primer_Plus/10-标准模板库","date":"2022-12-27T03:12:54.005Z","updated":"2022-12-27T03:12:54.005Z","comments":true,"path":"posts/60bae8b.html","link":"","permalink":"https://www.mingsrc.work/posts/60bae8b","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 删除向量中的所有元素，然后将选代器first和last指示范围中的元素插入该向量中void assign(iterator first,iterator last) //删除向量中的所有元素，然后将cdl的n个副本插入该向量中void assign(size_type n,constT&amp;el=T()) //返回向量中位置为n的元素T&amp;at(siz type n) //返回向量中位置为n的元素const T&amp;at(size_type n)const //返回向量的最后一个元素T&amp;back() //返回向量的最后一个元素const T&amp;back()const //返回一个选代器，该选代器引用向量的第一个元素iterator begin() //返回一个迭代器∶该送代都引用向量的第一个元素const_iterator begin()const //返回可以存储在向量中的元素数目siz_type capacity() //清除向量中的所有元素void clear() //如果向量不包括元素，则返回true，否则返回falsebool empty()const //返回一个迭代器。，该选代器位于向量的最后一个元素之后iterator end() //返回一个const达代器，该达代器位于向量的最后一个元素之后const_iterator end()const //除由迭代器i引用的元素，返回一个迭代器，用被除元素之后的元素iterator erase(teator i)//删除迭代器first和last指示范围中的元素，返回一个达代器，引用被除的最后一个元素之后的元素iterator erase(iterator fist,iterator last) //返回向量的第一个元素T&amp; front() //返回向量的第一个元素const T&amp; front()const //在由选代器i引用的元素之前插入d，并返回引用新插入元素的选代器iterator insert(iterator const T&amp; el=T()) //在选代器i引用的元素之前插入el的n个副本void insert(iterator i,size_type n, const T&amp;el) //在选代器i引用的元素之前插入迭代器frs和hst指示范围中的元素void insert(iterator i,iterator fist,iterator last) //返回向量的最大元素数size _type max_sizt()const //下标运算符T&amp;operator[] //下标运算符const T&amp; operatof[]const //删除向量的最后一个元素void pop_back() //在向量的末尾插入elvoid push_back(const T&amp; el) //返回引用向量中最后一个元素的迭代器reverse_iterator rbegin() //返回引用向量中最后一个元素的选代器const_reverse_iterator rbegin()const //返回位于向量中第一个元素之前的选代器reverse_iterator rend() //返回位于向量中第一个元素之前的迭代器const_reverse_iternator rend()const //如果向量的容量小于n，该函数就为向量预留保存n项的足够空间void reserve(size_type n) //反转向量void reverse()//使向量保存n个元素，方法是∶通过元素el再添加n-size()个位置，或者丢弃向量末尾溢出的sizs()-n个位置void resize(size_type n,const T&amp;el=T)) //返回向量中的元素数量size_type size()const //与另一个向量v交换内容void swap(vector&lt;T&gt;&amp;v) //创建空向量vector() //用类型T的n个el副本创建一个向量（如果没有提供ed，则使用默认的构造函数T()）vector(siz_type n, const T&amp;el=T()) //用达代器fist 和last指示范围中的元素构造一个向量vector(iterator fist,iterator last) //复制构造函数vector(const vector&lt;T&gt;&amp; v) sort()排序函数 排序算法具有同样的灵活性，在对向量v5排序的例子中，v5是以升序来排序的。那么v5如何 按降序排序呢?方法之一先对向量进行升序排序，然后用 reverse()算法来反转向量。另一种方法是 强制sort0算法在得出结果时使用&gt;运算符。为此，可以直接把函数对象作为参数∶ 12345678sort(v5.begin(),v5.end(),greater&lt;int&gt;());//或者间接使用sort(v5.begin(),v5.end(),f2);bool f2(int m,int n)&#123; return m &gt; n ;&#125; greater()函数 头文件 #include STL已定义的函数，这个函数对象定义为模板结构，实际上该函数重载了运算符&gt;。 函数size()： 返回向量当前的元素数目（即：向量大小） 函数capacity()：返回向量能够拥有的元素数目（即：向量的容量） 函数resize() ：可以改变函数的容量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void main(int arhc, const char * argv[])&#123; int a[] = &#123; 1,2,3,4,5 &#125;; int b[] = &#123;0&#125;; // b[1] = 5; //cout &lt;&lt; &quot;b1:&quot; &lt;&lt; b[1] &lt;&lt;endl; vector&lt;int&gt; v1; for (int j = 1; j &lt;= 5; j++) &#123; v1.push_back(j); &#125; cout &lt;&lt; &quot;v1:&quot; &lt;&lt; v1.size() &lt;&lt; endl; vector&lt;int&gt; v2(3, 7); cout &lt;&lt; &quot;v2:&quot; &lt;&lt; v2.size() &lt;&lt; endl; //获取v1的下标为【1】的元素复制给i1 vector&lt;int&gt;::iterator i1 = v1.begin() + 1; vector&lt;int&gt; v3(i1, i1 + 3); cout &lt;&lt; &quot;v3:&quot; &lt;&lt; v3.at(2) &lt;&lt; endl; v3[1] = v3.front(); for (SIZE_T i = 0; i &lt; v3.size(); i++) &#123; cout &lt;&lt; &quot;V3[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; v3[i] &lt;&lt; endl; &#125; vector&lt;int&gt; v4(v1); // v4=(1 2 3 4 5),size=5,capacity=5 vector&lt;int&gt; v5(5); // v5=&#123;0 0 0 0 0&#125; v5[1] = v5.at(3)=9; // v5 = (0 9 0 9 0) v3.reserve(6); // v3=(2 3),size= 2,capacity=6 v4.resize(7); // v4=(1234500),size=7,capacity=10 v4.resize(3); // v4=(123),size=3,capacity=10 v4.clear(); // v4 is empty,size=0,capacity=10(!) v4.insert(v4.end(), v3[1]); // v4 = (3) v4.insert(v4.end(), v3.at(1)); // v - (33) v4.insert(v4.end(), 2, 4); // 4=(3344) v4.insert(v4.end(), v1.begin() + 1, v1.end() - 1);// v4=(3 3 4 4 2 3 4) v4.erase(v4.end() - 2); //v4=(3 3 4 4 2 4) v4.erase(v4.begin(), v4.begin() + 4); // v4 = (2 4) v4.assign(3, 8); // v4 = (8 8 8) v4.assign(a, a + 3); // v4 = (1 2 3) replace(v5.begin(), v5.end(), 0, 7); printVector(v5); const char *s = &quot;Green&quot;; vector&lt;Person&gt; v6(1,Person(s,25)); v6.push_back(Person(&quot;Ann&quot;, 30)); v6.push_back(Person(&quot;Bill&quot;, 20)); sort(v6.begin(), v6.end(),greater&lt;Person&gt;()); for (size_t i = 0; i &lt; v6.size(); i++) &#123; info manInfo = v6[i].getInfo(v6[i]); cout &lt;&lt; manInfo.name &lt;&lt; &quot;今年&quot; &lt;&lt; manInfo.age &lt;&lt; &quot;了&quot; &lt;&lt; endl; &#125; sort(v6.begin(), v6.end(),lesserAge); for (size_t i = 0; i &lt; v6.size(); i++) &#123; info manInfo = v6[i].getInfo(v6[i]); cout &lt;&lt; manInfo.name &lt;&lt; &quot;今年&quot; &lt;&lt; manInfo.age &lt;&lt; &quot;了&quot; &lt;&lt; endl; &#125; return;&#125;","raw":null,"content":null,"categories":[{"name":"C++笔记","slug":"C-笔记","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/"},{"name":"C++_Primer_Plus","slug":"C-笔记/C-Primer-Plus","permalink":"https://www.mingsrc.work/categories/C-%E7%AC%94%E8%AE%B0/C-Primer-Plus/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"WHERR与HAVING与ON","slug":"C_面试/数据库/WHERE与HAVING与ON","date":"2022-12-27T03:12:54.004Z","updated":"2022-12-27T03:12:54.004Z","comments":true,"path":"posts/e5f67d8e.html","link":"","permalink":"https://www.mingsrc.work/posts/e5f67d8e","excerpt":"","text":"WHERE与HAVING与ON1. where与having的区别WHERE 与 HAVING 的根本区别在于： WHERE子句在 GROUP BY 分组与聚合函数之前对数据行进行过滤； HAVING 子句对 GROUP BY 分组和聚合函数之后的数据进行过滤。 where where是一个约束声明，使用where来约束来数据库的数据； where是在结果返回之前起作用的； where子句中不能使用聚合函数。 having having 是一个过滤声明 在查询结果返回结果集以后，对结果进行的过滤操作； 在 having 中可以使用聚合函数。 所以可以看出， having 通常和聚合函数以及 group by 连用。（面试知识点） having子句中不能输用除了分组字段和聚合函数之外的其他字段。 123456#例如:查找每个部门月薪#大于等于30000的员工人数select dept_id,count(*)from employeegroup by dept_idhaving salary &gt;= 30000; 因为经过group by分组和聚合函数之后，不再存在salary字段，having 子句中只能使用分组字段或者聚合函数。 当然， WHERE 和 having 可以组合在一起使用。例如： 1234567891011select dept_id, count(*)from employeewhere salary &gt; 10000group by dept_idhaving count(*) &gt; 1;/*该语句返回了月薪大于10000的员工人数大于1的部门；WHERE用于过滤月薪大于10000的员工；HAVING用于过滤员工数量大于1的部门。*/ WHERE与ON 当涉及多个表的关联时，我们那既可以使用 WHERE 子句也可以使用 ON 子句指定链接条件和过滤条件。这两者的主要区别在于： 对于内链接（inner join）查询， WHERE 和 ON 中的过滤条件等效； 对于外链接（outer join）查询， ON 中的过滤条件在连接操作之前执行， WHERE 中的过滤条件（逻辑上）在连接操作之后执行。 2. 聚合函数和group by聚合函数就是例如： SUM、COUNT、MAX、AVG等 对一组（多条）数据操作的函数，需要配合group by来使用。 1234#如：select SUM(popultion),region FROM T01_beijing GROUP BY region;//计算北京每个分区的人数 3. where和having的执行顺序 where 早于 group by 早于 having where子句在聚合前筛选记录，也就是说作用在group by子句和having子句前，而having子句在聚合后对组记录进行筛选 4. where不能使用聚合函数、having中可以使用聚合函数12345#筛选出ABC及各区学校数量SELECT region，count(school)FROM T02_beijing_schoolWHERE region IN (&#x27;Ａ&#x27;,&#x27;B&#x27;,&#x27;C&#x27;)GROUP BY region HAVING COUNT(school) &gt; 10; 12345#筛选出ABC三地中学校数量超过10的区及各区学校SELECT region ,count(school)FROM T02_beijing_schoolWHERE region IN (&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;)GROUP BY region HAVING count(shool) &gt; 10;","raw":null,"content":null,"categories":[{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/"},{"name":"数据库","slug":"面试/数据库","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.mingsrc.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库常见面试问题","slug":"C_面试/数据库/数据库面试常见问题","date":"2022-12-27T03:12:54.004Z","updated":"2022-12-27T03:12:54.004Z","comments":true,"path":"posts/42c6ad67.html","link":"","permalink":"https://www.mingsrc.work/posts/42c6ad67","excerpt":"","text":"数据库常见面试问题数据库索引索引是对数据表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。索引有助于更快的获取信息。 索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。 数据库事务数据库事务（Database Transaction），是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部操作成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务时数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。 数据库事务隔离同一时间，只允许一个事务请求统一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转钱。 inner join 和 left joinleft join（左连接）返回包括左表中的所有记录和右边中联结字段相等的记录 right join（右连接）返回包含右表中所有记录和左表中联结字段相等的记录 inner join（等值连接）只返回两个表中联结字段相等的行 数据库事务的一致性事务是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务时DBMA中最基础的单位，事务不可分割。 事务具有四个特征：分别是原子性、一致性、隔离性、持续性。简称ACID。 请你说一下索引是什么，多加索引一定会好吗？ 索引 数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。 DB在执行一条sql语句的时候，默认的方式事根据搜索条件进行全表扫描，遇到匹配条件的就加入到搜索结果集合。如果我们对某一个字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少了遍历匹配的行数，所以能明显增加查询的速度。 优点： 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 可以加快数据的检索速度，这也是键索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 缺点： 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 索引需要占物理空间，输了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要占用的空间就更大。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 聚簇索引和非聚簇索引 聚簇索引：将数据存储与索引放到了一块，找到了索引也就找到了数据 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点只想了数据的对应行，myisam和key-buffer把索引先缓存到内存结构中，当需要访问数据时（通过索引访问数据），当内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key-buffer命中时，速度慢的原因。 注：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值 添加索引的原则 很少使用的或者参考的列不应该创建索引。 数据库死锁怎么解决 找到进程号，kill进程","raw":null,"content":null,"categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"数据库常见面试问题","slug":"C_面试/数据库/面试常问","date":"2022-12-27T03:12:54.004Z","updated":"2022-12-27T03:12:54.004Z","comments":true,"path":"posts/42c6ad67.html","link":"","permalink":"https://www.mingsrc.work/posts/42c6ad67","excerpt":"","text":"数据库面试WHERE与HAVING与ON 事务 数据库面试 🪡索引 数据库索引索引是对数据表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。索引有助于更快的获取信息。 索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。 数据库事务数据库事务（Database Transaction），是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部操作成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务时数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。 数据库事务隔离同一时间，只允许一个事务请求统一数据，u痛的事务之间彼此美欧任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转钱。 inner join 和 left joinleft join（左连接）返回包括左表中的所有记录和右边中联结字段相等的记录 right join（右连接）返回包含右表中所有记录和左表中联结字段相等的记录 inner join（等值连接）只返回两个表中联结字段相等的行 example: 某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表： +—-+——-+| Id | Name |+—-+——-+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+—-+——-+Orders 表： +—-+————+| Id | CustomerId |+—-+————+| 1 | 3 || 2 | 1 |+—-+————+例如给定上述表格，你的查询应返回： +———–+| Customers |+———–+| Henry || Max |+———–+ 12345select c.Name as Customersfrom Customers cleft join Orders d on c.Id = d.CustomerIdwhere d.CustomerId is null 数据库事务的一致性事务是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务时DBMA中最基础的单位，事务不可分割。 事务具有四个特征：分别是原子性、一致性、隔离性、持续性。简称ACID。 mysql的四种隔离状态Mysql主要包含四种隔离状态：读未提交、不可重复读、可重复读、串行化 事务隔离级别 脏读 不可重复读 幻读 读未提交（read-uncommitted） 是 是 是 不可重复读（read-committed） 否 是 是 可重复读（repeatable-read） 否 否 是 串行化（serializable） 否 否 否 请你介绍一下mysql的MVCC机制MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。 数据库默认端口1、mysql的默认端口是3306，可以编辑用户目录下的 .my.cnf 文件进行修改； 2、sqlserver默认端口号为：1433； 3、oracle默认端口号为：1521； 4、DB2默认端口号为：50000； 5、PostgreSQL默认端口号为：5432。 主键索引和普通索引的区别 1.主键索引索引着数据，然而普通索引索引着主键ID值(这是在innodb中，但是如果是myisam中，主键索引和普通索引是没有区别的都是直接索引着数据)2.当你查询用的是where id&#x3D;x 时，那只需要扫描一遍主键索引，然后拿到相应数据，但是如果是查询的普通索引的话，那么会先扫描一次普通索引，拿到主键值，然后再去扫主键索引，拿到所需要的数据，这个过程叫做回表","raw":null,"content":null,"categories":[{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/"},{"name":"数据库","slug":"面试/数据库","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.mingsrc.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"为什么要使用HTTPS？","slug":"C_面试/计算机网络/HTTPS","date":"2022-12-27T03:12:54.004Z","updated":"2022-12-27T03:12:54.004Z","comments":true,"path":"posts/58cf9bb0.html","link":"","permalink":"https://www.mingsrc.work/posts/58cf9bb0","excerpt":"","text":"转载声明：SHERlocked93 分享一个HTTP的抓包工具： fiddler（fiddler中文版）是一个http协议Web调试代理工具。fiddler能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点查看所有的“进出”Fiddler的数据（指html,cookie,css，js等文件，这些都可以让你胡乱修改的意思）。Fiddler（fiddler中文版）要比其他的网络调试器要更加简单，因为它不仅仅可以帮助用户提供暴露http通讯，还提供了一个友好的用户格式。Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用.net语言进行扩展，适用于：开发环境的host配置；前后端接口调试；线上bugfix；性能分析和优化等等。本站提供fiddler下载。 一、什么是HTTPS HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 HTTPS主要作用是： （1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全; （2）对网站服务器进行真实身份认证。 我们经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用 http://，而是改用 https://。另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标记。对HTTPS的显示方式会因浏览器的不同而有所改变。 二、为什么需要HTTPS在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题，接下来，我们先来了解下 HTTP协议存在的哪些问题： 通信使用明文（不加密），内容可能被窃听 由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，HTTP报文使用明文（指未经过加密的报文）方式发送。 HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。 无法证明报文的完整性，所以可能遭篡改 所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发出的请求&#x2F;响应和接收到的请求&#x2F;响应是前后相同的。 不验证通信方的身份，因此有可能遭遇伪装 HTTP协议中的请求和响应不会对通信方进行确认。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下） HTTP协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉。 反观HTTPS协议，它比HTTP协议相比多了以下优势（下文会详细介绍）: 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥 数据完整性：内容传输经过完整性校验 身份认证：第三方无法伪造服务端（客户端）身份 三、HTTPS如何解决HTTP上述问题?HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。 通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。","raw":null,"content":null,"categories":[],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://www.mingsrc.work/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.mingsrc.work/tags/HTTP/"}]},{"title":"计算机网络协议","slug":"C_面试/计算机网络/五层协议及功能","date":"2022-12-27T03:12:54.004Z","updated":"2022-12-27T03:12:54.004Z","comments":true,"path":"posts/17750952.html","link":"","permalink":"https://www.mingsrc.work/posts/17750952","excerpt":"","text":"一些可以帮助学习各种协议的工具推荐： Cisco Packet Tracer中文版 是一款功能齐全的思科交换机模拟器，简称PT。为学习CCNA课程的网络初学者提供了网络模拟环境。Cisco Packet Tracer中文版是思科最新7.0模拟器，以前的5.5和5.3的版本只能做NA的实验，现在这个可以做NP的实验，里边的IOS也升级了，思科在save里面保存有很多学习用的拓扑，值得研究。 常见抓包工具： fiddler（fiddler中文版）是一个http协议Web调试代理工具。fiddler能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点查看所有的“进出”Fiddler的数据（指html,cookie,css，js等文件，这些都可以让你胡乱修改的意思）。Fiddler（fiddler中文版）要比其他的网络调试器要更加简单，因为它不仅仅可以帮助用户提供暴露http通讯，还提供了一个友好的用户格式。Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用.net语言进行扩展，适用于：开发环境的host配置；前后端接口调试；线上bugfix；性能分析和优化等等。本站提供fiddler下载。 Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包, 并尽可能显示出最为详细的网络封包资料。网络封包分析软件的功能可想像成 “电工技师使用电表来量测电流、电压、电阻” 的工作 - 只是将场景移植到网络上，并将电线替换成网络线。 在过去，网络封包分析软件是非常昂贵，或是专门属于营利用的软件。Ethereal的出现改变了这一切。在GNU GPL通用许可证的保障范围底下，使用者可以以免费的代价取得软件与其程式码，并拥有针对其原始码修改及客制化的权利。Ethereal是目前全世界最广泛的网络封包分析软件之一 五层网络协议、功能 OSI七层模型OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。 三种模型结构： 各层对应的协议： tr:hover {background-color: #000;color:white;filter:brightness(3);} OSI七层网络模型 TCP/IP四层概念模型 对应网络协议 应用层(Application) HTTP、TFTP、FTP、NFS、WAIS、SMTP 表示层(Presentation) 应用层 Telnet、Rlogin、SNMP、Gopher 会话层(Session) SMTP、DNS 运输层(Transport) 传输层 TCP、UDP 网络层（Network） 网络层 IP、ICMP、ARP、RAPP、AKP、UUCP 数据链路层（Data Link） 数据链路层 FDDI、Ethernet、Arpanet、PDN、SLIP、PPP 物理层（Physical） IEEE 802.1A、IEEE802.2到IEEE 802.11 第五层——应用层（application layer） 应用层是体系结构中的最高层。直接为用户的应用进程（例如电子邮件、文档传输和终端仿真）提供服务。 在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持电子邮件的SMPT协议、支持文件传送的FTP协议、DNS协议、POP3、SNMP、TeInet等等。 第四层——运输层（transport layer） 运输层负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能 复用，就是多个应用进程可同时使用下面运输层的服务 分用，就是把收到的信息分别交付给上面应用层中相应的进程。 运输层主要使用以下两种协议： 传输控制协议TCP(Tranmisson Contronl Protocol)：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 用户数据包协议UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。 第三层——网络层（networl layer）网络层主要包含以下两个任务： 负责为分组交换网上的不同主机提供通信服务。在发送数据是，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP&#x2F;IP体系中，由于网络层使用IP协议，因此分组也叫作IP数据报，或简称为数据报。 选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。 协议：IP、ICMP、IGMP、ARP、RAPP 第二层——数据链路层（Data link layer) 在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点之间的链路上“透明”的传送帧中的数据。 每一帧包含数据和必要的控制信息（如同步地址、地址信息、差错控制等）。典型的帧长是几百字节到一千多字节。 注：”透明”是一个很重要的术语。它表示，某一个实际存在的事物看起来却好像不存在一样。”在数据链路层透明传送数据”表示无力什么样的比特组合的数据都能够通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层。或者说，数据链路层对这些数据来说是透明的。 (1)在接收数据时，控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。 (2)控制信息还使接收端能检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如需改正错误，就由运输层的TCP协议来完成。 第一层——物理层（physical layer)在物理层上所传数据的单位是比特。物理层的任务就是透明的传送比特流。 数据在各层之间的传递过程 常见端口及对应服务 端口 服务 21 主要用于FTP（File Transfer Protocol,文件传输协议）服务 22 ssh传统的网络服务程序，如ftp、pop和teInet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据 23 Telnet服务 25 SMTP服务 80 HTTP服务器 110 POP3 1158 Oracle EmCTL 1521 Oracle数据库 3036 MySQL 3389 WIN2003远程登录 8080 JBOSS 8080 TOMCAT 9080 Webshpere应用程序 9090 webshpere 1、按端口号分布划分 （1）知名端口（Well-Known Ports） 知名端口即众所周知的端口号，范围从0到1023，这些端口号一般固定分配给一些服务。比如21端口分配给FTP服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务，135端口分配给RPC（远程过程调用）服务等等。 （2）动态端口（Dynamic Ports） 动态端口的范围从1024到65535，这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。比如1024端口就是分配给第一个向系统发出申请的程序。在关闭程序进程后，就会释放所占用的端口号。 不过，动态端口也常常被病毒木马程序所利用，如冰河默认连接端口是7626、WAY 2.4是8011、Netspy 3.0是7306、YAI病毒是1024等等。 2、按协议类型划分 按协议类型划分，可以分为TCP、UDP、IP和ICMP（Internet控制消息协议）等端口。下面主要介绍TCP和UDP端口： （1）TCP端口 TCP端口，即传输控制协议端口，需要在客户端和服务器之间建立连接，这样可以提供可靠的数据传输。常见的包括FTP服务的21端口，Telnet服务的23端口，SMTP服务的25端口，以及HTTP服务的80端口等等。 （2）UDP端口 UDP端口，即用户数据包协议端口，无需在客户端和服务器之间建立连接，安全性得不到保障。常见的有DNS服务的53端口，SNMP（简单网络管理协议）服务的161端口，QQ使用的8000和4000端口等等。","raw":null,"content":null,"categories":[],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://www.mingsrc.work/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"网络编程","slug":"网络编程","permalink":"https://www.mingsrc.work/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"C++面试宝典——操作系统1","slug":"C_面试/操作系统/操作系统(1)","date":"2022-12-27T03:12:54.003Z","updated":"2022-12-27T03:12:54.003Z","comments":true,"path":"posts/fe44a3e7.html","link":"","permalink":"https://www.mingsrc.work/posts/fe44a3e7","excerpt":"","text":"操作系统进程与线程基本概念：进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发； 线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。 死锁的原因 系统资源不足 进程运行推进的顺序不合适 资源分配不当 四个必要条件： 互斥条件：一个资源每次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 遇到死锁怎么处理找到进程号，关闭进程","raw":null,"content":null,"categories":[{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/"},{"name":"操作系统","slug":"面试/操作系统","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.mingsrc.work/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"B+树、B树、hash表","slug":"C_面试/数据库/B+树、B树、hash表","date":"2022-12-27T03:12:54.003Z","updated":"2022-12-27T03:12:54.003Z","comments":true,"path":"posts/bf9c7d2e.html","link":"","permalink":"https://www.mingsrc.work/posts/bf9c7d2e","excerpt":"","text":"一、B+树做索引而不用B-树那么Mysql如何衡量查询效率呢？– 磁盘IO次数。一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。B-树&#x2F;B+树 的特点就是每层节点数目非常多，层数很少，目的就是为了减少磁盘IO次数，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。 优点一： B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。 优点二： B+树所有的Data域在叶子节点，并且所有叶子节点之间都有一个链指针。 这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。 二、B+树做索引而不用红黑树AVL 树（平衡二叉树）和红黑树（二叉查找树）基本都是存储在内存中才会使用的数据结构。在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。 数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"C++面试宝典——编译与底层","slug":"C_面试/基础知识/编译底层","date":"2022-12-27T03:12:54.002Z","updated":"2022-12-27T03:12:54.002Z","comments":true,"path":"posts/9dd3ece6.html","link":"","permalink":"https://www.mingsrc.work/posts/9dd3ece6","excerpt":"","text":"编译与底层1 一个C++源文件从文本到可执行文件经历的过程？对于C++源文件，从文本到可执行文件一般需要四个过程： 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件🔻。 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件🔻。 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件🔻。 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件 2 include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。 双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。 对于使用双引号包含的头文件，查找头文件路径的顺序为： 当前头文件目录 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径） 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径 对于使用尖括号包含的头文件，查找头文件的路径顺序为： 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径） 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径 3 malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显式链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。 当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配； 当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。 Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。 其中当申请内存小于128K时，会使用系统函数brk在堆区中分配； 而当申请内存大于128K时，会使用系统函数mmap在映射区分配。 4 C++的内存管理是怎样的？在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。 代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。 数据段：存储程序中已初始化的全局变量和静态变量 bss 段(Block Started by Symbol)：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。 堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。 映射区：存储动态链接库以及调用mmap函数进行的文件映射 栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值 5 C++&#x2F;C的内存分配 32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0~3G是用户态空间，3~4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下： 各个段说明如下： 3G用户空间和1G内核空间 静态区域： text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。 data segment(数据段)：存储程序中已初始化的全局变量和静态变量 bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0 动态区域： heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。 堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。 memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数） stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。 6 如何判断内存泄漏？内存泄漏通常是由于调用了malloc&#x2F;new等内存申请的操作，但是缺少了对应的free&#x2F;delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。 7 什么时候会发生段错误段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况： 使用野指针 试图修改字符串常量的内容 8 什么是memory leak，也就是内存泄漏内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。 内存泄漏的分类： 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 9 new和malloc的区别 new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配； new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。 new不仅分配一段内存，而且会调用构造函数，malloc不会。 new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。 new是一个操作符可以重载，malloc是一个库函数。 malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。 new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。 申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。 10 如何采用单线程的方式处理高并发在单线程模型中，可以采用I&#x2F;O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来","raw":null,"content":null,"categories":[{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"面试/C","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"面向对象和泛型编程","slug":"C_面试/基础知识/面向对象和泛型编程","date":"2022-12-27T03:12:54.002Z","updated":"2022-12-27T03:12:54.003Z","comments":true,"path":"posts/2d1049a4.html","link":"","permalink":"https://www.mingsrc.work/posts/2d1049a4","excerpt":"","text":"左值与右值https://zhuanlan.zhihu.com/p/85668787 左值：占用了一定内存，且拥有可辨认的地址的对象 右值：左值以外的所有对象 右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 引用（注意左值引用）1234567int i;int &amp;r = i;int &amp;r = 5; // 错误，不能左值引用绑定右值// const 引用是例外// 可以认为指向一个临时左值的引用，其值为5const int &amp;r = 5; 右值引用用途： 移动语义 完美转发 移动语义移动语意(std::move)，可以将左值转化为右值引用 12345678910111213141516171819202122232425int a = 1; // 左值int &amp;b = a; // 左值引用// 移动语意: 转换左值为右值引用int &amp;&amp;c = std::move(a); void printInt(int&amp; i) &#123; cout &lt;&lt; &quot;lval ref: &quot; &lt;&lt; i &lt;&lt; endl; &#125;void printInt(int&amp;&amp; i) &#123; cout &lt;&lt; &quot;rval ref: &quot; &lt;&lt; i &lt;&lt; endl; &#125; int main() &#123; int i = 1; // 调用 printInt(int&amp;), i是左值 printInt(i); // 调用 printInt(int&amp;&amp;), 6是右值 printInt(6); // 调用 printInt(int&amp;&amp;)，移动语意 printInt(std::move(i)); &#125; 完美转发完美转发是指 只有在需要的时候，才调用复制构造函数 左值被转发为左值，右值被转发为右值 右值引用和左值引用的区别 左值可以寻址，而右值不可以。 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。","raw":null,"content":null,"categories":[{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"面试/C","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"static","slug":"static","permalink":"https://www.mingsrc.work/tags/static/"}]},{"title":"C++面试基本知识点（1）","slug":"C_面试/基础知识/基本知识点(1)","date":"2022-12-27T03:12:54.002Z","updated":"2022-12-27T09:41:45.579Z","comments":true,"path":"posts/64d12821.html","link":"","permalink":"https://www.mingsrc.work/posts/64d12821","excerpt":"","text":"基本语言(一) 1 说一下static关键字的作用 静态变量：编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。另外，如果没有显式地初始化静态变量，编译器将把它设置为0.这种变量被称为零初始化的（zero-initialized）。 （1）全局静态变量在全局变量前加上关键字static，全局变量就定义成一个全局静态变量. 静态存储区，在整个程序运行期间一直存在。 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）； 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。 （2）局部静态变量在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。 内存中的位置：静态存储区 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）； 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变； 5种变量存储方式 这里指的是声明为static的变量对外的访问性，默认的全局变量是extern的。 存储描述 持续性 作用域 链接性 如何声明 自动 自动 代码块 无 在代码块中 寄存器 自动 代码块 无 在代码块中，使用关键字register 静态，无链接性 静态 代码块 无 在代码块中，使用关键字static 静态，外部链接性 静态 文件 外部 不再任何函数内 静态，内部链接性 静态 文件 内部 不再任何函数内，使用关键字static 补充关键字：静态持续性、外部链接性 （3）静态函数在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。 函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突； warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰； （4）类的静态成员详细请阅读C++ Primer Plus第六版 P428相关文章 在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。 一个不恰当的比喻就是：静态成员就好比公用电话，所有对象共同使用；非静态成员就好比手机，每个对象使用自己的 注意：不能再类声明中初始化静态成员变量。这是因为声明描述了如何分配内存，但并不分配内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static。 &lt;类型&gt; &lt;类名&gt;::&lt;变量名&gt; = &lt;值&gt; 如果静态类成员是私有，则不能通过类名+变量名访问，会报如下错误！ 是否可以继承子类可以访问弗雷德static变量，但受访问控制（若父类中的static是private就无法访问） 子类和父类的static变量是同一变量，共享同一存储空间。 而继承关系，子类和父类是分别有自己的存储空间。 （5）类的静态函数静态成员函数和静态数据成员一样，他们都属于类的静态成员，他们都不是对象成员。因此，对静态成员的引用不需要用对象名。 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。 调用格式：&lt;类名&gt;::&lt;静态成员函数&gt;(&lt;参数表&gt;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* myString.h (4)(5)说明*/#pragma once#include &lt;iostream&gt;using namespace std;class myString &#123;private: char * str; int len; // static int numStrings;public: static int numStrings; // 如果是私有的，则无法通过&lt;类名&gt;::&lt;变量名&gt;访问 myString(const char * s); myString(); ~myString(); static void getdata(myString s); //friend function friend ostream &amp; operator&lt;&lt;(ostream &amp; os, const myString &amp; st);&#125;;/* myString.cpp (4)(5)说明*/#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &quot;myString.h&quot;#include &lt;stdlib.h&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;using namespace std;int myString::numStrings = 0;myString::myString(const char * s)&#123; len = strlen(s); str = new char[len + 1]; strcpy(str,s); numStrings++; cout &lt;&lt; numStrings &lt;&lt; &quot;: \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot; object created\\n&quot;;&#125;myString::myString()&#123; len = 4; str = new char[4]; strcpy(str, &quot;C++&quot;); numStrings++; cout &lt;&lt; numStrings &lt;&lt; &quot;:\\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;object created\\n&quot;;&#125;myString::~myString()&#123; cout &lt;&lt; &quot;\\&quot;&quot;&lt;&lt;str&lt;&lt;&quot;\\&quot; object deleted,&quot;; --numStrings; cout &lt;&lt; numStrings &lt;&lt; &quot;left \\n&quot;; delete[] str;&#125;ostream &amp; operator&lt;&lt;(ostream &amp; os, const myString &amp; st)&#123; os &lt;&lt; st.str; return os;&#125;void myString::getdata(myString s)&#123; cout &lt;&lt; &quot;numStrings：&quot; &lt;&lt; numStrings &lt;&lt; endl; //numStrings是静态成员，可以在静态成员中访问 cout &lt;&lt; &quot;当前传入字符为：&quot; &lt;&lt; s.str &lt;&lt; endl;//在静态成员函数中，只能通过对象访问类的非静态成员 cout &lt;&lt; &quot;当前传入字符长度为：&quot; &lt;&lt; s.len &lt;&lt; endl; &#125;/* main.h (4)(5)说明*/#include &lt;iostream&gt;#include &quot;myString.h&quot;using namespace std;int main()&#123; cout &lt;&lt; &quot;测试开始&quot; &lt;&lt; endl; myString headline1(&quot;足球&quot;); myString headline2(&quot;羽毛球&quot;); //静态类成员函数调用直接通过类名 cout &lt;&lt; &quot;执行静态类成员函数：\\n&quot; &lt;&lt; &quot;--------------\\n&quot;; myString::getdata(headline2); //headline1.getdata(headline1); 通过对象名也可以 cout &lt;&lt; &quot;--------------\\n&quot;; cout &lt;&lt; &quot;测试结束&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2 C++和C的区别设计思想上： C++是面向对象的语言，而C是面向过程的结构化编程语言 语法上： C++具有封装、继承和多态三种特性 C++相比C，增加多许多类型安全的功能，比如强制类型转换 C++支持范式编程，比如模板类、函数模板等 3 C++中的static关键字的作用 对于函数定义和代码块之外的变量声明，static修改标识符的链接属性，由默认的external变为internal，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。 对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。 对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用 对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。 4 C++中显式类型转换和隐式类型转换显式类型转换参考回答： 1.const_cast用于将const变量转为非const1234567891011121314int main()&#123; int age = 40; const int agep = age; cout &lt;&lt; &quot;const of age:&quot; &lt;&lt; agep &lt;&lt; endl; int &amp;nConstAge = const_cast&lt;int&amp;&gt;(agep); // 修改nConstAge的值看看是否能成功修改age的值 nConstAge = 18; cout &lt;&lt; &quot;new const of age：&quot; &lt;&lt; agep &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.static_cast用于将const变量转为非const 3.dynamic_cast用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化是，如果是非法的对于指针返回NULL,对于引用跑一场。要深入了解内部转换的原理。 向上转换：指的是子类向基类的转换 向下转换：指的是基类想子类的转换 她通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够向下转换。 4.reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用； 隐式类型转换算术转换如果是不同类型的变量，计算+-*/的时候，会出现类型转换，最后会转换成只有一种类型的式子进行运算。 在进行运算时，以表达式中最长类型为主，将其他类型位据均转换成该类型，如： (1)若运算数中有double型或float型，则其他类型数据均转换成double类型进行运算。 (2)若运算数中最长的类型为long型．则其他类型数均转换成long型数。 (3)若运算数中最长类型为int型，则char型也转换成int型进行运算。算术转换是在运算过程中自动完成的。 大致就是如下所示，算式中的变量会转换为长度更长的更高的类型。此种情况的的还有bool类型的变量，除0之外，其他变量都会被bool类型转换为true。 1234567891011121314#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;int main()&#123; int a = 2; double b = 3.1415; char c = &#x27;a&#x27;; cout &lt;&lt; typeid(a*b-c).name() &lt;&lt; endl; bool flag = 0.01; cout &lt;&lt; flag &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 赋值转换进行赋值操作时，赋值运算符右边的数据类型必须转换成赋值号左边的类型，若右边的数据类型的长度大于左边，则要进行截断或舍入操作。 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;int main()&#123; int a = 2; double b = 3.1415; char c = &#x27;a&#x27;; /* 1. a--&gt;double 2. c--&gt;int 原式就变成了 double-int 3. int--&gt;double 原始式子就是变成了 int = double 最后等号部分，double--&gt;int */ int result = a*b-a*c; system(&quot;pause&quot;); return 0;&#125; 输出转换输出转换就是在程序中用printf()函数以指定格式输出，当要输出的数据类型与输出格式不符合时，会转化为以输出格式的输出形式。 12char a = &#x27;a&#x27;;printf(&quot;输出a的ASCII值：%d&quot;, a); //输出“输出a的ASCII值：97” 5. 为何说呢么不使用c的强制转换？C的强制转换表面上看起来功能很强发什么都能转，但是转化不够明确，不能进行错误检查，容易出错。 5 请说一下C/C++中指针和引用的区别 指针有自己的一块空间，而引用只是一个别名； 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小； 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用； 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象； 可以有const指针，但是没有const引用； 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变； 指针可以有多级指针（**p），而引用止于一级； 指针和引用使用++运算符的意义不一样； 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。 6 C++中的smart pointer 四个只能指针：shared_ptr,unique_ptr,weak_ptr,auto_ptr 参考回答： C++里面的三个智能指针：auto_ptr,shared_ptr,weak_ptr,unique_ptr其中后三个是C++11支持，并且第一个已经被11弃用。 为什么要使用智能指针： 智能指针的作用是管理一个指针，因为存在一下这种情况：申请的空间在函数结束时忘记释放，造成内存泄露。使用智能指针可以很大程度上的避免这个问题，与因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是函数结束时自动释放内存空间，不需要手动释放内存空间。 1、auto_ptrC++98的方案，C++11已经抛弃采用所有权模式。 123auoto_ptr&lt;string&gt; p1 (new string (&quot;I reigned lonely as a cloud.&quot;));auto_ptr&lt;string&gt; p2;p2 = p1; //auto_ptr不会报错 此时不会报错，p2剥夺了p1的所有权，但是当程序运行时，访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！ 2、unique_ptr替换auto_ptrunique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个只能指针可以指向该对象。它对于避免资源泄露（例如：以new创建对象后因为发生异常而忘记调用delete，特别有用。 采用所有权模式，还是上面那个例子 123unique_ptr&lt;string&gt; p3 (new string (&quot;auto&quot;));unique_ptr&lt;string&gt; p4;p4 = p3; // 此时会报错~ 编译器认为p4=p3非法，避免了p3不再设置项有效数据的问题。因此，unique_ptr比auto_ptr更安全。 另外unique_ptr还有更聪明的地方：当程序视图将一个unique_ptr赋值给另一个时，如果源unique_ptr是个临时右值，编译器允许这么做；如果源unique_ptr将存在一段时间，编译器将禁止这么做，比如： 12345unique_ptr&lt;string&gt; pu1(new string (&quot;hello world&quot;));unique_ptr&lt;string&gt; pu2;pu2 = pu1; //#1 not allowedunique_ptr&lt;string&gt; pu3;pu3 = unique_ptr&lt;string&gt;(new string (&quot;You&quot;)); //#2 allowed 其中#1留下的悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用unique_ptr的构造函数，该构造函数创建的临时对象再起所有权让给pu3后就会被销毁。这种情况而已的行为表明，unique_ptr由于允许两种赋值的auto_ptr。 注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如： 12345unique_ptr&lt;string&gt; ps1, ps2;ps1 = demo(&quot;hello&quot;);ps2 = move(ps1);ps1 = demo(&quot;alexia&quot;);cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl; 3、shared_ptrshared_ptr实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，他使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造。还可以通过传入auto_ptr、unique_ptr、weak_ptr来构造。当我们使用release()时，当前指针会释放资源苏有权，计数减一。当计数等于0时，资源会被释放。 shared_ptr是为了解决auto_ptr在对象所有权上的局限性（auto_ptr是独占的），在使用引用计数的机制上提供了可以共享所有权的智能指针。 成员函数 说明 use_count 返回引用计数的个数 unique 返回是否是独占所有权 swap 交换两个shared_ptr对象（即交换所拥有的对象） reset 放弃内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少 get 返回内部对象（指针），由于已经重载了（）方法，因此和直接使用对象是一样的。如shared_ptr&lt;int&gt; sp(new int (1)); sp与sp.get()是等价的 4、weak_ptrweak_ptr是一种不控制对象生命周期的只能指针，它指向一个shared_ptr管理的对象。进行该对象的内训管理的是那个强引用的shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr设计的目的是为配合shared_ptr而引入的一种智能指针来协助shared_ptr工作，它只可以从一个shared_ptr或另一个weak_ptr对象构造,它的构造和析构不会引起引用技术的增加或见啥，weak_ptr是用来解决shatred_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数不可能下降为0，资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和share_ptr之间可以相互转化，shared_ptr可以直赋值给它，它可以通过lock()函数来获得shared_ptr。 这篇文章还在编辑中······","raw":null,"content":null,"categories":[{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"面试/C","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"}]},{"title":"C++面试经典题目","slug":"C_面试/基础知识/C++面试经典题目","date":"2022-12-27T03:12:54.001Z","updated":"2022-12-27T03:12:54.001Z","comments":true,"path":"posts/19326953.html","link":"","permalink":"https://www.mingsrc.work/posts/19326953","excerpt":"","text":"直接上一些问题，做一下就知道自己可不可以了！ 1 如何判断一段程序是C还是C++编译程序编译参考答案12345#ifdef __cplusplus //双下划线 cout &lt;&lt; &quot;C++&quot;;#else cout &lt;&lt; &quot;C&quot;;#endif 2 C++值传递方式有哪几种？参考答案 指针传递 引用专递 值传递 在C语言中都可以认为是值传递。在C++中多了引用传递（1.在函数内部可以修改值；2.节省内存）。 为了提高效率，可以在函数传参时选择使用const refrence的方式节省对象拷贝创造副本造成的内存浪费 3 静态全局变量的作用域参考答案本文件中全局使用 4 虚函数问A中fun1()是否为虚函数、B中fun2()是否为虚函数？ 123456789101112class A &#123; virtual void fun1(); void fun2();&#125;;class b : class A &#123; void fun1()&#123; cout &lt;&lt; &quot;fun1()&quot;; &#125; virtual void fun2()&#123; cout &lt;&lt; &quot;fun2()&quot;; &#125;&#125;; 参考答案A中fun1()和B中fun2()均为虚函数；其中如果父类函数为virtual，子类重写时，可省略virtual关键字。无论子类函数是否是virtual，子类与父类同名函数指的是不同函数。 父类有virtual时，其子类必定是虚函数 父类无virtual时，就要看其子类函数是否有virtual关键字，有就是虚函数。可以用高中生物遗传想这个问题。 5 C和C++中struct有什么区别？参考答案 protection行为 能否定义函数 C 无 否，但可以有函数指针 C++ 有，默认是public 可以，包括构造函数，析构函数等 6 int id[sizeof(unsigned long)];这种写法是否正确?为什么？参考答案正确。sizeof()是编译时运算符，编译时就确定了，可以认为其实和机器有关的常量。所以sizeof(long)=4;，这句话相当于定义了一个大小为4的数组id； 123cout &lt;&lt; &quot;sizeof(long):&quot; &lt;&lt; sizeof(long) &lt;&lt; endl;int id[sizeof(long)];cout &lt;&lt; &quot;sizeof(id)&quot; &lt;&lt; sizeof(id) &lt;&lt; endl; 7 变量的指针的含义是指变量的参考答案点击查看 B.地址?A. 值&nbsp;&nbsp;&nbsp;&nbsp;B.地址&nbsp;&nbsp;&nbsp;&nbsp; C.存储 &nbsp;&nbsp;&nbsp;&nbsp;D.名字 8 重载（overload）、重定义（redefintion）、重写（override）的区别？参考答案 名称 名字空间 区别 重载 同一名字空间 是指允许存在多个同名函数，而这些函数的参数表不同。 重定义/隐藏 不同名字空间 用于继承，派生类与基类的函数同名，屏蔽基类的函数 重写/覆盖 不同名字空间 用于继承，子类重新定义父类虚函数的方法 9 多态的作用参考答案 隐藏实现细节，是的代码能够模块化；扩展代码模块，实现代码复用 接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。 10 多态中虚函数表什么时候建立参考答案虚函数表是在编译期就建立了。各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组，而对象的隐藏成员——虚拟函数表指针是在运行期——也就是构造函数被调用时进行初始化的，这是实现多态的关键。 11 面向对象的三个基本特征，并简单叙述参考答案 封装：将客观事物抽象成类，每个类对自身的数据和方法事项protection（private，protected，public） 继承：广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后带子类实现）。前两种（累继承）和后一种（对象组合=&gt;接口继承以及纯虚函数）构成了功能复用的两种方式。 多态：是将父对象设置成为和一个或更多的与他的子对象相等的技术。赋值之后，父对象的就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单讲就是：允许将子类类型的指针赋值给父类类型的指针。 12 内联函数是否做类型检查参考答案内联函数要做参数类型检查，这是内联函数跟宏相比的优势。 13 内存分配的方式有几种参考答案 静态存储区域。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。 在栈上创建。在执行函数是，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责何时使用free和delete释放内存。动态内存的生存期由我们决定，使用比较灵活，但问题也最多。很容易造成内存泄露、越界等问题 14 频繁使用的短小函数，在C语言中应用什么实现，在c++中应用什么实现？参考答案C用宏定义，C++用inline 15 全局变量和局部变量的区别全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？ 参考答案生命周期不同：全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；内存中分配在全局数据区。 使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。操作系统和编译器通过内存分配的位置来知道的，全局变量变量分配在全局数据段并且在程序开始运行的时候被夹在。局部变量则分配在堆栈里边。 16 如何判断一个操作系统是16为还是32位？参考答案定义一个指针p。打印出sizeof(p)，如果节后是4，则表示该操作系统是32位；打印结果是2，则表示是16位。 17 上题在不能使用sizeof()情况下如何判断？参考答案超过32位时，这种方法不管用，最好的办法还是使用sizeof()。 12345unsigned int a = ~0; // 最好是 unsigned intif(a&gt;65536) cout &lt;&lt; &quot;32 bit&quot; &lt;&lt; endl;else cout &lt;&lt; &quot;16 bit&quot; &lt;&lt; endl; 18 如何处理内存耗尽如果再申请动态内存时找不到足够大的内存块，malloc和new⬇️ 将返回NULL指针，宣告内存申请失败。如何处理内存耗尽？ new如果分配失败了会抛出bad_malloc的异常malloc则会返回NULL 参考答案如果返回的NULL，则马上使用人return语句终止本函数。 19 为什么要使用堆空间，使用堆空间的原因？参考答案直到运行时才知道一个对象需要多少内存；不知道对象的生存期到底有多长。 20 析构函数和虚函数的用法和作用参考答案析构函数是特殊的类成员函数，它没有返回类型，没有参数，不能随意调用，也没有重载，只有在类对象的生命期结束的时候，由系统自动调用。有适放内存空间的作用。虚函数是C++多态的一种表现，使用虚函数，我们可以灵活的进行动态绑定，当然是以一定的开销为代价。 21 错误的转移字符是参考答案点击查看 A.091？参考答案A. ‘\\091'&nbsp;&nbsp;&nbsp;&nbsp;B.'\\\\'&nbsp;&nbsp;&nbsp;&nbsp; C.'\\0' &nbsp;&nbsp;&nbsp;&nbsp;D.'\\'' 22 引用和指针有什么区别参考答案 引用不会开辟新的内存，是对引用变量地址的调用 引用必须被初始化，指针不必 引用初始化以后不能被改变，指针可以改变所指的对象 不存在指向空值的引用，但是存在指向空值的指针 23 直接在程序中填写数字或字符串，将会有什么麻烦？参考答案 程序的可读性（可理解性）变差。程序员自己会忘记那些数字或字符串是什么意思，用户则更加不知它们从何处来、表示什么。 在程序的很多地方输入同样的数字或字符串，难保不发生书写错误。 如果要修改数字或字符串，则会在很多地方改动，既麻烦又容易出错。 24 重复多次fclose一个打开过一次的FLIE *fp指针会有什么结果，并解释参考答案导致文件描述符结构中指针指向的内存被重复释放，进而导致一些不可预期的异常。 25 C++是不是类型安全参考答案不是，两个不同类型的指针之间可以强制转换（用reinterpret cast） 26 C++中是不是所有的动作都是main()引起的？参考答案不是。比如全局变量的初始化，就不是由main()函数引起的。举例： 123class A&#123;&#125;； A a;// a的构造函数先执行int main()&#123;&#125; 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 参考答案 当前文章还在编辑当中······ 参考答案","raw":null,"content":null,"categories":[{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/"},{"name":"C++","slug":"面试/C","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"C++面试知识点（牛客）","slug":"C_面试/基础知识/C++面试必备","date":"2022-12-27T03:12:54.001Z","updated":"2022-12-27T03:12:54.001Z","comments":true,"path":"posts/2c47887.html","link":"","permalink":"https://www.mingsrc.work/posts/2c47887","excerpt":"C++面试宝典📖\n转载自：牛客网C++面试技巧\n\n博客仅用于记录面试经验与技巧~~给自己加油","text":"C++面试宝典📖 转载自：牛客网C++面试技巧 博客仅用于记录面试经验与技巧~~给自己加油 需要注意的是：此图不绝对，因为实际面试中面试官会根据你的简历去问，比如你的项目多可能就问的项目多一些，或者你说哪里精通可能面试官就多去问你这些。而且此图是根据题库数据整理出来，并不是根据实际单场面试整理，比如基础部分不会考那么多，会从中抽着考 但是面试中必考的点且占比非常大的有c基础和算法。 决定你是否能拿sp offer（高薪offer）以及是否进名企的是项目和算法。 面试技巧面试一般分为&#x3D;&#x3D;技术面&#x3D;&#x3D;和&#x3D;&#x3D;hr面&#x3D;&#x3D;，形式的话很少有群面，少部分企业可能会有一个交叉面，不过总的来说，技术面基本就是考察你的专业技术水平的，hr面的话主要是看这个人的综合素质以及家庭情况符不符合公司要求，一般来讲，技术的话只要通过了技术面hr面基本上是没有问题（也有少数企业hr面会刷很多人） 那我们主要来说技术面，技术面的话主要是考察专业技术知识和水平，我们是可以有一定的技巧的，但是一定是基于有一定的能力水平的。 所以也慎重的告诉大家，技巧不是投机取巧，是起到辅助效果的，技术面最主要的还是要有实力，这里是基于实力水平之上的技巧。 整个过程都去主动引导聊天内容的方向 简历上做一个引导 ​ 在词汇上做好区分，比如熟悉java，了解python，精通c语言等 在面试的过程中做一个引导 在自我介绍中做一个引导 面试过程中展示出自信 面试前的准备：最重要的肯定是系统的学习了，有一个知识的框架，基础知识的牢靠程度等。 其中算法尤其重要，越来越多公司还会让你现场或者视频面试中手写代码； 另一大重要的和加分项就是项目，在面试前，一定要练习回答自己项目的三个问题： 这是一个怎样的项目 用到了什么技术，为什么用这项技术（以及每项技术很细的点以及扩展） 过程中遇到了什么问题，怎么解决的。 面试后需要做的：面试完了的话就不用太在意结果了，有限的时间就应该做事半功倍的事情，当然，要保持电话邮箱畅通，不然别给你发offer你都不知道。 抛开这些，我们需要做的是及时将面试中的问题记录下来，尤其是自己回答的不够好的问题，一定要花时间去研究，并解决这些问题，下次面试再遇到相同的问题就能很好的解决，当然，即使不遇到，你这个习惯坚持住，后面也可以作为一个经历去跟面试官说，能表现出你对技术的喜爱和钻研的一个态度，同时，每次面试后你会发现自己的不足，查缺补漏的好机会，及时调整，在不断的调整和查缺补漏的过程中，你会越来越好。 C++知识图谱","raw":null,"content":null,"categories":[{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"面试","slug":"面试","permalink":"https://www.mingsrc.work/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"算法——查找算法","slug":"A_程序员内功/C_算法与数据结构/算法/算法复杂度","date":"2022-12-27T03:12:54.000Z","updated":"2022-12-27T03:12:54.000Z","comments":true,"path":"posts/f43b98cb.html","link":"","permalink":"https://www.mingsrc.work/posts/f43b98cb","excerpt":"哈希、红黑树、B+树、二叉树、平衡算法","text":"哈希、红黑树、B+树、二叉树、平衡算法 搜索算法 二分查找二分查找一定是有序的：target ? (left+right)/2 如果说二分查找转换成数据结构展示——&gt;==二叉树—-&gt;二叉查找树、二叉搜索树== 二叉搜索树1. 时间复杂度：二分：log(n) AVL树：平衡二叉树红黑树（特殊的二叉查找树）这篇文章还在编辑中······ 本文结束！","raw":null,"content":null,"categories":[{"name":"程序员内功","slug":"程序员内功","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/"},{"name":"算法与数据结构","slug":"程序员内功/算法与数据结构","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"查找算法","slug":"查找算法","permalink":"https://www.mingsrc.work/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"}]},{"title":"Manacher算法","slug":"A_程序员内功/C_算法与数据结构/算法/Manacher算法","date":"2022-12-27T03:12:53.999Z","updated":"2022-12-27T03:12:53.999Z","comments":true,"path":"posts/9c101d38.html","link":"","permalink":"https://www.mingsrc.work/posts/9c101d38","excerpt":"Manacher算法\n求最长子回文串\n\n转载声明：@刘毅 (Ethson Liu)\n","text":"Manacher算法 求最长子回文串 转载声明：@刘毅 (Ethson Liu) 算法过程分析由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是： 在字符串首尾及每个字符间都插入一个 “#”，这样可以使得原先的奇偶回文都变为奇回文； 接着再在首尾两端各插入 “$” 和 “^”，这样中心扩展寻找回文的时候会自动退出循环，不需每次判断是否越界，可参见下面代码。 上述新插入的三个字符，即 “#”、 “$” 和 “^”，必须各异，且不可以与原字符串中的字符相同。 举个例子：s=&quot;abbahopxpo&quot;，转换为 s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#^&quot;。如此，s 里起初有一个偶回文 abba 和一个奇回文 opxpo，被转换为 #a#b#b#a# 和 #o#p#x#p#o#，长度都转换成了奇数。 定义一个辅助数组 int p[]，其中 p[i] 表示以 i 为中心的最长回文的半径，例如： i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 s_new[i] $ # a # b # b # a # h # o # p # x # p # o # ^ p[i] 1 1 2 1 2 5 2 1 2 1 2 1 2 1 2 1 6 1 2 1 2 1 1 可以看出，p[i] - 1 正好是原字符串中最长回文串的长度。 接下来的重点就是求解 p 数组，如下图：设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是 mx = id + p[id]。 假设我们现在求 p[i]，也就是以 i 为中心的最长回文半径，如果 i &lt; mx，如上图，那么： 12if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); 2 * id - i 为 i 关于 id 的对称点，即上图的 j 点，而 p[j]表示以 j 为中心的最长回文半径，因此我们可以利用 p[j] 来加快查找。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;algorithm&gt; #include &lt;stdio.h&gt;using namespace std;char s[1000];char s_new[2000];int p[2000];int Init()&#123; int len = strlen(s); s_new[0] = &#x27;$&#x27;; s_new[1] = &#x27;#&#x27;; int j = 2; for (int i = 0; i &lt; len; i++) &#123; s_new[j++] = s[i]; s_new[j++] = &#x27;#&#x27;; &#125; s_new[j] = &#x27;\\0&#x27;; // 这是一个好习惯 return j; // 返回 s_new 的长度&#125;int Manacher()&#123; int len = Init(); // 取得新字符串长度并完成向 s_new 的转换 int max_len = -1; // 最长回文长度 int id; int mx = 0; for (int i = 1; i &lt; len; i++) &#123; if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); // 需搞清楚上面那张图含义，mx 和 2*id-i 的含义 else p[i] = 1; while (s_new[i - p[i]] == s_new[i + p[i]]) // 不需边界判断，因为左有 $，右有 ^ p[i]++; // 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远， // 这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率 if (mx &lt; i + p[i]) &#123; id = i; mx = i + p[i]; &#125; max_len = max(max_len, p[i] - 1); &#125; return max_len;&#125;int main()&#123; printf(&quot;请输入字符串：&quot;); cin.getline(s,10); printf(&quot;最长回文长度为 %d\\n\\n&quot;, Manacher()); cout &lt;&lt; Manacher(); return 0;&#125;","raw":null,"content":null,"categories":[{"name":"程序员内功","slug":"程序员内功","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/"},{"name":"算法与数据结构","slug":"程序员内功/算法与数据结构","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"最长回文子串","slug":"最长回文子串","permalink":"https://www.mingsrc.work/tags/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"name":"Manacher算法","slug":"Manacher算法","permalink":"https://www.mingsrc.work/tags/Manacher%E7%AE%97%E6%B3%95/"},{"name":"马拉车算法","slug":"马拉车算法","permalink":"https://www.mingsrc.work/tags/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"}]},{"title":"排序算法小记","slug":"A_程序员内功/C_算法与数据结构/算法/排序算法","date":"2022-12-27T03:12:53.999Z","updated":"2022-12-27T03:12:53.999Z","comments":true,"path":"posts/b170dee.html","link":"","permalink":"https://www.mingsrc.work/posts/b170dee","excerpt":"","text":"冒泡排序： 两两比较确定最大数，依次确定第二大，第三大数 稳定 时间复杂度O(n^2^) 12345678910111213void sort(int[] nums) &#123; if(nums == null || nusm.size() &lt; 2) return; for ( int i = 0; i &lt; nums.size()-1; ++i) &#123; for(int j = 0; j &lt; nums.size()-i-1;++j) &#123; if(nums[j] &gt; nums[j + 1]) &#123; int temp = nums[j+1]; nums[j+1] = nums[j]; nums[j] = temp; &#125; &#125; &#125;&#125; 插入排序： 从后向前扫描，如果发现前边的比当前的大，则将前边元素后移，直到找到已排序元素中小于当前位置元素的数 稳定 时间复杂度O(n^2^) 12345678910111213void sort(int[] nums) &#123; if(nums == null || nums.length &lt; 2) return ; for (iny i = 0; i &lt; nums.length - 1; i++) &#123; iny curr = nums[i+1]; int preIndex = i; while ( preIndex &gt;= 0 &amp;&amp; curr &lt; nums[preIdnex]) &#123; nums[preIndex + 1] = nums[preIndex]; preIndex--; &#125; nums[preIndex + 1] = curr; &#125;&#125; 选择排序： 从最小元素开始，依次找第二小，第三小元素（与冒泡排序对称相反） 不稳定 时间复杂度O(n^2^) 123456789101112131415void sort(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] &lt; nums[minIndex]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123; int temp = nums[i]; nums[minIndex] = temp; nums[i] = nums[minIndex]; &#125; &#125;&#125; 快速排序：分治思想 思路： 从数组中选一个数做为基准值，一般选第一个数，或者最后一个数。 采用双指针(头尾两端)遍历，从左往右找到比基准值大的第一个数，从右往左找到比基准值小的第一个数，交换两数位置，直到头尾指针相等或头指针大于尾指针，把基准值与头指针的数交换。这样一轮之后，左边的数就比基准值小，右边的数就比基准值大。 对左边的数列，重复上面1，2步骤。对右边重复1，2步骤。 左右两边数列递归结束后，排序完成。 123456789101112131415161718192021222324252627282930313233void sort(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return; &#125; quickSort(nums, 0, nums.length - 1); &#125;void quickSort(int[] nums, int star, int end) &#123; if (star &gt; end) &#123; return; &#125; int i = star; int j = end; int key = nums[star]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[j] &gt; key) &#123; j--; &#125; while (i &lt; j &amp;&amp; nums[i] &lt;= key) &#123; i++; &#125; if (i &lt; j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; &#125; nums[star] = nums[i]; nums[i] = key; quickSort(nums, star, i - 1); quickSort(nums, i + 1, end); &#125;&#125;//10万个数的数组，耗时：50毫秒 快排，面试最喜欢问的排序算法。这是运用分治法的一种排序算法。 从数组中选一个数做为基准值，一般选第一个数，或者最后一个数。 采用双指针(头尾两端)遍历，从左往右找到比基准值大的第一个数，从右往左找到比基准值小的第一个数，交换两数位置，直到头尾指针相等或头指针大于尾指针，把基准值与头指针的数交换。这样一轮之后，左边的数就比基准值小，右边的数就比基准值大。 对左边的数列，重复上面1，2步骤。对右边重复1，2步骤。 左右两边数列递归结束后，排序完成。 不稳定 O(nlogn) 123456789101112131415161718192021222324252627 void quickSort(int[] nums, int star, int end) &#123; if (star &gt; end) &#123; return; &#125; int i = star; int j = end; int key = nums[star]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[j] &gt; key) &#123; j--; &#125; while (i &lt; j &amp;&amp; nums[i] &lt;= key) &#123; i++; &#125; if (i &lt; j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; &#125; nums[star] = nums[i]; nums[i] = key; quickSort(nums, star, i - 1); quickSort(nums, i + 1, end); &#125;&#125;//10万个数的数组，耗时：50毫秒","raw":null,"content":null,"categories":[],"tags":[]},{"title":"查找算法小记","slug":"A_程序员内功/C_算法与数据结构/算法/查找算法","date":"2022-12-27T03:12:53.999Z","updated":"2022-12-27T03:12:53.999Z","comments":true,"path":"posts/8b24ddfa.html","link":"","permalink":"https://www.mingsrc.work/posts/8b24ddfa","excerpt":"","text":"顺序查找说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。 复杂度分析： 查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL &#x3D; 1&#x2F;n(1+2+3+…+n) &#x3D; (n+1)&#x2F;2 ;当查找不成功时，需要n次比较，时间复杂度为O(n);所以，顺序查找的时间复杂度为O(n)。 C++实现源码： 123456789//顺序查找int SequenceSearch(int a[], int value, int n)&#123; int i; for(i=0; i&lt;n; i++) if(a[i] == value) return i; return -1;&#125; 二分查找说明：元素必须是有序的，如果是无序的则要先进行排序操作。 基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。 复杂度分析：最坏情况下，关键词比较次数为 （ 取下整），且期望时间复杂度为 ； 折半查找是一棵二叉排序树，每个根结点的值都大于左子树的所有结点的值，小于右子树所有结点的值。 例如：长度为10的有序表的平均查找长度为：ASL&#x3D;(11+22+34+43)&#x2F;10&#x3D;29&#x2F;10&#x3D;2.9; 12345678910111213141516171819202122232425262728293031323334353637void BinarySearch2() &#123; //二分查找（折半查找），循环实现int BinarySearch1(int a[], int value, int n)&#123; int low, high, mid; low = 0; high = n-1; while(low&lt;=high) &#123; mid = (low+high)/2; if(a[mid]==value) return mid; else if(a[mid]&gt;value) high = mid-1; else if(a[mid]&lt;value) low = mid+1; &#125; return -1;&#125;//二分查找，递归实现int BinarySearch2(int a[], int value, int low, int high)&#123; if(low &lt;= high) &#123; int mid = low+(high-low)/2; if(a[mid]==value) return mid; else if(a[mid]&gt;value) return BinarySearch2(a, value, low, mid-1); else if(a[mid]&lt;value) return BinarySearch2(a, value, mid+1, high); &#125; else return -1;&#125;&#125; 插值查找二分查找的升级版本；添加了一个比例参数用以调整每次查找区间的大小。 int mid = low+（value-a[low])/(a[high]-a[low])*(high-low); 基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 1234567891011121314151617181920// 关键代码int value ; //比例参数int mid = low+（value-a[low])/(a[high]-a[low])*(high-low);//插值查找int InsertionSearch(int a[], int value, int low, int high)&#123; if(low &lt;= high) &#123; int mid = low+(value-a[low])/(a[high]-a[low])*(high-low); if(a[mid]==value) return mid; if(a[mid]&gt;value) return InsertionSearch(a, value, low, mid-1); if(a[mid]&lt;value) return InsertionSearch(a, value, mid+1, high); &#125; else return -1;&#125;","raw":null,"content":null,"categories":[],"tags":[]},{"title":"BFS和DFS算法(基础)","slug":"A_程序员内功/C_算法与数据结构/算法/BFS和DFS","date":"2022-12-27T03:12:53.998Z","updated":"2022-12-27T03:12:53.998Z","comments":true,"path":"posts/9ced94a0.html","link":"","permalink":"https://www.mingsrc.work/posts/9ced94a0","excerpt":"","text":"导读 在《数据结构》这本书中，第七章第三小节讲了图的遍历，需要的同学可以自行去查看。同时，在牛客或者力扣刷题，遍历二叉树经常会用到DFS和BFS。 和树的遍历类似。图的遍历也是从某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。这一过程就叫做图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。在图的遍历中，为了避免同一顶点被访问多次，必须记下每个已访问过的顶点。可以设置一个辅助数组用以判断当前结点是否已被访问。 在图的遍历中，有：深度优先搜索和广度优先搜索，他们对无向图和有向图都适用。 区别假设有这样一棵树如下所示： 深度优先搜索算法(Breadth-First-Search，缩写为 BFS)：上图的遍历顺序为A-B-D-C-E-F。是一种利用队列实现的搜索算法，类似于树的先序遍历，是树的先序遍历的推广。 广度优先搜索算法(Breadth-First-Search，缩写为 BFS)：上图的遍历顺序为A-B-C-D-E-F。是一种利用递归搜索算法。遍历类似于树的按层次遍历的过程。 BFS的重点在于队列，而DFS的重点在于递归。这是它们的本质区别 应用求树的深度 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 DFS方法“不撞南墙不回头” 123456789101112131415161718192021/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; if(pRoot == NULL)&#123; return 0; &#125; int left = TreeDepth(pRoot-&gt;left); int right = TreeDepth(pRoot-&gt;right); return (left &gt; right) ? (left + 1) : (right + 1); &#125;&#125;; BFS方法“剥洋葱，一层一层剥开” 12345678910111213141516171819202122232425262728293031323334353637C++/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; if(pRoot == NULL)&#123; return 0; &#125; queue&lt;TreeNode*&gt; que; int depth = 0; que.push(pRoot); while(!que.empty())&#123; int size = que.size(); depth++; for(int i = 0; i &lt; size; i++)&#123; TreeNode* node = que.front(); que.pop(); if(node-&gt;left)&#123; que.push(node-&gt;left); &#125; if(node-&gt;right)&#123; que.push(node-&gt;right); &#125; &#125; &#125; return depth; &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"程序员内功","slug":"程序员内功","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/"},{"name":"算法与数据结构","slug":"程序员内功/算法与数据结构","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"BFS","slug":"BFS","permalink":"https://www.mingsrc.work/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"https://www.mingsrc.work/tags/DFS/"}]},{"title":"链表","slug":"A_程序员内功/C_算法与数据结构/数据结构/链表","date":"2022-12-27T03:12:53.998Z","updated":"2022-12-27T03:12:53.998Z","comments":true,"path":"posts/2362a8ea.html","link":"","permalink":"https://www.mingsrc.work/posts/2362a8ea","excerpt":"链表学习记录，若有不足请指出来\n","text":"链表学习记录，若有不足请指出来 1 结点结构123456// Definition for singly-linked list.struct SinglyListNode &#123; int val; SinglyListNode *next; SinglyListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; 2 操作与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按索引来访问元素平均要花费O(N)时间，其中 N 是链表的长度。 添加操作-单链表 令插入结点的next为其插入位置下结点 原位置下一节点为要插入的结点即可 与数组不同，我们不需要将所有元素移动到插入元素之后。因此，您可以在 O(1) 时间复杂度中将新结点插入到链表中，这非常高效。 删除操作-单链表12//删除prev的下一结点prev-&gt;next == prev-&gt;next -&gt;next; 删除第一个结点12SinglyListNode *deleteTopList = singlylistNode-&gt;next; //singlyListnode为需要删除头结点的链表singlylistnode -&gt; next = deletTopList; 3 设计链表设计链表的实现。 ​ 单链表中的节点属性：val和next(如果是双向链表，还需要属性prev以指示链表中的上一个节点) 在链表中需要实现的功能有： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 代码 虽然看着很简单，但是还是要认真写才行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class MyLinkedList &#123;public: /** Initialize your data structure here. */ struct LinkedNode &#123; int val; LinkedNode* next; LinkedNode(int val):val(val),next(nullptr)&#123;&#125; LinkedNode(int val,LinkedNode* next1):val(val),next(next1)&#123;&#125; &#125;; MyLinkedList()&#123; dummyHead = new LinkedNode(0); _size = 0; &#125; /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */ int get(int index) &#123; if(index &gt; (_size - 1) || index &lt; 0) return -1; LinkedNode* top = dummyHead-&gt;next; while(index--) top = top-&gt;next; return top-&gt;val; &#125; /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */ void addAtHead(int val) &#123; LinkedNode *second = dummyHead-&gt;next; LinkedNode* addNode = new LinkedNode(val,second); dummyHead-&gt;next = addNode; _size++; &#125; /** Append a node of value val to the last element of the linked list. */ void addAtTail(int val) &#123; LinkedNode* newNode=new LinkedNode(val); LinkedNode* tail = dummyHead; while(tail-&gt;next != nullptr)&#123; tail = tail-&gt;next; &#125; tail -&gt; next = newNode; _size++; &#125; /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */ void addAtIndex(int index, int val) &#123; if (index &gt; _size ) &#123; return; &#125; LinkedNode * indexNode = dummyHead; while(index--)&#123; indexNode = indexNode-&gt;next; &#125; LinkedNode* tmp = new LinkedNode(val,indexNode-&gt;next); indexNode-&gt;next = tmp; _size++; &#125; /** Delete the index-th node in the linked list, if the index is valid. */ void deleteAtIndex(int index) &#123; if (index &gt;= _size || index &lt; 0) &#123; return; &#125; LinkedNode* indexNode = dummyHead; while(index--)&#123; indexNode = indexNode-&gt;next; &#125; LinkedNode* tmp = indexNode-&gt;next; indexNode-&gt;next = indexNode-&gt;next-&gt;next; delete tmp; _size--; &#125;private: int _size; LinkedNode* dummyHead;&#125;;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */","raw":null,"content":null,"categories":[{"name":"程序员内功","slug":"程序员内功","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/"},{"name":"算法与数据结构","slug":"程序员内功/算法与数据结构","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://www.mingsrc.work/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"红黑树🌲","slug":"A_程序员内功/C_算法与数据结构/数据结构/红黑树","date":"2022-12-27T03:12:53.998Z","updated":"2022-12-27T03:12:53.998Z","comments":true,"path":"posts/5ec0a1e5.html","link":"","permalink":"https://www.mingsrc.work/posts/5ec0a1e5","excerpt":"R-B Tree🌲\nR-B Tree,全称Red-Black Tree，又称为”红黑树”，一种特殊的二叉树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红（Red)或黑（black)\n转载声明：https://www.cnblogs.com/skywang12345/p/3245399.html\n","text":"R-B Tree🌲 R-B Tree,全称Red-Black Tree，又称为”红黑树”，一种特殊的二叉树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红（Red)或黑（black) 转载声明：https://www.cnblogs.com/skywang12345/p/3245399.html 红黑树的优势红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入效率更高！！！ 红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如： Java中的java.util.TreeMap,java.util.TreeSet； C++ STL中的：map,multimap,multiset； .NET中的：SortedDictionary,SortedSet 等。 红黑树的特性(1) 每个节点或者是黑色，或者是红色 (2) 根节点是黑色 (3) 每个叶子节点（nil)是黑色 (4) 如果一个节点是红色的，则它的子节点必须是黑色的。 (5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 注意： 特性(3)中的叶子节点，是指为空（NIL或null）的节点。 特性(5)，确保没有一条路径会比其他路径长处两倍。因而，红黑树是相对接近平衡的二叉树。 红黑树示意图 红黑树的应用红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。 红黑树的基本操作（1） 左旋和右旋左旋红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。旋转包括两种：左旋 和 右旋。下面分别对它们进行介绍。 左旋的伪代码《算法导论》，参考上示意图和如下伪代码，理解“红黑树T的节点x进行左旋”是如何进行的。 123456789101112LEFT-ROTATE(T, x) 01 y ← right[x] // 前提：这里假设x的右孩子为y。下面开始正式操作02 right[x] ← left[y] // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子03 p[left[y]] ← x // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x04 p[y] ← p[x] // 将 “x的父亲” 设为 “y的父亲”05 if p[x] = nil[T] 06 then root[T] ← y // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点07 else if x = left[p[x]] 08 then left[p[x]] ← y // 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”09 else right[p[x]] ← y // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”10 left[y] ← x // 将 “x” 设为 “y的左孩子”11 p[x] ← y // 将 “x的父节点” 设为 “y” 理解左旋之后，再看一下鲜明的例子。你可以先行尝试一下： 右旋 对x进行左旋，意味着”将x变成一个左节点”。 右旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点y进行右旋”是如何进行的。 123456789101112RIGHT-ROTATE(T, y) 01 x ← left[y] // 前提：这里假设y的左孩子为x。下面开始正式操作02 left[y] ← right[x] // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子03 p[right[x]] ← y // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y04 p[x] ← p[y] // 将 “y的父亲” 设为 “x的父亲”05 if p[y] = nil[T] 06 then root[T] ← x // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点07 else if y = right[p[y]] 08 then right[p[y]] ← x // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”09 else left[p[y]] ← x // 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”10 right[x] ← y // 将 “y” 设为 “x的右孩子”11 p[y] ← x // 将 “y的父节点” 设为 “x” 理解右旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。 3. 区分 左旋 和 右旋 仔细观察上面”左旋”和”右旋”的示意图。我们能清晰的发现，它们是对称的。无论是左旋还是右旋，被旋转的树，在旋转前是二叉查找树，并且旋转之后仍然是一颗二叉查找树。 红黑树的基本操作（二）添加将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下： 第一步: 将红黑树当作一颗二叉查找树，将节点插入。 红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。 好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！ 第二步：将插入的节点着色为”红色”。 为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：(1) 每个节点或者是黑色，或者是红色。(2) 根节点是黑色。(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！](4) 如果一个节点是红色的，则它的子节点必须是黑色的。(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。o(∩∩)o…哈哈 第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。 第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？ 对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。 对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。 对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。 对于”特性(4)”，是有可能违背的！ 那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。 伪代码 123456789101112131415161718RB-INSERT(T, z) 01 y ← nil[T] // 新建节点“y”，将y设为空节点。02 x ← root[T] // 设“红黑树T”的根节点为“x”03 while x ≠ nil[T] // 找出要插入的节点“z”在二叉树T中的位置“y”04 do y ← x 05 if key[z] &lt; key[x] 06 then x ← left[x] 07 else x ← right[x] 08 p[z] ← y // 设置 “z的父亲” 为 “y”09 if y = nil[T] 10 then root[T] ← z // 情况1：若y是空节点，则将z设为根11 else if key[z] &lt; key[y] 12 then left[y] ← z // 情况2：若“z所包含的值” &lt; “y所包含的值”，则将z设为“y的左孩子”13 else right[y] ← z // 情况3：(“z所包含的值” &gt;= “y所包含的值”)将z设为“y的右孩子” 14 left[z] ← nil[T] // z的左孩子设为空15 right[z] ← nil[T] // z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了。16 color[z] ← RED // 将z着色为“红色”17 RB-INSERT-FIXUP(T, z) // 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树 结合伪代码以及为代码上面的说明，先理解RB-INSERT。理解了RB-INSERT之后，我们接着对 RB-INSERT-FIXUP的伪代码进行说明。 添加修正操作的伪代码《算法导论》 1234567891011121314151617RB-INSERT-FIXUP(T, z)01 while color[p[z]] = RED // 若“当前节点(z)的父节点是红色”，则进行以下处理。02 do if p[z] = left[p[p[z]]] // 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。03 then y ← right[p[p[z]]] // 将y设置为“z的叔叔节点(z的祖父节点的右孩子)”04 if color[y] = RED // Case 1条件：叔叔是红色05 then color[p[z]] ← BLACK ▹ Case 1 // (01) 将“父节点”设为黑色。06 color[y] ← BLACK ▹ Case 1 // (02) 将“叔叔节点”设为黑色。07 color[p[p[z]]] ← RED ▹ Case 1 // (03) 将“祖父节点”设为“红色”。08 z ← p[p[z]] ▹ Case 1 // (04) 将“祖父节点”设为“当前节点”(红色节点)09 else if z = right[p[z]] // Case 2条件：叔叔是黑色，且当前节点是右孩子10 then z ← p[z] ▹ Case 2 // (01) 将“父节点”作为“新的当前节点”。11 LEFT-ROTATE(T, z) ▹ Case 2 // (02) 以“新的当前节点”为支点进行左旋。12 color[p[z]] ← BLACK ▹ Case 3 // Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。13 color[p[p[z]]] ← RED ▹ Case 3 // (02) 将“祖父节点”设为“红色”。14 RIGHT-ROTATE(T, p[p[z]]) ▹ Case 3 // (03) 以“祖父节点”为支点进行右旋。15 else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged) // 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。16 color[root[T]] ← BLACK 根据被插入节点的父节点的情况，可以将”当节点z被着色为红色节点，并插入二叉树”划分为三种情况来处理。① 情况说明：被插入的节点是根节点。 处理方法：直接把此节点涂为黑色。② 情况说明：被插入的节点的父节点是黑色。 处理方法：什么也不需要做。节点被插入后，仍然是红黑树。③ 情况说明：被插入的节点的父节点是红色。 处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为3种情况(Case)。 现象说明 处理策略 Case 1 当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。 (01) 将“父节点”设为黑色。 (02) 将“叔叔节点”设为黑色。 (03) 将“祖父节点”设为“红色”。 (04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。 Case 2 当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子 (01) 将“父节点”作为“新的当前节点”。 (02) 以“新的当前节点”为支点进行左旋。 Case 3 当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子 (01) 将“父节点”设为“黑色”。 (02) 将“祖父节点”设为“红色”。 (03) 以“祖父节点”为支点进行右旋。 上面三种情况(Case)处理问题的核心思路都是：将红色的节点移到根节点；然后，将根节点设为黑色。下面对它们详细进行介绍。 1. (Case 1)叔叔是红色 1.1 现象说明当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。 1.2 处理策略(01) 将“父节点”设为黑色。(02) 将“叔叔节点”设为黑色。(03) 将“祖父节点”设为“红色”。(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。 下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比) “当前节点”和“父节点”都是红色，违背“特性(4)”。所以，将“父节点”设置“黑色”以解决这个问题。 但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。 解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：第一，为什么“祖父节点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。 第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。 按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。 1.3 示意图 2. (Case 2)叔叔是黑色，且当前节点是右孩子 2.1 现象说明当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子 2.2 处理策略(01) 将“父节点”作为“新的当前节点”。(02) 以“新的当前节点”为支点进行左旋。 下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比) 首先，将“父节点”作为“新的当前节点”；接着，以“新的当前节点”为支点进行左旋。 为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置“父节点”的代号为F(Father)，“当前节点”的代号为S(Son)。为什么要“以F为支点进行左旋”呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是“将红色的节点移到根节点”，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而S又是一个右孩子，因此，我们可以通过“左旋”来将S上移！ 按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为“黑色”，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01)，即“将F设为‘新的当前节点’”。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为“左旋”之后，F变成了S的“子节点”，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决“孩子”的问题，再解决“父亲”的问题；所以，我们执行步骤(01)：将“父节点”作为“新的当前节点”。 2.2 示意图 3. (Case 3)叔叔是黑色，且当前节点是左孩子 3.1 现象说明当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子 3.2 处理策略(01) 将“父节点”设为“黑色”。(02) 将“祖父节点”设为“红色”。(03) 以“祖父节点”为支点进行右旋。 下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比) 为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“叔叔节点”为U(Uncle)，“父节点”为F(Father)，祖父节点为G(Grand-Father)。 S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。 2.3 示意图 提示：上面的进行Case 3处理之后，再将节点”120”当作当前节点，就变成了Case 2的情况。 红黑树的基本操作(三) 删除将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下： 第一步：将红黑树当作一颗二叉查找树，将节点删除。 这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况： ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。 ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。 ③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。 第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。 因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。 删除操作的伪代码《算法导论》 12345678910111213141516171819RB-DELETE(T, z)01 if left[z] = nil[T] or right[z] = nil[T] 02 then y ← z // 若“z的左孩子” 或 “z的右孩子”为空，则将“z”赋值给 “y”；03 else y ← TREE-SUCCESSOR(z) // 否则，将“z的后继节点”赋值给 “y”。04 if left[y] ≠ nil[T]05 then x ← left[y] // 若“y的左孩子” 不为空，则将“y的左孩子” 赋值给 “x”；06 else x ← right[y] // 否则，“y的右孩子” 赋值给 “x”。07 p[x] ← p[y] // 将“y的父节点” 设置为 “x的父节点”08 if p[y] = nil[T] 09 then root[T] ← x // 情况1：若“y的父节点” 为空，则设置“x” 为 “根节点”。10 else if y = left[p[y]] 11 then left[p[y]] ← x // 情况2：若“y是它父节点的左孩子”，则设置“x” 为 “y的父节点的左孩子”12 else right[p[y]] ← x // 情况3：若“y是它父节点的右孩子”，则设置“x” 为 “y的父节点的右孩子”13 if y ≠ z 14 then key[z] ← key[y] // 若“y的值” 赋值给 “z”。注意：这里只拷贝z的值给y，而没有拷贝z的颜色！！！15 copy y&#x27;s satellite data into z 16 if color[y] = BLACK 17 then RB-DELETE-FIXUP(T, x) // 若“y为黑节点”，则调用18 return y 结合伪代码以及为代码上面的说明，先理解RB-DELETE。理解了RB-DELETE之后，接着对 RB-DELETE-FIXUP的伪代码进行说明 123456789101112131415161718192021222324RB-DELETE-FIXUP(T, x)01 while x ≠ root[T] and color[x] = BLACK 02 do if x = left[p[x]] 03 then w ← right[p[x]] // 若 “x”是“它父节点的左孩子”，则设置 “w”为“x的叔叔”(即x为它父节点的右孩子) 04 if color[w] = RED // Case 1: x是“黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。05 then color[w] ← BLACK ▹ Case 1 // (01) 将x的兄弟节点设为“黑色”。06 color[p[x]] ← RED ▹ Case 1 // (02) 将x的父节点设为“红色”。07 LEFT-ROTATE(T, p[x]) ▹ Case 1 // (03) 对x的父节点进行左旋。08 w ← right[p[x]] ▹ Case 1 // (04) 左旋后，重新设置x的兄弟节点。09 if color[left[w]] = BLACK and color[right[w]] = BLACK // Case 2: x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。10 then color[w] ← RED ▹ Case 2 // (01) 将x的兄弟节点设为“红色”。11 x ← p[x] ▹ Case 2 // (02) 设置“x的父节点”为“新的x节点”。12 else if color[right[w]] = BLACK // Case 3: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。13 then color[left[w]] ← BLACK ▹ Case 3 // (01) 将x兄弟节点的左孩子设为“黑色”。14 color[w] ← RED ▹ Case 3 // (02) 将x兄弟节点设为“红色”。15 RIGHT-ROTATE(T, w) ▹ Case 3 // (03) 对x的兄弟节点进行右旋。16 w ← right[p[x]] ▹ Case 3 // (04) 右旋后，重新设置x的兄弟节点。17 color[w] ← color[p[x]] ▹ Case 4 // Case 4: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的。(01) 将x父节点颜色 赋值给 x的兄弟节点。18 color[p[x]] ← BLACK ▹ Case 4 // (02) 将x父节点设为“黑色”。19 color[right[w]] ← BLACK ▹ Case 4 // (03) 将x兄弟节点的右子节设为“黑色”。20 LEFT-ROTATE(T, p[x]) ▹ Case 4 // (04) 对x的父节点进行左旋。21 x ← root[T] ▹ Case 4 // (05) 设置“x”为“根节点”。22 else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged) // 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。23 color[x] ← BLACK 下面对删除函数进行分析。在分析之前，我们再次温习一下红黑树的几个特性：(1) 每个节点或者是黑色，或者是红色。(2) 根节点是黑色。(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！](4) 如果一个节点是红色的，则它的子节点必须是黑色的。(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 前面我们将”删除红黑树中的节点”大致分为两步，在第一步中”将红黑树当作一颗二叉查找树，将节点删除”后，可能违反”特性(2)、(4)、(5)”三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。 为了便于分析，我们假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。为什么呢？ 通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设”x包含一个额外的黑色”，就正好弥补了”删除y所丢失的黑色节点”，也就不会违反”特性(5)”。 因此，假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。 现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是”红+黑”或”黑+黑”，它违反了”特性(1)”。 现在，我们面临的问题，由解决”违反了特性(2)、(4)、(5)三个特性”转换成了”解决违反特性(1)、(2)、(4)三个特性”。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：a) x指向一个”红+黑”节点。此时，将x设为一个”黑”节点即可。b) x指向根。此时，将x设为一个”黑”节点即可。c) 非前面两种姿态。 将上面的姿态，可以概括为3种情况。① 情况说明：x是“红+黑”节点。 处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。② 情况说明：x是“黑+黑”节点，且x是根。 处理方法：什么都不做，结束。此时红黑树性质全部恢复。③ 情况说明：x是“黑+黑”节点，且x不是根。 处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示： 现象说明 处理策略 Case 1 x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。 (01) 将x的兄弟节点设为“黑色”。 (02) 将x的父节点设为“红色”。 (03) 对x的父节点进行左旋。 (04) 左旋后，重新设置x的兄弟节点。 Case 2 x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。 (01) 将x的兄弟节点设为“红色”。 (02) 设置“x的父节点”为“新的x节点”。 Case 3 x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。 (01) 将x兄弟节点的左孩子设为“黑色”。 (02) 将x兄弟节点设为“红色”。 (03) 对x的兄弟节点进行右旋。 (04) 右旋后，重新设置x的兄弟节点。 Case 4 x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。 (01) 将x父节点颜色 赋值给 x的兄弟节点。 (02) 将x父节点设为“黑色”。 (03) 将x兄弟节点的右子节设为“黑色”。 (04) 对x的父节点进行左旋。 (05) 设置“x”为“根节点”。 1. (Case 1)x是”黑+黑”节点，x的兄弟节点是红色 1.1 现象说明x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。 1.2 处理策略(01) 将x的兄弟节点设为“黑色”。(02) 将x的父节点设为“红色”。(03) 对x的父节点进行左旋。(04) 左旋后，重新设置x的兄弟节点。 下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比) 这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，同时“将x的父节点设为红色”；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。 1.3 示意图 2. (Case 2) x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色 2.1 现象说明x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。 2.2 处理策略(01) 将x的兄弟节点设为“红色”。(02) 设置“x的父节点”为“新的x节点”。 下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比) 这个情况的处理思想：是将“x中多余的一个黑色属性上移(往根方向移动)”。 x是“黑+黑”节点，我们将x由“黑+黑”节点 变成 “黑”节点，多余的一个“黑”属性移到x的父节点中，即x的父节点多出了一个黑属性(若x的父节点原先是“黑”，则此时变成了“黑+黑”；若x的父节点原先时“红”，则此时变成了“红+黑”)。 此时，需要注意的是：所有经过x的分支中黑节点个数没变化；但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属性)！为了解决这个问题，我们需要将“所有经过x的兄弟节点的分支中黑色节点的个数减1”即可，那么就可以通过“将x的兄弟节点由黑色变成红色”来实现。 经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。我们需要将x的父节点设为“新的x节点”进行处理。若“新的x节点”是“黑+红”，直接将“新的x节点”设为黑色，即可完全解决该问题；若“新的x节点”是“黑+黑”，则需要对“新的x节点”进行进一步处理。 2.3 示意图 3. (Case 3)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的 3.1 现象说明x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。 3.2 处理策略(01) 将x兄弟节点的左孩子设为“黑色”。(02) 将x兄弟节点设为“红色”。(03) 对x的兄弟节点进行右旋。(04) 右旋后，重新设置x的兄弟节点。 ​ 下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比)​ 我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑色”，同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。 3.3 示意图 4. (Case 4)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色 4.1 现象说明x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。 4.2 处理策略(01) 将x父节点颜色 赋值给 x的兄弟节点。(02) 将x父节点设为“黑色”。(03) 将x兄弟节点的右子节设为“黑色”。(04) 对x的父节点进行左旋。(05) 设置“x”为“根节点”。 下面谈谈为什么要这样处理。(建议理解的时候，通过下面的图进行对比) 我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是“：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的。 为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother’s Left Son)，“兄弟节点的右孩子”为BRS(Brother’s Right Son)，“父节点”为F(Father)。 我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后： 第一，“同时经过根节点和S的分支的黑色节点个数不变”。 若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。 第二，“同时经过根节点和BLS的分支的黑色节点数不变”。 若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色”黑色”，赋值给了F)。至此，我们算是调换了F和B的颜色。 第三，“同时经过根节点和BRS的分支的黑色节点数不变”。 在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。 至此，我们就完成了Case 4的处理。理解Case 4的核心，是了解如何“去掉当前节点额外的黑色”。 4.3 示意图 OK！至此，红黑树的理论知识差不多讲完了。后续再更新红黑树的实现代码！ 变换规则变颜色的情况：当前节点的父亲是红色，且它的祖父节点的另一个子节点也是红色(叔叔节点)： 把父节点设为黑色 把叔叔也设为黑色 把祖父节点也就是父亲的父亲设为红色（爷爷） 把指针定义到祖父节点设为当前要操作的。（爷爷）分析的点变换的的规则。 左旋当前父节点是红色，叔叔是黑色的时候，且当前的节点是右子树。左旋以父节点作为左旋。 右旋 把父节点变为黑色 把祖父节点变为红色（爷爷） 以祖父节点旋转(爷爷) 参考文献1, 《算法导论》 2, 教你透彻了解红黑树","raw":null,"content":null,"categories":[{"name":"程序员内功","slug":"程序员内功","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/"},{"name":"算法与数据结构","slug":"程序员内功/算法与数据结构","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://www.mingsrc.work/tags/tree/"},{"name":"红黑树","slug":"红黑树","permalink":"https://www.mingsrc.work/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"}]},{"title":"设计模式","slug":"A_程序员内功/B_设计模式/设计模式","date":"2022-12-27T03:12:53.997Z","updated":"2022-12-27T07:05:52.457Z","comments":true,"path":"posts/364ea8cc.html","link":"","permalink":"https://www.mingsrc.work/posts/364ea8cc","excerpt":"除了“设计模式”，你还应该知道什么程序员内功之设计模式🔥\n\n推荐学习视频C++常用设计模式\n","text":"除了“设计模式”，你还应该知道什么程序员内功之设计模式🔥 推荐学习视频C++常用设计模式 设计模式从何而来四人组（Gang of Four)，简称GoF. GoF将模式的概念引入软件工程领域，这标志着软件模式的诞生。软件模式（Software Pattern是）是将模式的一半概念应用于软件开发领域，即软件开发的总体指导思路或参照样板. 需要了解软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等。 “软件设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可充用代码，让代码更容易被他人理解并且保证代码可靠性。” ——软件设计模式的定义 一句大白话就是：“在一定环境下，用固定套路解决问题”。 软件设计模式的种类GoF提出的设计模式有23个，包括： 设计模式之创建型模式(Creational)：如何创建对象; 创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 设计模式之结构型模式(Structional)：如何实现类或对象的组合； 结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。 结构型模式分为以下 7 种： 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 设计模式之行为型模式(Behavioral)：类或对象怎样交互以及怎么分配职责。 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。 行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。 行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。 设计模式目前的种类：GoF的23种 +“简答工厂模式” \\= 24种 软件设计模式有什么用？有助于更加深入地理解面向对象思想，让你知道： 1. 如何将代码分散在几个不同的类中 2. 为什么要有“接口” 3. 何为针对抽象编程 4. 合适不应该使用继承 5. 如何不修改源代码增加新功能 6. 更好地阅读和理解现有类库与其他系统中的源代码 如何学好设计模式设计模式的基础是：多态，参考书上给的建议就是： 初学者：积累案例，不要盲目的背类图（我就是） 初级开发人员：多思考，多梳理，归纳总结，尊重事物的认知规律，注意临界点的突破，不要浮躁。 中级开发人员：合适的开发环境，寻找合适的设计模式来解决问题。多应用，对经典的组合设计模式，大量自由的运用，要不断地追求。 关于语言语言是基础，学习设计模式之前一定要对自己现在使用和运用的语言加以了解；熟悉、掌握多态。 C++学习者建议可以读一遍《c++ Primer Plus》，尤其是面向对象部分 设计模式总览创建型模式（Creational） 结构型模式(Structural) 行为型模式（Behavioral） 面向对象设计原则 名称 定义 单一职责原则（Single Responsibility Principle,SRP)⭐️⭐️⭐️⭐️ 类的职责单一，对外只提供一种可能，而引起类变化的原因都应该只有一个。 开闭原则（Open-Closed Principle,OCP)⭐️⭐️⭐️⭐️⭐️ 类的改动是通过增加代码进行的，而不是修改源代码 里氏代换原则(Liskov Substitution Principle,LSP)⭐️⭐️⭐️⭐️⭐️ 任何抽象类出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。 依赖倒转原则（Dependence Inversion Priciple,DIP)⭐️⭐️⭐️⭐️⭐️ 依赖于抽象（接口），不要依赖具体的实现（类），也就是针对接口编程。 接口隔离原则（Interface Segregation Principle,ISP)⭐️⭐️ 不应该强迫用户的程序依赖他们不需要的接口方法。一个接口只提供一种对外功能，不应该把所有操作都封装到一个接口中去。 合成复用原则（Composite Reuse Principle，CRP)⭐️⭐️⭐️⭐️ 如果使用继承，会导致父类的任何变化都可能影响到子类的行为，如果使用对象组合，就降低了这种依赖关系，对于继承和类，优先使用该组合。 迪米特法则（Law of Demeter,LoD)⭐️⭐️⭐️ 一个对象应当对其他对象尽可能少的了解,从而降低各个对象之间的耦合,提高系统的可维护性。例如在一个程序中,各个模块之间相互调用时,通常会提供- -个统- -的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节, 这样当一个模块内部的实现发生改变时,不会影响其他模块的使用。( 黑盒原理) 借鉴了《Easy搞定设计模式》","raw":null,"content":null,"categories":[{"name":"程序员内功","slug":"程序员内功","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/"},{"name":"设计模式","slug":"程序员内功/设计模式","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.mingsrc.work/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.mingsrc.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"创建型模式","slug":"创建型模式","permalink":"https://www.mingsrc.work/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"数据结构——栈和队列","slug":"A_程序员内功/C_算法与数据结构/数据结构/栈和队列","date":"2022-12-27T03:12:53.997Z","updated":"2022-12-27T03:12:53.997Z","comments":true,"path":"posts/9b2a43f2.html","link":"","permalink":"https://www.mingsrc.work/posts/9b2a43f2","excerpt":"","text":"栈栈的定义与运算 栈是只允许在线性表的一段进行插入和删除的线性表。表中值允许插入和删除的一段称为栈顶命令一段称为栈底。 由于只能在栈顶进行插入和删除操作，使得后进栈的元素先出栈，先进栈的元素后出栈，所以栈是一种后进先出（Last In First Out，简称LIFO）的数据结构。有关栈的应用都是基于这一特性。 栈的操作通常称为入栈或进栈，其删除操作称为出栈或退栈。当栈中五元素是，称为空栈。 有关栈的基本操作主要有以下几种： 1. 栈的初始化操作，即建立一个空栈S 2. 判空栈操作，弱S为空栈，返回一个真值 3. 进栈操作，在S栈顶插入一个元素X 4. 出栈操作，若栈S不空，则取栈顶元素（栈顶元素不删除）。 栈的顺序存储结构（又称为顺序栈）类似于线性表的顺序存储结构。 队列双队列实现栈的操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MyStack &#123; queue&lt;int&gt; queue1; queue&lt;int&gt; queue2;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; queue2.push(x); while (!queue1.empty()) &#123; queue2.push(queue1.front()); queue1.pop(); &#125; swap (queue1,queue2); &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int r = queue1.front(); queue1.pop(); return r; &#125; /** Get the top element. */ int top() &#123; int r = queue1.front(); return r; &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return queue1.empty(); &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */ 环形队列环形队列（头就是尾，尾就是头）","raw":null,"content":null,"categories":[{"name":"程序员内功","slug":"程序员内功","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/"},{"name":"算法与数据结构","slug":"程序员内功/算法与数据结构","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.mingsrc.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"设计模式之行为型模式","slug":"A_程序员内功/B_设计模式/行为型模式","date":"2022-12-27T03:12:53.996Z","updated":"2022-12-27T07:04:20.962Z","comments":true,"path":"posts/69f2f423.html","link":"","permalink":"https://www.mingsrc.work/posts/69f2f423","excerpt":"","text":"行为型模式 学习笔记之C++设计模式——创建型模式 📑 设计模式之结构型模式 📑 设计模式之创建型模式 总的来说，行为型模式就是用来对类或对象怎样交互和怎样分配职责进行描述。 模板方法模式 AbstractClass（抽象类）：在抽象类中定义了一系列基本操作（PrimitiveOperations），这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法（Template Method），用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。 ConcreteClass（具体子类）：它是抽象类的子类，用于是现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中的已经实现的具体基本操作。 模板方法案例 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 模板方法.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 制作饮料class Beverage&#123;public: // 煮水 void BoilWater() &#123; cout &lt;&lt; &quot;烧开水&quot; &lt;&lt; endl; &#125; // 冲泡 特殊接口 virtual void Brew() = 0; // 倒入杯中 void PourinVup() &#123; cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl; &#125; // 添加料 特殊接口 virtual void AddCondiments() = 0; // hook 方法，决定某些算法步骤是否挂钩在算法中 virtual bool CustomWantsCondiments() &#123; return true; &#125; // 模板方法 void PrepareBeverage() &#123; BoilWater(); Brew(); PourinVup(); if (CustomWantsCondiments()) &#123; AddCondiments(); &#125; &#125;protected: private:&#125;;class Coffee : public Beverage&#123;public: virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡咖啡豆&quot; &lt;&lt; endl; &#125; virtual void AddCondiments() &#123; cout &lt;&lt; &quot;添加糖和牛奶&quot; &lt;&lt; endl; &#125;protected:private:&#125;;class Tea : public Beverage&#123;public: virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡茶叶&quot; &lt;&lt; endl; &#125; virtual void AddCondiments() &#123; cout &lt;&lt; &quot;添加柠檬&quot; &lt;&lt; endl; &#125;protected:private:&#125;;int main()&#123; Beverage *pTea = new Tea; pTea-&gt;PrepareBeverage(); delete pTea; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; Beverage *pCoffee = new Tea; pCoffee-&gt;PrepareBeverage(); delete pCoffee; return 0;&#125; 输出： 烧开水 冲泡茶叶 倒入杯中 添加柠檬 ----------------------- 烧开水 冲泡茶叶 倒入杯中 添加柠檬 请按任意键继续. . . 模板方法的优缺点 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。 适用场景 具有统一的操作步骤或操作过程； 具有不同的操作细节； 存在多个具有同样操作步骤的应用场景，但某些具体的操作细节却各不相同 在抽象类中统一操作步骤，并规定好接口；让子类实现接口。这样可以吧各个具体的子类和操作步骤解耦合。 命令模式将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为模式，其别名为动作(Action)模式或事务（Tranaction）模式。 命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 命令模式.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;using namespace std;class Doctor&#123;public: void treat_eye() &#123; cout &lt;&lt; &quot;医生 治疗 眼科病&quot; &lt;&lt; endl; &#125; void treat_nose() &#123; cout &lt;&lt; &quot;医生 治疗 鼻科病&quot; &lt;&lt; endl; &#125;protected:private:&#125;;class CommandTreatEye &#123;public: CommandTreatEye(Doctor *doctor) &#123; m_doctor = doctor; &#125; void treat() &#123; m_doctor-&gt;treat_eye(); &#125;private: Doctor *m_doctor;&#125;;class CommandTreatNose &#123;public: CommandTreatNose(Doctor *doctor) &#123; m_doctor = doctor; &#125; void treat() &#123; m_doctor-&gt;treat_nose(); &#125;private: Doctor *m_doctor;&#125;;int main()&#123; // 1. 医生直接看病 Doctor *doctor = new Doctor; doctor-&gt;treat_eye(); delete doctor; cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl; // 2. 通过医疗指令来看病 Doctor *doctorCmd = new Doctor; CommandTreatEye * cmdEyeDoc = new CommandTreatEye(doctorCmd); cmdEyeDoc-&gt;treat(); delete cmdEyeDoc; CommandTreatNose *cmdNoseDoc = new CommandTreatNose(doctorCmd); cmdNoseDoc-&gt;treat(); delete cmdNoseDoc; delete doctorCmd; return 0;&#125; 输出： 医生 治疗 眼科病 ----------------- 医生 治疗 眼科病 医生 治疗 鼻科病 请按任意键继续. . . 命令模式的本质是对请求进行封装对应于一个命令，将发出命令的责任和执行命令的责任分割开。 命令模式中的角色和职责 策略模式 观察者模式","raw":null,"content":null,"categories":[{"name":"程序员内功","slug":"程序员内功","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/"},{"name":"设计模式","slug":"程序员内功/设计模式","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.mingsrc.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之结构型模式","slug":"A_程序员内功/B_设计模式/结构型模式","date":"2022-12-27T03:12:53.996Z","updated":"2022-12-27T03:12:53.996Z","comments":true,"path":"posts/eea0cb26.html","link":"","permalink":"https://www.mingsrc.work/posts/eea0cb26","excerpt":"","text":".dimitt:hover:after{ } 结构型模式 学习笔记之C++设计模式——创建型模式 📑 设计模式之结构型模式 📑 设计模式之行为型模式 Proxy模式又叫做代理模式，是构造型的设计模式之一， 它可以为其他对象提供-种代理( Proxy )以控制对这个对象的访问。所谓代理，是指具有与代理元(被代理的对象)具有相同的接口的类，客户端必须通过代理与被代理的目标类交互，而代理一-般在交互的过程中 (交互前后) , 进行某些特别的处理。 代理模式 通俗理解就和海外代购类似，由一个海外代购专门负责所有需要从其他国家购买的这个行为。 以下为代理模式案例及其代码： 点击查看123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 代理模式.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Item&#123;public: Item(string kind, bool fact) &#123; this-&gt;kind = kind; this-&gt;fact = fact; &#125; string getKind() &#123; return kind; &#125; bool getFact() &#123; return fact; &#125;protected:private: string kind; bool fact;&#125;;// 抽象的购物方式class Shopping&#123;public: virtual void buy(Item *it) = 0;protected:private:&#125;;class KoeraShopping : public Shopping&#123;public: void buy(Item *it) &#123; cout &lt;&lt; &quot;去韩国买了&quot; &lt;&lt; it-&gt;getKind() &lt;&lt; endl; &#125;protected:private:&#125;;class USAShopping : public Shopping&#123;public: void buy(Item * it) &#123; cout &lt;&lt; &quot;去美国买了&quot; &lt;&lt; it-&gt;getKind() &lt;&lt; endl; &#125;protected:private:&#125;;// 海外代理class OverseasProxy : public Shopping&#123;public: OverseasProxy(Shopping *shopping) &#123; this-&gt;shopping = shopping; &#125; virtual void buy(Item *it) &#123; if (it-&gt;getFact() == true) &#123; cout &lt;&lt; &quot;发现正品&quot; &lt;&lt; endl; shopping-&gt;buy(it); cout &lt;&lt; &quot;---------安检-----------&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;发现假货&quot; &lt;&lt; it-&gt;getKind() &lt;&lt; endl; &#125; &#125;protected:private: Shopping *shopping; // 有一个购物方式&#125;;int main()&#123; Item it1(&quot;nike鞋子&quot;, true); Item it2(&quot;CET4证书&quot;, false); Shopping *Koerashopping = new KoeraShopping; Shopping *usaShopping = new USAShopping; Shopping *overseaProxy = new OverseasProxy(usaShopping); overseaProxy-&gt;buy(&amp;it1); overseaProxy-&gt;buy(&amp;it2); return 0;&#125; 代理模式的种类远程代理（Remote Proxy）为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另外一台主机中，远程代理又称为大使（Ambassador）。 远程代理： 使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速相应并处理客户端的请求。远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。 如图所示: 客户端对象不能直接访问远程主机中的业务对象，只能采取间接访问的方式。远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端对象而言是透明的。客户端无须关心实现具体业务的是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。 在基于.NET平台的分布式技术，例如DCOM（Distribute Component Object Mdoel， 分布式组件对象模型）、Web Service中，都应用了远程代理模式。 虚拟代理（Virtual Proxy）如果需要创建一个资源消耗巨大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 虚拟代理(Virtual Proxy)也是一种常用的代理模式，对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。 通常，在以下两种情况下可以考虑使用虚拟代理： (1) 由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象。通常在实现时可以结合多线程技术，一个线程用于显示代理对象，其他线程用于加载真实对象。这种虚拟代理模式可以应用在程序启动的时候，由于创建代理对象在时间和处理复杂度上要少于创建真实对象，因此，在程序启动时，可以用代理对象代替真实对象初始化，大大加速了系统的启动时间。当需要使用真实对象时，再通过代理对象来引用，而此时真实对象可能已经成功加载完毕，可以缩短用户的等待时间。 (2) 当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象。为了节省内存，在第一次引用真实对象时再创建对象，并且该对象可被多次重用，在以后每次访问时需要检测所需对象是否已经被创建，因此在访问该对象时需要进行存在性检测，这需要消耗一定的系统时间，但是可以节省内存空间，这是一种用时间换取空间的做法。 无论是以上哪种情况，虚拟代理都是用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能。 保护代理（Protect Proxy）控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限 缓冲代理（Cache Proxy）为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果 缓冲代理(Cache Proxy)也是一种较为常用的代理模式，它为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而可以避免某些方法的重复执行，优化系统性能。 智能引用代理（Smart Reference Proxy）当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。 装饰模式 装饰模式（decorator Pattern）: 动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。 案例 代码点击查看123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// 装饰模式.cpp : 定义控制台应用程序的入口点。#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 一个抽象的构件，他是具体构件和抽象装饰类的父类 class Phone&#123;public: virtual void Show() = 0;protected:private:&#125;;// 具体的构件class iPhone : public Phone&#123;public: iPhone(string kind) &#123; this-&gt;kind = kind; &#125; virtual void Show() &#123; cout &lt;&lt; &quot;秀出了 iPhone- &quot; &lt;&lt; kind &lt;&lt; &quot;:&quot; &lt;&lt; endl; &#125;protected:private: string kind;&#125;;// 具体的构件class Mi : public Phone&#123;public: Mi(string kind) &#123; this-&gt;kind = kind; &#125; virtual void Show() &#123; cout &lt;&lt; &quot;秀出了 Mi-&quot; &lt;&lt; kind &lt;&lt; &quot;:&quot; &lt;&lt; endl; &#125;protected:private: string kind;&#125;;// 抽象的手机装饰类，必须包含抽象的构件class DeCoratorPhone : public Phone&#123;public: DeCoratorPhone() &#123; &#125; DeCoratorPhone(Phone *phone) &#123; this-&gt;phone = phone; &#125; virtual void Show() &#123; this-&gt;phone-&gt;Show(); &#125;protected:private: Phone *phone;&#125;;// 具体的装饰器class DeCoratorPhoneMo : public DeCoratorPhone &#123;public: DeCoratorPhoneMo(Phone *phone) &#123; this-&gt;phone = phone; &#125; virtual void Show() &#123; this-&gt;phone-&gt;Show(); addMo(); &#125; void addMo() &#123; cout &lt;&lt; &quot;装饰: 手机贴膜&quot; &lt;&lt; endl; &#125;private: Phone *phone;&#125;;// 具体的装饰器class DeCoratorPhoneKe : public DeCoratorPhone &#123;public: DeCoratorPhoneKe(Phone *phone) &#123; this-&gt;phone = phone; &#125; virtual void Show() &#123; this-&gt;phone-&gt;Show(); addMo(); &#125; void addMo() &#123; cout &lt;&lt; &quot;装饰: 手机装保护壳&quot; &lt;&lt; endl; &#125;private: Phone *phone;&#125;;int main()&#123; Phone *phone = NULL; DeCoratorPhone * hasMoPhone = NULL; DeCoratorPhone * hasKePhone = NULL; DeCoratorPhone * hasMoKePhone = NULL; // 定义一个Iphone 13手机 phone = new iPhone(&quot;iPhone 13&quot;); // 给普通iphone 加上贴膜 hasMoPhone = new DeCoratorPhoneMo(phone); // 给普通iphone 加上保护套 hasKePhone = new DeCoratorPhoneKe(phone); hasMoPhone-&gt;Show(); hasKePhone-&gt;Show(); // 给有皮套的iphone 加上贴膜 hasMoKePhone = new DeCoratorPhoneMo(hasKePhone); hasMoKePhone-&gt;Show(); delete hasMoKePhone; delete hasKePhone; delete hasMoPhone; delete phone; cout &lt;&lt; &quot;---------------------------------------&quot; &lt;&lt; endl; phone = new Mi(&quot;Mix 4&quot;); hasMoPhone = new DeCoratorPhoneMo(phone); hasKePhone = new DeCoratorPhoneKe(phone); hasMoPhone-&gt;Show(); hasKePhone-&gt;Show(); hasMoKePhone = new DeCoratorPhoneKe(hasKePhone); hasMoKePhone-&gt;Show(); delete hasMoKePhone; delete hasKePhone; delete hasMoPhone; delete phone; return 0;&#125; 输出： 秀出了 iPhone- iPhone 13: 装饰: 手机贴膜 秀出了 iPhone- iPhone 13: 装饰: 手机装保护壳 秀出了 iPhone- iPhone 13: 装饰: 手机装保护壳 装饰: 手机贴膜 秀出了 Mi-Mix 4: 装饰: 手机贴膜 秀出了 Mi-Mix 4: 装饰: 手机装保护壳 秀出了 Mi-Mix 4: 装饰: 手机装保护壳 装饰: 手机装保护壳 请按任意键继续. . . 装饰模式的优缺点 对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加。 可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为。 可以对一个对象进行多次装饰。 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无需改变，符合“开闭原则”。 使用装饰模式进行系统设计时产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能。 适用场景 动态、透明的方式给耽搁对象添加职责 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。 装饰器模式关注于在一个对象上动态的添加方法。然而代理模式关注于控制对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将院士对象作为一个参数创给装饰者的构造器。 外观模式根据迪米特法则，如果两个类不必彼此直接通信，那么两个类就不应当发生直接的相互作用。 一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。 例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个木块的内部实现细节，当一个模块内部的实现发生改变是，不会影响其他模块的使用。（黑盒原理）。 Facade模式也叫外观模式。是有GoF提出的23中设计模式中的一种。Facade模式为一组具有类似功能的类群，比如类库、子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。 Facade(外观角色): 为调用方，定义简单的调用接口 SubSystem(子系统角色): 功能提供者。指提供功能的类群（模块或子系统）。 更加具体的理解直接看代码就能明白。 代码点击展开123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 外观模式.cpp : 定义控制台应用程序的入口点。///* 外观模式就是将复杂的子类系统抽象到同一个的接口进行管理 外界只需要通过此接口与子类系统进行交互，而不必直接与复杂的子类系统进行交互。*/#include &quot;stdafx.h&quot;#include &lt;iostream&gt;using namespace std;// 这里定义四个字了系统class SubSystem1&#123;public: void Methor1() &#123; cout &lt;&lt; &quot;子系统方法一&quot; &lt;&lt; endl; &#125;protected:private:&#125;;class SubSystem2&#123;public: void Methor2() &#123; cout &lt;&lt; &quot;子系统方法二&quot; &lt;&lt; endl; &#125;protected:private:&#125;;class SubSystem3&#123;public: void Methor3() &#123; cout &lt;&lt; &quot;子系统方法三&quot; &lt;&lt; endl; &#125;protected:private:&#125;;class SubSystem4&#123;public: void Methor4() &#123; cout &lt;&lt; &quot;子系统方法四&quot; &lt;&lt; endl; &#125;protected:private:&#125;;/* 外观类，接口 */class Facade&#123;public: Facade() &#123; one = new SubSystem1; two = new SubSystem2; three = new SubSystem3; four = new SubSystem4; &#125; ~Facade() &#123; delete one; delete two; delete three; delete four; &#125; void MethorA() &#123; cout &lt;&lt; &quot;方法组A()&quot; &lt;&lt; endl; one-&gt;Methor1(); two-&gt;Methor2(); &#125; void MethorB() &#123; cout &lt;&lt; &quot;方法组B()&quot; &lt;&lt; endl; three-&gt;Methor3(); four-&gt;Methor4(); &#125;protected:private: SubSystem1 *one; SubSystem2 *two; SubSystem3 *three; SubSystem4 *four;&#125;;int main()&#123; Facade facade; facade.MethorA(); facade.MethorB(); return 0;&#125; 输出： 方法组A() 子系统方法一 子系统方法二 方法组B() 子系统方法三 子系统方法四 请按任意键继续. . . 案例 外观模式较为简单，实现上述模式依次实现电视、灯、音响、麦克风、DVD、游戏机即可，在此基础上实现外观类Facade（家庭影院）即可。 外观模式的优缺点 他对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，预支关联的对象也很少。 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。 一个子系统的修改对其他子系统没有任何影响。 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。 适用场景 复杂系统需要简单入口使用。 客户端程序与多个子系统之间存在很大的依赖性。 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。 适配器模式 将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 适配器模式中的角色和职责 Target（目标抽象类）：目标抽象类定义客户所需接口，可以使一个抽象类或接口，也可以是具体类。 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，他通过继承Target并关联一个Adaptee对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。 根据对象适配器模式结构图，在对象适配器中，客户端需要调用request()方法，而适配者类Adaptee没有该方法，但是它所提供的SpecificRequest()方法确实客户端所需要的。为了是客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的Request()方法中调用适配者的SpecificRequest()方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式。 案例 代码点击展开12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 适配器模式.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// targetclass V5&#123;public: virtual void uesV5() = 0;private:&#125;;class V220 &#123;public: virtual void useV220() &#123; cout &lt;&lt; &quot;用220V电压进行充电&quot; &lt;&lt; endl; &#125;&#125;;// Adapter 充电器class ChargerAdapter : public V5&#123;public: virtual void uesV5() &#123; cout &lt;&lt; &quot;充电器对电压进行适配&quot; &lt;&lt; endl; m_p220V.useV220(); &#125;protected:private: V220 m_p220V;&#125;;class Phone&#123;public: Phone() &#123; v5Adapter = new ChargerAdapter; &#125; ~Phone() &#123; if (v5Adapter != NULL) &#123; delete v5Adapter; v5Adapter = NULL; &#125; &#125; void charge() &#123; cout &lt;&lt; &quot;手机进行充电&quot; &lt;&lt; endl; v5Adapter-&gt;uesV5(); &#125;private: // 5v 手机充电器 V5 *v5Adapter;&#125;;int main()&#123; Phone iphone; iphone.charge(); return 0;&#125; 输出： 手机进行充电 充电器对电压进行适配 用220V电压进行充电 请按任意键继续. . . 适配器模式的优缺点 将目标类和适配者类解耦。通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。 增加了类的透明性和复用性。将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 灵活性和扩展性都非常好。可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 适配器中置换适配者类的某些方法比较麻烦。 适应场景 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。 到此，设计模式之结构型模式。over~~~😀🌝","raw":null,"content":null,"categories":[{"name":"程序员内功","slug":"程序员内功","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/"},{"name":"设计模式","slug":"程序员内功/设计模式","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.mingsrc.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式之创建型模式","slug":"A_程序员内功/B_设计模式/创建型模式","date":"2022-12-27T03:12:53.995Z","updated":"2022-12-27T07:02:00.440Z","comments":true,"path":"posts/3dfd8b5b.html","link":"","permalink":"https://www.mingsrc.work/posts/3dfd8b5b","excerpt":"设计模式\n 学习笔记之C++设计模式——创建型模式\n📑 设计模式之结构型模式 \n📑 设计模式之行为型模式\n","text":"设计模式 学习笔记之C++设计模式——创建型模式 📑 设计模式之结构型模式 📑 设计模式之行为型模式 一、工厂模式简单工厂模式代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &quot;main.h&quot;using namespace std;/* 定义一个水果抽象类。供具体水果实现，和工厂使用*/class Fruit &#123;public: virtual void getName() = 0;&#125;;class Apple : public Fruit&#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;我是苹果&quot; &lt;&lt; endl; &#125;&#125;;class Banana : public Fruit &#123;public: virtual void getName()&#123; cout &lt;&lt; &quot;我是香蕉&quot; &lt;&lt; endl; &#125;&#125;;//抽象的工厂类class AbstractFactory&#123;public: virtual Fruit * createFruit() = 0;&#125;;//通过具体的某一产品的工厂生产某种产品class AppleFactory : public AbstractFactory &#123;public: virtual Fruit * createFruit() &#123; return new Apple; &#125;&#125;;class BananaFactory : public AbstractFactory&#123;public: virtual Fruit * createFruit() &#123; return new Banana; &#125;&#125;;int main()&#123; //来一个香蕉工厂 AbstractFactory * bananaFactory = new BananaFactory; //给我来一个水果 Fruit * banana = bananaFactory-&gt;createFruit(); banana-&gt;getName(); delete bananaFactory; delete banana; AbstractFactory * appleFactory = new AppleFactory; Fruit * apple = appleFactory-&gt;createFruit; apple-&gt;getName(); system(&quot;pause&quot;); return 0;&#125; 类图 工厂模式的优缺点优点 不需要记住具体类名，甚至连具体参数都不用记忆。 实现了对象创建和使用的分离。 系统的可扩展性也就变得个非常好，无需修改接口和原类。 缺点 增加系统中类的个数，复杂度和理解度增加。 增加了系统的抽象性和理解难度。 二、抽象工厂模式 工厂方法模式通过引入工厂等级结构,解决了简单工厂模式中工厂类职责太重的问题,但由于工厂方法模式中的每个工厂只生产-产品，可能会导致系统中存在大量的工厂类,势必会增加系统的开销。此时,我们可以考虑将一些相关的产品组成一个”产品族”, 由同-个工厂来统-生产,这就是我们本文将要学习的抽象工厂模式的基本思想。 图例 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &quot;main.h&quot;using namespace std;//抽象产品类 供具体产地产品实现class AbstractApple &#123;public: virtual void getName() = 0;&#125;;class AbstractBanana &#123;public: virtual void getName() = 0;&#125;;class AbstractPear &#123;public: virtual void getName() = 0;&#125;;class USAApple : public AbstractApple &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;美国苹果&quot; &lt;&lt; endl; &#125;&#125;;class ChinaApple : public AbstractApple &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;中国苹果&quot; &lt;&lt; endl; &#125;&#125;;class JapanApple : public AbstractApple &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;日本苹果&quot; &lt;&lt; endl; &#125;&#125;;class USABanana : public AbstractBanana &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;美国香蕉&quot; &lt;&lt; endl; &#125;&#125;;class ChinaBanana : public AbstractBanana &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;中国香蕉&quot; &lt;&lt; endl; &#125;&#125;;class JapanBanana : public AbstractBanana &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;日本香蕉&quot; &lt;&lt; endl; &#125;&#125;;class USAPear : public AbstractPear &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;美国鸭梨&quot; &lt;&lt; endl; &#125;&#125;;class ChinaPear : public AbstractPear &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;中国鸭梨&quot; &lt;&lt; endl; &#125;&#125;;class JapanPear : public AbstractPear &#123;public: virtual void getName() &#123; cout &lt;&lt; &quot;日本鸭梨&quot; &lt;&lt; endl; &#125;&#125;;//抽象的工厂类，供具体产品族的实现class AbstractFactory &#123;public: virtual AbstractApple * creatApple() = 0; virtual AbstractBanana * creatBanana() = 0; virtual AbstractPear * creatPear() = 0;&#125;;//具体的工厂class USAFactory : public AbstractFactory &#123;public: virtual AbstractApple * creatApple() &#123; return new USAApple; &#125; virtual AbstractBanana * creatBanana() &#123; return new USABanana; &#125; virtual AbstractPear * creatPear() &#123; return new USAPear; &#125;&#125;;class ChinaFactory : public AbstractFactory &#123;public: virtual AbstractApple * creatApple() &#123; return new ChinaApple; &#125; virtual AbstractBanana * creatBanana() &#123; return new ChinaBanana; &#125; virtual AbstractPear * creatPear() &#123; return new ChinaPear; &#125;&#125;;class JapanFactory : public AbstractFactory &#123;public: virtual AbstractApple * creatApple() &#123; return new JapanApple; &#125; virtual AbstractBanana * creatBanana() &#123; return new JapanBanana; &#125; virtual AbstractPear * creatPear() &#123; return new JapanPear; &#125;&#125;;int main()&#123; //现在要准备一个 中国的苹果，中国的香蕉 AbstractApple *AA = NULL; AbstractBanana *AB = NULL; AbstractPear *AP = NULL; AbstractFactory *factory = NULL; factory = new ChinaFactory; //中国的苹果 AA = factory-&gt;creatApple(); //中国的香蕉 AB = factory-&gt;creatBanana(); AP = factory-&gt;creatPear(); AA-&gt;getName(); AB-&gt;getName(); AP-&gt;getName(); delete AA; delete AB; delete AP; delete factory; system(&quot;pause&quot;); return 0;&#125; 抽象工厂模式不符合“开闭原则” 抽象工厂模式的优缺点优点： 拥有工厂方法模式的优点 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 增加新的产品族很方便，无需修改已有系统，符合“开闭原则”。 缺点： 增加新的产品结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，带来较大的不便，违背了“开闭原则”。 抽象模式的应用：可以自己写一个计算机产品相关 简单工厂模式 + “开闭原则” = 工厂方法模式 工厂方法模式 + “产品族” = 抽象工厂模式 简单工厂模式（规模较小的模型） 工厂方法模式（中等） 抽象工厂模式（复杂的） 借鉴了《Easy搞定设计模式》 三 单例模式 保证一个类、只有一个实例存在，同时提供能对该实例加以访问的的全局访问方法。 三个要点：一是某个类只能有一个实例； 二是它必须自行创建这个实例； 三是它必须自行向整个系统提供这个实例。 角色和职责Singleton（单例）：在单例类的内部实现只生成一个实例，同时是他提供一个静态的getInstance()方法，让客户可以访问他的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。 单例模式的使用步骤 构造函数私有化 提供一个全局的静态方法（全局访问点） 来获取单例对象。 在类中定义一个静态指针，指向本类的变量的静态变量指针 饿汉模式理解主要就是为了只让类只有一个实例而把构造函数私有化。定义一个全局的静态实例。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;/*三个步骤： 1.构造函数私有化（为了不让在类的外部再创建多余的实例） 2.提供一个全局的静态类指针指向唯一实例 3.提供一个全局的静态函数获取实例*/class Singleton &#123;public: // 静态类函数 返回静态实例 static Singleton * getInstance() &#123; return instance; &#125;private: //不让类的外部创建实例 Singleton() &#123; Singleton *single = getInstance(); &#125; Singleton getsingle() &#123; &#125; static Singleton * instance; //指向本类的唯一实例指针&#125;;//静态类变量在类外初始化Singleton*Singleton::instance = new Singleton;int main()&#123; //通过getInstance()获取实例 Singleton * s1 = Singleton::getInstance(); system(&quot;pause&quot;); return 0;&#125; 懒汉模式在程序执行期间再去判断是否需要实例。 1234567891011121314151617181920class Singleton1 &#123;public: //提供一个返回实例的方法 static Singleton1 * getInstance() &#123; // 不确定程序在编译期间是否需要实例 // 如果是多线程下，需要在这里加锁 if (instance1 == NULL) &#123; instance1 = new Singleton1; &#125; // 释放锁 cout &lt;&lt; &quot;Singleton1&quot; &lt;&lt; endl; return instance1; &#125;private: Singleton1() &#123; &#125; static Singleton1 *instance1;&#125;;//懒汉式的初始化方式 饿汉式在初始化时已经指向了singletonSingleton1 * Singleton1::instance1 = NULL; 针对单例模式去判断是否是同一实例 123456Singleton *s1 = Singleton::getinstace();Singleton *s2 = Singleton::getinstace();if (s1 == s2 ) cout &lt;&lt; &quot;s1 == s2&quot; &lt;&lt; endl;else cout &lt;&lt; &quot;s1 != s2&quot; &lt;&lt; endl; 单例模式的应用——打印机用单例模式实现一个打印机程序，用以记录打印的次数和内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Printer &#123;public: static Printer * getinstance() &#123; return instance; &#125; void print(string text) &#123; cout &lt;&lt; &quot;打印的内容为：&quot; &lt;&lt; text &lt;&lt; endl; sequence++; cout &lt;&lt; &quot;打印机今天使用了&quot; &lt;&lt; sequence &lt;&lt; &quot;次&quot; &lt;&lt; endl; &#125; static int getSequence() &#123; return sequence; &#125;private: // 定义一个类去析构单例 class Garbo &#123; private: ~Garbo() &#123; if (instance != NULL) &#123; delete instance; &#125; &#125; &#125;; static Garbo garbo; // 在静态区域开辟一个对象，Garbo static int sequence; static Printer * instance;&#125;;int Printer::sequence = 0;Printer *Printer::instance = new Printer;Printer::Garbo Printer::garbo;int main()&#123; //三个peple使用打印机 Printer * p1 = Printer::getinstance(); p1-&gt;print(&quot;亿封简历&quot;); Printer *p2 = Printer::getinstance(); p2-&gt;print(&quot;一份工作汇报&quot;); Printer *p3 = Printer::getinstance(); p3-&gt;print(&quot;离职申请&quot;); system(&quot;pause&quot;); return 0;&#125; 以上就是几种常见的创建型设计模式。","raw":null,"content":null,"categories":[{"name":"程序员内功","slug":"程序员内功","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/"},{"name":"设计模式","slug":"程序员内功/设计模式","permalink":"https://www.mingsrc.work/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.mingsrc.work/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"树🌳","slug":"H_Coding/力扣自刷/树","date":"2020-10-29T02:07:52.378Z","updated":"2020-11-13T01:22:30.434Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://www.mingsrc.work/posts/undefined","excerpt":"刷题目录求根到叶子节点数字之和\n检查平衡性","text":"刷题目录求根到叶子节点数字之和 检查平衡性 求根到叶子节点数字之和129. 求根到叶子节点数字之和给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1: 123456789输入: [1,2,3] 1 / \\ 2 3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25. 示例 2: 123456789101112输入: [4,9,0,5,1] 4 / \\ 9 0 / \\5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026. 代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int dfs(TreeNode *root,int data) &#123; if(root == nullptr)&#123; return 0; &#125; int sum = data * 10 + root-&gt;val; if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) &#123; return sum; &#125; else &#123; return dfs(root-&gt;left, sum) + dfs(root-&gt;right, sum); &#125; &#125; int sumNumbers(TreeNode* root) &#123; return dfs(root,0); &#125;&#125;; 检查平衡性面试题 04.04. 检查平衡性实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。 12345678910111213141516171819202122class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if (root == NULL) return true; int lh = height(root-&gt;left); int rh = height(root-&gt;right); if (abs(lh-rh) &gt; 1) &#123; return false; &#125; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125; int height(TreeNode* root) &#123; if (root == NULL) return 0; int lh = height(root-&gt;left); int rh = height(root-&gt;right); return lh&gt;rh?lh+1:rh+1; &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://www.mingsrc.work/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"二叉树","slug":"H_Coding/力扣自刷/二叉树","date":"2020-10-27T07:39:14.523Z","updated":"2020-10-27T13:20:13.413Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://www.mingsrc.work/posts/undefined","excerpt":"二叉树二叉树的前序遍历\n平衡二叉树","text":"二叉树二叉树的前序遍历 平衡二叉树 二叉树的前序遍历44. 二叉树的前序遍历 给定一个二叉树，返回它的 前序 遍历。 示例: 123456789输入: [1,null,2,3] 1 \\ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: void preoreder(TreeNode *root,vector&lt;int&gt; &amp;res)&#123; if(root == nullptr)&#123; return; &#125; res.push_back(root-&gt;val); preoreder(root-&gt;left,res); preoreder(root-&gt;right,res); &#125; vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; preoreder(root,res); return res; &#125;&#125;; 平衡二叉树110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int height(TreeNode* root)&#123; if(root == NULL) return 0; else return max(height(root-&gt;left),height(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if(root == NULL) return true; else return abs(height(root-&gt;left)-height(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;;","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"二叉树","slug":"二叉树","permalink":"https://www.mingsrc.work/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"回溯","slug":"H_Coding/力扣自刷/HS回溯","date":"2020-10-25T13:04:53.197Z","updated":"2021-05-10T01:25:39.060Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://www.mingsrc.work/posts/undefined","excerpt":"副本文件回溯17. 电话号码的字母组合\n22. 括号生成","text":"副本文件回溯17. 电话号码的字母组合 22. 括号生成 电话号码的字母组合17. 电话号码的字母组合 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 12345678910111213141516171819202122232425262728293031public: map&lt;char, string&gt; M = &#123; &#123;&#x27;2&#x27;,&quot;abc&quot;&#125;,&#123;&#x27;3&#x27;,&quot;def&quot;&#125;, &#123;&#x27;4&#x27;,&quot;ghi&quot;&#125;,&#123;&#x27;5&#x27;,&quot;jkl&quot;&#125;,&#123;&#x27;6&#x27;,&quot;mno&quot;&#125;, &#123;&#x27;7&#x27;,&quot;pqrs&quot;&#125;,&#123;&#x27;8&#x27;,&quot;tuv&quot;&#125;,&#123;&#x27;9&#x27;,&quot;wxyz&quot;&#125; &#125;; vector&lt;string&gt; ans; string current; void DFS(int index ,string digits) &#123; if (index == digits.size()) &#123; ans.push_back(current); return; &#125; for (int i = 0; i &lt; M[digits[index]].size();i++) &#123; current.push_back(M[digits[index]][i]); DFS(index + 1, digits); current.pop_back(); &#125; &#125; vector&lt;string&gt; letterCombinations(string digits) &#123; if (digits.size() == 0) return ans; DFS(0, digits); return ans; &#125;&#125;; 括号生产22. 括号生成数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 输入：n &#x3D; 3输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”] 示例 2： 输入：n &#x3D; 1输出：[“()”] 提示：1 &lt;&#x3D; n &lt;&#x3D; 8 123456789101112131415161718192021222324252627282930313233343536373839404142434445// dfs生成/*理解为二叉树的每个节点括号交替*//*void dfs(int n, string str, vector&lt;string&gt;&amp; res) &#123; if (str.length() == 2 * n) &#123; res.push_back(str); return; &#125; dfs(n, str + &#x27;(&#x27;, res); dfs(n, str + &#x27;)&#x27;, res);&#125;*/// 括号生成、剪枝策略void dfs(int n, string str, vector&lt;string&gt;&amp; res, int open, int close) &#123; if (open &gt; n || close &gt; open) return; if (str.length() == 2 * n) &#123; res.push_back(str); return; &#125; dfs(n, str + &#x27;(&#x27;, res,open + 1, close); dfs(n, str + &#x27;)&#x27;, res,open,close + 1);&#125;// 括号生成vector&lt;string&gt; generateParenthesis(int n)&#123; vector&lt;string&gt; res; if (n &lt;= 0) return res; dfs(n, &quot;&quot;, res,0,0); return res;&#125;int main()&#123; vector&lt;string&gt; ans = generateParenthesis(2); for (auto i : ans) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; system(&quot;pause&quot;);&#125;","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"回溯","slug":"回溯","permalink":"https://www.mingsrc.work/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"copy(自刷)","slug":"H_Coding/力扣自刷/copy","date":"2020-10-13T08:35:14.986Z","updated":"2020-10-13T14:27:50.121Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://www.mingsrc.work/posts/undefined","excerpt":"副本文件题目一","text":"副本文件题目一 题目一","raw":null,"content":null,"categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"刷题笔记/C","permalink":"https://www.mingsrc.work/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.mingsrc.work/tags/%E7%AE%97%E6%B3%95/"},{"name":"力扣","slug":"力扣","permalink":"https://www.mingsrc.work/tags/%E5%8A%9B%E6%89%A3/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://www.mingsrc.work/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"}]},{"title":"创建表","slug":"E_学习笔记/数据库/Oracle/实验二、创建表","date":"2020-10-12T05:28:08.821Z","updated":"2020-11-12T01:19:30.847Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://www.mingsrc.work/posts/undefined","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Oracle数据库","slug":"学习笔记/Oracle数据库","permalink":"https://www.mingsrc.work/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.mingsrc.work/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"Oracle","permalink":"https://www.mingsrc.work/tags/Oracle/"}]}]}