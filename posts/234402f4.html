<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>🎨剑指offer🎨 | 欧恩意</title><meta name="keywords" content="C++,力扣"><meta name="author" content="mingming.shi"><meta name="copyright" content="mingming.shi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="🎨剑指offer🎨">
<meta property="og:type" content="article">
<meta property="og:title" content="🎨剑指offer🎨">
<meta property="og:url" content="https://www.mingsrc.work/posts/234402f4">
<meta property="og:site_name" content="欧恩意">
<meta property="og:description" content="🎨剑指offer🎨">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg">
<meta property="article:published_time" content="2020-09-24T22:43:12.766Z">
<meta property="article:modified_time" content="2021-11-21T13:29:22.135Z">
<meta property="article:author" content="mingming.shi">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="力扣">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg"><link rel="shortcut icon" href="/../../../images/Logo.png"><link rel="canonical" href="https://www.mingsrc.work/posts/234402f4"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式🌙🌙","night_to_day":"你已切换为浅色模式🌝🌝","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '🎨剑指offer🎨',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-21 21:29:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/hbe.style.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/var.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/taglink.css"><link rel="stylesheet" href="/css/hideCategory.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/code.css"><link rel="stylesheet" href="/css/buttons.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/font-awesome.css"><link rel="stylesheet" href="/css/title.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/all.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/v4-shims.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><link href="https://.googleapis.com/css2?family=Noto+Serif+SC:wght@400;900&display=swap" rel="stylesheet" media="print" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="欧恩意" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/../../../images/me.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">196</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">103</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">61</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ming/"><i class="fa-fw fa-fw fas fa-desktop faa-vertical animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-fw fas fa-home faa-vertical animated-hover"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-book faa-pulse animated-hover"></i><span> 找文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive faa-tada animated-hover"></i><span> 时间</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags faa-tada animated-hover"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open faa-tada animated-hover"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat faa-pulse animated-hover"></i><span> 清单</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-flask faa-vertical animated-hover"></i><span> 皮一下</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/test/demo"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试</span></a></li><li><a class="site-page child" href="/player/"><i class="fa-fw fa fa-play-circle"></i><span> 播放器</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-vertical animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link faa-tada animated-hover"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">欧恩意</a></span><div id="menus"><button id="darkmodebutton" type="button" title="浅色和深色模式转换"><a class="site-page social-icon search"><i class="fas fa-adjust fa-fw"></i></a></button><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ming/"><i class="fa-fw fa-fw fas fa-desktop faa-vertical animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-fw fas fa-home faa-vertical animated-hover"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-book faa-pulse animated-hover"></i><span> 找文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive faa-tada animated-hover"></i><span> 时间</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags faa-tada animated-hover"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open faa-tada animated-hover"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat faa-pulse animated-hover"></i><span> 清单</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-flask faa-vertical animated-hover"></i><span> 皮一下</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/test/demo"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试</span></a></li><li><a class="site-page child" href="/player/"><i class="fa-fw fa fa-play-circle"></i><span> 播放器</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-vertical animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link faa-tada animated-hover"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">🎨剑指offer🎨</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-24T22:43:12.766Z" title="发表于 2020-09-25 06:43:12">2020-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-21T13:29:22.135Z" title="更新于 2021-11-21 21:29:22">2021-11-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/">大神们の笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/github/">github</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>103分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="🎨剑指offer🎨"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="🎨剑指offer🎨"><a href="#🎨剑指offer🎨" class="headerlink" title="🎨剑指offer🎨"></a>🎨剑指offer🎨</h1><span id="more"></span>



<ul>
<li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">1.数组中重复的数字</a></li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">2.二维数组中的查找</a></li>
<li><a href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">3.替换空格</a></li>
<li><a href="#%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">4.从尾到头打印链表</a></li>
<li><a href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">5.重建二叉树</a></li>
<li><a href="#%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">6.用两个栈实现队列</a></li>
<li><a href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">7.斐波那契数列</a></li>
<li><a href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98">8.青蛙跳台阶问题</a></li>
<li><a href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">9.旋转数组的最小数字</a></li>
<li><a href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">10.矩阵中的路径</a></li>
<li><a href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4">11.机器人的运动范围</a></li>
<li><a href="#%E5%89%AA%E7%BB%B3%E5%AD%90">12.剪绳子</a></li>
<li><a href="#%E5%89%AA%E7%BB%B3%E5%AD%90II">13.剪绳子II</a></li>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">14.二进制中1的个数</a></li>
<li><a href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9">15.数值的整数次方</a></li>
<li><a href="#%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0">16.打印从1到最大的n位数</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9">17.删除链表的节点</a></li>
<li><a href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2">18.调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">19.链表中倒数第k个节点</a></li>
<li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">20.反转链表</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">21.合并两个排序的链表</a></li>
<li><a href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">22.树的子结构</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F">23.二叉树的镜像</a></li>
<li><a href="#%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91">24.对称的二叉树</a></li>
<li><a href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5">25.顺时针打印矩阵</a></li>
<li><a href="#%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88">26.包含min函数的栈</a></li>
<li><a href="#%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97">27.栈的压入、弹出序列</a></li>
<li><a href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">28.从上到下打印二叉树</a></li>
<li><a href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91II">29.从上到下打印二叉树II</a></li>
<li><a href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91III">30.从上到下打印二叉树III</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97">31.二叉搜索树的后序遍历序列</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84">32.二叉树中和为某一值的路径</a></li>
<li><a href="#%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">33.复杂链表的复制</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">34.二叉搜索树与双向链表</a></li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91">35.序列化二叉树</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97">36.字符串的排列</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97">37.数组中出现次数超过一半的数字</a></li>
<li><a href="#%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0">38.最小的k个数</a></li>
<li><a href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">39.连续子数组的最大和</a></li>
<li><a href>40.连续子数组的最大和</a></li>
<li><a href="#1%EF%BD%9En%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">41.1～n整数中1出现的次数</a></li>
<li><a href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0">42.把数组排成最小的数</a></li>
<li><a href="#%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2">43.把数字翻译成字符串</a></li>
<li><a href="#%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC">44.礼物的最大价值</a></li>
<li><a href="#%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2">45.最长不含重复字符的子字符串</a></li>
<li><a href="#%E4%B8%91%E6%95%B0">46.丑数</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6">47.第一个只出现一次的字符</a></li>
<li><a href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9">48.两个链表的第一个公共节点</a></li>
<li><a href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97I">49.在排序数组中查找数字I</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9">50.二叉搜索树的第k大节点</a></li>
<li><a href="#0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97">51.0～n-1中缺失的数字</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">52.二叉树的深度</a></li>
<li><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">53.平衡二叉树</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">54.数组中数字出现的次数</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0II">55.数组中数字出现的次数II</a></li>
<li><a href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97">56.和为s的两个数字</a></li>
<li><a href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97">57.和为s的连续正数序列</a></li>
<li><a href="#%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F">58.翻转单词顺序</a></li>
<li><a href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">59.左旋转字符串</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC">60.滑动窗口的最大值</a></li>
<li><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC">61.队列的最大值</a></li>
<li><a href="#n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0">62.n个骰子的点数</a></li>
<li><a href="#%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90">63.扑克牌中的顺子</a></li>
<li><a href="#%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97">64.圆圈中最后剩下的数字</a></li>
<li><a href="#%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6">65.股票的最大利润</a></li>
<li><a href="#%E6%B1%821+2+%E2%80%A6+n">66.求1+2+…+n</a></li>
<li><a href="#%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95">67.不用加减乘除做加法</a></li>
<li><a href="#%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84">68.构建乘积数组</a></li>
<li><a href="#%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0">69.把字符串转换成整数</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">70.二叉搜索树的最近公共祖先</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">71.二叉树的最近公共祖先</a></li>
<li><a href="#%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97">72.数字序列中某一位的数字</a></li>
</ul>
<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">leetcode</a> 找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h3 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h3><ul>
<li>建立哈希表或者数组记录数字出现次数，大于1就返回<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> cnt[<span class="hljs-number">100000</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cnt[nums[i]]++;<br>        <span class="hljs-keyword">if</span> (cnt[nums[i]] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h3></li>
<li>先排序，遍历发现前后两个值一样，就是重复的数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[i <span class="hljs-number">-1</span> ]) <span class="hljs-keyword">return</span> nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">leetcode</a>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一般规律性很强的矩阵，数列，一定要找一个关键位置的数字，作为比较，用这个数字能够完成一部分筛选</li>
<li>例如本题的左下角，因为他是本行的最小值，所以如果<code>target</code>比他还要小，说明target一定不在此行。他又是本列的最大值，如果<code>target</code>比他还要大，那target一定不在这一列。通过这样可以筛选掉一行或者一列。</li>
<li>直到左下角的值等于target时结束。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[row][col] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target) row--;<br>        <span class="hljs-keyword">else</span> col++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>方法二：因为是有序数组，就想到二分查找，每一行都使用二分法找target,但是此方法没有利用列得有序性  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(matrix, i, target)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix[row].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (matrix[row][mid] &lt; target) left = mid + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][mid] &gt; target) right = mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][mid] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> matrix[row][left] == target;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">leetcode</a>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;We are happy.&quot;<br>输出：&quot;We%20are%20happy.&quot;<br></code></pre></td></tr></table></figure>
<p>限制：<br>0 &lt;= s 的长度 &lt;= 10000</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>方法1：遍历找到空格，删除空格，插入新字符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            s.<span class="hljs-built_in">erase</span>(i, <span class="hljs-number">1</span>);<br>            s.<span class="hljs-built_in">insert</span>(i, <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;%20&quot;</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>方法2：使用额外空间，创建空字符，遇到空格就push新字符，非空格push正常字符。</li>
<li>注意 <code>？a ：b</code>运算符中a和b必须属于同一类型，<code>“%20”</code>是const char*类型，而<code>ch</code>属于char类型，只能用以下形式来写。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : s) <br>        ans = (ch == <span class="hljs-string">&#x27; &#x27;</span>) ? ans + <span class="hljs-string">&quot;%20&quot;</span> : ans + ch ;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br>    string res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            res += <span class="hljs-string">&quot;%20&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res += s[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>如果面试官要求不能使用额外得空间，实现原地修改，可以先统计空格数量，再原字符串后添加足够长得空间<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) cnt++;<br>    &#125;<br>    s += <span class="hljs-built_in">string</span>(cnt * <span class="hljs-number">2</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-keyword">int</span> p1 = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> p2 = len - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p2 &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (s[p2] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            s[p1--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            s[p1--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            s[p1--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            s[p1--] = s[p2];<br>        &#125;<br>        p2--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">leetcode</a>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>反转一般想到头插法或者栈实现<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>     ListNode* pre = <span class="hljs-literal">NULL</span>;<br>     ListNode* cur = head;<br>     <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>         ListNode * tmp = cur-&gt;next;<br>         cur-&gt;next = pre;<br>         pre = cur;<br>         cur = tmp;<br>     &#125;<br>     vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>     <span class="hljs-keyword">while</span> (pre != <span class="hljs-literal">NULL</span>) &#123;<br>         res.<span class="hljs-built_in">push_back</span>(pre-&gt;val);<br>         pre = pre-&gt;next;<br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125; <br></code></pre></td></tr></table></figure></li>
<li>用栈反转<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; sck;<br>    <span class="hljs-keyword">while</span> (head) &#123;<br>        sck.<span class="hljs-built_in">push</span>(head-&gt;val);<br>        head = head-&gt;next;<br>    &#125;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span> (!sck.<span class="hljs-built_in">empty</span>()) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(sck.<span class="hljs-built_in">top</span>());<br>        sck.<span class="hljs-built_in">pop</span>(); <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>最low 的方法是用遍历链表，输出每个结点的值到数组中，然后用reverse()进行反转。  </li>
</ul>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">leetcode</a>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">前序遍历 preorder &#x3D; [3,9,20,15,7]<br>中序遍历 inorder &#x3D; [9,3,15,20,7]<br></code></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">  3<br> &#x2F; \<br>9  20<br>  &#x2F;  \<br> 15   7<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>新建/改变树结构的，在递归函数中一定要新建<code>root</code>结点并给<code>root-&gt;left</code>和<code>root-&gt;right</code>赋值。</li>
<li>用两个指针在树中遍历时：结束条件就是<code>left &gt; right</code>,<code>left=right</code>是最后一个结点或者说叶子节点。</li>
<li>新建树一定是先序遍历，先建立根再建立左右子树，递归函数的参数表示，<code>pre_root</code>根结点再先序列中的索引，<code>in_left</code>中序列中左子树左边界 <code>in_right </code>中序列中右子树右边界。</li>
<li>根节点都是从先序中找，第一个结点一定是根，根后一个结点一定是左子树的根节点，根后+左子树大小+1就是右子树的根结点。</li>
<li>左子树的大小则通过中序遍历得到，因为在中序列中根节点左边全是左子树的结点。</li>
<li>因为涉及根据值取他得索引，所以事先要建立id映射表<code>idHash</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; idHash;<br>  vector&lt;<span class="hljs-keyword">int</span>&gt; pre;<br>  <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>      pre = preorder;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>          idHash[inorder[i]] = i;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTree</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pre_root, <span class="hljs-keyword">int</span> in_left, <span class="hljs-keyword">int</span> in_right)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (in_left &gt; in_right) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>      TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[pre_root]);<br>      <span class="hljs-keyword">int</span> in_root = idHash[pre[pre_root]];<br>      root-&gt;left = <span class="hljs-built_in">buildTree</span>(pre_root + <span class="hljs-number">1</span>, in_left, in_root - <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 左节点个数是：in_root - in_left + 1 经常容易写错</span><br>      root-&gt;right = <span class="hljs-built_in">buildTree</span>(pre_root + in_root - in_left + <span class="hljs-number">1</span>, in_root + <span class="hljs-number">1</span>, in_right);<br>      <span class="hljs-keyword">return</span> root;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">leetcode</a><br>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>插入时，按正常入栈，但弹出时需要从最先入栈的即栈底开始，所以要用到辅助栈，将栈底元素倒出来到辅助栈的栈顶</li>
<li>只有当辅助栈的元素全部弹空后，再开始新一轮从数据栈往辅助栈倒</li>
<li>两个栈都为空时，才是真的空了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-keyword">int</span>&gt; sck1;<br>stack&lt;<span class="hljs-keyword">int</span>&gt; sck2;<br><span class="hljs-built_in">CQueue</span>() &#123; &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    sck1.<span class="hljs-built_in">push</span>(value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sck2.<span class="hljs-built_in">empty</span>() &amp;&amp; sck1.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (sck2.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (!sck1.<span class="hljs-built_in">empty</span>()) &#123;<br>            sck2.<span class="hljs-built_in">push</span>(sck1.<span class="hljs-built_in">top</span>());<br>            sck1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> front = sck2.<span class="hljs-built_in">top</span>();<br>    sck2.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> front;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">leetcode</a><br>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下,斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>经典的动规问题，出了前两个元素，其他任意一个元素值都与他的前两个元素相关，所以状态方程为：<code>dp[i] = dp[i -1] + dp[i -2]</code></li>
<li>注意答案要取模<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dp[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> dp[i] = (dp[i - <span class="hljs-number">1</span>]  + dp[i - <span class="hljs-number">2</span>]) % <span class="hljs-number">1000000007</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>如果面试管要求较少的空间，可以只需要三个变量，实时记录当前值，他的前一个值和前二个值，每次遍历都进行一个更新。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>, second = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> ans = n == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        ans = (first + second) % <span class="hljs-number">1000000007</span>;<br>        first = second;<br>        second = ans;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">leetcode</a><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>PS:为什么要模1000000007（跟我念，一，八个零，七）,int64位的最大值为2^63-1，用最大值模1000000007的结果求平方，不会在int64中溢出。<br>所以在大数相乘问题中,相乘时两边都对1000000007取模，保存在int64里面不会溢出.</li>
<li>建立dp数组建立跳到当前台阶的方法数，那么对于任意台阶，可以从他前一个台阶或者前两个台阶跳到，状态方程为：’dp[i] = dp[i - 1] + dp[i - 2]’  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dp[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span> dp[i] = (dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]) % <span class="hljs-number">1000000007</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>节省空间的做法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> first = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> second = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>        res = (first + second) % <span class="hljs-number">1000000007</span>;<br>        first = second;<br>        second = res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">leetcode</a><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>典型的二分查找，要查找的数左右两边的特点，他的左边都是大于数组的最后一个数，他的右边都是小于数组最后一个数。</li>
<li>本题的不同之处在于存在重复数字，所以会出现mid所指与right所指之数相等，导致无法判断最小值出现在mid左边还是右边，因此需要删除一个重复值，暴力的缩小范围。<code>right--</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[right]) left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[right]) right = mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == nums[right]) right--;                           <br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[left];<br>&#125;  <br></code></pre></td></tr></table></figure></li>
<li>暴力法：遍历整个数组，如果发现后面一个数小于前面一个数，说明找到了分界点。</li>
<li>如果没有找到分界点，说明整个数组都是一个数重复，就返回第一个数即可。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; numbers.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (numbers[i] &gt; numbers[i + <span class="hljs-number">1</span>]) <br>            <span class="hljs-keyword">return</span> numbers[i + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">leetcode</a><br>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。<br>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]<br>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>本题第一想到DFS或BFS</li>
<li>使用DFS时应该注意递归结束条件有哪些：坐标越界、已经访问过、递归的深度超过word长度、字符不等于word对应位置的字符。</li>
<li>这里介绍另一种标记已访问过的方法：就是访问时将数组中的数字提取出来，原位置用其他不常用字符代替，因为递归时只访问word中字符，所以访问过的一定不会再访问，递归结束后记得回复原样（不恢复也行）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, i, j, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; b, string&amp; w, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= b.<span class="hljs-built_in">size</span>() || i &lt; <span class="hljs-number">0</span> || j &gt;= b[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || j &lt; <span class="hljs-number">0</span> || b[i][j] != w[k])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (k == w.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">char</span> temp = b[i][j];<br>        b[i][j] = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> q = <span class="hljs-number">0</span>; q &lt; <span class="hljs-number">4</span>; q ++ ) &#123;<br>            <span class="hljs-keyword">int</span> m = i + dx[q], n = j + dy[q];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(b, w, m, n, k + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        b[i][j] = temp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>第二版解题思路，类似此类问题：通过dfs在多条路径中寻找其中一条满足条件的路径。</li>
<li>注意：第一次通过遍历先发现头节点，再根据次节点展开深度递归，记录路径长度或者储存路径信息的变量都要再每次dfs前重新定义。</li>
<li>注意：每次递归完要恢复isVis标志位。只有一种情况不需要恢复就是，只从一个节点开始dfs，只需要找到一条满足的路径即可，不需要回溯。</li>
<li>dfs模板：先判断是否已经访问，再写递归结束的条件，最后只有满足一定条件的子节点才进行dfs。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> off[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; isVis;<br>string word;<br>vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt; board;<br><span class="hljs-keyword">int</span> row;<br><span class="hljs-keyword">int</span> col;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>    row = board.<span class="hljs-built_in">size</span>();<br>    col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">this</span>-&gt;isVis.<span class="hljs-built_in">resize</span>(row, vector&lt;<span class="hljs-keyword">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">this</span>-&gt;board = board;<br>    <span class="hljs-keyword">this</span>-&gt;word = word;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == word[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i, j, depth)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;  <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> depth)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isVis[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    isVis[x][y] = <span class="hljs-literal">true</span>;<br>    cout &lt;&lt; board[x][y];<br>    <span class="hljs-keyword">if</span> (depth == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> m = x + off[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> n = y + off[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (m &lt; row &amp;&amp; m &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt; col &amp;&amp; n &gt;= <span class="hljs-number">0</span> &amp;&amp; board[m][n] == word[depth + <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(m, n, depth + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    isVis[x][y] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">leetcode</a><br>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>此题的难度在于理解上面，并不是暴力的遍历全部结点，判断哪个符合条件，因为题目时运动范围即，所以符合要求的结点都时连接在一起的。</li>
<li>因为数组中的值仅仅为两位数，因此’ x / 10 + x %10’就是个位与十位的数位和</li>
<li>这里用了一个二维数组记录访问过的结点，一定要初始化二维数组。</li>
<li>因为本题求得是机器人得运动范围，不是求某一最长得路径，因此再dfs结束后不需要回复isVis数组。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> m, n, k;<br><span class="hljs-keyword">int</span> off[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-keyword">bool</span>** isVis;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m = m;<br>    <span class="hljs-keyword">this</span>-&gt;n = n;<br>    <span class="hljs-keyword">this</span>-&gt;k = k;<br><br>    isVis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>*[m];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        isVis[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[n];<br>        <span class="hljs-built_in">memset</span>(isVis[i], <span class="hljs-number">0</span>, n * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">bool</span>));<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, isVis);<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">bool</span>** isVis)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isVis[i][j]) <span class="hljs-keyword">return</span>;<br>    isVis[i][j] = <span class="hljs-literal">true</span>;<br>    cnt++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>; z &lt; <span class="hljs-number">4</span>; ++z) &#123;<br>        <span class="hljs-keyword">int</span> x = i + off[z][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> y = j + off[z][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp;<br>           (x / <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span> + y / <span class="hljs-number">10</span> + y % <span class="hljs-number">10</span> &lt;= k)) <br>                <span class="hljs-built_in">dfs</span>(x, y, isVis);      <br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">leetcode</a><br>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入: 2<br>输出: 1<br>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1<br><br>输入: 10<br>输出: 36<br>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>贪心+暴力解决  </li>
<li>要想积最大，每段长度都尽量相等或接近就行，首先想到用平均值avg，如果平均下来有剩余值，就降剩余值再平均前面每个值上，就变avg + 1，所以最终分段完每段的长度不是avg就是avg + 1</li>
<li>设分了m段,那么余数有多少，就有多少个avg + 1,剩下的就是avg</li>
<li>pow(int num, int exp);求乘方函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">2</span>; m &lt;=n; ++m) &#123;<br>        <span class="hljs-keyword">int</span> avg = n / m; <br>        <span class="hljs-keyword">int</span> sum = n % m ? <span class="hljs-built_in">pow</span>(avg, m - n % m) * <span class="hljs-built_in">pow</span>(avg + <span class="hljs-number">1</span>, n % m) : <span class="hljs-built_in">pow</span>(avg, m);<br>        res = <span class="hljs-built_in">max</span>(res, sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剪绳子II"><a href="#剪绳子II" class="headerlink" title="剪绳子II"></a>剪绳子II</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">leetcode</a><br>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>本题与上一题得区别在于存在大数操作，<code>2 &lt;= n &lt;= 1000</code></li>
<li>对于本题需要了解数学知识，要想使成绩最大化，就需要将绳子尽可能的多分段，因此每段长度有，1，2，3中长度考虑，1显然不行，2或3中，3更合适，因此此题就变为求3的幂操作。</li>
<li>幂操作因为指数级别的增加，很容易溢出int32甚至int64，所以为了不让溢出，就需要对幂结果求余，采用分割后分别求余。</li>
<li>循环求幂：大数取余满足分配律，<code>(xy)⊙p=[(x⊙p)(y⊙p)]⊙p</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">4</span>) &#123;<br>        res = res * <span class="hljs-number">3</span> % <span class="hljs-number">1000000007</span>;<br>        n -= <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res * n % <span class="hljs-number">1000000007</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>方法二，用贪心+快速幂指法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickPow</span>(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span> % <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickPow</span>(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * (b + <span class="hljs-number">3</span>) % <span class="hljs-number">1000000007</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> t = x;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) <br>            res = res * t % <span class="hljs-number">1000000007</span>;<br>        t = t * t % <span class="hljs-number">1000000007</span>;<br>        n /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>三种方法：1、掩码为1，让数子<code>(num &amp; 1)</code> 判断num二进制形式的最后一位是否是1，<code>num &gt;&gt;= 1</code>让num二进制数右移一位，就可以实现逐位判断。</li>
<li>2、方法一通过不断右移num，还可以不断左移掩码1来判断</li>
<li>3、 反转num的最后一位，记录反转次数 反转’n &amp;= n -1’<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) cnt++;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">uint32_t</span> mask = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; mask) cnt++;<br>        mask &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        n &amp;= n - <span class="hljs-number">1</span>;<br>        cnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">leetcode</a><br>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>如果采用whie(exp–)根据指数个数不断求积的方式计算，对于指数很大的数可能会超时，因此使用快速求幂算法</p>
</li>
<li><p>核心就是通过指数的二进制形式，将指数进行的分解，例如（<code>x^9</code> 指数为<code>9</code>，二进制是:1001, 那么<code>9 = 2^3 + 2^0</code>, 所以<code>x^9 = x^8 * x^1</code> )</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">bool</span> isPositive = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">long</span> t = n;<br>    <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = -t, isPositive = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">double</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (t) &#123;<br>        <span class="hljs-keyword">if</span> (t &amp; <span class="hljs-number">1</span>) res *= x; <br>        x *= x;<br>        t &gt;&gt;= <span class="hljs-number">1</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> isPositive ? res : (<span class="hljs-number">1</span> / res);<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>其中用到了用移位<code>t &gt;&gt;= 1</code>,</p>
</li>
<li><p>注意能够使用的前提是<code>t</code>不能是负数（因为负数用的是补码），因此之前现做绝对化处理,但是力扣的用例中使用了<code>n = -2147483648</code>这个数，int的取值范围是-2147483648到2147483647，但-2147483648取绝对值2147483648超出int范围，所以需要long去接他。</p>
</li>
<li><p>可以用除法 n /= 2来代替，就不会有如上问题,也不同考虑符数问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> t = n;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= x;<br>        x *= x;<br>        n /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t &gt; <span class="hljs-number">0</span> ? res : <span class="hljs-number">1</span> / res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>使用递归思想，易理解,因为只有<code>n</code>在递归中发送变化，因此结束条件只考虑n的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / x;<br>    <span class="hljs-keyword">double</span> half = <span class="hljs-built_in">myPow</span>(x, n / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">double</span> mod = <span class="hljs-built_in">myPow</span>(x, n % <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> half * half * mod;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">leetcode</a><br>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入: n &#x3D; 1<br>输出: [1,2,3,4,5,6,7,8,9]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>此题相对书上的做了简化，因为已经给出返回值是int型，所以用例中不会有大数，就简单很多</li>
<li>关键在于找到最大值，然后遍历打印即可</li>
<li>可以用pow(10, n)来确定最大边界。</li>
<li>我这里提供另一种算法：例如3位数，那么最大值就是999，4位数最大9999。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span> (n--) &#123;   <br>        cnt = cnt * <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; ++i) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">leetcode</a>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。</p>
<ul>
<li>删除某个结点的前提一定是找到他的前驱和要删除的结点，因此需要两个指针。</li>
<li>改变链表的操作，有可能会删除第一个结点，因此需要一个头节点作为第一个结点的前驱，来统一化操作。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode* cur = head;<br>    ListNode* pre = dummy;<br>    <span class="hljs-keyword">while</span> (cur-&gt;val != val) &#123;<br>        cur = cur-&gt;next;<br>        pre = pre-&gt;next;<br>    &#125;<br>    pre-&gt;next = cur-&gt;next;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">leetcode</a><br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>思路来自于快排的挖坑法，定义两个头尾指针，把最后一个数挖走，然后left指针遍历直到发现一个偶数，就把这个偶数挖走放到最后的坑里，再用right往前遍历，直到发现一个奇数，挖走放到前面那个坑里，直到俩个指针相遇，把坑不上即可。</p>
</li>
<li><p>注意：如果将第一个数挖走，一开始就要从末尾开始遍历，如果挖走最后一个数，就要从左先开始遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> temp = nums[right];<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">while</span> ((nums[left] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> &amp;&amp; left &lt; right) left++;<br>        nums[right] = nums[left];<br>        <span class="hljs-keyword">while</span> ((nums[right] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; left &lt; right) right--;<br>        nums[left] = nums[right];<br>    &#125;<br>    nums[left] = temp;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>改进版,不需要挖坑了，而且只交换一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span> ,right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; (nums[right] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) right--;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; (nums[left] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) left++;<br>        <span class="hljs-built_in">swap</span>(nums[left++], nums[right--]); <br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-bi