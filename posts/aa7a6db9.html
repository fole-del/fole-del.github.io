<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go学习笔记（实验楼） | 欧恩意</title><meta name="keywords" content="Go,实验楼"><meta name="author" content="mingming.shi"><meta name="copyright" content="mingming.shi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Go学习之路,感谢实验楼的课程">
<meta property="og:type" content="article">
<meta property="og:title" content="Go学习笔记（实验楼）">
<meta property="og:url" content="https://www.mingsrc.work/posts/aa7a6db9">
<meta property="og:site_name" content="欧恩意">
<meta property="og:description" content="Go学习之路,感谢实验楼的课程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg">
<meta property="article:published_time" content="2022-01-30T02:39:14.905Z">
<meta property="article:modified_time" content="2022-02-07T11:11:00.522Z">
<meta property="article:author" content="mingming.shi">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="实验楼">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg"><link rel="shortcut icon" href="/../../../images/icon.jpg"><link rel="canonical" href="https://www.mingsrc.work/posts/aa7a6db9"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式🌙🌙","night_to_day":"你已切换为浅色模式🌝🌝","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go学习笔记（实验楼）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-07 19:11:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/hbe.style.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/var.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/taglink.css"><link rel="stylesheet" href="/css/hideCategory.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/code.css"><link rel="stylesheet" href="/css/buttons.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/font-awesome.css"><link rel="stylesheet" href="/css/title.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/all.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/v4-shims.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><link href="https://.googleapis.com/css2?family=Noto+Serif+SC:wght@400;900&display=swap" rel="stylesheet" media="print" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="欧恩意" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/../../../images/icon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">186</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">62</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ming/"><i class="fa-fw fa-fw fas fa-desktop faa-vertical animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-fw fas fa-home faa-vertical animated-hover"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-book faa-pulse animated-hover"></i><span> 找文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive faa-tada animated-hover"></i><span> 时间</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags faa-tada animated-hover"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open faa-tada animated-hover"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat faa-pulse animated-hover"></i><span> 清单</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-flask faa-vertical animated-hover"></i><span> 皮一下</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/test/demo"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试</span></a></li><li><a class="site-page child" href="/player/"><i class="fa-fw fa fa-play-circle"></i><span> 播放器</span></a></li><li><a class="site-page child" href="/happy-new-year/"><i class="fa-fw fa fa-wheelchair-alt"></i><span> HappyNewYear</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-vertical animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link faa-tada animated-hover"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">欧恩意</a></span><div id="menus"><button id="darkmodebutton" type="button" title="浅色和深色模式转换"><a class="site-page social-icon search"><i class="fas fa-adjust fa-fw"></i></a></button><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ming/"><i class="fa-fw fa-fw fas fa-desktop faa-vertical animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-fw fas fa-home faa-vertical animated-hover"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-book faa-pulse animated-hover"></i><span> 找文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive faa-tada animated-hover"></i><span> 时间</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags faa-tada animated-hover"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open faa-tada animated-hover"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat faa-pulse animated-hover"></i><span> 清单</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-flask faa-vertical animated-hover"></i><span> 皮一下</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/test/demo"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试</span></a></li><li><a class="site-page child" href="/player/"><i class="fa-fw fa fa-play-circle"></i><span> 播放器</span></a></li><li><a class="site-page child" href="/happy-new-year/"><i class="fa-fw fa fa-wheelchair-alt"></i><span> HappyNewYear</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-vertical animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link faa-tada animated-hover"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go学习笔记（实验楼）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-30T02:39:14.905Z" title="发表于 2022-01-30 10:39:14">2022-01-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-07T11:11:00.522Z" title="更新于 2022-02-07 19:11:00">2022-02-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Go/">Go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>62分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Go学习笔记（实验楼）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="一、Go语言介绍"><a href="#一、Go语言介绍" class="headerlink" title="一、Go语言介绍"></a>一、Go语言介绍</h1><h2 id="Go语言的特性"><a href="#Go语言的特性" class="headerlink" title="Go语言的特性"></a>Go语言的特性</h2><h4 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程*"></a>并发编程<code>*</code></h4><p>Go 语言引入了 <code>goroutine</code>，它是 Go 实现快速高效的并发编程的关键。通过调用 <code>go</code> 关键字，我们就可以让函数以 <strong>goroutine</strong> 的方式进行运行，<u>也就是以协程为单位进行运行</u>。</p>
<blockquote>
<p>协程比线程更加的轻量级，也更节省系统资源，这使得我们可以创建大量的 goroutine，从而进行轻松且高质量的并发编程。同时，goroutine 内部采用管道 <code>channel</code> 进行消息传递，从而实现共享内存。在第五章我们还将对 Go 并发编程进行详细的讲解。</p>
</blockquote>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Go 语言中的错误处理的哲学和 C 语言一样，函数通过返回错误类型 (<code>error</code>) 或者 <code>bool</code> 类型（不需要区分多种错误状态时）表明函数的执行结果，调用检查返回的错误类型值是否是 <code>nil</code> 来判断调用结果。并引入了 <code>defer</code> 关键字用于标准的错误处理流程，并提供了内置函数 <code>panic</code>、<code>recover</code> 完成异常的抛出与捕捉。</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>Go 语言自带垃圾自动回收的功能，让 Go 语言不需要 <code>delete</code> 关键字，也不需要 <code>free()</code> 来释放内存。因此开发者无需考虑何时需要释放之前分配的内存的问题，系统会自动帮我们判断，并在适当的时候进行垃圾处理。<strong>垃圾自动回收是 Go 语言的一个特点，也是一大亮点。</strong></p>
<h4 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h4><p>Go 语言和 Python 一样也支持函数的多返回值功能，这个特性让开发者可以从原来用各种比较别扭的方式返回多个值得痛苦中解脱出来，不需要为了一次返回多个值而专门定义一个结构体。并且每个返回值都有自己的名字，开发者还可以选择具体需要返回的值，只需要使用下划线作为占位符来丢掉不要的返回值即可。</p>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>Go 语言支持常规的匿名函数和闭包，开发者可以随意对匿名函数变量进行传递和调用，下面就是一个匿名函数样例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x,y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> x+y<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Go语言可以做什么"><a href="#Go语言可以做什么" class="headerlink" title="Go语言可以做什么"></a>Go语言可以做什么</h2><p>Go 语言是谷歌发布的第二款开源编程语言。专门针对多处理器系统应用程序的编程进行了优化，<strong>使用 Go 编译的程序可以媲美 C 或 C++ 代码的速度，而且更加安全、支持并行进程。</strong></p>
<p>Go 的目标是希望提升现有编程语言对程序库等依赖性 (dependency) 的管理，这些软件元素会被应用程序反复调用。由于存在并行编程模式，因此也被设计用来解决多处理器的任务。目前，已经有很多公司开始使用 Go 语言开发自己的服务，甚至完全转向 Go 开发，也诞生了很多基于 Go 的服务和应用，比如 <code>Dokcer</code>、<code>k8s</code> 等，现在我们看下，有哪些大公司在用 Go 语言了。</p>
<ul>
<li><p>Google 对 Go 寄予厚望。旗下 App Engine 和其他部分产品已经开始使用 Go 语言来编写。作为开发 Go 语言的公司，当仁不让。</p>
</li>
<li><p>Facebook 也在用 GO，还专门在 GitHub 上建立了一个开源组织 Facebookgo，大家可以通过 GitHub 访问查看 Facebook 开源的项目，比如著名的——平滑升级的 grace。</p>
</li>
</ul>
<p>此外，<u>百度、阿里</u>都在招 GO。<u>京东云消息推送系统、云存储以及京东商城</u>等都有使用 Go 做开发。</p>
<p>360 对 Golang 的使用主要是开源的日志搜索系统 <strong>Poseidon</strong>。而且，<u>360 直播</u>在招聘 Golang 开发工程师。</p>
<p><u>小米</u>对 Golang 的支持，莫过于运维监控系统的开源，也就是 open-falcon 。此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用 Golang。</p>
<hr>
<h1 id="二、Go语言基础"><a href="#二、Go语言基础" class="headerlink" title="二、Go语言基础"></a>二、Go语言基础</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量使用关键字 <code>const</code> 声明，下面有几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> limit = <span class="hljs-number">512</span><br><span class="hljs-keyword">const</span> top <span class="hljs-type">uint16</span> = <span class="hljs-number">1421</span><br><span class="hljs-keyword">const</span> Pi <span class="hljs-type">float64</span> = <span class="hljs-number">3.1415926</span><br><span class="hljs-keyword">const</span> x,y <span class="hljs-type">int</span> = <span class="hljs-number">1</span>,<span class="hljs-number">3</span> <span class="hljs-comment">//多重赋值</span><br></code></pre></td></tr></table></figure>

<p>Go 的常量定义可以限定常量类型，但不是必需的。如果定义常量时没有指定类型，那么该常量就是无类型常量，也叫字面常量。</p>
<p>当需要设置多个常量的时候，不必重复使用 <code>const</code> 关键字，可以使用以下语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Cyan = <span class="hljs-number">0</span><br>    Black = <span class="hljs-number">1</span><br>    White = <span class="hljs-number">2</span><br>)<br></code></pre></td></tr></table></figure>

<p>Go 语言还预定义了这些常量：<code>true</code>、<code>false</code>、<code>iota</code>。</p>
<p><code>iota</code> 是一个可以被编译器修改的常量，在 <code>const</code> 关键字出现时被重置为 0，在下一个 <code>const</code> 出现之前，每出现一次 <code>iota</code>，其所代表的数字自动加 1。下面通过一个例子讲解 <code>iota</code> 的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//a == 0</span><br>    b = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//b ==1</span><br>    c = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//c == 2</span><br>)<br><br><span class="hljs-keyword">const</span> d = <span class="hljs-literal">iota</span> <span class="hljs-comment">//d==0,因为const的出现，iota被重置为0</span><br></code></pre></td></tr></table></figure>

<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul>
<li><code>+</code>：相加；</li>
<li><code>-</code>：相减；</li>
<li><code>*</code>：相乘；</li>
<li><code>/</code>：相除；</li>
<li><code>%</code>：求余；</li>
<li><code>++</code>：自增；</li>
<li><code>--</code>：自减；</li>
</ul>
<blockquote>
<p>其中，<code>++</code> 与 <code>--</code> 不能用于赋值表达式, 如: <code>count2 := count++</code>；并且在 Go 语言中，不存在如：<code>++count</code> 表达式。</p>
</blockquote>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul>
<li><code>==</code>：检查两个值是否相等，如果相等返回 <code>true</code>，否则返回 <code>false</code>；</li>
<li><code>!=</code>：检查两个值是否不相等，如果不相等返回 <code>true</code>，否则返回 <code>false</code>；</li>
<li><code>&gt;</code>：检查左边值是否大于右边值，如果是返回 <code>true</code>，否则返回 <code>false</code>；</li>
<li><code>&lt;</code>：检查左边值是否小于右边值，如果是返回 <code>true</code>，否则返回 <code>false</code>；</li>
<li><code>&gt;=</code>：检查左边值是否大于等于右边值，如果是返回 <code>true</code>，否则返回 <code>false</code>；</li>
<li><code>&lt;=</code>：检查左边值是否小于等于右边值，如果是返回 <code>true</code>，否则返回 <code>false</code>；</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li><code>&amp;&amp;</code>：逻辑 <code>AND</code> 运算符。如果两边的操作数都是 <code>true</code>，则条件为 <code>true</code>，否则为 <code>false</code>；</li>
<li><code>||</code>：逻辑 <code>OR</code> 运算符。如果两边的操作数有一个 <code>true</code>，则条件为 <code>true</code>，否则为 <code>false</code>；</li>
<li><code>!</code>：逻辑 <code>NOT</code> 运算符。如果条件为 <code>true</code>，则逻辑 <code>NOT</code> 添加为 <code>true</code>，否则为 <code>false</code>；</li>
</ul>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul>
<li><code>&amp;</code>：按位与运算符。其功能是参与运算的两个数的二进制按位对齐，<strong>当对应位都为 1 时，才返回 1</strong>；</li>
<li><code>|</code>：按位或运算符。其功能是参与运算的两个数的二进制按位对齐，<strong>当对应位中只要有一位是 1，就返回 1</strong>；</li>
<li><code>^</code>：按位异或运算符。其是参与运算的两个数的二进制按位对齐，<strong>当对应位有一位是 1，就返回 1；如果对应两位都是 1 或 0，就返回 0</strong>；</li>
<li><code>&lt;&lt;</code>：左移运算符。<strong>其功能是将数值的二进制所有位向左移动指定的位数</strong>；</li>
<li><code>&gt;&gt;</code>：右移运算符。<strong>其功能是将数值的二进制所有位向右移动指定的位数</strong>；</li>
</ul>
<h3 id="赋值运算法"><a href="#赋值运算法" class="headerlink" title="赋值运算法"></a>赋值运算法</h3><ul>
<li><code>=</code>：简单的赋值运算符，将一个表达式的值赋给一个左值;</li>
<li><code>+=</code>：相加后再赋值;</li>
<li><code>-=</code>：相减后再赋值；</li>
<li><code>*=</code>：相乘后再赋值；</li>
<li><code>/=</code>：相除后再赋值；</li>
<li><code>%=</code>：取余后再赋值；</li>
<li><code>&amp;=</code>：按位与后赋值；</li>
<li><code>|=</code>：按位或后赋值；</li>
<li><code>^=</code>：按位异或后赋值；</li>
<li><code>&lt;&lt;=</code>：左位移后赋值；</li>
<li><code>&gt;&gt;=</code>：右位移后赋值；</li>
</ul>
<h3 id="和-amp"><a href="#和-amp" class="headerlink" title="*和&amp;"></a><code>*</code>和<code>&amp;</code></h3><ol>
<li><code>&amp;</code>是取地址符号 , 即取得某个变量的地址 , 如 ：<code>&amp;a</code></li>
<li><code>*</code>是指针运算符 , 可以表示一个变量是<strong>指针类型</strong> , 也可以表示<strong>一个指针变量所指向的存储单元</strong> , 也就是这个地址所存储的值 .</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是所有语言最基本和最重要的组成部分。Go 语言引入了关键字 <code>var</code> 对变量进行声明，也可以使用 <code>:=</code> 来对变量直接进行初始化，Go 编译器会自动推导出该变量的类型，这大大的方便了开发者的工作。但是需要注意的是 <code>:=</code> 左侧的变量不能是已经被声明过的，否则会导致编译器错误。</p>
<p>以下是 Go 声明和初始化变量的各种方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> c <span class="hljs-type">float64</span><br><span class="hljs-keyword">var</span> d [<span class="hljs-number">5</span>] <span class="hljs-type">int</span>  <span class="hljs-comment">//数组</span><br><span class="hljs-keyword">var</span> e [] <span class="hljs-type">int</span>   <span class="hljs-comment">//数组切片</span><br><span class="hljs-keyword">var</span> f * <span class="hljs-type">int</span>    <span class="hljs-comment">//正确</span><br><span class="hljs-keyword">var</span> v1 <span class="hljs-type">int</span> = <span class="hljs-number">5</span> <span class="hljs-comment">//正确</span><br><span class="hljs-keyword">var</span> v2 = <span class="hljs-number">5</span>     <span class="hljs-comment">//正确，编译器自动推导出V2类型</span><br>v3 := <span class="hljs-number">5</span>        <span class="hljs-comment">//正确，编译器自动推导出V3的类型</span><br></code></pre></td></tr></table></figure>

<h3 id="多重赋值"><a href="#多重赋值" class="headerlink" title="多重赋值"></a>多重赋值</h3><p>Go 语言提供了大多数语言不支持的多重赋值，这使得变量的交换变得十分简单。下面通过一个例子来了解 Go 语言的多重赋值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">2</span><br>j := <span class="hljs-number">3</span><br>i, j = j, i  <span class="hljs-comment">//交换i和j的值，此时i == 3，j == 2</span><br></code></pre></td></tr></table></figure>

<p>这样的方式可以一行代码实现变量的交换，明显的减少代码的行数，而不需要像 C&#x2F;C++ 那样引入一个中间变量。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型*"></a>数据类型<code>*</code></h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>Go 语言提供了 11 种整型，如下列表所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>等同于 uint8</td>
</tr>
<tr>
<td><code>int</code></td>
<td>依赖于不同平台下的实现，可以是 int32 或者 int64</td>
</tr>
<tr>
<td><code>int8</code></td>
<td>[-128, 127]</td>
</tr>
<tr>
<td><code>int16</code></td>
<td>[-32768, 32767]</td>
</tr>
<tr>
<td><code>int32</code></td>
<td>[-2147483648, 2147483647]</td>
</tr>
<tr>
<td><code>int64</code></td>
<td>[-9223372036854775808, 9223372036854775807]</td>
</tr>
<tr>
<td><code>rune</code></td>
<td>等同于 int32</td>
</tr>
<tr>
<td><code>uint</code></td>
<td>依赖于不同平台下的实现，可以是 uint32 或者 uint64</td>
</tr>
<tr>
<td><code>uint8</code></td>
<td>[0, 255]</td>
</tr>
<tr>
<td><code>uint16</code></td>
<td>[0, 65535]</td>
</tr>
<tr>
<td><code>uint32</code></td>
<td>[0, 4294967295]</td>
</tr>
<tr>
<td><code>uint64</code></td>
<td>[0, 18446744073709551615]</td>
</tr>
<tr>
<td><code>uintptr</code></td>
<td>一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64）</td>
</tr>
</tbody></table>
<p>在 <code>C</code> 语言中我们可以通过 <code>sizeof</code> 操作符查看类型的字节长度，在 Go 语言中可以通过 <code>unsafe.Sizeof</code> 函数进行，创建源文件 <code>type_length.go</code>，输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := <span class="hljs-number">12</span><br>    fmt.Println(<span class="hljs-string">&quot;length of a: &quot;</span>, unsafe.Sizeof(a))<br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">12</span><br>    fmt.Println(<span class="hljs-string">&quot;length of b(int): &quot;</span>, unsafe.Sizeof(b))<br>    <span class="hljs-keyword">var</span> c <span class="hljs-type">int8</span> = <span class="hljs-number">12</span><br>    fmt.Println(<span class="hljs-string">&quot;length of c(int8): &quot;</span>, unsafe.Sizeof(c))<br>    <span class="hljs-keyword">var</span> d <span class="hljs-type">int16</span> = <span class="hljs-number">12</span><br>    fmt.Println(<span class="hljs-string">&quot;length of d(int16): &quot;</span>, unsafe.Sizeof(d))<br>    <span class="hljs-keyword">var</span> e <span class="hljs-type">int32</span> = <span class="hljs-number">12</span><br>    fmt.Println(<span class="hljs-string">&quot;length of e(int32): &quot;</span>, unsafe.Sizeof(e))<br>    <span class="hljs-keyword">var</span> f <span class="hljs-type">int64</span> = <span class="hljs-number">12</span><br>    fmt.Println(<span class="hljs-string">&quot;length of f(int64): &quot;</span>, unsafe.Sizeof(f))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码中，首先声明了目前的源文件属于 <code>main</code> 包，然后导入了 <code>fmt</code> 和 <code>unsafe</code> 包，<code>fmt</code> 包用于格式化字符串，<code>unsafe</code> 包含了用于获取 Go 语言类型信息的方法。然后在 <code>main()</code> 函数中，我们分别声明了几种类型的整型变量，并通过 <code>unsafe.Sizeof</code> 方法获取该类型的字节长度。最后我们通过以下方法运行 <code>type_length.go</code>，同时打印出了输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run type_length.go<br>length of a:  8<br>length of b(int):  8<br>length of c(int8):  1<br>length of d(int16):  2<br>length of e(int32):  4<br>length of f(int64):  8<br></code></pre></td></tr></table></figure>

<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>Go 语言提供了两种浮点类型和两种复数类型，具体如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>float32</td>
<td>±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数</td>
</tr>
<tr>
<td>float64</td>
<td>±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数</td>
</tr>
<tr>
<td>complex32</td>
<td>复数，实部和虚部都是 float32</td>
</tr>
<tr>
<td>complex64</td>
<td>复数，实部和虚部都是 float64</td>
</tr>
</tbody></table>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>Go 语言提供了内置的布尔值 <code>true</code> 和<code>false</code>。Go 语言支持标准的逻辑和比较操作，这些操作的结果都是布尔值。值得注意的地方是可以通过 <code>!b</code> 的方式反转变量 <code>b</code> 的真假。需要注意的是布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。实例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">bool</span><br>a = <span class="hljs-literal">true</span><br>b := (<span class="hljs-number">2</span> == <span class="hljs-number">3</span>) <span class="hljs-comment">//b也会被推导为bool类型</span><br><br><span class="hljs-comment">//错误示范</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">bool</span><br>b = <span class="hljs-number">1</span> <span class="hljs-comment">//编译错误</span><br>b = <span class="hljs-type">bool</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//编译错误</span><br></code></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go 语言中的字符串是 <a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/UTF-8">UTF-8</a> 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串也可能根据需要占用 1 至 4 个字节，这与其它语言如 C++、Java 或者 Python 不同。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。</p>
<p>Go 语言中字符串的可以使用双引号 (<code>&quot;</code>) 或者反引号 (&#96;&#96;&#96;) 来创建。双引号用来创建可解析的字符串字面量，所谓可解析的是指字符串中的一些符号可以被格式化为其他内容，如 <code>\n</code> 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。以下是几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">t1 := <span class="hljs-string">&quot;\&quot;hello\&quot;&quot;</span>             <span class="hljs-comment">//内容： &quot;hello&quot;</span><br>t2 := <span class="hljs-string">`&quot;hello&quot;`</span>               <span class="hljs-comment">//内容：和t1一致</span><br>t3 := <span class="hljs-string">&quot;\u6B22\u8FCE&quot;</span>          <span class="hljs-comment">//内容：欢迎</span><br></code></pre></td></tr></table></figure>

<p>Go 语言中的部分转义字符如下表所示：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\\</code></td>
<td>表示反斜线</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>换行符</td>
</tr>
<tr>
<td><code>\uhhhh</code></td>
<td>4 个 16 进制数字给定的 Unicode 字符</td>
</tr>
</tbody></table>
<p>在 Go 语言中单个字符可以使用单引号 (<code>&#39;</code>) 来创建。之前的课程中，我们有学习过 <code>rune</code> 类型，它等同于 <code>int32</code>，在 Go 语言中，一个单一的字符可以用一个单一的 <code>rune</code> 来表示。这也是容易理解的，因为 Go 语言的字符串是 UTF-8 编码，其底层使用 4 个字节表示，也就是 32 bit。</p>
<p>在 Go 语言中，字符串支持切片操作，但是需要注意的是如果字符串都是由 ASCII 字符组成，那可以随便使用切片进行操作，但是如果字符串中包含其他非 ASCII 字符，直接使用切片获取想要的单个字符时需要十分小心，因为对字符串直接使用切片时是通过字节进行索引的，但是非 ASCII 字符在内存中可能不是由一个字节组成。如果想对字符串中字符依次访问，可以使用 <code>range</code> 操作符。另外获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。字符串支持以下操作：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>s += t</code></td>
<td>将字符串 t 追加到 s 末尾</td>
</tr>
<tr>
<td><code>s + t</code></td>
<td>将字符串 s 和 t 级联</td>
</tr>
<tr>
<td><code>s[n]</code></td>
<td>从字符串 s 中索引位置为 n 处的原始字节</td>
</tr>
<tr>
<td><code>s[n:m]</code></td>
<td>从位置 n 到位置 <code>m-1</code> 处取得的字符（字节）串</td>
</tr>
<tr>
<td><code>s[n:]</code></td>
<td>从位置 n 到位置 <code>len(s)-1</code> 处取得的字符（字节）串</td>
</tr>
<tr>
<td><code>s[:m]</code></td>
<td>从位置 0 到位置 <code>m-1</code> 处取得的字符（字节）串</td>
</tr>
<tr>
<td><code>len(s)</code></td>
<td>字符串 s 中的字节数</td>
</tr>
<tr>
<td><code>len([]rune(s))</code></td>
<td>字符串 s 中字符的个数，可以使用更快的方法 <code>utf8.RuneCountInString()</code></td>
</tr>
<tr>
<td><code>[]rune(s)</code></td>
<td>将字符串 s 转换为一个 unicode 值组成的串</td>
</tr>
<tr>
<td><code>string(chars)</code></td>
<td>chars 类型是 <code>[]rune</code> 或者 <code>[]int32</code>, 将之转换为字符串</td>
</tr>
<tr>
<td><code>[]byte(s)</code></td>
<td>无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节</td>
</tr>
</tbody></table>
<p>让我们尝试一个例子，创建源文件 <code>string_t.go</code>，然后输入以下源代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    t0 := <span class="hljs-string">&quot;\u6B22\u8FCE\u6765\u5230&quot;</span> <span class="hljs-comment">// t0内容：欢迎来到</span><br>    t1 := <span class="hljs-string">&quot;\u5B9E\u9A8C\u697C&quot;</span>       <span class="hljs-comment">// t1内容：实验楼</span><br>    t2 := t0 + t1<br>    <span class="hljs-keyword">for</span> index, char := <span class="hljs-keyword">range</span> t2 &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%-2d    %U      &#x27;%c&#x27;    %X      %d\n&quot;</span>,<br>            index, char, char, []<span class="hljs-type">byte</span>(<span class="hljs-type">string</span>(char)), <span class="hljs-built_in">len</span>([]<span class="hljs-type">byte</span>(<span class="hljs-type">string</span>(char))))<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;length of t0: %d, t1: %d, t2: %d\n&quot;</span>, <span class="hljs-built_in">len</span>(t0), <span class="hljs-built_in">len</span>(t1), <span class="hljs-built_in">len</span>(t2))<br>    fmt.Printf(<span class="hljs-string">&quot;content of t2[0:2] is: %X\n&quot;</span>, t2[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后通过以下方式运行，在这里一起显示了程序的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run string_t.go<br>0     U+6B22      <span class="hljs-string">&#x27;欢&#x27;</span>    E6ACA2      3<br>3     U+8FCE      <span class="hljs-string">&#x27;迎&#x27;</span>    E8BF8E      3<br>6     U+6765      <span class="hljs-string">&#x27;来&#x27;</span>    E69DA5      3<br>9     U+5230      <span class="hljs-string">&#x27;到&#x27;</span>    E588B0      3<br>12    U+5B9E      <span class="hljs-string">&#x27;实&#x27;</span>    E5AE9E      3<br>15    U+9A8C      <span class="hljs-string">&#x27;验&#x27;</span>    E9AA8C      3<br>18    U+697C      <span class="hljs-string">&#x27;楼&#x27;</span>    E6A5BC      3<br>length of t0: 12, t1: 9, t2: 21<br>content of t2[0:2] is: E6AC<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<p>通过前面的课程我们知道通过 <code>\uhhhh</code> 的方式我们可以通过创建 Unicode 字符。</p>
<p>在以上程序中，首先通过 <code>:=</code> 符号创建了变量 <code>t0</code>，其值为 <code>\u6B22\u8FCE\u6765\u5230</code>，是 <code>欢迎来到</code> 中文字符的 unicode 编码，然后以同样的方式创建了变量 <code>t1</code>，其值为 <code>实验楼</code>，然后通过 <code>+</code> 操作符将 <code>t0</code> 和<code>t1</code> 拼接赋值给 <code>t2</code>。然后我们通过 <code>range</code> 操作符号对 unicode 字符串 <code>t2</code> 中的每一个 unicode 字符依次操作，我们这里只是简单的打印出每个字符在 <code>t2</code> 中的位置，每个字符的 unicode 码值，每个字符的字面量，每个字符的十六进制值，以及每个字符的字节长度。</p>
<p>这里我们使用 <code>fmt</code> 包种支持的格式指令，如果读者学习过 C 语言的话就一目了然。接着，我们通过 <code>len</code> 操作符计算出了每个字符串的字节长度。最后，我们使用切片访问了字符串 <code>t2</code> 的第 0-1 个字节，也就是前两个字节，其内容为 <code>E6AC</code>。前面我们说到不能使用切片的方式访问非 ASCII 字符串中的字符，原因在这里一目了然。字符 <code>欢</code> 其底层使用了三个字节表示，内容是 <code>E6ACA2</code>，如果只是简单的使用切片（只取切片中的一项）访问的是不能访问到整个字符的，因为字符的切片是通过字节数来索引的。</p>
<h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>Go 语言标准库中的 <code>fmt</code> 包提供了打印函数将数据以字符串形式输出到控制台，文件，其他满足 <code>io.Writer</code> 接口的值以及其他字符串。目前为止我们使用了 <code>fmt.Printf</code> 和 <code>fmt.Println</code>，对于前者的使用，就像 C 语言中的 <code>printf</code> 函数一样，我们可以提供一些格式化指令，让 Go 语言对输出的字符串进行格式化。同样的我们可以使用一些格式化修饰符，改变格式化指令的输出结果， 如左对齐等。常用的格式化指令如下：</p>
<table>
<thead>
<tr>
<th>格式化指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>%%</code></td>
<td>% 字面量</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>一个二进制整数，将一个整数格式化为二进制的表达方式</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>一个 Unicode 的字符</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>十进制数值</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>八进制数值</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>小写的十六进制数值</td>
</tr>
<tr>
<td><code>%X</code></td>
<td>大写的十六进制数值</td>
</tr>
<tr>
<td><code>%U</code></td>
<td>一个 Unicode 表示法表示的整形码值，默认是 4 个数字字符</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>输出以原生的 UTF-8 字节表示的字符，如果 console 不支持 UTF-8 编码，则会输出乱码</td>
</tr>
<tr>
<td><code>%t</code></td>
<td>以 true 或者 false 的方式输出布尔值</td>
</tr>
<tr>
<td><code>%v</code></td>
<td>使用默认格式输出值，或者使用类型的 String() 方法输出的自定义值，如果该方法存在的话</td>
</tr>
<tr>
<td>%T</td>
<td>输出值的类型</td>
</tr>
</tbody></table>
<p>常用的格式化指令修饰符如下：</p>
<ul>
<li><p><code>空白</code> 如果输出的数字为负，则在其前面加上一个减号 <code>-</code>。如果输出的是整数，则在前面加一个空格。使用 <code>%x</code> 或者 <code>%X</code> 格式化指令输出时，会在结果之间添加一个空格。例如 <code>fmt.Printf(&quot;% X&quot;, &quot;实&quot;)</code> 输出 E5 AE 9E。</p>
</li>
<li><p><code>#</code></p>
<ul>
<li><code>%#o</code> 输出以 <code>0</code> 开始的八进制数据。</li>
<li><code>%#x</code> 输出以 <code>0x</code> 开始的十六进制数据。</li>
</ul>
</li>
<li><p><code>+</code> 让格式化指令在数值前面输出 <code>+</code> 号或者 <code>-</code> 号，为字符串输出 ASCII 字符（非 ASCII 字符会被转义），为结构体输出其字段名。</p>
</li>
<li><p><code>-</code> 让格式化指令将值向左对齐（默认值为像右对齐）。</p>
</li>
<li><p><code>0</code> 让格式指令以数字 0 而非空白进行填充。</p>
</li>
</ul>
<p>让我们练习一下，创建源文件 <code>fmt_t.go</code>，输入以下源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    text := <span class="hljs-string">&quot;\u5B9E\u9A8C\u697C&quot;</span><br>    fmt.Printf(<span class="hljs-string">&quot;bool output:\n%t\n%t\n\n&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)<br>    fmt.Println(<span class="hljs-string">&quot;number output, origin value: 64&quot;</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;|%b|%8b|%-8b|%08b|% 8b|\n&quot;</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;|%x|%8x|%-8x|%08X|% 8X|\n\n&quot;</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>)<br>    fmt.Println(<span class="hljs-string">`text output, origin value: \u5B9E\u9A8C\u697C`</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;content: %s\n&quot;</span>, text)<br>    fmt.Printf(<span class="hljs-string">&quot;hex value: % X\nUnicode value: &quot;</span>, text)<br>    <span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> text &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%U &quot;</span>, char)<br>    &#125;<br>    fmt.Println()<br>    bytes := []<span class="hljs-type">byte</span>(text)<br>    fmt.Printf(<span class="hljs-string">&quot;value of bytes: %s\n&quot;</span>, bytes)<br>    fmt.Printf(<span class="hljs-string">&quot;hex value of bytes: % X\n&quot;</span>, bytes)<br>    fmt.Printf(<span class="hljs-string">&quot;origin value of bytes: %v\n&quot;</span>, bytes)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行代码，输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run fmt_t.go<br>bool output:<br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br><br>number output, origin value: 64<br>|1000000| 1000000|1000000 |01000000| 1000000|<br>|40|      40|40      |00000040|      40|<br><br>text output, origin value: \u5B9E\u9A8C\u697C<br>content: 实验楼<br>hex value: E5 AE 9E E9 AA 8C E6 A5 BC<br>Unicode value: U+5B9E U+9A8C U+697C<br>value of bytes: 实验楼<br>hex value of bytes: E5 AE 9E E9 AA 8C E6 A5 BC<br>origin value of bytes: [229 174 158 233 170 140 230 165 188]<br></code></pre></td></tr></table></figure>

<h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>在 Go 语言中支持两个字符类型，</p>
<ul>
<li><code>UTF-8</code>：一个是 <code>Byte</code>（实际上是 Unit8 的别名），代表 UTF-8 字符串的单个字节的值；</li>
<li><code>Unicode</code>:另一个是 <code>rune</code>，代表单个 Unicode 字符。</li>
</ul>
<p>处于简化语言的考虑，<strong>Go 语言的多数 API 都假设字符串为 UTF-8 编码</strong>。尽管 Unicode 字符在标准库中有支持，但实际很少使用。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Go 语言的数组是一个定长的序列，其中的元素类型相同。多维数组可以简单地使用自身为数组的元素来创建。数组的元素使用操作符号 <code>[ ]</code> 来索引，索引从 <code>0</code> 开始，到 <code>len(array)-1</code> 结束。数组使用以下语法创建：</p>
<ul>
<li><code>[length]Type</code></li>
<li><code>[N]Type&#123;value1, value2, ..., valueN&#125;</code></li>
<li><code>[...]Type&#123;value1, value2, ..., valueN&#125;</code></li>
</ul>
<p>如果使用了 <code>...</code>（省略符）操作符，Go 语言会为我们自动计算数组的长度。在任何情况下，一个数组的长度都是固定的并且不可修改。数组的长度可以使用 <code>len()</code> 函数获得。由于数组的长度是固定的，因此数组的长度和容量都是一样的，因此对于数组而言 <code>cap()</code> 和 <code>len()</code> 函数返回值都是一样的。数组也可以使用和切片一样的语法进行切片，只是其结果为一个切片，而非数组。同样的，数组也可以使用 <code>range</code> 进行索引访问。</p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>一般而言，Go 语言的切片比数组更加灵活，强大而且方便。数组是按值传递的（即是传递的副本），而切片是引用类型，传递切片的成本非常小，而且是不定长的。而且数组是定长的，而切片可以调整长度。创建切片的语法如下：</p>
<ul>
<li><code>make([ ]Type, length, capacity)</code></li>
<li><code>make([ ]Type, length)</code></li>
<li><code>[ ]Type&#123;&#125;</code></li>
<li><code>[ ]Type&#123;value1, value2, ..., valueN&#125;</code></li>
</ul>
<p>内置函数 <code>make()</code> 用于创建切片、映射和通道。当用于创建一个切片时，它会创建一个隐藏的初始化为零值的数组，然后返回一个引用该隐藏数组的切片。该隐藏的数组与 Go 语言中的所有数组一样，都是固定长度，如果使用第一种语法创建，那么其长度为切片的容量 <code>capacity</code>；如果是第二种语法，那么其长度记为切片的长度 <code>length</code>。一个切片的容量即为隐藏数组的长度，而其长度则为不超过该容量的任意值。另外可以通过内置的函数 <code>append()</code> 来增加切片的容量。切片可以支持以下操作：</p>
<p>我们练习下，创建源文件 <code>slice_array.go</code>，输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br>    fmt.Printf(<span class="hljs-string">&quot;len and cap of array %v is: %d and %d\n&quot;</span>, a, <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">cap</span>(a))<br>    fmt.Printf(<span class="hljs-string">&quot;item in array: %v is:&quot;</span>, a)<br>    <span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> a &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;% d&quot;</span>, value)<br>    &#125;<br><br>    fmt.Println()<br><br>    s1 := a[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>]<br>    fmt.Printf(<span class="hljs-string">&quot;len and cap of slice: %v is: %d and %d\n&quot;</span>, s1, <span class="hljs-built_in">len</span>(s1), <span class="hljs-built_in">cap</span>(s1))<br>    fmt.Printf(<span class="hljs-string">&quot;item in slice: %v is:&quot;</span>, s1)<br>    <span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> s1 &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>, value)<br>    &#125;<br><br>    fmt.Println()<br><br>    s1[<span class="hljs-number">0</span>] = <span class="hljs-number">456</span><br>    fmt.Printf(<span class="hljs-string">&quot;item in array changed after changing slice: %v is:&quot;</span>, s1)<br>    <span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> a &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>, value)<br>    &#125;<br><br>    fmt.Println()<br><br>    s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>    s2[<span class="hljs-number">4</span>] = <span class="hljs-number">5</span><br>    fmt.Printf(<span class="hljs-string">&quot;len and cap of slice: %v is: %d and %d\n&quot;</span>, s2, <span class="hljs-built_in">len</span>(s2), <span class="hljs-built_in">cap</span>(s2))<br>    fmt.Printf(<span class="hljs-string">&quot;item in slice %v is:&quot;</span>, s2)<br>    <span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> s2 &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>, value)<br>    &#125;<br><br>    fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码中，我们首先创建了一个数组，数组的长度是由 Go 语言自动计算出的（省略号语法），然后通过切片操作从数组 <code>a</code> 中创建了切片 <code>s1</code>，接着我们修改了该切片的第一个位置的数值，然后发现数组 <code>a</code> 中的值也发生了变化。最后我们通过 <code>make()</code> 函数创建了一个切片，该切片的长度和容量分别为 10 和 20，还可以发现 Go 语言将未初始化的项自动赋予零值。运行代码输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$  go run slice_array.go<br>len and <span class="hljs-built_in">cap</span> of array [1 2 3 4 5 6 7] is: 7 and 7<br>item <span class="hljs-keyword">in</span> array: [1 2 3 4 5 6 7] is: 1 2 3 4 5 6 7<br>len and <span class="hljs-built_in">cap</span> of slice: [4 5 6] is: 3 and 4<br>item <span class="hljs-keyword">in</span> slice: [4 5 6] is: 4 5 6<br>item <span class="hljs-keyword">in</span> array changed after changing slice: [456 5 6] is: 1 2 3 456 5 6 7<br>len and <span class="hljs-built_in">cap</span> of slice: [0 0 0 0 5 0 0 0 0 0] is: 10 and 20<br>item <span class="hljs-keyword">in</span> slice [0 0 0 0 5 0 0 0 0 0] is: 0 0 0 0 5 0 0 0 0 0<br></code></pre></td></tr></table></figure>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><blockquote>
<p><strong>包</strong>是各种类型和函数的集合。在包中，如果标示符（类型名称，函数名称，方法名称）的首字母是大写，那这些标示符是可以被导出的，也就是说可以在包以外直接使用。</p>
</blockquote>
<p><code>$GOPATH</code> ：环境变量（指向一个或多个目录），以及其子目录 <code>src</code> 目录的，当我们使用 <code>import</code> 关键字导入包的时候，Go 语言会在 <code>$GOPATH</code> 和 <code>GOROOT</code> 目录中搜索包。</p>
<hr>
<h1 id="三、Go语言顺序编程"><a href="#三、Go语言顺序编程" class="headerlink" title="三、Go语言顺序编程"></a>三、Go语言顺序编程</h1><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><blockquote>
<p>Go 语言提供的流程控制语句包括 <code>if</code>、<code>switch</code>、<code>for</code>、<code>goto</code>、<code>select</code>，其中 <code>select</code> 用于监听 <code>channel</code>（通道）在讲解通道的时候再详细介绍。</p>
</blockquote>
<h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p>语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> optionalStatement1; booleanExpression1 &#123;<br>    block1<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> optionalStatement2; booleanExpression2 &#123;<br>    block2<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    block3<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中 <code>optionalStatement</code> 是可选的表达式，真正决定分支走向的是 <code>booleanExpression1</code> 的值。</p>
<h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><p>Go 语言的 <code>for</code> 语句可以遍历数组，切片，映射等类型，也可以用于无限循环。以下是其语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">// 无限循环</span><br>    block<br>&#125;<br><br><span class="hljs-keyword">for</span> booleanExpression &#123; <span class="hljs-comment">// while循环，在Go语言中没有while关键字</span><br><br>&#125;<br><br><span class="hljs-keyword">for</span> index, char := <span class="hljs-keyword">range</span> aString &#123; <span class="hljs-comment">// 迭代字符串</span><br><br>&#125;<br><br><span class="hljs-keyword">for</span> item := <span class="hljs-keyword">range</span> aChannel &#123; <span class="hljs-comment">// 迭代通道</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="跳转语句goto"><a href="#跳转语句goto" class="headerlink" title="跳转语句goto"></a>跳转语句<code>goto</code></h4><p>Go 语言中使用 <code>goto</code> 关键字实现跳转。<code>goto</code> 语句的语义非常简单，就是跳转到本函数内的某个标签，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myfunc</span><span class="hljs-params">()</span></span>&#123;<br>    i := <span class="hljs-number">0</span><br>    THIS: <span class="hljs-comment">//定义一个THIS标签</span><br>    fmt.Println(i)<br>    i++<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">goto</span> THIS <span class="hljs-comment">//跳转到THIS标签</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="switch分支"><a href="#switch分支" class="headerlink" title="switch分支"></a>switch分支</h4><p>Go 语言中 <code>switch</code> 分支既可用于常用的分支就像 C 语言中的 <code>switch</code> 一样，也可以用于类型开关，所谓类型开关就是用于判断变量属于什么类型。但是需要注意的是 Go 语言的 <code>switch</code> 语句不会自动贯穿，相反，如果想要贯穿需要添加 <code>fallthrough</code> 语句。表达式开关 <code>switch</code> 的语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> optionalStatement; optionalExpression &#123;<br>    <span class="hljs-keyword">case</span> expression1: block1<br>    ...<br>    <span class="hljs-keyword">case</span> expressionN: blockN<br>    <span class="hljs-keyword">default</span>: blockD<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面是个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> &#123;        <span class="hljs-comment">// 没有表达式，默认为True值，匹配分支中值为True的分支</span><br>    <span class="hljs-keyword">case</span> value &lt; minimum:<br>        <span class="hljs-keyword">return</span> minimum<br>    <span class="hljs-keyword">case</span> value &gt; maximum:<br>        <span class="hljs-keyword">return</span> maximum<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> value<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，switch 后面没有默认的表达式，这个时候 Go 语言默认其值为 <code>True</code>。</p>
<p>在前面我们提到过类型断言，如果我们知道变量的类型就可以使用类型断言，但是当我们知道类型可能是许多类型中的一种时候，我们就可以使用类型开关。其语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> optionalStatement; typeSwitchGuard &#123;<br>    <span class="hljs-keyword">case</span> type1: block1<br>    ...<br>    <span class="hljs-keyword">case</span> typeN: blockN<br>    <span class="hljs-keyword">default</span>: blockD<br>&#125;<br></code></pre></td></tr></table></figure>

<p>说了这么多，让我们进行下练习，创建源文件 <code>switch_t.go</code>，输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">classchecker</span><span class="hljs-params">(items ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123; <span class="hljs-comment">// 创建一个函数，该函数可以接受任意多的任意类型的参数</span><br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> items &#123;<br>        <span class="hljs-keyword">switch</span> x := x.(<span class="hljs-keyword">type</span>) &#123; <span class="hljs-comment">// 创建了影子变量</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;param #%d is a bool, value: %t\n&quot;</span>, i, x)<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">float64</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;param #%d is a float64, value: %f\n&quot;</span>, i, x)<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>, <span class="hljs-type">int8</span>, <span class="hljs-type">int16</span>, <span class="hljs-type">int32</span>, <span class="hljs-type">int64</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;param #%d is a int, value: %d\n&quot;</span>, i, x)<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">uint</span>, <span class="hljs-type">uint8</span>, <span class="hljs-type">uint16</span>, <span class="hljs-type">uint32</span>, <span class="hljs-type">uint64</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;param #%d is a uint, value: %d\n&quot;</span>, i, x)<br>        <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;param #%d is a nil\n&quot;</span>, i)<br>        <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;param #%d is a string, value: %s\n&quot;</span>, i, x)<br>        <span class="hljs-keyword">default</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;param #%d&#x27;s type is unknow\n&quot;</span>, i)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    classchecker(<span class="hljs-number">5</span>, <span class="hljs-number">-17.98</span>, <span class="hljs-string">&quot;AIDEN&quot;</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>, <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码中我们首先创建了一个接收任意数量任意类型参数的函数，然后使用 <code>for ... range aSlice</code> 的语法迭代了每一个在切片 <code>items</code> 中的元素，接着使用了 <code>switch</code> 类型开关判断了每一个参数的类型，并打印了其值和类型。程序运行输出如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> run switch_t.<span class="hljs-keyword">go</span><br>param #<span class="hljs-number">0</span> is a <span class="hljs-type">int</span>, value: <span class="hljs-number">5</span><br>param #<span class="hljs-number">1</span> is a <span class="hljs-type">float64</span>, value: <span class="hljs-number">-17.980000</span><br>param #<span class="hljs-number">2</span> is a <span class="hljs-type">string</span>, value: AIDEN<br>param #<span class="hljs-number">3</span> is a <span class="hljs-literal">nil</span><br>param #<span class="hljs-number">4</span> is a <span class="hljs-type">bool</span>, value: <span class="hljs-literal">true</span><br>param #<span class="hljs-number">5</span><span class="hljs-string">&#x27;s type is unknow</span><br></code></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Go 语言可以很方便的自定义函数，其中有特殊的函数 <code>main</code> 函数。<code>main</code> 函数必须出现在 <code>main</code> 包里，且只能出现一次。当 Go 程序运行时候会自动调用 <code>main</code> 函数开始整个程序的执行。<code>main</code> 函数不可接收任何参数，也不返回任何结果。</p>
<h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>在 Go 语言中，函数的基本组成包括：关键字 <code>func</code>、函数名、参数列表、返回值、函数体和返回语句，这里我们用一个简单的加法函数来对函数的定义进行说明。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> add<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> (num <span class="hljs-type">int</span>)&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h4><p>函数调用非常简单，先将被调用函数所在的包导入，就可以直接使用该函数了。注意需要把包文件夹放到 <code>$GOPATH</code> 目录中，实例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;add&quot;</span> <span class="hljs-comment">//导入 add 包</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    c := add.Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">//调用 add 包中的 add 函数</span><br>    fmt.Println(c)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="函数的多返回值"><a href="#函数的多返回值" class="headerlink" title="函数的多返回值"></a>函数的多返回值</h4><p>与 C&#x2F;C++ 和 JAVA 不同，Go 语言的函数和方法可以有多个返回值，这是 Go 提供的一个优美的特性，示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> Divide<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;errors&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span> <span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> (num <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)&#123; <span class="hljs-comment">//定义两个返回值</span><br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br>        err = errors.New(<span class="hljs-string">&quot;被除数不能为零！&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> a / b, <span class="hljs-literal">nil</span>   <span class="hljs-comment">//支持多个返回值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="匿名函数-1"><a href="#匿名函数-1" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>在 Go 语言中，你可以在代码里随时定义匿名函数，匿名函数由一个不带函数名的函数声明和函数体组成，示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a, b, c <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> a * b &lt; c<br>&#125;<br></code></pre></td></tr></table></figure>

<p>你可以将匿名函数直接赋值给一个变量，也可以直接调用运行，示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a, b, c <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> a * b &lt; c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a, b, c <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> a * b &lt; c<br>&#125; (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">//小括号内直接给参数列表表示函数调用</span><br></code></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h4 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h4><p>Go 语言提供了一种在不同但相互兼容的类型之间相互转换的方式，这种转换非常有用并且是安全的。但是需要注意的是在数值之间进行转换可能造成其他问题，如精度丢失或者错误的结果。以下是类型转换的语法：</p>
<ul>
<li><code>resultOfType := Type(expression)</code></li>
</ul>
<p>几个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-type">int16</span>(<span class="hljs-number">2345</span>)        <span class="hljs-comment">// 声明一个类型为int16的整数，其值为2345</span><br>y := <span class="hljs-type">int32</span>(x)           <span class="hljs-comment">// 将int16类型的整数转换为int32类型</span><br>a := <span class="hljs-type">uint16</span>(<span class="hljs-number">65000</span>)       <span class="hljs-comment">// 声明一个类型为uint16类型的整数</span><br>b := <span class="hljs-type">int16</span>(a)           <span class="hljs-comment">// 转换为int16类型，虽然能转换成功，但是由于65000超过in16类型的范围，会导致结果错误，b的值为 -536</span><br></code></pre></td></tr></table></figure>

<p>另外在 Go 语言中可以通过 <code>type</code> 关键字声明类型，如 <code>type StringsSlice []string</code> 将 <code>[]string</code>（<code>string</code> 类型的切片）声明为 <code>StringSlice</code> 类型。</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>说到类型断言就需要先了解下 Go 语言中的接口。在 Go 语言中接口是一个自定义类型。它声明了一个或者多个方法。任何实现了这些方法的对象（类型）都满足这个接口。</p>
<p>接口是完全抽象的，不能实例化。<code>interface&#123;&#125;</code> 类型表示一个空接口，任何类型都满足空接口。也就是说 <code>interface&#123;&#125;</code> 类型的值可以用于表示任意 Go 语言类型的值。</p>
<p>这里的空接口有点类似于 Python 语言中的 object 实例。既然 <code>interface&#123;&#125;</code> 可以用于表示任意类型，那有的时候我们需要将 <code>interface&#123;&#125;</code> 类型转换为我们需要的类型，这个操作称为类型断言。</p>
<p><strong>一般情况下只有我们希望表达式是某种特定类型的值时才使用类型断言</strong>。Go 语言中可以使用以下语法：</p>
<ul>
<li><code>resultOfType, boolean := expression.(Type)</code>：安全的类型断言。</li>
<li><code>resultOfType := expression.(Type)</code>：非安全的类型断言，失败时程序会产生异常。</li>
</ul>
<p>创建源文件 <code>type_t.go</code>，输入以下源文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x := <span class="hljs-type">uint16</span>(<span class="hljs-number">65000</span>)<br>    y := <span class="hljs-type">int16</span>(x) <span class="hljs-comment">// 将 x转换为int16类型</span><br>    fmt.Printf(<span class="hljs-string">&quot;type and value of x is: %T and %d\n&quot;</span>, x, x) <span class="hljs-comment">// %T 格式化指令的作用是输出变量的类型</span><br>    fmt.Printf(<span class="hljs-string">&quot;type and value of y is: %T and %d\n&quot;</span>, y, y)<br><br>    <span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">99</span> <span class="hljs-comment">// 创建一个interface&#123;&#125;类型，其值为99</span><br>    <span class="hljs-keyword">var</span> s <span class="hljs-keyword">interface</span>&#123;&#125; = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;left&quot;</span>, <span class="hljs-string">&quot;right&quot;</span>&#125;<br>    j := i.(<span class="hljs-type">int</span>) <span class="hljs-comment">// 我们假设i是兼容int类型，并使用类型断言将其转换为int类型</span><br>    fmt.Printf(<span class="hljs-string">&quot;type and value of j is: %T and %d\n&quot;</span>, j, j)<br><br>    <span class="hljs-keyword">if</span> s, ok := s.([]<span class="hljs-type">string</span>); ok &#123; <span class="hljs-comment">// 创建了影子变量，if的作用域中覆盖了外部的变量s</span><br>        fmt.Printf(<span class="hljs-string">&quot;%T -&gt; %q\n&quot;</span>, s, s)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run type_t.go<br><span class="hljs-built_in">type</span> and value of x is: uint16 and 65000<br><span class="hljs-built_in">type</span> and value of y is: int16 and -536<br><span class="hljs-built_in">type</span> and value of j is: int and 99<br>[]string -&gt; [<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-string">&quot;right&quot;</span>]<br></code></pre></td></tr></table></figure>

<h2 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理*"></a>错误处理<code>*</code></h2><blockquote>
<p>错误处理是任何语言都需要考虑到的问题，而 Go 语言在错误处理上解决得更为完善，优雅的错误处理机制是 Go 语言的一大特点。</p>
</blockquote>
<h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>Go 语言引入了一个错误处理的标准模式，即 <code>error</code> 接口，该接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于大多数函数，如果要返回错误，可以将 <code>error</code> 作为多返回值的最后一个：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(param <span class="hljs-type">int</span>)</span></span>(ret <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用时的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">n, err := foo(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">//  错误处理</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 使用返回值n</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们还可以自定义错误类型，创建源文件 <code>error.go</code>，输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;errors&quot;</span><br><br><span class="hljs-comment">//自定义的出错结构</span><br><span class="hljs-keyword">type</span> myError <span class="hljs-keyword">struct</span> &#123;<br>    arg  <span class="hljs-type">int</span><br>    errMsg <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-comment">//实现Error接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *myError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d - %s&quot;</span>, e.arg, e.errMsg)<br>&#125;<br><br><span class="hljs-comment">//两种出错</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">error_test</span><span class="hljs-params">(arg <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> arg &lt; <span class="hljs-number">0</span>  &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>, errors.New(<span class="hljs-string">&quot;Bad Arguments - negtive!&quot;</span>)<br>     &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> arg &gt;<span class="hljs-number">256</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>, &amp;myError&#123;arg, <span class="hljs-string">&quot;Bad Arguments - too large!&quot;</span>&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arg*arg, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">//相关的测试</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1000</span>&#125; &#123;<br>        <span class="hljs-keyword">if</span> r, e := error_test(i); e != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;failed:&quot;</span>, e)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;success:&quot;</span>, r)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><blockquote>
<p>你可以在 Go 函数中添加多个 <code>defer</code> 语句，当函数执行到最后时，这些 defer 语句会按照逆序执行（即最后一个 <code>defer</code> 语句将最先执行），最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。</p>
</blockquote>
<p>如下代码所示，我们一般写打开一个资源是这样操作的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CopyFile</span><span class="hljs-params">(dst, src <span class="hljs-type">string</span>)</span></span> (w <span class="hljs-type">int64</span>, err <span class="hljs-type">error</span>) &#123;<br>    srcFile, err := os.Open(src)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">defer</span> srcFile.Close()<br><br>    dstFile, err := os.Create(dst)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">defer</span> dstFile.Close()<br><br>    <span class="hljs-keyword">return</span> io.Copy(dstFile, srcFile)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果 <code>defer</code> 后面一条语句干不完清理工作，也可以使用一个匿名函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    ...<br>&#125;()<br></code></pre></td></tr></table></figure>

<p>注意，<code>defer</code> 语句是在 <code>return</code> 之后执行的，新建源文件 <code>defer.go</code> 输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> (result <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        result = <span class="hljs-number">12</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(test())     <span class="hljs-comment">// 12</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="panic-和-recover"><a href="#panic-和-recover" class="headerlink" title="panic 和 recover"></a><code>panic</code> 和 <code>recover</code></h3><p><code>panic()</code> 函数用于抛出异常，<code>recover()</code> 函数用于捕获异常，这两个函数的原型如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panic</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recover</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>当在一个函数中调用 <code>panic()</code> 时，正常的函数执行流程将立即终止，但函数中之前使用 <code>defer</code> 关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致逐层向上执行 <code>panic()</code> 流程，直至所属的 <code>goroutine</code> 中所有正在执行的函数被终止。错误信息将被报告，包括在调用 <code>panic()</code> 函数时传入的参数，这个过程称为错误流程处理。</p>
<p><code>panic()</code> 接受一个 <code>interface&#123;&#125;</code> 参数，可支持任意类型，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">panic</span>(<span class="hljs-number">404</span>)<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;network broken&quot;</span>)<br><span class="hljs-built_in">panic</span>(Error(<span class="hljs-string">&quot;file not exists&quot;</span>))<br></code></pre></td></tr></table></figure>

<p>在 <code>defer</code> 语句中，可以使用 <code>recover()</code> 终止错误处理流程，这样可以避免异常向上传递，但要注意 <code>recover()</code> 之后，程序不会再回到 <code>panic()</code> 那里，函数仍在 <code>defer</code> 之后返回。新建一个源文件 <code>error1.go</code>，输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">panic</span>(errors.New(<span class="hljs-string">&quot;i&#x27;m a bug&quot;</span>))<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> (result <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>            err := r.(<span class="hljs-type">error</span>)<br>            fmt.Println(<span class="hljs-string">&quot;Cache Exception:&quot;</span>, err)<br>        &#125;<br>    &#125;()<br>    foo()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(test())     <span class="hljs-comment">// 0</span><br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h1 id="四、面向对象编程"><a href="#四、面向对象编程" class="headerlink" title="四、面向对象编程"></a>四、面向对象编程</h1><blockquote>
<p>Go 语言的代码是以包结构来组织的，且如果标示符（变量名，函数名，自定义类型等）**<code>*</code>如果以大写字母开头那么这些标示符是可以导出的**，可以在任何导入了定义该标示符的包的包中直接使用。Go 语言中的面向对象和 C++，Java 中的面向对象不同，因为 Go 语言不支持继承，Go 语言只支持组合。</p>
</blockquote>
<h2 id="自定义类型及结构体"><a href="#自定义类型及结构体" class="headerlink" title="自定义类型及结构体"></a>自定义类型及结构体</h2><blockquote>
<p>Go 语言的中结构体 <code>struct</code> 与 C++、JAVA 中的类 <code>class</code> 相似，但 Go 放弃了传统面向对象的诸多特性，只保留了组合。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> typeName typeSpecification<br></code></pre></td></tr></table></figure>

<p>其中，<code>typeName</code> 可以是一个包或者函数内唯一合法的 Go 标示符。<code>typeSpecification</code> 可以是任何内置的类型，一个接口或者是一个结构体。所谓结构体，它的字段是由其他类型或者接口组成。例如我们通过结构体定义了一下类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ColorPoint <span class="hljs-keyword">struct</span> &#123;<br>    color.Color     <span class="hljs-comment">// 匿名字段(嵌入)</span><br>    x, y <span class="hljs-type">int</span>        <span class="hljs-comment">// 具名字段(聚合)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码我们通过结构体自定义了类型 <code>ColorPoint</code>，结构体中 <code>color.Color</code> 字段是 Color 包的类型 color，这个字段没有名字，所以被称为匿名的，也是嵌入字段。字段 <code>x</code> 和 <code>y</code> 是有变量名的，所以被称为具名字段。假如我们创建了类型 <code>ColorPoint</code> 的一个值 <code>point</code>（通过语法：<code>point := ColorPoint&#123;&#125;</code> 创建），那么这些字段可以通过 <code>point.Color</code>、<code>point.x</code>、<code>point.y</code> 访问。其他面向对象语言中的”类 (<code>class</code>)”、”对象 (<code>object</code>)”、”实例 (<code>instance</code>)”在 Go 语言中我们完全避开使用。相反的我们使用”类型 (<code>type</code>)”和其对应的”值”，其中自定义类型的值可以包含方法。</p>
<p>定义了结构体后如何创建并初始化一个对象实例呢？Go 语言支持以下几种方法进行实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//先定义一个结构体Man</span><br><span class="hljs-keyword">type</span> Man <span class="hljs-keyword">struct</span>&#123;<br>    name <span class="hljs-type">string</span><br>    age <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-comment">//对象创建与初始化</span><br>man := <span class="hljs-built_in">new</span>(Man)<br>man := &amp;Man&#123;&#125;<br>man := &amp;Man&#123;<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">18</span>&#125;<br>man := &amp;Man&#123;name: <span class="hljs-string">&quot;Tom&quot;</span>, age: <span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure>

<p>为了更加方便的创建对象，我们一般会使用一个全局函数来完成对象的创建，这和传统的“构造函数”类似。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMan</span><span class="hljs-params">(name <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>)</span></span> *Man &#123;<br>    <span class="hljs-keyword">return</span> &amp;Man&#123;name, age&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><blockquote>
<p><strong>方法</strong>是作用在自定义类型上的一类特殊函数，通常自定义类型的值会被传递给该函数，该值可能是以指针或者复制值的形式传递。定义方法和定义函数几乎相同，只是需要在 <code>func</code> 关键字和方法名之间必须写上接接受者。例如我们给类型 <code>Count</code> 定义了以下方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Count <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(count *Count)</span></span> Increment() &#123; *count++ &#125;  <span class="hljs-comment">// 接受者是一个 `Count` 类型的指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(count *Count)</span></span> Decrement() &#123; *count-- &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(count Count)</span></span> IsZero() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure>

<p>以上代码中，我们在内置类型 <code>int</code> 的基础上定义了自定义类型 <code>Count</code>，然后给该类型添加了 <code>Increment()</code>、<code>Decrement()</code> 和 <code>IsZero()</code> 方法，其中前两者的接受者为 <code>Count</code> 类型的指针，后一个方法接收 <code>Count</code> 类型的值。</p>
</blockquote>
<p>Demo:</p>
<p>类型的方法集是指可以被该类型的值调用的所有方法的集合。</p>
<p>一个指向自定义类型的值的指针，它的方法集由该类型定义的所有方法组成，无论这些方法接受的是一个值还是一个指针。如果在指针上调用一个接受值的方法，Go 语言会聪明地将该指针解引用。</p>
<p>一个自定义类型值的方法集合则由该类型定义的接收者为值类型的方法组成，但是不包括那些接收者类型为指针的方法。</p>
<p>其实这些限制 Go 语言帮我们解决的非常好，结果就是我们可以在值类型上调用接收者为指针的方法。假如我们只有一个值，仍然可以调用一个接收者为指针类型的方法，这是因为 Go 语言会自动获取值的地址传递给该方法，前提是该值是可寻址的。</p>
<p>在以上定义的类型 <code>Count</code> 中，<code>*Count</code> 方法集是 <code>Increment()</code>, <code>Decrement()</code> 和 <code>IsZero()</code>，<code>Count</code> 的值的方法集是 <code>IsZero()</code>。但是因为 <code>Count</code> 类型的是可寻址的，所以我们可以使用 <code>Count</code> 的值调用全部的方法。</p>
<p>另外如果结构体的字段也有方法，我们也可以直接通过结构体访问字段中的方法。下面让我们练习下，创建源文件 <code>struct_t.go</code>，输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Count <span class="hljs-type">int</span> <span class="hljs-comment">// 创建自定义类型 Count</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(count *Count)</span></span> Increment()  &#123; *count++ &#125; <span class="hljs-comment">// Count类型的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(count *Count)</span></span> Decrement()  &#123; *count-- &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(count Count)</span></span> IsZero() <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span> &#125;<br><br><span class="hljs-keyword">type</span> Part <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 基于结构体创建自定义类型 Part</span><br>    stat  <span class="hljs-type">string</span><br>    Count <span class="hljs-comment">// 匿名字段</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(part Part)</span></span> IsZero() <span class="hljs-type">bool</span> &#123; <span class="hljs-comment">// 覆盖了匿名字段Count的IsZero()方法</span><br>    <span class="hljs-keyword">return</span> part.Count.IsZero() &amp;&amp; part.stat == <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// 调用了匿名字段的方法</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(part Part)</span></span> String() <span class="hljs-type">string</span> &#123; <span class="hljs-comment">// 定义String()方法，自定义了格式化指令%v的输出</span><br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;&lt;&lt;%s, %d&gt;&gt;&quot;</span>, part.stat, part.Count)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> i Count = <span class="hljs-number">-1</span><br>    fmt.Printf(<span class="hljs-string">&quot;Start \&quot;Count\&quot; test:\nOrigin value of count: %d\n&quot;</span>, i)<br>    i.Increment()<br>    fmt.Printf(<span class="hljs-string">&quot;Value of count after increment: %d\n&quot;</span>, i)<br>    fmt.Printf(<span class="hljs-string">&quot;Count is zero t/f? : %t\n\n&quot;</span>, i.IsZero())<br>    fmt.Println(<span class="hljs-string">&quot;Start: \&quot;Part\&quot; test:&quot;</span>)<br>    part := Part&#123;<span class="hljs-string">&quot;232&quot;</span>, <span class="hljs-number">0</span>&#125;<br>    fmt.Printf(<span class="hljs-string">&quot;Part: %v\n&quot;</span>, part)<br>    fmt.Printf(<span class="hljs-string">&quot;Part is zero t/f? : %t\n&quot;</span>, part.IsZero())<br>    fmt.Printf(<span class="hljs-string">&quot;Count in Part is zero t/f?: %t\n&quot;</span>, part.Count.IsZero()) <span class="hljs-comment">// 尽管覆盖了匿名字段的方法，单还是可以访问</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码中，我们创建了 <code>Count</code> 类型，然后在其基础上又创建了结构体类型 <code>Part</code>。我们为 <code>Count</code> 类型定义了 3 个方法，并在 <code>Part</code> 类型中创建了方法 <code>IsZero()</code> 覆盖了其匿名字段 <code>Count</code> 中 <code>IsZero()</code> 方法。但是我们还是可以二次访问到匿名字段中被覆盖的方法。执行代码，输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run struct_t.go<br>Start <span class="hljs-string">&quot;Count&quot;</span> <span class="hljs-built_in">test</span>:<br><br><br>Origin value of count: -1<br>Value of count after increment: 0<br>Count is zero t/f? : <span class="hljs-literal">true</span><br><br>Start: <span class="hljs-string">&quot;Part&quot;</span> <span class="hljs-built_in">test</span>:<br>Part: &lt;&lt;<span class="hljs-string">232, 0&gt;&gt;</span><br><span class="hljs-string">Part is zero t/f? : false</span><br><span class="hljs-string">Count in Part is zero t/f?: true</span><br></code></pre></td></tr></table></figure>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><blockquote>
<p>Go 语言虽然抛弃了继承，但是却提供了一个更加方便的组合特性。相对于继承的编译期确定实现，组合的运行态指定实现，更加灵活。下面通过一段代码来了解组合的基本属性以及它与继承的不同之处。</p>
</blockquote>
<p>先定义一个结构体 Base, 并为它添加两个方法 <code>Foo()</code> 和 <code>Bar()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Base <span class="hljs-keyword">struct</span>&#123;<br>    Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Base)</span></span> Foo() &#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Base)</span></span> Bar() &#123;...&#125;<br><br><span class="hljs-keyword">type</span> Seed <span class="hljs-keyword">struct</span> &#123;<br>    Base<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Seed)</span></span> Foo() &#123;<br>    s.Base.Foo()<br>    s.Bar()<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码先定义了一个 Base 类，然后定义了一个 Seed 类。Seed 类“继承”了 Base 类的所有成员属性和方法并重写了 <code>Foo()</code> 方法。同时在重写 <code>Foo()</code> 方法时调用了 Base 类的 <code>Foo()</code> 方法和 <code>Bar()</code> 方法。需要注意的是，若此时 Seed 的对象通过 <code>s.Foo()</code> 调用 <code>Foo()</code> 方法时，实际调用的是 Seed 重写过后的 <code>Foo()</code> 方法，而不是基类 Base 的 <code>Foo()</code> 方法，若想调用 Base 类的 <code>Foo()</code> 方法则要使用 <code>s.Base.Foo</code>，而调用没有重写的 <code>Bar()</code> 方法时，<span style="background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900">使用 <code>s.Bar()</code> 和<code>s.Base.Bar()</code> 效果是一样的</span>。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在 Go 中，<strong>接口</strong>是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。它与 oop 非常相似。接口指定类型应具有的方法，类型决定如何实现这些方法。</p>
<h3 id="接口基础"><a href="#接口基础" class="headerlink" title="接口基础"></a>接口基础</h3><p>之所以说 Go 语言的面向对象很灵活，很大一部分原因是由于接口的存在。接口是一个自定义类型，它声明了一个或者多个方法签名，任何实现了这些方法的类型都实现这个接口。<code>infterface&#123;&#125;</code> 类型是声明了空方法集的接口类型。任何一个值都满足 <code>interface&#123;&#125;</code> 类型，也就是说如果一个函数或者方法接收 <code>interface&#123;&#125;</code> 类型的参数，那么任意类型的参数都可以传递给该函数。接口是完全抽象的，不能实例化。接口能存储任何实现了该接口的类型。直接看例子吧，创建源文件 <code>interface_t.go</code>，输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Human <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 结构体</span><br>    name  <span class="hljs-type">string</span><br>    age   <span class="hljs-type">int</span><br>    phone <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">//Human实现SayHi方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Human)</span></span> SayHi() &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)<br>&#125;<br><br><span class="hljs-comment">//Human实现Sing方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Human)</span></span> Sing(lyrics <span class="hljs-type">string</span>) &#123;<br>    fmt.Println(<span class="hljs-string">&quot;La la la la...&quot;</span>, lyrics)<br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>    Human  <span class="hljs-comment">//匿名字段</span><br>    school <span class="hljs-type">string</span><br>    loan   <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>    Human   <span class="hljs-comment">//匿名字段</span><br>    company <span class="hljs-type">string</span><br>    money   <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-comment">// Employee重载Human的SayHi方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> SayHi() &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,<br>        e.company, e.phone)<br>&#125;<br><br><span class="hljs-comment">// Interface Men被Human,Student和Employee实现</span><br><span class="hljs-comment">// 因为这三个类型都实现了这两个方法</span><br><span class="hljs-keyword">type</span> Men <span class="hljs-keyword">interface</span> &#123;<br>    SayHi()<br>    Sing(lyrics <span class="hljs-type">string</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    mike := Student&#123;Human&#123;<span class="hljs-string">&quot;Mike&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;222-222-XXX&quot;</span>&#125;, <span class="hljs-string">&quot;MIT&quot;</span>, <span class="hljs-number">0.00</span>&#125;<br>    paul := Student&#123;Human&#123;<span class="hljs-string">&quot;Paul&quot;</span>, <span class="hljs-number">26</span>, <span class="hljs-string">&quot;111-222-XXX&quot;</span>&#125;, <span class="hljs-string">&quot;Harvard&quot;</span>, <span class="hljs-number">100</span>&#125;<br>    sam := Employee&#123;Human&#123;<span class="hljs-string">&quot;Sam&quot;</span>, <span class="hljs-number">36</span>, <span class="hljs-string">&quot;444-222-XXX&quot;</span>&#125;, <span class="hljs-string">&quot;Golang Inc.&quot;</span>, <span class="hljs-number">1000</span>&#125;<br>    Tom := Employee&#123;Human&#123;<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">37</span>, <span class="hljs-string">&quot;222-444-XXX&quot;</span>&#125;, <span class="hljs-string">&quot;Things Ltd.&quot;</span>, <span class="hljs-number">5000</span>&#125;<br><br>    <span class="hljs-comment">//定义Men类型的变量i</span><br>    <span class="hljs-keyword">var</span> i Men<br><br>    <span class="hljs-comment">//i能存储Student</span><br>    i = mike<br>    fmt.Println(<span class="hljs-string">&quot;This is Mike, a Student:&quot;</span>)<br>    i.SayHi()<br>    i.Sing(<span class="hljs-string">&quot;November rain&quot;</span>)<br><br>    <span class="hljs-comment">//i也能存储Employee</span><br>    i = Tom<br>    fmt.Println(<span class="hljs-string">&quot;This is Tom, an Employee:&quot;</span>)<br>    i.SayHi()<br>    i.Sing(<span class="hljs-string">&quot;Born to be wild&quot;</span>)<br><br>    <span class="hljs-comment">//定义了slice Men</span><br>    fmt.Println(<span class="hljs-string">&quot;Let&#x27;s use a slice of Men and see what happens&quot;</span>)<br>    x := <span class="hljs-built_in">make</span>([]Men, <span class="hljs-number">3</span>)<br>    <span class="hljs-comment">//这三个都是不同类型的元素，但是他们实现了interface同一个接口</span><br>    x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>], x[<span class="hljs-number">2</span>] = paul, sam, mike<br><br>    <span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> x &#123;<br>        value.SayHi()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="接口变量值的类型"><a href="#接口变量值的类型" class="headerlink" title="接口变量值的类型*"></a>接口变量值的类型<code>*</code></h3><blockquote>
<p><span style="background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900">接口类型声明的变量里能存储任何实现了该接口的类型的值。</span></p>
<p>有的时候我们需要知道这个变量里的值的类型，那么需要怎么做呢？可以使用类型断言，或者是 <code>switch</code> 类型判断分支。以下的例子 <code>interface_t1.go</code> 我们使用了 <code>switch</code> 类型判断分支。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*使用了switch 类型判断分支*/</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Element <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">type</span> List []Element<br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>	name <span class="hljs-type">string</span><br>	age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 实现了fmt.Stringer接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> String() <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(name: &quot;</span> + p.name + <span class="hljs-string">&quot;- age: &quot;</span> + strconv.Itoa(p.age) + <span class="hljs-string">&quot; years)&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	list := <span class="hljs-built_in">make</span>(List, <span class="hljs-number">4</span>)<br>	list[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>	list[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Hello&quot;</span><br>	list[<span class="hljs-number">2</span>] = Person&#123;<span class="hljs-string">&quot;Dennis&quot;</span>, <span class="hljs-number">70</span>&#125;<br>	list[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span> + <span class="hljs-number">2i</span><br><br>	<span class="hljs-keyword">for</span> index, element := <span class="hljs-keyword">range</span> list &#123;<br>		<span class="hljs-keyword">switch</span> value := element.(<span class="hljs-keyword">type</span>) &#123;<br>		<span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>			fmt.Printf(<span class="hljs-string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)<br>		<span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>			fmt.Printf(<span class="hljs-string">&quot;list[%d] is an int and its value is %s\n&quot;</span>, index, value)<br>		<span class="hljs-keyword">case</span> Person:<br>			fmt.Printf(<span class="hljs-string">&quot;list[%d] is an int and its value is %s\n&quot;</span>, index, value)<br>		<span class="hljs-keyword">default</span>:<br>			fmt.Printf(<span class="hljs-string">&quot;list[%d] is of a different type&quot;</span>, index)<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="嵌入interface"><a href="#嵌入interface" class="headerlink" title="嵌入interface"></a>嵌入interface</h3><p>结构体中可以嵌入匿名字段，其实在接口里也可以再嵌入接口。<span style="background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900">如果一个 <code>interface1</code> 作为 <code>interface2</code> 的一个嵌入字段，那么 <code>interface2</code> 隐式的包含了 <code>interface1</code> 里的方法。</span>如下例子中，<code>Interface2</code> 包含了 <code>Interface1</code> 的所有方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface1 <span class="hljs-keyword">interface</span> &#123;<br>    Send()<br>    Receive()<br>&#125;<br><br><span class="hljs-keyword">type</span> Interface2 <span class="hljs-keyword">interface</span> &#123;<br>    Interface1<br>    Close()<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="五、并发编程"><a href="#五、并发编程" class="headerlink" title="五、并发编程"></a>五、并发编程</h1><blockquote>
<h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><p>并发指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，通过 CPU 时间片轮转使多个进程快速交替的执行。而并行的关键是你有同时处理多个任务的能力。并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）CPU 执行，如果可以就说明是并行，而并发是多个线程被（一个）CPU 轮流切换着执行。一个经典且通俗易懂的例子这样解释并发与并行的区别：并发是两个队列，使用一台咖啡机；并行是两个队列，使用两台咖啡机。如果串行，一个队列使用一台咖啡机，那么哪怕前面那个人有事出去了半天，后面的人也只能等着他回来才能去接咖啡，这效率无疑是最低的。图解：</p>
<p><img src="/../../../images/GO_%E5%AE%9E%E9%AA%8C%E6%A5%BC%E7%AC%94%E8%AE%B0/GO_1.png" alt="并发与并行"></p>
</blockquote>
<blockquote>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程*"></a>协程<code>*</code></h4><p>协程也叫轻量级线程。与传统的进程和线程相比，协程最大的优点就在于其足够“轻”，操作系统可以轻松创建上百万个协程而不会导致系统资源枯竭，而线程和进程通常最多不过近万个。而多数语言在语法层面上是不支持协程的，一般都是通过库的方式进行支持，但库的支持方式和功能不够完善，经常会引发阻塞等一系列问题，而 Go 语言在语法层面上支持协程，也叫 <code>goroutine</code>。这让协程变得非常简单，让轻量级线程的切换管理不再依赖于系统的进程和线程，也不依赖 CPU 的数量。</p>
</blockquote>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine*"></a>goroutine<code>*</code></h2><p><code>goroutine</code> 是 Go 语言并行设计的核心。<code>goroutine</code> 是一种比线程更轻量的实现，十几个 <code>goroutine</code> 可能在底层就是几个线程。 不同的是，Golang 在 runtime、系统调用等多方面对 <code>goroutine</code> 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 <code>goroutine</code> 的 CPU (P) 转让出去，让其他 <code>goroutine</code> 能被调度并执行，也就是 Golang 从语言层面支持了协程。要使用 <code>goroutine</code> 只需要简单的在需要执行的函数前添加 <code>go</code> 关键字即可。当执行 <code>goroutine</code> 时候，Go 语言立即返回，接着执行剩余的代码，<code>goroutine</code> 不阻塞主线程。下面我们通过一小段代码来讲解 <code>go</code> 的使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//首先我们先实现一个 Add()函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>    c := a + b<br>    fmt.Println(c)<br>&#125;<br><br><span class="hljs-keyword">go</span> Add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">//使用go关键字让函数并发执行</span><br></code></pre></td></tr></table></figure>

<p>Go 的并发执行就是这么简单，当在一个函数前加上 <code>go</code> 关键字，该函数就会在一个新的 goroutine 中并发执行，当该函数执行完毕时，这个新的 goroutine 也就结束了。不过需要注意的是，如果该函数具有返回值，那么返回值会被丢弃。所以什么时候用 <code>go</code> 还需要酌情考虑。</p>
<p>接着我们通过一个案例来体验一下 Go 的并发到底是怎么样的。新建源文件 <code>goroutine.go</code>，输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>    c := a + b<br>    fmt.Println(c)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> Add(i, i)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行 <code>goroutine.go</code> 文件会发现屏幕上什么都没有，但程序并不会报错，这是什么原因呢？原来当主程序执行到 for 循环时启动了 10 个 <code>goroutine</code>，然后主程序就退出了，而启动的 10 个 <code>goroutine</code> 还没来得及执行 <code>Add()</code> 函数，所以程序不会有任何输出。也就是说主 <code>goroutine</code> 并不会等待其他 <code>goroutine</code> 执行结束。那么如何解决这个问题呢？Go 语言提供的信道（<code>channel</code>）就是专门解决并发通信问题的</p>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p><code>channel</code> 是<code>goroutine</code> 之间互相通讯的东西。类似我们 Unix 上的管道（可以在进程间传递消息），用来 <code>goroutine</code> 之间发消息和接收消息。其实，就是在做 <code>goroutine</code> 之间的内存共享。<code>channel</code> 是类型相关的，也就是说一个 <code>channel</code> 只能传递一种类型的值，这个类型需要在 <code>channel</code> 声明时指定。</p>
<h3 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h3><p><code>channel</code> 的一般声明形式：<strong>var</strong> chanName <strong>chan</strong> ElementType。</p>
<p>与普通变量的声明不同的是在类型前面加了 <code>channel</code> 关键字，<code>ElementType</code> 则指定了这个 <code>channel</code> 所能传递的元素类型。示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">//声明一个传递元素类型为int的channel</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">chan</span> <span class="hljs-type">float64</span><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure>

<p>初始化一个 <code>channel</code> 也非常简单，直接使用 Go 语言内置的 <code>make()</code> 函数，示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">//初始化一个int型的名为a的channel</span><br>b := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">float64</span>)<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure>

<p><code>channel</code> 最频繁的操作就是写入和读取，这两个操作也非常简单，示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>a &lt;- <span class="hljs-number">1</span>  <span class="hljs-comment">//将数据写入channel</span><br>z := &lt;-a  <span class="hljs-comment">//从channel中读取数据</span><br></code></pre></td></tr></table></figure>

<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><code>select</code> 用于处理异步 IO 问题，它的语法与 <code>switch</code> 非常类似。由 <code>select</code> 开始一个新的选择块，每个选择条件由 <code>case</code> 语句来描述，并且每个 <code>case</code> 语句里必须是一个 <code>channel</code> 操作。它既可以用于 <code>channel</code> 的数据接收，也可以用于 <code>channel</code> 的数据发送。如果 <code>select</code> 的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。</p>
<p>新建源文件 <code>channel.go</code>，输入以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(time.Second * <span class="hljs-number">1</span>)<br>        c1 &lt;- <span class="hljs-string">&quot;one&quot;</span><br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        time.Sleep(time.Second * <span class="hljs-number">2</span>)<br>        c2 &lt;- <span class="hljs-string">&quot;two&quot;</span><br>    &#125;()<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> msg1 := &lt;-c1:<br>            fmt.Println(<span class="hljs-string">&quot;received&quot;</span>, msg1)<br>        <span class="hljs-keyword">case</span> msg2 := &lt;-c2:<br>            fmt.Println(<span class="hljs-string">&quot;received&quot;</span>, msg2)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码先初始化两个 <code>channel</code> c1 和 c2，然后开启两个 <code>goroutine</code> 分别往 c1 和 c2 写入数据，再通过 <code>select</code> 监听两个 <code>channel</code>，从中读取数据并输出。</p>
<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run channel.go<br>received one<br>received two<br></code></pre></td></tr></table></figure>

<h2 id="关于-for-select-和-channel-的用法："><a href="#关于-for-select-和-channel-的用法：" class="headerlink" title="关于 for select 和 channel 的用法："></a>关于 for select 和 channel 的用法：</h2><p>select 语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行。select 语句的分支分为两种，一种叫做候选分支，另一种叫做默认分支。候选分支总是以关键字 case 开头，后跟一个 case 表达式和一个冒号，然后我们可以从下一行开始写入当分支被选中时需要执行的语句。</p>
<p>由于 select 语句是专为通道而设计的，所以每个 case 表达式中都只能包含操作通道的表达式，比如接收表达式。使用一个接收值可以接收通道里的值，使用两个接收值可以判断通道是否已经关闭了。</p>
<p>对于 select 语句的执行规则如下：</p>
<ul>
<li>每个 case 都必须是一个通信。</li>
<li>所有 Channel 表达式都会被求值。</li>
<li>所有被发送的表达式都会被求值。</li>
<li>如果任意某个通信可以进行，它就执行，其他被忽略。</li>
<li>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 否则：</li>
<li>如果有 default 子句，则执行该语句。</li>
<li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 Channel 或值进行求值。</li>
</ul>
<p>注意这里是和 switch 的操作是不一样的，switch 操作中，只要从上到下有一个满足条件了，就会执行相应的那一个 case，select 中，我们是全部计算一遍，然后再从可满足条件的 case 中公平的执行其中一个。这是为了防止有些通道长期得不到执行。</p>
<h2 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h2><p>通过前面的内容我们了解到，<code>channel</code> 的读写操作非常简单，只需要通过 <code>&lt;-</code> 操作符即可实现，但是 <code>channel</code> 的使用不当却会带来大麻烦。我们先来看之前的一段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>a &lt;- <span class="hljs-number">1</span><br>z := &lt;-a<br></code></pre></td></tr></table></figure>

<p>观察上面三行代码，第 2 行往 <code>channel</code> 内写入了数据，第 3 行从 <code>channel</code> 中读取了数据，如果程序运行正常当然不会出什么问题，可如果第二行数据写入失败，或者 <code>channel</code> 中没有数据，那么第 3 行代码会因为永远无法从 <code>a</code> 中读取到数据而一直处于阻塞状态。相反的，如果 <code>channel</code> 中的数据一直没有被读取，那么写入操作也会一直处于阻塞状态。如果不正确处理这个情况，很可能会导致整个 <code>goroutine</code> 锁死，这就是超时问题。Go 语言没有针对超时提供专门的处理机制，但是我们却可以利用 <code>select</code> 来巧妙地实现超时处理机制，下面看一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">t := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span></span> &#123;<br>    time.Sleep(<span class="hljs-number">1e9</span>) <span class="hljs-comment">//等待1秒</span><br>    t &lt;- <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-ch:  <span class="hljs-comment">//从ch中读取数据</span><br><br>    <span class="hljs-keyword">case</span> &lt;-t:  <span class="hljs-comment">//如果1秒后没有从ch中读取到数据，那么从t中读取，并进行下一步操作</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样的方法就可以让程序在等待 1 秒后继续执行，而不会因为 ch 读取等待而导致程序停滞，从而巧妙地实现了超时处理机制，这种方法不仅简单，在实际项目开发中也是非常实用的。</p>
<h4 id="channel-的关闭"><a href="#channel-的关闭" class="headerlink" title="channel 的关闭"></a>channel 的关闭</h4><p><code>channel</code> 的关闭非常简单，使用 Go 语言内置的 <code>close()</code> 函数即可关闭 <code>channel</code>，示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-built_in">close</span>(ch)<br></code></pre></td></tr></table></figure>

<p>关闭了 <code>channel</code> 后如何查看 <code>channel</code> 是否关闭成功了呢？很简单，我们可以在读取 <code>channel</code> 时采用多重返回值的方式，示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">x, ok := &lt;-ch<br></code></pre></td></tr></table></figure>

<p>通过查看第二个返回值的 <code>bool</code> 值即可判断 <code>channel</code> 是否关闭，若为 <code>false</code> 则表示 <code>channel</code> 被关闭，反之则没有关闭。</p>
<hr>
<h1 id="六、词频统计综合案例"><a href="#六、词频统计综合案例" class="headerlink" title="六、词频统计综合案例"></a>六、词频统计综合案例</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>词频统计的程序逻辑很简单。我们首先会创建一个映射，然后读取文件的每一行，提取单词，然后更新映射中单词所对应的数量即可。</p>
<p>为了演示面向对象和 goroutine 的使用，我们将基础映射类型封装成了一个统计单词频率的包。我们在基础映射类型上创建了类型 <code>WordCound</code>，然后为该类型了实现了关键方法 <code>UpdateFreq()</code> 和 <code>WordFreqCounter()</code>，其中前者会读取一个文件并统计该文件中的所有单词的词频，后者通过 goroutine 实现了并发统计。</p>
<p>其并发逻辑是：对于每一个文件，创建一个 goroutine，在这个 goroutine 内部调用 <code>UpdateFreq()</code> 方法统计对应文件的词频，当统计完成以后会将映射中每一对键值转化为 <code>Pair</code> 结构发送到 <code>results</code> 通道，并在发送完成时候发送一个空结构体的值到 <code>done</code> 通道以表示自己的任务已经完成。由于 <code>map</code> 映射结构不支持并发写操作，所以我们通过 <code>result</code> 通道来保证每次只有一个 goroutine 能更新映射。又因为当所有的 goroutine 结束以后，有可能 <code>results</code> 通道中还有没来得及处理的数据，所以在 <code>WordFreqCounter()</code> 的结尾我们又开启了一个 <code>for</code> 循环处理 <code>results</code> 通道中的剩余数据。说了这么多，我们直接写代码吧。</p>
<p>在 <code>$GOPATH/src/wordcount</code> 目录中创建文件 <code>wordcount.go</code>，输入以下源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> wordcount<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bufio&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;sort&quot;</span><br>    <span class="hljs-string">&quot;strings&quot;</span><br>    <span class="hljs-string">&quot;unicode&quot;</span><br>    <span class="hljs-string">&quot;unicode/utf8&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Pair <span class="hljs-keyword">struct</span> &#123;<br>    Key   <span class="hljs-type">string</span><br>    Value <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// PariList实现了sort接口，可以使用sort.Sort对其排序</span><br><br><span class="hljs-keyword">type</span> PairList []Pair<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p PairList)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; p[i], p[j] = p[j], p[i] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p PairList)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(p) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p PairList)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> p[j].Value &lt; p[i].Value &#125; <span class="hljs-comment">// 逆序</span><br><br><span class="hljs-comment">// 提取单词</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SplitOnNonLetters</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    notALetter := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(char <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> !unicode.IsLetter(char) &#125;<br>    <span class="hljs-keyword">return</span> strings.FieldsFunc(s, notALetter)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   基于map实现了类型WordCount, 并对期实现了Merge(), Report(), SortReport(), UpdateFreq(),</span><br><span class="hljs-comment">   WordFreqCounter() 方法</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">type</span> WordCount <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 用于合并两个WordCount</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(source WordCount)</span></span> Merge(wordcount WordCount) WordCount &#123;<br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> wordcount &#123;<br>        source[k] += v<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> source<br>&#125;<br><br><span class="hljs-comment">// 打印词频统计情况</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wordcount WordCount)</span></span> Report() &#123;<br>    words := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(wordcount))<br>    wordWidth, frequencyWidth := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> word, frequency := <span class="hljs-keyword">range</span> wordcount &#123;<br>        words = <span class="hljs-built_in">append</span>(words, word)<br>        <span class="hljs-keyword">if</span> width := utf8.RuneCountInString(word); width &gt; wordWidth &#123;<br>            wordWidth = width<br>        &#125;<br>        <span class="hljs-keyword">if</span> width := <span class="hljs-built_in">len</span>(fmt.Sprint(frequency)); width &gt; frequencyWidth &#123;<br>            frequencyWidth = width<br>        &#125;<br>    &#125;<br>    sort.Strings(words)<br>    gap := wordWidth + frequencyWidth - <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;Word&quot;</span>) - <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;Word %*s%s\n&quot;</span>, gap, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;Frequency&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> words &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%-*s %*d\n&quot;</span>, wordWidth, word, frequencyWidth,<br>            wordcount[word])<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 从多到少打印词频</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wordcount WordCount)</span></span> SortReport() &#123;<br>    p := <span class="hljs-built_in">make</span>(PairList, <span class="hljs-built_in">len</span>(wordcount))<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> wordcount &#123; <span class="hljs-comment">// 将wordcount map转换成PairList</span><br>        p[i] = Pair&#123;k, v&#125;<br>        i++<br>    &#125;<br><br>    sort.Sort(p) <span class="hljs-comment">// 因为PairList实现了排序接口，所以可以使用sort.Sort()对其排序</span><br><br>    wordWidth, frequencyWidth := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, pair := <span class="hljs-keyword">range</span> p &#123;<br>        word, frequency := pair.Key, pair.Value<br>        <span class="hljs-keyword">if</span> width := utf8.RuneCountInString(word); width &gt; wordWidth &#123;<br>            wordWidth = width<br>        &#125;<br>        <span class="hljs-keyword">if</span> width := <span class="hljs-built_in">len</span>(fmt.Sprint(frequency)); width &gt; frequencyWidth &#123;<br>            frequencyWidth = width<br>        &#125;<br>    &#125;<br>    gap := wordWidth + frequencyWidth - <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;Word&quot;</span>) - <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;Frequency&quot;</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;Word %*s%s\n&quot;</span>, gap, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;Frequency&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> _, pair := <span class="hljs-keyword">range</span> p &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%-*s %*d\n&quot;</span>, wordWidth, pair.Key, frequencyWidth,<br>            pair.Value)<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 从文件中读取单词，并更新其出现的次数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wordcount WordCount)</span></span> UpdateFreq(filename <span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">var</span> file *os.File<br>    <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><br>    <span class="hljs-keyword">if</span> file, err = os.Open(filename); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Println(<span class="hljs-string">&quot;failed to open the file: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">defer</span> file.Close() <span class="hljs-comment">// 本函数退出之前时，关闭文件</span><br><br>    reader := bufio.NewReader(file)<br>    <span class="hljs-keyword">for</span> &#123;<br>        line, err := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>        <span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> SplitOnNonLetters(strings.TrimSpace(line)) &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) &gt; utf8.UTFMax ||<br>                utf8.RuneCountInString(word) &gt; <span class="hljs-number">1</span> &#123;<br>                wordcount[strings.ToLower(word)] += <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> err != io.EOF &#123;<br>                log.Println(<span class="hljs-string">&quot;failed to finish reading the file: &quot;</span>, err)<br>            &#125;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 并发统计单词频次</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wordcount WordCount)</span></span> WordFreqCounter(files []<span class="hljs-type">string</span>) &#123;<br><br>    results := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Pair, <span class="hljs-built_in">len</span>(files))  <span class="hljs-comment">// goroutine 将结果发送到该channel</span><br>    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-built_in">len</span>(files)) <span class="hljs-comment">// 每个goroutine工作完成后，发送一个空结构体到该channel，表示工作完成</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(files); &#123; <span class="hljs-comment">// 有多少个文件就开启多少个goroutine, 使用匿名函数的方式</span><br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(done <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">struct</span>&#123;&#125;, results <span class="hljs-keyword">chan</span>&lt;- Pair, filename <span class="hljs-type">string</span>)</span></span> &#123;<br>            wordcount := <span class="hljs-built_in">make</span>(WordCount)<br>            wordcount.UpdateFreq(filename)<br>            <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> wordcount &#123;<br>                pair := Pair&#123;k, v&#125;<br>                results &lt;- pair<br>            &#125;<br>            done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>        &#125;(done, results, files[i])<br><br>        i++<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> working := <span class="hljs-built_in">len</span>(files); working &gt; <span class="hljs-number">0</span>; &#123; <span class="hljs-comment">// 监听通道，直到所有的工作goroutine完成任务时才退出</span><br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> pair := &lt;-results: <span class="hljs-comment">// 接收发送到通道中的统计结果</span><br>            wordcount[pair.Key] += pair.Value<br><br>        <span class="hljs-keyword">case</span> &lt;-done: <span class="hljs-comment">// 判断工作goroutine是否全部完成</span><br>            working--<br><br>        &#125;<br>    &#125;<br><br>DONE: <span class="hljs-comment">// 再次启动for循环处理通道中还未处理完的值</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> pair := &lt;-results:<br>            wordcount[pair.Key] += pair.Value<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span> DONE<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>(results)<br>    <span class="hljs-built_in">close</span>(done)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后在 <code>$GOPATH</code> 目录中创建文件 <code>wordfreq.go</code>，输入以下源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;path/filepath&quot;</span><br>    <span class="hljs-string">&quot;wordcount&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) == <span class="hljs-number">1</span> || os.Args[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;-h&quot;</span> || os.Args[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;--help&quot;</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;usage: %s &lt;file1&gt; [&lt;file2&gt; [... &lt;fileN&gt;]]\n&quot;</span>,<br>            filepath.Base(os.Args[<span class="hljs-number">0</span>]))<br>        os.Exit(<span class="hljs-number">1</span>)<br>    &#125;<br><br>    wordcounter := <span class="hljs-built_in">make</span>(wordcount.WordCount)<br>    <span class="hljs-comment">// for _, filename := range os.Args[1:] &#123;</span><br>    <span class="hljs-comment">//  wordcount.UpdateFreq(filename)</span><br>    <span class="hljs-comment">// &#125;</span><br>    wordcounter.WordFreqCounter(os.Args[<span class="hljs-number">1</span>:])<br><br>    wordcounter.SortReport()<br>&#125;<br></code></pre></td></tr></table></figure>





<hr>
<h1 id="七、IDE及环境配置"><a href="#七、IDE及环境配置" class="headerlink" title="七、IDE及环境配置"></a>七、IDE及环境配置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br></code></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a><a class="post-meta__tags" href="/tags/%E5%AE%9E%E9%AA%8C%E6%A5%BC/">实验楼</a></div><div class="post_share"><div class="social-share" data-image="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/67527f52"><img class="prev-cover" src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Zinx</div></div></a></div><div class="next-post pull-right"><a href="/posts/8cb5320c"><img class="next-cover" src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">力扣高效算法入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/67527f52" title="Zinx"><img class="cover" src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-01</div><div class="title">Zinx</div></div></a></div><div><a href="/posts/8cb5320c" title="力扣高效算法入门"><img class="cover" src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-23</div><div class="title">力扣高效算法入门</div></div></a></div><div><a href="/posts/85980731" title="(Golang)链表学习记录"><img class="cover" src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-16</div><div class="title">(Golang)链表学习记录</div></div></a></div><div><a href="/posts/206c9e3b" title="力扣每日一题"><img class="cover" src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-16</div><div class="title">力扣每日一题</div></div></a></div><div><a href="/posts/24feca74" title="Go_hard_Algorithm"><img class="cover" src="/../../../images/EasyAlgorithm/image-20220108233318575.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-09</div><div class="title">Go_hard_Algorithm</div></div></a></div><div><a href="/posts/a0a70754" title="Go_Easy_Algorithm"><img class="cover" src="/../../../images/EasyAlgorithm/image-20220108233318575.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-08</div><div class="title">Go_Easy_Algorithm</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/../../../images/icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mingming.shi</div><div class="author-info__description">信仰就是力量</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">186</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">98</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">62</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/fole-del"><i class="fab fa-github"></i><span>一些小Demo~</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:191099862@qq.com" target="_blank" title="Email"><i class="iconfont icon-Email"></i></a><a class="social-icon" href="https://tva3.sinaimg.cn/large/0072YHp3ly1gjtbxnamacj30e80e8dgx.jpg" target="_blank" title="weixin"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=191099862&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="iconfont icon-QQ1"></i></a><a class="social-icon" href="https://blog.csdn.net/Fuel_Ming?spm=1001.2014.3001.5113" target="_blank" title="CSDN"><i class="iconfont icon-csdn"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content"><div id="balls"><div>固执无<span style="background:white;border-radius:25px;color:black">罪</span>❗❗❗</div><div class="snake-spinner"><span></span><span></span><span></span><span></span><span></span></div><div><span style="background:white;border-radius:25px;color:black">梦</span>想有价🌈🌈🌈</div></div><div class="twopeople"><div class="twopeople"><div class="container"style="height:200px;"><canvas class="illo"width="800"height="800"style="max-width:200px; max-height:200px; touch-action:none; width:640px; height:640px;"></canvas></div><script src="https://cdn.guole.fun/js/twopeople1.js"></script><script src="https://cdn.guole.fun/js/zdog.dist.js"></script><script id="rendered-js"src="https://cdn.guole.fun/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Go%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">一、Go语言介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">Go语言的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">并发编程*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">多返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.0.5.</span> <span class="toc-text">匿名函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go%E8%AF%AD%E8%A8%80%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">Go语言可以做什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">二、Go语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.1.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.1.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.2.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.3.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.4.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.5.</span> <span class="toc-text">赋值运算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-amp"><span class="toc-number">2.2.6.</span> <span class="toc-text">*和&amp;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%B5%8B%E5%80%BC"><span class="toc-number">2.3.1.</span> <span class="toc-text">多重赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">数据类型*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.3.</span> <span class="toc-text">布尔类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.4.4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">格式化字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">字符类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.5.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-number">2.4.6.</span> <span class="toc-text">切片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">2.5.</span> <span class="toc-text">包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Go%E8%AF%AD%E8%A8%80%E9%A1%BA%E5%BA%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">三、Go语言顺序编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">if 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">for 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5goto"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">跳转语句goto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E5%88%86%E6%94%AF"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">switch分支</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">函数的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">函数的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">函数的多返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-1"><span class="toc-number">3.2.0.4.</span> <span class="toc-text">匿名函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">3.4.</span> <span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-1"><span class="toc-number">3.5.</span> <span class="toc-text">错误处理*</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#error"><span class="toc-number">3.5.1.</span> <span class="toc-text">error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-number">3.5.2.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#panic-%E5%92%8C-recover"><span class="toc-number">3.5.3.</span> <span class="toc-text">panic 和 recover</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">四、面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.1.</span> <span class="toc-text">自定义类型及结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">4.3.</span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.4.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80"><span class="toc-number">4.4.1.</span> <span class="toc-text">接口基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%8F%98%E9%87%8F%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.2.</span> <span class="toc-text">接口变量值的类型*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5interface"><span class="toc-number">4.4.3.</span> <span class="toc-text">嵌入interface</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">五、并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">5.0.0.1.</span> <span class="toc-text">并发与并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">5.0.0.2.</span> <span class="toc-text">协程*</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#goroutine"><span class="toc-number">5.1.</span> <span class="toc-text">goroutine*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#channel"><span class="toc-number">5.2.</span> <span class="toc-text">channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.2.1.</span> <span class="toc-text">声明与初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select"><span class="toc-number">5.3.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-for-select-%E5%92%8C-channel-%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">5.4.</span> <span class="toc-text">关于 for select 和 channel 的用法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">5.5.</span> <span class="toc-text">超时机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#channel-%E7%9A%84%E5%85%B3%E9%97%AD"><span class="toc-number">5.5.0.1.</span> <span class="toc-text">channel 的关闭</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">六、词频统计综合案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81IDE%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">7.</span> <span class="toc-text">七、IDE及环境配置</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/67527f52" title="Zinx"><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Zinx"/></a><div class="content"><a class="title" href="/posts/67527f52" title="Zinx">Zinx</a><time datetime="2022-02-07T13:39:36.741Z" title="更新于 2022-02-07 21:39:36">2022-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aa7a6db9" title="Go学习笔记（实验楼）"><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go学习笔记（实验楼）"/></a><div class="content"><a class="title" href="/posts/aa7a6db9" title="Go学习笔记（实验楼）">Go学习笔记（实验楼）</a><time datetime="2022-02-07T11:11:00.522Z" title="更新于 2022-02-07 19:11:00">2022-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8cb5320c" title="力扣高效算法入门"><img src="/../../../images/EasyAlgorithm/image-20220108233318575.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="力扣高效算法入门"/></a><div class="content"><a class="title" href="/posts/8cb5320c" title="力扣高效算法入门">力扣高效算法入门</a><time datetime="2022-01-27T14:43:15.601Z" title="更新于 2022-01-27 22:43:15">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/85980731" title="(Golang)链表学习记录"><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="(Golang)链表学习记录"/></a><div class="content"><a class="title" href="/posts/85980731" title="(Golang)链表学习记录">(Golang)链表学习记录</a><time datetime="2022-01-27T14:37:30.913Z" title="更新于 2022-01-27 22:37:30">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8cb5320c" title="力扣高效算法入门"><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="力扣高效算法入门"/></a><div class="content"><a class="title" href="/posts/8cb5320c" title="力扣高效算法入门">力扣高效算法入门</a><time datetime="2022-01-27T14:37:25.333Z" title="更新于 2022-01-27 22:37:25">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a0a70754" title="Go_Easy_Algorithm"><img src="/../../../images/EasyAlgorithm/image-20220108233318575.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go_Easy_Algorithm"/></a><div class="content"><a class="title" href="/posts/a0a70754" title="Go_Easy_Algorithm">Go_Easy_Algorithm</a><time datetime="2022-01-27T14:37:19.453Z" title="更新于 2022-01-27 22:37:19">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/58412853" title="explicit关键字"><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="explicit关键字"/></a><div class="content"><a class="title" href="/posts/58412853" title="explicit关键字">explicit关键字</a><time datetime="2022-01-27T14:36:07.603Z" title="更新于 2022-01-27 22:36:07">2022-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/206c9e3b" title="力扣每日一题"><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="力扣每日一题"/></a><div class="content"><a class="title" href="/posts/206c9e3b" title="力扣每日一题">力扣每日一题</a><time datetime="2022-01-23T06:59:28.876Z" title="更新于 2022-01-23 14:59:28">2022-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2498e501" title="Python端口占用测试（检测Socket）"><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python端口占用测试（检测Socket）"/></a><div class="content"><a class="title" href="/posts/2498e501" title="Python端口占用测试（检测Socket）">Python端口占用测试（检测Socket）</a><time datetime="2022-01-23T06:59:28.864Z" title="更新于 2022-01-23 14:59:28">2022-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/24feca74" title="Go_hard_Algorithm"><img src="/../../../images/EasyAlgorithm/image-20220108233318575.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go_hard_Algorithm"/></a><div class="content"><a class="title" href="/posts/24feca74" title="Go_hard_Algorithm">Go_hard_Algorithm</a><time datetime="2022-01-08T18:32:19.294Z" title="更新于 2022-01-09 02:32:19">2022-01-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By mingming.shi</div><div class="footer_custom_text"><div id="mouseMove">&nbsp;</div><i class="fas faa-bounce animated-hover">勇敢就是接受发生在你身上的事，并把它尽力做到最好！</i><br> Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="animation:bgbreath 4s infinite;">Hexo</a> | 主题 <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="animation:bgbreath 4s infinite;">butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'dark',
      })
      false && mermaid.init()
    })
  }
}</script></div><canvas id="universe"></canvas><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11"></script><script src="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@3.0.8/js/instantclick-1.2.2.js" type="module"></script><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="160318399252" m="0"></script><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/zdoj.js"></script><script src="/js/twoPeople.js"></script><script src="/js/twoPeople1.js"></script><script src="/js/qipao.js"></script><script src="/js/universe.js"></script><script src="/js/mouseMove.js"></script><script defer src="https://use.fontawesome.com/releases/v5.11.2/js/all.js"></script><script defer src="https://use.fontawesome.com/releases/v5.11.2/js/v4-shims.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>