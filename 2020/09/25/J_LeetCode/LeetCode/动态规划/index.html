<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>动态规划 | 青·木</title><meta name="keywords" content="C++,力扣,动态规划"><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="🙈动态规划🙈转自：🔥【github】">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="https://www.mingsrc.xyz/2020/09/25/J_LeetCode/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">
<meta property="og:site_name" content="青·木">
<meta property="og:description" content="🙈动态规划🙈转自：🔥【github】">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.mingsrc.xyz/img/emotional.jpg">
<meta property="article:published_time" content="2020-09-24T22:43:12.821Z">
<meta property="article:modified_time" content="2020-09-28T11:22:53.705Z">
<meta property="article:author" content="Ming">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="力扣">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.mingsrc.xyz/img/emotional.jpg"><link rel="shortcut icon" href="/../../../images/Logo_stop.png"><link rel="canonical" href="https://www.mingsrc.xyz/2020/09/25/J_LeetCode/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '动态规划',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-09-28 19:22:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/hbe.style.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/var.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/taglink.css"><link rel="stylesheet" href="/css/icon.css"><link rel="stylesheet" href="/css/hideCategory.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/code.css"><link href="https://.googleapis.com/css2?family=Noto+Serif+SC:wght@400;900&display=swap" rel="stylesheet" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/css/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="青·木" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/../../../images/Logo_stop.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">95</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ming/"><i class="fa-fw fa-fw fas fa-desktop faa-vertical animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-fw fas fa-home faa-vertical animated-hover"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-book faa-pulse animated-hover"></i><span> 找文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive faa-tada animated-hover"></i><span> 时间</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags faa-tada animated-hover"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open faa-tada animated-hover"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat faa-pulse animated-hover"></i><span> 清单</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-flask faa-vertical animated-hover"></i><span> 皮一下</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/test/"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试页面</span></a></li><li><a class="site-page child" href="/test/demo"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试2</span></a></li><li><a class="site-page child" href="/player/"><i class="fa-fw fa fa-play-circle"></i><span> 播放器</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-vertical animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link faa-tada animated-hover"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/emotional.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青·木</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ming/"><i class="fa-fw fa-fw fas fa-desktop faa-vertical animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-fw fas fa-home faa-vertical animated-hover"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-book faa-pulse animated-hover"></i><span> 找文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive faa-tada animated-hover"></i><span> 时间</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags faa-tada animated-hover"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open faa-tada animated-hover"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat faa-pulse animated-hover"></i><span> 清单</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-flask faa-vertical animated-hover"></i><span> 皮一下</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/test/"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试页面</span></a></li><li><a class="site-page child" href="/test/demo"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试2</span></a></li><li><a class="site-page child" href="/player/"><i class="fa-fw fa fa-play-circle"></i><span> 播放器</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-vertical animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link faa-tada animated-hover"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">动态规划</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-24T22:43:12.821Z" title="发表于 2020-09-25 06:43:12">2020-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-28T11:22:53.705Z" title="更新于 2020-09-28 19:22:53">2020-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/">大神们の笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E7%A5%9E%E4%BB%AC%E3%81%AE%E7%AC%94%E8%AE%B0/C/">C++</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/github/">github</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="动态规划"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="🙈动态规划🙈"><a href="#🙈动态规划🙈" class="headerlink" title="🙈动态规划🙈"></a>🙈动态规划🙈</h1><p>转自：🔥<a target="_blank" rel="noopener" href="https://github.com/liuwentao1992">【github】</a> </p>
<span id="more"></span>

<p>==========</p>
<ul>
<li><a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">198.打家劫舍</a>  </li>
<li><a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII">213.打家劫舍II</a>  </li>
<li><a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII">337.打家劫舍III</a>  </li>
</ul>
<p>矩阵 (10%)</p>
<ul>
<li><a href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">120.三角形最小路径和</a>  </li>
<li><a href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">64.最小路径和</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">62.不同路径</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II">63.不同路径II</a></li>
</ul>
<p>序列(40%)</p>
<ul>
<li><a href="#%E7%88%AC%E6%A5%BC%E6%A2%AF">70.爬楼梯</a></li>
<li><a href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F">55.跳跃游戏</a></li>
<li><a href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII">45.跳跃游戏II</a></li>
<li><a href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2II">132.分割回文串II</a></li>
<li><a href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97">300.最长上升子序列</a></li>
<li><a href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">139.单词拆分</a>    </li>
<li><a href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">322.零钱兑换</a></li>
</ul>
<p>双序列(40%)</p>
<ul>
<li><a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">1143.最长公共子序列</a></li>
<li><a href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">72.编辑距离</a>  </li>
<li><a href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">5.最长回文子串</a></li>
</ul>
<h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯  "></a>爬楼梯  </h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">Leetcode</a> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？  </p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>到达第n阶台阶有两种方式，一个是在第<code>n-1</code>个台阶处+1阶或在<code>n-2个</code>台阶处+2阶</li>
<li>建立一个dp数组，记录到达每一层时的所有方法总数</li>
<li>所以到达第n个台阶的方法与到底第<code>n-1</code>和<code>n-2</code>个台阶相关，<code>dp[n]=dp[n-1]+dp[n-2]</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)&#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) wayNums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">1</span>) wayNums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">else</span> wayNums.<span class="hljs-built_in">push_back</span>(dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">leetcode</a>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>动态规划：建立一个bool类型的dp数组用来记录每个格子是否能够到达</li>
<li>当前格子能否到达与它前面的每个格子都有关系，所以需要遍历它前面的所有格子，只要有一个格子本身能够到达且也能够跳到当前格子，则当前格子就能到达。</li>
<li>本体使用动态规划的时间复杂度比较大,主要用于培养动规的思想。</li>
<li>针对力扣提交的用例，在遍历当前格子之前的格子时，从后往前遍历不容易超时。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            <span class="hljs-keyword">if</span> (dp[j] == <span class="hljs-literal">true</span> &amp;&amp; nums[j] &gt;= i - j) &#123;<br>                dp[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game-ii/">leetcode</a>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>如果要用动规的思想去解决，那么需要建立一个记录达到每个格子的最小跳跃次数的dp数组，</li>
<li>当前格子的最少次数 = 它前面所有能到达当前位置的格子的步数最小值 + 1，所以还是要遍历当前格子之前的所以格子，时间复杂度会相当高，超过时间限制。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">int</span> less = <span class="hljs-number">0x3f3f3f3f</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;    <br>                <span class="hljs-keyword">if</span> (j + nums[j] &gt;= i) &#123;<br>                    less = <span class="hljs-built_in">min</span>(less, dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            dp[i] = less;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>还可以想办法继续优化，例如加上贪心的算法，因为既然有多个格子可以跳跃到当前格子，从最少跳跃次数的角度考虑，我当然希望是离当前格子最远的地方跳跃过来，也就是我们只需要正向遍历到第一个能够跳跃到当前格子的位置就行了。</li>
<li>当然用c++还是会超时间限制，可以用java<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; j + nums[j] &lt; i)  j++;<br>        dp[i] = dp[j] + <span class="hljs-number">1</span>;<br>    &#125;  <br>    <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="分割回文串-II"><a href="#分割回文串-II" class="headerlink" title="分割回文串 II"></a>分割回文串 II</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">leetcode</a>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回符合要求的最少分割次数。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入: &quot;aab&quot;<br>输出: 1<br>解释: 进行一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>首先建立dp数组，记录每到一个字母，和它前面所组成的字符串，能使每个子串都是回文串最少分割次数。</li>
<li>动态规划的思路就是，找到当前<code>dp[i]</code>的值与<code>dp[i-1]、dp[i-2].....</code>有怎么的联系</li>
<li>对于本题，通过遍历<code>i</code>之前的所有下标<code>j</code>，找到所有能和<code>i</code>组成回文串的<code>j</code>下标，在这么多能和i组成的回文串的<code>j</code>下标中，通过比较找出最少分割数的dp[j],再+1就是当前位置dp[i]的值.</li>
<li>如果一整个串就是一个回文串，那么最小分割数自然为0</li>
<li>下面的代码会超时，主要学习动规的思路，可以通过优化判断回文串isPalindrome()的方法。这里只用了最简单的方式。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size(), <span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, <span class="hljs-number">0</span>, i))&#123;<br>            dp[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; --j)&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, j, i))&#123;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(right == left) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (s[left] != s[right]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        left++, right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">Leetcode</a> 计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。  在不触动警报装置的情况下，能够偷窃到的最高金额。  </p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>dp数组储存抢劫每户时的最大抢劫量，dp[i]表示抢到第i个房间时的最大抢劫量</li>
<li>因为不能相邻抢劫，所以如果抢劫了<code>i-1</code>户，就不能抢劫第i户，或者是<code>i-2</code>户再加上当前户<code>i</code></li>
<li><code>dp[i]=max(dp[i-1],dp[i-2]+nums[i])</code>;</li>
<li>dp数组第一个值和第二个值分别为<code>nums[0]</code>和<code>max(nums[0].nums[1])</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp.<span class="hljs-built_in">push_back</span>(nums[<span class="hljs-number">0</span>]);           <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) dp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]));<br>        <span class="hljs-keyword">else</span> dp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II  "></a>打家劫舍II  </h1><p>所有的房屋都围成一圈.<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">Leetcode</a>  </p>
<ul>
<li>打劫问题升级版，因为是环形的，所以多了一个限制条件：</li>
<li>如果从第一户开始偷，那么最后一户就不能偷，下标:<code>0~n-2</code></li>
<li>如果从第二户开始偷，最后一户就可以偷，下标为:<code>1~n-1</code></li>
<li>环形问题分解为两条子序列，子序列使用动态规划，比较者最大值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">rob</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>),<span class="hljs-built_in">rob</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">//根据left和right确定开辟dp数组的大小</span><br>    <span class="hljs-keyword">int</span> cnt = left - right + <span class="hljs-number">1</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dp;<br>    <span class="hljs-comment">//cur是dp数组的下标，不是nums的下标，cur从0，即dp的第一元素开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>; cur &lt; cnt; cur++)&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) dp.<span class="hljs-built_in">push_back</span>(nums[left]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur ==<span class="hljs-number">1</span>) dp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">max</span>(nums[left], nums[left + <span class="hljs-number">1</span>]));<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//max里比的是dp数组里的值，不是nums数组的</span><br>            dp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">max</span>(dp[cur - <span class="hljs-number">1</span>], dp[cur - <span class="hljs-number">2</span>] + nums[left + cur]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">Leetcode</a>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。<br>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。  </p>
<h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>树形动态规划问题</li>
<li>首先要明确相邻的节点不能偷，也就是’爷爷’选择偷，’儿子’就不能偷了，但是’孙子’可以偷</li>
<li>二叉树只有左右两个孩子，1个’爷爷’最多 2 个’儿子’，4 个’孙子’</li>
<li>4 个’孙子’偷的钱 + ‘爷爷’的钱 VS 两个’儿子’偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root = <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> money = root-&gt;val;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) money += <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left) + <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) money += <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left) + <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(money, <span class="hljs-built_in">rob</span>(root-&gt;left) + <span class="hljs-built_in">rob</span>(root-&gt;right)); <br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="建立dp缓存的动态规划"><a href="#建立dp缓存的动态规划" class="headerlink" title="建立dp缓存的动态规划"></a>建立dp缓存的动态规划</h2><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>我们发现’爷爷’在计算自己能偷多少钱的时候，同时计算了 4 个’孙子’能偷多少钱，也计算了 2 个’儿子’能偷多少钱。这样在’儿子’当’爷爷’时，就会产生重复计算一遍’孙子’节点</li>
<li>动态规划的关键优化点 ‘重复子问题’</li>
<li>使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。</li>
<li>由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value,记录每个计算过得结点值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    unordered_map&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt;dp;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rob</span>(root, dp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root, unordered_map&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; dp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (dp.<span class="hljs-built_in">count</span>(root) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[root];<br>    <span class="hljs-keyword">int</span> money=root-&gt;val;<br>    <span class="hljs-keyword">if</span> (root-&gt;left) money += <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left, dp) + <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right, dp);<br>    <span class="hljs-keyword">if</span> (root-&gt;right) money += <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left, dp) + <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right, dp);<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">max</span>(money,<span class="hljs-built_in">rob</span>(root-&gt;left,dp) + <span class="hljs-built_in">rob</span>(root-&gt;right, dp));<br>    dp[root] = res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
终极解法</li>
</ul>
<hr>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>上面两种解法用到了’孙子’节点，计算’爷爷’节点能偷的钱还要同时去计算’孙子’节点投的钱</li>
<li>每个节点储存偷或者不偷两种状态得最大值</li>
<li>我们使用一个大小为 2 的数组来表示,下标0存不偷的值，下标1存偷的值</li>
<li>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱</li>
<li>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</li>
<li>自下而上选择后序遍历<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    res = <span class="hljs-built_in">postOrder</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; left = <span class="hljs-built_in">postOrder</span>(root-&gt;left);<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; right = <span class="hljs-built_in">postOrder</span>(root-&gt;right);<br>    res[<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>    res[<span class="hljs-number">1</span>] = root-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/triangle/">leetcode</a>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<br>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>自顶向下，所以每一行的元素都与上一行的元素有关，第一行除外，所以遍历从第二行开始</li>
<li>建立dp数组，dp[i][j]表示到达此此处的最小路径和，dp数组中最后一行的最小值即为所求。</li>
<li>公式：每一项都与他的上一行有关<code>dp[i][j] = min(dp[i-1][j] + dp[i-1][j]) + triangle[i][j]</code></li>
<li>需要考虑边界，因为时三角形的，例如每一行的第0个元素，他的上一行没有<code>0-1</code>的元素;还有每一行的最后一个第i元素，他的上一行只有<code>i-1</code>这个元素。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = triangle.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,vector&lt;<span class="hljs-keyword">int</span>&gt;(len,<span class="hljs-number">0x3f3f3f3f</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; triangle[i].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + triangle[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == i) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + triangle[i][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) + triangle[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(dp[len<span class="hljs-number">-1</span>].<span class="hljs-built_in">begin</span>(), dp[len<span class="hljs-number">-1</span>].<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> dp[len<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3></li>
<li>自底向上，所以每一个元素都与下一行的元素有关，最后一行除外，所以遍历从倒数第二行开始</li>
<li>公式：<code>dp[i][j] = min(dp[i+i][j], dp[i+1][j]) + triangle[i][j]</code></li>
<li>因为是三角形，边界的元素在下一行必有相邻的元素存在，所以免去了边界检测。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;<br>    <span class="hljs-comment">// 自底向上</span><br>    <span class="hljs-comment">// 从倒数第二行开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = triangle.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; triangle[i].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            triangle[i][j] += <span class="hljs-built_in">min</span>(triangle[i+<span class="hljs-number">1</span>][j], triangle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">leetcode</a>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>上一题是三角形，这一题变矩形，首先考虑自左上角到右下角，那么每个元素的最小路径和都与他的上一个元素或者左边的元素有关，但是考虑到边界，第一列和第一行的元素并没有左或者上面的于元素，所以需要单独考虑，同时第一个元素左和上都没有，也需要单独考虑。</li>
<li>剩下的元素公式为：<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(row, vector&lt;<span class="hljs-keyword">int</span>&gt;(col, <span class="hljs-number">0x3f3f3f3f</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span>      (i == <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span>)  dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] + grid[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> &amp;&amp; i &gt; <span class="hljs-number">0</span>)  dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + grid[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) dp[i][j] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[row<span class="hljs-number">-1</span>][col <span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3></li>
<li>如果是自右下至左上，对于本题仍然有边界需要考虑，每个元素的最小路径和都与他的右边和下边的值有关，但是对于最后一行和最后一列并没有下或者右边的值，需要单独考虑，最右下角的值右和下都没有，更需要单独考虑</li>
<li>对于其他元素,可以不用建立dp数组的方式实现，取他的右和下最小值相加：<code>grid[i][j] += min(grid[i+1][j], grid[i][j+1]);</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            <span class="hljs-keyword">if</span> (i == row<span class="hljs-number">-1</span> &amp;&amp; j == col<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == row<span class="hljs-number">-1</span>) grid[i][j] += grid[i][j+<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == col<span class="hljs-number">-1</span>) grid[i][j] += grid[i+<span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span> grid[i][j] += <span class="hljs-built_in">min</span>(grid[i+<span class="hljs-number">1</span>][j], grid[i][j+<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">leetcode</a>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>问总共有多少条不同的路径？</p>
<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>此题是上一题<a href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">最小路径和</a>的简易版,这里就只写了一种自右下至左上的思路</li>
<li>需要一个dp数组来记录到某个格子的所有路径个数，因为是自右下往左上，所以每个格子都可以从他的右边或者下面到达，所以这个格子的路径数就等于他下面和右边格子路径数之和。</li>
<li>大部分格子的公式:dp[i][j] = dp[i+1][j] + dp[i][j+1];但是又边界的考虑，例如最后一列和最后一行的格子没有右或者下面的格子，就必须单独考虑。最右下角的格子右边和下面都没有，更需要拎出来单独考虑了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,vector&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0x3f3f3f3f</span>));<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m<span class="hljs-number">-1</span>; i &gt;=<span class="hljs-number">0</span>; --i) &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>           <span class="hljs-keyword">if</span> (i == m<span class="hljs-number">-1</span> &amp;&amp; j == n<span class="hljs-number">-1</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == m<span class="hljs-number">-1</span>) dp[i][j] = dp[i][j+<span class="hljs-number">1</span>];<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n<span class="hljs-number">-1</span>) dp[i][j] = dp[i+<span class="hljs-number">1</span>][j];<br>           <span class="hljs-keyword">else</span> dp[i][j] = dp[i+<span class="hljs-number">1</span>][j] + dp[i][j+<span class="hljs-number">1</span>];<br>       &#125;<br>   &#125; <br>   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a>不同路径 II</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">leetcode</a>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：<br>1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br>2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>此题就体现出了从右下往左上建立dp表的优势，因为障碍物的出现只会影响上面和左边的格子，但是因为遍历的顺序是从右下往左上，所以一定是先遍历到障碍物的格子，之后才会遍历到被它所影响到的格子。</li>
<li>既然是先遍历到障碍物，那直接将其在dp数组中的路径数设为0，对于被他影响的格子就相当于此路不通，不走这个障碍物格子。</li>
<li>其他正常的格子路径还是：<code>dp[i][j] = dp[i+1][j] + dp[i][j+1];</code></li>
<li>对于两个边界：最后一列的格子:<code>dp[i][j] = dp[i+1][j];</code>,最后一行的格子<code>dp[i][j] = dp[i][j+1];</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> row = obstacleGrid.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-keyword">int</span> col = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>   vector&lt;vector&lt;<span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-built_in">dp</span>(row,vector&lt;<span class="hljs-keyword">long</span>&gt;(col,<span class="hljs-number">0x3f3f3f3f</span>));<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row<span class="hljs-number">-1</span>; i &gt;=<span class="hljs-number">0</span>; --i) &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>           <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>)  &#123;dp[i][j] = <span class="hljs-number">0</span>; <span class="hljs-keyword">continue</span>;&#125;<br>           <span class="hljs-keyword">if</span> (i == row<span class="hljs-number">-1</span> &amp;&amp; j == col<span class="hljs-number">-1</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == row<span class="hljs-number">-1</span>) dp[i][j] = dp[i][j+<span class="hljs-number">1</span>];<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == col<span class="hljs-number">-1</span>) dp[i][j] = dp[i+<span class="hljs-number">1</span>][j];<br>           <span class="hljs-keyword">else</span> dp[i][j] = dp[i+<span class="hljs-number">1</span>][j] + dp[i][j+<span class="hljs-number">1</span>];<br>       &#125;<br>   &#125; <br>   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">leetcode</a>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入: [10,9,2,5,3,7,101,18]<br>输出: 4 <br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>使用暴力法动态规划：定义dp[i] 为考虑前 i 个元素，必须以第 i个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取为最长上升子序列之中。</li>
<li>所以状态转移方程为:<code> dp[i] = max(dp[j], dp[j-1].......） + 1</code> 其中j表示i之前的所以元素。</li>
<li>因为是升序序列，j在i之前，所以一定<code>nums[j] &lt; nums[i]</code> 才行。</li>
<li>注意返回值不在是<code>dp[nums.size()-1]</code>，而是dp数组中的最大值，因为dp[i]代表的是以nums[i]为序列结尾的最长个数。实际最长的序列不一定是以最后一个数字<code>nums[size()-1]</code>为结尾的。</li>
<li><code>max_element()</code>在头文件 <code>#include &lt;algorithm&gt;</code> 中，返回的是迭代器，所以输出值的话要在前面加 *,默认是从小到大排列.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() , <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i])&#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">leetcode</a>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p>
<h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]<br>输出: true<br>解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。<br>输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]<br>输出: true<br>解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。<br>     注意你可以重复使用字典中的单词。<br><br></code></pre></td></tr></table></figure>


<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">leetcode</a>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。<br>若这两个字符串没有公共子序列，则返回 0。</p>
<h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; <br>输出：3  <br>解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>动规面试题高频题型，最长公共子序列（Longest Common Subsequence，简称 LCS）</li>
<li>对于子序列类型的问题，暴力点就是穷举问题，而动态规划算法做的就是穷举 + 剪枝，所以可以说只要涉及子序列问题，基本上就是动规解决</li>
<li>因为两个字符串就要建立一个dp table来解决，首先明白dp数组的含义是<code>dp[i][j]</code>表示：对于 <code>s1[1..i]</code> 和 <code>s2[1..j]</code>，它们的 LCS 长度是 <code>dp[i][j]</code>。</li>
<li>由于两个字符串有可能其中一个是空串，所以dp数组还需要多加一列和一行，他们的dp[i][j]永远是0，因为是空串，永远不会有lcs。所以之后i和j的遍历时从1开始.szie()结束。</li>
<li>状态转移方程，二维的dp table，每个状态值都是由前面的三个状态影响：<code>dp[i][j] = (dp[i-1][j], dp[i][j-1], dp[i-1][j-1)</code></li>
<li>还要明白，如果一个字母，两个串都有，那么他一定属于LCS，LCS长度就要+1。</li>
<li>i和j指针所指的如果不相等，那么就取前面两个状态的最大值即可。</li>
<li>超详细原理请参考其他大佬的：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/">动态规划之最长公共子序列</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len1 = text1.<span class="hljs-built_in">size</span>(); <br>    <span class="hljs-keyword">int</span> len2 = text2.<span class="hljs-built_in">size</span>(); <br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(len1 + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(len2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len1 + <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; len2 + <span class="hljs-number">1</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>]) &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len1][len2];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">leetcode</a>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<h3 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;<br>输出：3<br>解释：<br>horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)<br>rorse -&gt; rose (删除 &#39;r&#39;)<br>rose -&gt; ros (删除 &#39;e&#39;)<br><br></code></pre></td></tr></table></figure>

<h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>参考大佬的解题思路：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/solution/zi-di-xiang-shang-he-zi-ding-xiang-xia-by-powcai-3/">powcai</a></li>
<li><code>dp[i][j]</code> 代表 <code>word1</code> 到 <code>i</code> 位置转换成 <code>word2</code> 到<code> j</code> 位置需要最少步数</li>
<li>当 <code>word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；</code></li>
<li>当 <code>word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code></li>
<li>因为我们要将<code>word1</code>变为<code>word2</code>,也就是用删除，增加，替换操作将<code>word1</code>的每个字母变成<code>word2</code>的字母</li>
<li>说明 更容易理解些： dp[i-1][j-1]到dp[i][j]需要进行替换操作，dp[i-1][j]到d[i][j]需要进行删除操作，dp[i][j-1] 到d[i][j]需要进行添加操作。</li>
<li>dp table第一行，是 <code>word1</code> 为空变成 <code>word2</code> 最少步数，就是插入操作</li>
<li>第一列，是 <code>word2</code> 为空，需要的最少步数，就是删除操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len1 = word1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> len2 = word2.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(len1 + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(len2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len1 + <span class="hljs-number">1</span>; ++i) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len2 + <span class="hljs-number">1</span>; ++i) &#123;<br>        dp[<span class="hljs-number">0</span>][i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len1 + <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; len2 + <span class="hljs-number">1</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>]) &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">leetcode</a>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> coin : coins) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; coin) <span class="hljs-keyword">continue</span>;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i-coin] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">0x3f3f3f3f</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">leetcode</a><br>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>动态规划，要想知道长度为n的字符串是否是回文，需要先了解长度n-2的字符串是否是回文，同时首尾的字符也必须相等才行。</li>
<li><code>dp[i][j] = dp[i + 1][j - 1] &amp;&amp; s[i] == s[j]</code> 表示从第i个字符开始到第j个字符结束</li>
<li>判断长得字符串是否回文需要先判断短得字符串是否成立，所以必须从长度 <code>len = 0</code> 开始遍历建立dp数组。</li>
<li>边界条件1，长度为1即len = 0时，一个字母一定是回文串，所以为true</li>
<li>边界条件2，长度为2即len = 1时，两个字母只有相等时才是true<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n ,<span class="hljs-literal">false</span>));<br>    string res;<br>    <span class="hljs-keyword">int</span> MAX = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>; len &lt; n; ++len) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + len &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> j = i + len;<br>            <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) dp[i][j] = (s[i] == s[j]);<br>            <span class="hljs-keyword">else</span> dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; len + <span class="hljs-number">1</span> &gt; MAX) &#123;<br>                MAX = len + <span class="hljs-number">1</span>;<br>                res = s.<span class="hljs-built_in">substr</span>(i, len + <span class="hljs-number">1</span>); <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E5%8A%9B%E6%89%A3/">力扣</a><a class="post-meta__tags" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></div><div class="post_share"><div class="social-share" data-image="/img/emotional.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/25/J_LeetCode/LeetCode/%E5%8F%8C%E6%8C%87%E9%92%88/"><img class="prev-cover" src="/img/emotional.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">双指针</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/25/J_LeetCode/LeetCode/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"><img class="next-cover" src="/img/emotional.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">力扣周赛</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/09/25/J_LeetCode/LeetCode/%E9%93%BE%E8%A1%A8/" title="🐳链表🐳"><img class="cover" src="/img/emotional.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">🐳链表🐳</div></div></a></div><div><a href="/2020/09/25/J_LeetCode/LeetCode/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/" title="🎨程序员面试金典🎨"><img class="cover" src="/img/emotional.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">🎨程序员面试金典🎨</div></div></a></div><div><a href="/2020/09/25/J_LeetCode/LeetCode/%E6%A0%91/" title="树🌲"><img class="cover" src="/img/emotional.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">树🌲</div></div></a></div><div><a href="/2020/09/25/J_LeetCode/LeetCode/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="栈和队列"><img class="cover" src="/img/emotional.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">栈和队列</div></div></a></div><div><a href="/2020/09/25/J_LeetCode/LeetCode/%E6%95%B0%E7%BB%84/" title="数组"><img class="cover" src="/img/emotional.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">数组</div></div></a></div><div><a href="/2020/09/25/J_LeetCode/LeetCode/%E6%8E%92%E5%BA%8F/" title="📸排序📸"><img class="cover" src="/img/emotional.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">📸排序📸</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/../../../images/Logo_stop.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ming</div><div class="author-info__description">信仰就是力量</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">95</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fole-del"><i class="fab fa-github"></i><span>我的仓库~</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:191099862@qq.com" target="_blank" title="Email"><i class="iconfont icon-Email"></i></a><a class="social-icon" href="https://tva3.sinaimg.cn/large/0072YHp3ly1gjtbxnamacj30e80e8dgx.jpg" target="_blank" title="weixin"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=191099862&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="iconfont icon-QQ1"></i></a><a class="social-icon" href="https://blog.csdn.net/Fuel_Ming?spm=1001.2014.3001.5113" target="_blank" title="CSDN"><i class="iconfont icon-csdn"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content"><mark style="background:lightgreen;filter:brightness(1);border-radius:5px;width:110%;color:white;font-size:30px">固执</mark><span class="card-announcement-animation fas faa-vertical animated">无罪</span><mark style="background:pink;filter:brightness(1);border-radius:5px;width:110%;color:white;font-size:30px">梦想</mark>有价<div class="twopeople"><div class="twopeople"><div class="container"style="height:200px;"><canvas class="illo"width="800"height="800"style="max-width:200px; max-height:200px; touch-action:none; width:640px; height:640px;"></canvas></div><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%99%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%F0%9F%99%88"><span class="toc-number">1.</span> <span class="toc-text">🙈动态规划🙈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">2.</span> <span class="toc-text">爬楼梯  </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">2.0.1.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">3.</span> <span class="toc-text">跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.0.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="toc-number">3.0.2.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII"><span class="toc-number">4.</span> <span class="toc-text">跳跃游戏II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2"><span class="toc-number">4.0.1.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-II"><span class="toc-number">5.</span> <span class="toc-text">分割回文串 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">5.0.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3"><span class="toc-number">5.0.2.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">6.</span> <span class="toc-text">打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4"><span class="toc-number">6.0.1.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII"><span class="toc-number">7.</span> <span class="toc-text">打家劫舍II  </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII"><span class="toc-number">8.</span> <span class="toc-text">打家劫舍III</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92"><span class="toc-number">8.1.</span> <span class="toc-text">暴力递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5"><span class="toc-number">8.1.1.</span> <span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8Bdp%E7%BC%93%E5%AD%98%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">8.2.</span> <span class="toc-text">建立dp缓存的动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6"><span class="toc-number">8.2.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7"><span class="toc-number">8.2.2.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">9.</span> <span class="toc-text">三角形最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">9.0.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8"><span class="toc-number">9.0.2.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9"><span class="toc-number">9.0.3.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">10.</span> <span class="toc-text">最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">10.0.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10"><span class="toc-number">10.0.2.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-11"><span class="toc-number">10.0.3.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">11.</span> <span class="toc-text">不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-12"><span class="toc-number">11.0.1.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-number">12.</span> <span class="toc-text">不同路径 II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">12.0.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-13"><span class="toc-number">12.0.2.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">13.</span> <span class="toc-text">最长上升子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">13.0.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-14"><span class="toc-number">13.0.2.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">14.</span> <span class="toc-text">单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">14.0.1.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">15.</span> <span class="toc-text">最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">15.0.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-15"><span class="toc-number">15.0.2.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">16.</span> <span class="toc-text">编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">16.0.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-16"><span class="toc-number">16.0.2.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">17.</span> <span class="toc-text">零钱兑换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-17"><span class="toc-number">17.0.1.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">18.</span> <span class="toc-text">最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-18"><span class="toc-number">18.0.1.</span> <span class="toc-text">解题思路</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/11/25/F_%E6%9D%82%E8%AE%B0/Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/" title="Windows平台下的内存泄露检测"><img src="/../../images/Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/AAAAA_01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows平台下的内存泄露检测"/></a><div class="content"><a class="title" href="/2020/11/25/F_%E6%9D%82%E8%AE%B0/Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/" title="Windows平台下的内存泄露检测">Windows平台下的内存泄露检测</a><time datetime="2021-10-30T12:58:05.861Z" title="更新于 2021-10-30 20:58:05">2021-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/13/F_%E6%9D%82%E8%AE%B0/%E5%88%86%E4%BA%AB/%E6%8E%A8%E8%8D%90%E4%B8%80%E9%83%A8%E5%89%A7/%E3%80%8A%E6%88%91%E7%9A%84%E5%9B%A2%E9%95%BF%E6%88%91%E7%9A%84%E5%9B%A2%E3%80%8B/" title="《我的团长我的团》"><img src="https://gitee.com/fole-del/img/raw/master/20210613210525.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《我的团长我的团》"/></a><div class="content"><a class="title" href="/2021/06/13/F_%E6%9D%82%E8%AE%B0/%E5%88%86%E4%BA%AB/%E6%8E%A8%E8%8D%90%E4%B8%80%E9%83%A8%E5%89%A7/%E3%80%8A%E6%88%91%E7%9A%84%E5%9B%A2%E9%95%BF%E6%88%91%E7%9A%84%E5%9B%A2%E3%80%8B/" title="《我的团长我的团》">《我的团长我的团》</a><time datetime="2021-10-30T07:11:01.856Z" title="更新于 2021-10-30 15:11:01">2021-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/25/C_%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%8A%9F%E8%83%BD/" title="计算机网络协议"><img src="/../../../images/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%8A%9F%E8%83%BD/%E5%AF%B9%E5%BA%94%E5%8D%8F%E8%AE%AE.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络协议"/></a><div class="content"><a class="title" href="/2020/11/25/C_%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%8A%9F%E8%83%BD/" title="计算机网络协议">计算机网络协议</a><time datetime="2021-10-28T09:06:30.656Z" title="更新于 2021-10-28 17:06:30">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/10/F_%E6%9D%82%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AEhooks/" title="自动化部署项目hook"><img src="/../../../images/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AEhooks/git.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自动化部署项目hook"/></a><div class="content"><a class="title" href="/2021/03/10/F_%E6%9D%82%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AEhooks/" title="自动化部署项目hook">自动化部署项目hook</a><time datetime="2021-10-28T09:06:23.201Z" title="更新于 2021-10-28 17:06:23">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/19/F_%E6%9D%82%E8%AE%B0/%E6%89%80%E8%A7%81%E5%8D%B3%E6%89%80%E5%BE%97/" title="Markdown用法"><img src="/../images/markdown.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Markdown用法"/></a><div class="content"><a class="title" href="/2020/10/19/F_%E6%9D%82%E8%AE%B0/%E6%89%80%E8%A7%81%E5%8D%B3%E6%89%80%E5%BE%97/" title="Markdown用法">Markdown用法</a><time datetime="2021-10-28T09:06:19.068Z" title="更新于 2021-10-28 17:06:19">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/18/%E8%87%AA%E8%BF%B0/" title="明明是我"><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gjlriqpyayj30hs0hswf6.jp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="明明是我"/></a><div class="content"><a class="title" href="/2021/03/18/%E8%87%AA%E8%BF%B0/" title="明明是我">明明是我</a><time datetime="2021-10-28T08:30:46.573Z" title="更新于 2021-10-28 16:30:46">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/02/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之行为型模式"><img src="/img/emotional.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式之行为型模式"/></a><div class="content"><a class="title" href="/2020/10/02/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之行为型模式">设计模式之行为型模式</a><time datetime="2021-10-28T08:20:16.887Z" title="更新于 2021-10-28 16:20:16">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/01/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之结构型模式"><img src="/img/emotional.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式之结构型模式"/></a><div class="content"><a class="title" href="/2020/10/01/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之结构型模式">设计模式之结构型模式</a><time datetime="2021-10-28T08:20:03.273Z" title="更新于 2021-10-28 16:20:03">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/25/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之创建型模式"><img src="https://img.shields.io/badge/-创建型模式-blueciolet" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式之创建型模式"/></a><div class="content"><a class="title" href="/2020/09/25/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之创建型模式">设计模式之创建型模式</a><time datetime="2021-10-28T08:19:50.468Z" title="更新于 2021-10-28 16:19:50">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/25/C_%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/" title="为什么要使用HTTPS？"><img src="/../../../images/https.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="为什么要使用HTTPS？"/></a><div class="content"><a class="title" href="/2020/11/25/C_%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/" title="为什么要使用HTTPS？">为什么要使用HTTPS？</a><time datetime="2021-10-28T08:11:26.623Z" title="更新于 2021-10-28 16:11:26">2021-10-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Ming</div><div class="footer_custom_text"><i class="fas faa-tada animated-hover">勇敢就是接受发生在你身上的事，并把它尽力做到最好！</i><br> Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="animation:bgbreath 4s infinite;">Hexo</a> | 主题 <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="animation:bgbreath 4s infinite;">butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'dark',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '867UCrDSC31y4kg3RjpHqp9g-gzGzoHsz',
      appKey: 'PTh9DXsOTWrFqpuMPIA0s73M',
      placeholder: '这是你掉的一毛钱吗？',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11"></script><script src="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@3.0.8/js/instantclick-1.2.2.js" type="module"></script><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="160318399252" m="0"></script><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script src="/js/search/js/twoPeople.js"></script><script src="/js/search/js/twoPeople1.js"></script><script src="/js/search/js/dist.js"></script><script src="/js/search/js/side.js"></script><script src="/js/search/js/qipao.js"></script><script src="/js/search/js/hideCategory.js"></script><script src="/js/search/js/main.js"></script><script src="/js/search/js/tw_cn.js"></script><script src="/js/search/js/utiles.js"></script><script src="/js/search/js/choloate.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2020/11/25/C_面试/计算机网络/五层协议及功能/" alt=""><img width="48" height="48" src="../../../images/五层协议及功能/对应协议.png" alt="" onerror="this.src=https://cdn.jsdelivr.net/npm/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2020-11-25</span><a class="blog-slider__title" href="2020/11/25/C_面试/计算机网络/五层协议及功能/" alt="">计算机网络协议</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2020/11/25/C_面试/计算机网络/五层协议及功能/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2020/11/25/F_杂记/Windows平台下的内存泄露检测/" alt=""><img width="48" height="48" src="../../images/Windows平台下的内存泄露检测/AAAAA_01.jpg" alt="" onerror="this.src=https://cdn.jsdelivr.net/npm/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2020-11-25</span><a class="blog-slider__title" href="2020/11/25/F_杂记/Windows平台下的内存泄露检测/" alt="">Windows平台下的内存泄露检测</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2020/11/25/F_杂记/Windows平台下的内存泄露检测/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/03/10/F_杂记/自动化部署项目hooks/" alt=""><img width="48" height="48" src="../../../images/自动化部署项目hooks/git.jpg" alt="" onerror="this.src=https://cdn.jsdelivr.net/npm/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-03-10</span><a class="blog-slider__title" href="2021/03/10/F_杂记/自动化部署项目hooks/" alt="">自动化部署项目hook</a><div class="blog-slider__text">如何“自动化”部署git hook（C++项目）</div><a class="blog-slider__button" href="2021/03/10/F_杂记/自动化部署项目hooks/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2020/10/19/F_杂记/所见即所得/" alt=""><img width="48" height="48" src="../images/markdown.jpg" alt="" onerror="this.src=https://cdn.jsdelivr.net/npm/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2020-10-19</span><a class="blog-slider__title" href="2020/10/19/F_杂记/所见即所得/" alt="">Markdown用法</a><div class="blog-slider__text">所见即所得，总结的一些MarkDown常用方法</div><a class="blog-slider__button" href="2020/10/19/F_杂记/所见即所得/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>