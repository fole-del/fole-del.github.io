<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>STL基本概念 | A u r o r a</title><meta name="keywords" content="STL"><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="STL基本概念STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。 STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。 STL的从广义上讲分为三类：algorithm（算法）、contai">
<meta property="og:type" content="article">
<meta property="og:title" content="STL基本概念">
<meta property="og:url" content="https://www.mingsrc.xyz/2020/09/25/E_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL/STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">
<meta property="og:site_name" content="A u r o r a">
<meta property="og:description" content="STL基本概念STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。 STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。 STL的从广义上讲分为三类：algorithm（算法）、contai">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.mingsrc.xyz/images/STL8.png">
<meta property="article:published_time" content="2020-09-24T22:44:26.939Z">
<meta property="article:modified_time" content="2020-11-11T01:48:02.920Z">
<meta property="article:author" content="Ming">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.mingsrc.xyz/images/STL8.png"><link rel="shortcut icon" href="/../../../images/Logo_stop.png"><link rel="canonical" href="https://www.mingsrc.xyz/2020/09/25/E_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL/STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式🌙🌙","night_to_day":"你已切换为浅色模式🌝🌝","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STL基本概念',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-11 09:48:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/hbe.style.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/var.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/taglink.css"><link rel="stylesheet" href="/css/hideCategory.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/code.css"><link href="https://.googleapis.com/css2?family=Noto+Serif+SC:wght@400;900&display=swap" rel="stylesheet" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/css/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload="this.media='all'"><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="A u r o r a" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/../../../images/Logo_stop.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">95</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ming/"><i class="fa-fw fa-fw fas fa-desktop faa-vertical animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-fw fas fa-home faa-vertical animated-hover"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-book faa-pulse animated-hover"></i><span> 找文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive faa-tada animated-hover"></i><span> 时间</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags faa-tada animated-hover"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open faa-tada animated-hover"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat faa-pulse animated-hover"></i><span> 清单</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-flask faa-vertical animated-hover"></i><span> 皮一下</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/test/"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试页面</span></a></li><li><a class="site-page child" href="/test/demo"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试2</span></a></li><li><a class="site-page child" href="/player/"><i class="fa-fw fa fa-play-circle"></i><span> 播放器</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-vertical animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link faa-tada animated-hover"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../../images/STL8.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">A u r o r a</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/ming/"><i class="fa-fw fa-fw fas fa-desktop faa-vertical animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa-fw fas fa-home faa-vertical animated-hover"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-book faa-pulse animated-hover"></i><span> 找文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive faa-tada animated-hover"></i><span> 时间</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags faa-tada animated-hover"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open faa-tada animated-hover"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat faa-pulse animated-hover"></i><span> 清单</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-flask faa-vertical animated-hover"></i><span> 皮一下</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/test/"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试页面</span></a></li><li><a class="site-page child" href="/test/demo"><i class="fa-fw fa fa-thermometer-empty faa-vertical animated-hover"></i><span> 测试2</span></a></li><li><a class="site-page child" href="/player/"><i class="fa-fw fa fa-play-circle"></i><span> 播放器</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-vertical animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-link faa-tada animated-hover"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">STL基本概念</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-24T22:44:26.939Z" title="发表于 2020-09-25 06:44:26">2020-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-11T01:48:02.920Z" title="更新于 2020-11-11 09:48:02">2020-11-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E7%AC%94%E8%AE%B0/">C++笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E7%AC%94%E8%AE%B0/STL/">STL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STL基本概念"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h1><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。</p>
<p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。</p>
<p>STL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</p>
<span id="more"></span>

<p><em>STL细说六大件：</em></p>
<p>​                        <em>– 容器（Container）</em></p>
<p>​                        <em>– 算法（Algorithm）</em></p>
<p>​                        <em>– 迭代器（Iterator）</em></p>
<p>​                        <em>– 仿函数（Function object）</em></p>
<p>​                        <em>– 适配器（Adaptor）</em></p>
<p>​                        <em>– 空间配制器（allocator）</em></p>
<p>在C++标准中，STL被组织为下面的13个头文 件：&lt;algorithm&gt;、<a href="#deque%E5%AE%B9%E5%99%A8">&lt;deque&gt;</a>、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt;。</p>
<h4 id="说了这么多，使用STL有什么好处呢？"><a href="#说了这么多，使用STL有什么好处呢？" class="headerlink" title="说了这么多，使用STL有什么好处呢？"></a>说了这么多，使用STL有什么好处呢？</h4><p>1）STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p>
<p>2）STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。</p>
<p>3） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p>
<p>4） STL具有高可重用性，高性能，高移植性，跨平台的优点。</p>
<p>高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p>
<p>高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种)</p>
<p>高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。</p>
<p>跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。</p>
<p>5） 了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C＋＋程序员都应该好好学习STL。只有能够熟练使用STL的程序员，才是好的C++程序员。</p>
<p>6） 总之：招聘工作中，经常遇到C++程序员对STL不是非常了解。大多是有一个大致的映像，而对于在什么情况下应该使用哪个容器和算法都感到比较茫然。<em><strong>STL是C++程序员的一项不可或缺的基本技能</strong></em>，掌握它对提升C++编程大有裨益。</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1599604856029&di=7f8b27e773720571452df1eeba4f494d&imgtype=0&src=http://www.linuxeden.com/upimg/allimg/100929/095F1NL-0.jpg" alt="img"></p>
<div align="center">Alexander Stepanov</div>

<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>一些封装数据结构的模板类，简单来说，就是存储数据的结构</p>
<p><font style="color:red">序列式容器：</font>特点是不会对存储的元素进行排序，元素排列的顺序取决于存储它们的顺序。</p>
<p><font style="color:red">关联式容器：</font>在存储元素时会为每个元素在配备一个键，整体以键值对的方式存储到容器中，可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素，默认会根据各元素键值的大小做升序排序。</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>用来遍历容器中的元素的类型，<em>类中类</em>(可以理解为指针)，扮演着容器和算法之间的胶合剂</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>解决问题的方法</p>
<h4 id="容器、迭代器、算法分离案例"><a href="#容器、迭代器、算法分离案例" class="headerlink" title="容器、迭代器、算法分离案例"></a>容器、迭代器、算法分离案例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//算法：求数组元素个数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mcount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *begin,<span class="hljs-keyword">int</span> *end,<span class="hljs-keyword">int</span> arr[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (begin != end)<br>	&#123;<br>		num++;<br>		begin++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> num;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//容器</span><br>	<span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-comment">//迭代器</span><br>	<span class="hljs-keyword">int</span> *begin = arr;<br>	<span class="hljs-keyword">int</span> *end = &amp;arr[<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr[<span class="hljs-number">0</span>])];<br>	cout&lt;&lt;<span class="hljs-built_in">mcount</span>(begin,end,arr);<br><br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h1><h4 id="string概念"><a href="#string概念" class="headerlink" title="string概念"></a>string概念</h4><ul>
<li>string是STL的字符串类型，通常用来表示字符串。而在使用string之前，字符串通常是用char<em>表示的。string与char</em>都可以用来表示字符串，那么二者有什么区别呢。</li>
</ul>
<p><strong>string和char*的比较</strong></p>
<ul>
<li><p>string是一个类, char*是一个指向字符的指针。</p>
<p>​     <em>string封装了char*，管理这个字符串，是一个char*型的容器</em></p>
</li>
<li><p>string不用考虑内存释放和越界。</p>
<p>​     <em>string管理char</em>所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。*</p>
</li>
<li><p>string提供了一系列的字符串操作函数（这个等下会详讲）</p>
<pre><code>   *查找find，拷贝copy，删除erase，替换replace，插入insert*
</code></pre>
</li>
</ul>
<h4 id="string的构造函数"><a href="#string的构造函数" class="headerlink" title="string的构造函数"></a>string的构造函数</h4><ul>
<li><p>默认构造函数：</p>
<p>​    string();      //构造一个空的字符串string s1。</p>
</li>
<li><p>拷贝构造函数：</p>
<p>​    string(const string &amp;str);    //构造一个与str一样的string。如string s1(s2)。</p>
</li>
<li><p>带参数的构造函数</p>
<pre><code>  string(const char *s);   //用字符串s初始化
</code></pre>
<p>   string(int n,char c);   //用n个字符c初始化</p>
</li>
</ul>
<h4 id="string的存取字符操作"><a href="#string的存取字符操作" class="headerlink" title="string的存取字符操作"></a>string的存取字符操作</h4><ul>
<li><p>char &amp;operator[] (int n);</p>
</li>
<li><p>char &amp;at(int n);</p>
</li>
<li><p>operator[]和at()均返回当前字符串中第n个字符，但二者是有区别的。</p>
<p>主要区别在于at()在越界时会抛出异常，[]在刚好越界时会返回‘\0’，再继续越界时，程序直接中断。如果你的程序希望可以通过try,catch捕获异常，建议采用at()。</p>
</li>
</ul>
<p>从string取得const char*</p>
<ul>
<li>const char *c_str() const;  //返回一个以’\0’结尾的字符串的首地址</li>
<li>const char *data() const;  //同上 </li>
</ul>
<h4 id="把string拷贝到char-指向的内存空间的操作"><a href="#把string拷贝到char-指向的内存空间的操作" class="headerlink" title="把string拷贝到char*指向的内存空间的操作"></a>把string拷贝到char*指向的内存空间的操作</h4><ul>
<li><p>int copy(char *s, int n, int pos=0) const;  </p>
<p>把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目。注意要保证s所指向的空间足够大以容纳当前字符串，不然会越界。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;maye&quot;</span>)</span></span>;<br><span class="hljs-keyword">char</span> arr[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>str.<span class="hljs-built_in">copy</span>(arr, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<h4 id="string的长度"><a href="#string的长度" class="headerlink" title="string的长度"></a>string的长度</h4><ul>
<li><p>int length() const;  //返回当前字符串的长度。长度不包括字符串结尾的’\0’。</p>
</li>
<li><p>int size() const;    //同上</p>
</li>
<li><p>bool empty() const;   //当前字符串是否为空</p>
</li>
</ul>
<h4 id="string的赋值"><a href="#string的赋值" class="headerlink" title="string的赋值"></a>string的赋值</h4><ul>
<li><p>string &amp;operator=(const string &amp;s);//把字符串s赋给当前的字符串</p>
</li>
<li><p>string &amp;assign(const char *s); //把字符串s赋给当前的字符串</p>
</li>
<li><p>string &amp;assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串</p>
</li>
<li><p>string &amp;assign(const string &amp;s);  //把字符串s赋给当前字符串</p>
</li>
<li><p>string &amp;assign(int n,char c);  //用n个字符c赋给当前字符串</p>
</li>
<li><p>string &amp;assign(const string &amp;s,int start, int n);  //把字符串s中从start开始的n个字符赋给当前字符串</p>
</li>
</ul>
<h4 id="string字符串连接"><a href="#string字符串连接" class="headerlink" title="string字符串连接"></a>string字符串连接</h4><ul>
<li><p>string &amp;operator+=(const string &amp;s);  //把字符串s连接到当前字符串结尾</p>
</li>
<li><p>string &amp;operator+=(const char *s);//把字符串s连接到当前字符串结尾</p>
</li>
<li><p>string &amp;append(const char *s);   //把字符串s连接到当前字符串结尾</p>
</li>
<li><p>string &amp;append(const char *s,int n);  //把字符串s的前n个字符连接到当前字符串结尾</p>
</li>
<li><p>string &amp;append(const string &amp;s);  //同operator+=()</p>
</li>
<li><p>string &amp;append(const string &amp;s,int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾</p>
</li>
<li><p>string &amp;append(int n, char c);  //在当前字符串结尾添加n个字符c</p>
</li>
</ul>
<h4 id="string比较"><a href="#string比较" class="headerlink" title="string比较"></a>string比较</h4><p>int compare(const string &amp;s) const;  //与字符串s比较</p>
<p>int compare(const char *s) const;  //与字符串s比较</p>
<p>compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。此外还支持&gt;、&gt;=、&lt;、&lt;=、==直接比较</p>
<h4 id="string的子串"><a href="#string的子串" class="headerlink" title="string的子串"></a>string的子串</h4><p>string substr(int pos=0, int n=npos) const;   //返回由pos开始的n个字符组成的子字符串</p>
<h4 id="string的查找和替换"><a href="#string的查找和替换" class="headerlink" title="string的查找和替换"></a>string的查找和替换</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h5><p>int find(char c,int pos=0) const;  //从pos开始查找字符c在当前字符串的位置 </p>
<p>int find(const char *s, int pos=0) const;  //从pos开始查找字符串s在当前字符串的位置</p>
<p>int find(const string &amp;s, int pos=0) const;  //从pos开始查找字符串s在当前字符串中的位置</p>
<p>find函数如果查找不到，就返回-1</p>
<p>int rfind(char c, int pos=npos) const;  //从pos开始从后向前查找字符c在当前字符串中的位置 </p>
<p>int rfind(const char *s, int pos=npos) const;</p>
<p>int rfind(const string &amp;s, int pos=npos) const;</p>
<p>//rfind是反向查找的意思，如果查找不到， 返回-1</p>
<h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a><strong>替换</strong></h5><p>string &amp;replace(int pos, int n, const char *s);//删除从pos开始的n个字符，然后在pos处插入串s</p>
<p>string &amp;replace(int pos, int n, const string &amp;s);  //删除从pos开始的n个字符，然后在pos处插入串s</p>
<p>void swap(string &amp;s2);   //交换当前字符串与s2的值</p>
<h4 id="String的区间删除和插入"><a href="#String的区间删除和插入" class="headerlink" title="String的区间删除和插入"></a>String的区间删除和插入</h4><p>string &amp;insert(int pos, const char *s);</p>
<p>string &amp;insert(int pos, const string &amp;s);</p>
<p>//前两个函数在pos位置插入字符串s</p>
<p>string &amp;insert(int pos, int n, char c);  //在pos位置 插入n个字符c</p>
<p>string &amp;erase(int pos=0, int n=npos);  //删除pos开始的n个字符，返回修改后的字符串</p>
<h1 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h1><h4 id="Vector容器简介"><a href="#Vector容器简介" class="headerlink" title="Vector容器简介"></a>Vector容器简介</h4><p>vector是将元素置于一个动态数组中加以管理的容器。</p>
<p>vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）</p>
<p>vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时</p>
<h4 id="vector的构造函数"><a href="#vector的构造函数" class="headerlink" title="vector的构造函数"></a>vector的构造函数</h4><p>vector采用模板类实现，vector对象的默认构造形式</p>
<p>vector&lt;T&gt; vecT;    //尖括号内还可以设置任意的数据类型。</p>
<p>存放对象的时候值得注意：由于容器元素的存放是按值复制的方式进行的，所以此时类必须提供对象的拷贝构造函数，以保证对象间拷贝正常。</p>
<p>vector(begin,end);   //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。(能取begin的值，不能取end的值)</p>
<p> vector(n,elem);  //构造函数将n个elem拷贝给本身。</p>
<p>vector(const vector &amp;vec);  //拷贝构造函数</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span>  iArray[] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vecIntA</span><span class="hljs-params">(iArray, iArray + <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vecIntB</span><span class="hljs-params">(vecIntA.begin(), vecIntA.end())</span></span>;  <span class="hljs-comment">//用构造函数初始化容器vecIntB </span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vecIntB</span><span class="hljs-params">(vecIntA.begin(), vecIntA.begin() + <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vecIntC</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>)</span></span>; <span class="hljs-comment">//容器vecIntB存放3个元素，每个元素的值是9。</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vecIntD</span><span class="hljs-params">(vecIntA)</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="vector的赋值"><a href="#vector的赋值" class="headerlink" title="vector的赋值"></a>vector的赋值</h4><p> vector.assign(beg,end);   //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
<p>vector.assign(n,elem);  //将n个elem拷贝赋值给本身。</p>
<p>vector&amp; operator=(const vector  &amp;vec);    //重载等号操作符</p>
<p>vector.swap(vec);  // 将vec与本身的元素互换。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; vecIntA, vecIntB, vecIntC, vecIntD;<br><span class="hljs-keyword">int</span>  iArray[] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>vecIntA.<span class="hljs-built_in">assign</span>(iArray, iArray + <span class="hljs-number">5</span>);		<span class="hljs-comment">//把iArray全部赋值给vecIntA</span><br>vecIntB.<span class="hljs-built_in">assign</span>(vecIntA.<span class="hljs-built_in">begin</span>(), vecIntA.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">//用其它容器的迭代器作参数。</span><br>vecIntC.<span class="hljs-built_in">assign</span>(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>);<span class="hljs-comment">//容器vecIntB存放3个元素，每个元素的值是9。</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vecIntD;<br>vecIntD = vecIntA;<br>vecIntA.<span class="hljs-built_in">swap</span>(vecIntD);<span class="hljs-comment">//交换vecIntA和vecIntD的数据</span><br></code></pre></td></tr></table></figure>

<h4 id="vector的大小"><a href="#vector的大小" class="headerlink" title="vector的大小"></a>vector的大小</h4><p>vector.size();      //返回容器中元素的个数</p>
<p>vector.empty();      //判断容器是否为空</p>
<p>vector.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>vector.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<h4 id="vector末尾的添加移除操作"><a href="#vector末尾的添加移除操作" class="headerlink" title="vector末尾的添加移除操作"></a>vector末尾的添加移除操作</h4><p>vector.push_back(data);//在尾部添加一个元素</p>
<p>vector.pop_back();//删除尾部元素</p>
<h4 id="vector的数据存取"><a href="#vector的数据存取" class="headerlink" title="vector的数据存取"></a>vector的数据存取</h4><p>vec.at(index);  //返回索引index所指的数据，如果index越界，抛出out_of_range异常。</p>
<p>vec[index];  //返回索引index所指的数据，越界时，运行直接报错</p>
<h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><h4 id="Deque简介"><a href="#Deque简介" class="headerlink" title="Deque简介"></a>Deque简介</h4><p>deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数组，而vector是单端的。</p>
<p>deque在接口上和vector非常相似，在许多操作的地方可以直接替换。</p>
<p>deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。</p>
<p>deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。</p>
<p>#include <deque>  </p>
<h4 id="deque对象的默认构造"><a href="#deque对象的默认构造" class="headerlink" title="deque对象的默认构造"></a>deque对象的默认构造</h4><p>deque采用模板类实现，deque对象的默认构造形式：deque<T> deqT;  </p>
<p>deque <int> deqInt;       //一个存放int的deque容器。</p>
<p>deque <float> deq Float;   //一个存放float的deque容器。</p>
<p>deque <string> deq String;   //一个存放string的deque容器。</p>
<p>…                  </p>
<p> //尖括号内还可以设置指针类型或自定义类型。 </p>
<h4 id="deque对象的带参数构造"><a href="#deque对象的带参数构造" class="headerlink" title="deque对象的带参数构造"></a>deque对象的带参数构造</h4><p>deque(beg,end);   //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</p>
<p>deque(n,elem);  //构造函数将n个elem拷贝给本身。</p>
<p>deque(const deque  &amp;deq);  //拷贝构造函数。</p>
<h4 id="deque末尾的添加移除操作"><a href="#deque末尾的添加移除操作" class="headerlink" title="deque末尾的添加移除操作"></a>deque末尾的添加移除操作</h4><p>deque.push_back(elem);    //在容器尾部添加一个数据</p>
<p>deque.push_front(elem);    //在容器头部插入一个数据</p>
<p>deque.pop_back();       //删除容器最后一个数据</p>
<p>deque.pop_front();        //删除容器第一个数据</p>
<h4 id="deque的数据存取"><a href="#deque的数据存取" class="headerlink" title="deque的数据存取"></a>deque的数据存取</h4><p>deque.at(idx);  //返回索引idx所指的数据，如果idx越界，抛出out_of_range。</p>
<p>deque[idx];  //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</p>
<p>deque.front();  //返回第一个数据。</p>
<p>deque.back();  //返回最后一个数据</p>
<h4 id="deque的赋值"><a href="#deque的赋值" class="headerlink" title="deque的赋值"></a>deque的赋值</h4><p>deque.assign(beg,end);   //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
<p>deque.assign(n,elem);  //将n个elem拷贝赋值给本身。</p>
<p>deque&amp; operator=(const deque &amp;deq);    //重载等号操作符 </p>
<p>deque.swap(deq);  // 将vec与本身的元素互换</p>
<h4 id="deque的大小"><a href="#deque的大小" class="headerlink" title="deque的大小"></a>deque的大小</h4><p>deque.size();      //返回容器中元素的个数</p>
<p>deque.empty();      //判断容器是否为空</p>
<p>deque.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>deque.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<h4 id="deque的插入"><a href="#deque的插入" class="headerlink" title="deque的插入"></a>deque的插入</h4><p>deque.insert(pos,elem);  //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
<p>deque.insert(pos,n,elem);  //在pos位置插入n个elem数据，无返回值。</p>
<p>deque.insert(pos,beg,end);  //在pos位置插入[beg,end)区间的数据，无返回值。</p>
<h4 id="deque的删除"><a href="#deque的删除" class="headerlink" title="deque的删除"></a>deque的删除</h4><p>deque.clear();    //移除容器的所有数据</p>
<p>deque.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
<p>deque.erase(pos);   //删除pos位置的数据，返回下一个数据的位置。</p>
<h1 id="迭代器基本原理"><a href="#迭代器基本原理" class="headerlink" title="迭代器基本原理"></a>迭代器基本原理</h1><ul>
<li><p>代器是一个“可遍历STL容器内全部或部分元素”的对象。</p>
</li>
<li><p>迭代器指出容器中的一个特定位置。</p>
</li>
<li><p>迭代器就如同一个指针。</p>
</li>
<li><p>迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围。</p>
</li>
</ul>
<h4 id="迭代器的类别"><a href="#迭代器的类别" class="headerlink" title="迭代器的类别"></a>迭代器的类别</h4><p><em><strong>输入迭代器</strong></em>：也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p>
<p><em><strong>输出迭代器</strong></em>：也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p>
<p><em><strong>正向迭代器</strong></em>：组合输入迭代器和输出迭代器的功能，还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p>
<p><em><strong>双向迭代器</strong></em>：组合正向迭代器的功能，还可以通过++操作符向后移动位置。</p>
<p><strong>随机访问迭代器</strong>：组合双向迭代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p>
<h4 id="迭代器的操作"><a href="#迭代器的操作" class="headerlink" title="迭代器的操作"></a>迭代器的操作</h4><table>
<thead>
<tr>
<th>迭代器</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>所有迭代器</td>
<td>it++、++it</td>
</tr>
<tr>
<td>输入迭代器</td>
<td>*it、it1=it2、it1==it2、it1！=it2</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>*it、it1=it2</td>
</tr>
<tr>
<td>正向迭代器</td>
<td>提供输入输出迭代器的所有功能</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>it–、–it</td>
</tr>
<tr>
<td>随机迭代器</td>
<td>+=、-=、+、-、[]、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<p>这里用到的容器，都支持双向迭代器或随机访问迭代器，下面将会详细介绍这两个类别的迭代器。</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>对应迭代器类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>vector</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>list</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>set / multiset</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>map / multimap</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_map / unordered_multimap</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_set / unordered_multiset</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
</tbody></table>
<h4 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Data&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Vector</span>() :<span class="hljs-built_in">Array</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">curSize</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">capacity</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>	<span class="hljs-built_in">Vector</span>(<span class="hljs-keyword">int</span> size) :<span class="hljs-built_in">curSize</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">capacity</span>(size)<br>	&#123;<br>		Array = <span class="hljs-keyword">new</span> Data[size];<br>	&#125;<br>	<span class="hljs-built_in">Vector</span>(Vector&amp; arr) :<span class="hljs-built_in">curSize</span>(arr.curSize), <span class="hljs-built_in">capacity</span>(arr.capacity)<br>	&#123;<br>		Array = <span class="hljs-keyword">new</span> Data[capacity];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.curSize; i++)<br>		&#123;<br>			<span class="hljs-keyword">this</span>-&gt;Array[i] = arr.Array[i];<br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Data data)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">if</span> (curSize &lt; capacity)<br>		&#123;<br>			Array[curSize] = data;<br>			curSize++;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		cout &lt;&lt; <span class="hljs-string">&quot;数组越界&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrMul</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mulNum)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; curSize; i++)<br>		&#123;<br>			Array[i] *= mulNum;<br>			<span class="hljs-comment">//要确保存的数据类型，能够相乘</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>=(Vector&amp; arr)<br>	&#123;<br>		<span class="hljs-comment">//判断当前对象和arr的关系</span><br>		<span class="hljs-keyword">if</span> (capacity &lt; arr.curSize)<br>		&#123;<br>			<span class="hljs-keyword">delete</span>[] Array;<br>			capacity = arr.capacity;<br>			curSize = arr.curSize;<br>			Array = <span class="hljs-keyword">new</span> Data[capacity];<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.curSize; i++)<br>		&#123;<br>			<span class="hljs-keyword">this</span>-&gt;Array[i] = arr[i];<br>			<span class="hljs-comment">//要确保，存的类型能够相互赋值</span><br>		&#125;<br>		curSize = arr.curSize;<br>	&#125;<br>	Data&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; capacity)<br>		&#123;<br>			<span class="hljs-keyword">return</span> Array[index];<br>		&#125;<br>		cout &lt;&lt; <span class="hljs-string">&quot;数组访问越界&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Vector&amp; Array)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Array.curSize; i++)<br>		&#123;<br>			out &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::left) &lt;&lt; Array[i];<br>		&#125;<br>		<span class="hljs-keyword">return</span> out;<br>	&#125;<br>	~<span class="hljs-built_in">Vector</span>()<br>	&#123;<br>		<span class="hljs-keyword">delete</span>[] Array;<br>	&#125;<br>	<span class="hljs-comment">//迭代器</span><br>	<span class="hljs-function">Data* <span class="hljs-title">begin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> Array;<br>	&#125;<br>	<span class="hljs-function">Data* <span class="hljs-title">end</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> &amp;Array[curSize];<br>	&#125;<br>	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">iterotar</span></span><br><span class="hljs-class">	&#123;</span><br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">iterotar</span>(Data *begin=<span class="hljs-literal">nullptr</span>)<br>		&#123;<br>			pmove = begin;<br>		&#125;<br>		~<span class="hljs-built_in">iterotar</span>()<br>		&#123;<br><br>		&#125;<br>		<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(Data* end)<br>		&#123;<br>			<span class="hljs-keyword">return</span> pmove != end;<br>		&#125;<br>		Data* <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)<br>		&#123;<br>			Data* temp = pmove;<br>			<span class="hljs-keyword">this</span>-&gt;pmove++;<br>			<span class="hljs-keyword">return</span> temp;<br>		&#125;<br>		<span class="hljs-comment">//一定要返回引用，否则匿名对象不接受会出错</span><br>		Data&amp; <span class="hljs-keyword">operator</span>*()<br>		&#123;<br>			<span class="hljs-keyword">return</span> *pmove;<br>		&#125;<br>		Data* <span class="hljs-keyword">operator</span>-&gt;()<br>		&#123;<br>			<span class="hljs-keyword">return</span> pmove;<br>		&#125;<br>	<span class="hljs-keyword">private</span>:<br>		Data* pmove;<br>	&#125;;<br><span class="hljs-keyword">protected</span>:<br>	Data* Array;		<span class="hljs-comment">//数组指针</span><br>	<span class="hljs-keyword">int</span> curSzie;	<span class="hljs-comment">//数组当前大小</span><br>	<span class="hljs-keyword">int</span> capacity;	<span class="hljs-comment">//数组最大容量</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="initializer-list聚合初始化"><a href="#initializer-list聚合初始化" class="headerlink" title="initializer_list聚合初始化"></a>initializer_list聚合初始化</h4><p>前面给大家讲过数组可以用聚合的方式初始化，int arr[]={1,3,1,4,5,2,0};那么咱们自己写的vector能用聚合初始化吗？</p>
<p>答案是否定的，那么怎么做才能使用聚合形式进行初始化呢？</p>
<p>C++11提供的新模板类型initializer_list<T>,有了它之后咱们就可以使用聚合进行初始化啦！</p>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(initializer_list&lt;<span class="hljs-keyword">int</span>&gt; ls)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : ls)<br>	&#123;<br>		cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-built_in">show</span>(&#123; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span> &#125;);<span class="hljs-comment">//输出</span><br></code></pre></td></tr></table></figure>

<p>同理，在类中我们可以提供一个initializer_list类型的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//构造聚合初始化</span><br><span class="hljs-built_in">Vector</span>(initializer_list&lt;Data&gt; ls)<br>&#123;<br>	_capacity = ls.<span class="hljs-built_in">size</span>();<br>	_curSize = <span class="hljs-number">0</span>;<br>	_Array = <span class="hljs-keyword">new</span> Data[_capacity];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> Data&amp; temp : ls)<br>	&#123;<br>		<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">push_back</span>(temp);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h1><h4 id="list简介"><a href="#list简介" class="headerlink" title="list简介"></a>list简介</h4><p> list是一个双向链表容器，可高效地进行插入删除元素。</p>
<p> list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok)    it+5(err)</p>
<h4 id="list对象的默认构造"><a href="#list对象的默认构造" class="headerlink" title="list对象的默认构造"></a>list对象的默认构造</h4><p>list采用采用模板类实现,对象的默认构造形式：list<T> lsT;  如：</p>
<p>list<int> lstInt;       //定义一个存放int的list容器。</p>
<p>list<float> lstFloat;   //定义一个存放float的list容器。</p>
<p>list<string> lstString;   //定义一个存放string的list容器。</p>
<p>…                  </p>
<p>//尖括号内还可以设置指针类型或自定义类型。</p>
<h4 id="list头尾的添加移除操作"><a href="#list头尾的添加移除操作" class="headerlink" title="list头尾的添加移除操作"></a>list头尾的添加移除操作</h4><p>list.push_back(elem);      //在容器尾部加入一个元素</p>
<p>list.pop_back();        //删除容器中最后一个元素</p>
<p>list.push_front(elem);   //在容器开头插入一个元素</p>
<p>list.pop_front();        //从容器开头移除第一个元素</p>
<h4 id="list的数据存取"><a href="#list的数据存取" class="headerlink" title="list的数据存取"></a>list的数据存取</h4><p>list.front();  //返回第一个元素。</p>
<p>list.back();  //返回最后一个元素。</p>
<h4 id="list与迭代器"><a href="#list与迭代器" class="headerlink" title="list与迭代器"></a>list与迭代器</h4><p>list.begin();           //返回容器中第一个元素的迭代器。</p>
<p>list.end();            //返回容器中最后一个元素之后的迭代器。</p>
<p>list.rbegin();     //返回容器中倒数第一个元素的迭代器。</p>
<p>list.rend();     //返回容器中倒数最后一个元素的后面的迭代器。</p>
<h4 id="list对象的带参数构造"><a href="#list对象的带参数构造" class="headerlink" title="list对象的带参数构造"></a>list对象的带参数构造</h4><p>list(beg,end);   //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</p>
<p>list(n,elem);  //构造函数将n个elem拷贝给本身。</p>
<p>list(const list &amp;lst);  //拷贝构造函数。</p>
<h4 id="list的赋值"><a href="#list的赋值" class="headerlink" title="list的赋值"></a>list的赋值</h4><p>list.assign(beg,end);   //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
<p>list.assign(n,elem);  //将n个elem拷贝赋值给本身。</p>
<p>list&amp; operator=(const list &amp;lst);    //重载等号操作符</p>
<p>list.swap(lst);  // 将lst与本身的元素互换。</p>
<h4 id="list的大小"><a href="#list的大小" class="headerlink" title="list的大小"></a>list的大小</h4><p>list.size();      //返回容器中元素的个数</p>
<p>list.empty();      //判断容器是否为空</p>
<p>list.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>list.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<h4 id="list的插入"><a href="#list的插入" class="headerlink" title="list的插入"></a>list的插入</h4><p>list.insert(pos,elem);  //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
<p>list.insert(pos,n,elem);  //在pos位置插入n个elem数据，无返回值。</p>
<p>list.insert(pos,beg,end);  //在pos位置插入[beg,end)区间的数据，无返回值。</p>
<h4 id="list的删除"><a href="#list的删除" class="headerlink" title="list的删除"></a>list的删除</h4><p>list.clear();        //移除容器的所有数据</p>
<p>list.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
<p>list.erase(pos);   //删除pos位置的数据，返回下一个数据的位置。</p>
<p>lst.remove(elem);  //删除容器中所有与elem值匹配的元素。</p>
<p> <em><strong>当使用一个容器的insert或者erase函数通过迭代器插入或删除元素”可能”会导致迭代器失效，因此我们为了避免危险，应该获取insert或者erase返回的迭代器，以便用重新获取的新的有效的迭代器进行正确的操作</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-keyword">int</span>&gt; ls;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>	ls.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>list&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = ls.<span class="hljs-built_in">begin</span>(); it != ls.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>	<span class="hljs-keyword">if</span> (*it == <span class="hljs-number">5</span>)<br>	&#123;<br>		it=ls.<span class="hljs-built_in">erase</span>(it);<br>	&#125;<br>	cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="list的反序排列"><a href="#list的反序排列" class="headerlink" title="list的反序排列"></a>list的反序排列</h4><p>lst.reverse();   //反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>一、容器deque的使用方法</p>
<p>​    适合在头尾添加移除元素。使用方法与vector类似。</p>
<p>二、容器queue,stack的使用方法</p>
<p>​    适合队列，堆栈的操作方式。</p>
<p>三、容器list的使用方法</p>
<p>​    适合在任意位置快速插入移除元素</p>
<h1 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h1><p>Stack简介</p>
<p>stack是堆栈容器，是一种“先进后出”的容器。</p>
<p>stack是简单地装饰deque容器而成为另外的一种容器。</p>
<p>#include <stack>  </p>
<h4 id="stack对象的默认构造"><a href="#stack对象的默认构造" class="headerlink" title="stack对象的默认构造"></a>stack对象的默认构造</h4><p>stack采用模板类实现， stack对象的默认构造形式： stack <T> stkT;  </p>
<p>stack <int> stkInt;       //一个存放int的stack容器。</p>
<p>stack <float> stkFloat;   //一个存放float的stack容器。</p>
<p>stack <string> stkString;   //一个存放string的stack容器。</p>
<p>…                  </p>
<p>//尖括号内还可以设置指针类型或自定义类型。</p>
<h4 id="stack元素获取与删除"><a href="#stack元素获取与删除" class="headerlink" title="stack元素获取与删除"></a>stack元素获取与删除</h4><p>stack.push(elem);  //往栈头添加元素</p>
<p>stack.pop();  //从栈头移除第一个元素</p>
<p>stack.top();     //返回最栈顶元素</p>
<h4 id="stack对象的拷贝构造与赋值"><a href="#stack对象的拷贝构造与赋值" class="headerlink" title="stack对象的拷贝构造与赋值"></a>stack对象的拷贝构造与赋值</h4><p>stack(const stack &amp;stk);           //拷贝构造函数</p>
<p>stack&amp; operator=(const stack &amp;stk);    //重载等号操作符</p>
<h4 id="stack的大小"><a href="#stack的大小" class="headerlink" title="stack的大小"></a>stack的大小</h4><p>stack.empty();  //判断堆栈是否为空</p>
<p>stack.size();        //返回堆栈的大小</p>
<h1 id="Queue容器"><a href="#Queue容器" class="headerlink" title="Queue容器"></a>Queue容器</h1><h4 id="Queue简介"><a href="#Queue简介" class="headerlink" title="Queue简介"></a>Queue简介</h4><p>queue是队列容器，是一种“先进先出”的容器。</p>
<p>queue是简单地装饰deque容器而成为另外的一种容器。</p>
<p>#include <queue>  </p>
<h4 id="queue对象的默认构造"><a href="#queue对象的默认构造" class="headerlink" title="queue对象的默认构造"></a>queue对象的默认构造</h4><p>queue采用模板类实现，queue对象的默认构造形式：queue<T> queT;  如：</p>
<p>queue<int> queInt;       //一个存放int的queue容器。</p>
<p>queue<float> queFloat;   //一个存放float的queue容器。</p>
<p>queue<string> queString;   //一个存放string的queue容器。</p>
<p>…                  </p>
<p>//尖括号内还可以设置指针类型或自定义类型。 </p>
<h4 id="queue的数据存取"><a href="#queue的数据存取" class="headerlink" title="queue的数据存取"></a>queue的数据存取</h4><p>queue.push(elem);  //往队尾添加元素</p>
<p>queue.pop();  //从队头移除第一个元素</p>
<p>queue.back();  //返回最后一个元素</p>
<p>queue.front();  //返回第一个元素</p>
<h4 id="queue对象的拷贝构造与赋值"><a href="#queue对象的拷贝构造与赋值" class="headerlink" title="queue对象的拷贝构造与赋值"></a>queue对象的拷贝构造与赋值</h4><p>queue(const queue &amp;que);           //拷贝构造函数</p>
<p>queue&amp; operator=(const queue &amp;que);    //重载等号操作符</p>
<h4 id="queue的大小"><a href="#queue的大小" class="headerlink" title="queue的大小"></a>queue的大小</h4><p>queue.empty();  //判断队列是否为空</p>
<p>queue.size();        //返回队列的大小</p>
<h1 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h1><h4 id="set-multiset的简介"><a href="#set-multiset的简介" class="headerlink" title="set/multiset的简介"></a>set/multiset的简介</h4><p>set是一个<em><strong>集合</strong></em>容器，其中所包含的元素是<em><strong>唯一</strong></em>的，<em><strong>集合中的元素按一定的顺序排列</strong></em>。元素插入过程是按排序规则插入，所以不能指定插入位置。</p>
<p>set采用<em><strong>红黑树</strong></em>变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。</p>
<p>set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</p>
<p style="color:red;">multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。</p>

<p><font style="color:blue">不可以直接修改set或multiset容器中的元素值</font>，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。</p>
<p>#include <set>  </p>
<h4 id="set-multiset对象的默认构造"><a href="#set-multiset对象的默认构造" class="headerlink" title="set/multiset对象的默认构造"></a>set/multiset对象的默认构造</h4><p>set<int> setInt;       //一个存放int的set容器。</p>
<p>set<float> setFloat;   //一个存放float的set容器。</p>
<p>set<string> setString;   //一个存放string的set容器。</p>
<p>multiset<int> mulsetInt;       //一个存放int的multi set容器。</p>
<p>multi set<float> multisetFloat;   //一个存放float的multi set容器。</p>
<p>multi set<string> multisetString;   //一个存放string的multi set容器。</p>
<h4 id="set的插入"><a href="#set的插入" class="headerlink" title="set的插入"></a>set的插入</h4><p>set.insert(elem);   //在容器中插入元素。</p>
<h4 id="Set集合的元素排序"><a href="#Set集合的元素排序" class="headerlink" title="Set集合的元素排序"></a>Set集合的元素排序</h4><p>set&lt;int,less<int> &gt;  setIntA;  //该容器是按升序方式排列元素。</p>
<p>set&lt;int,greater<int>&gt; setIntB;  //该容器是按降序方式排列元素。</p>
<p>set<int> 相当于 set&lt;int,less<int>&gt;。</p>
<p>less<int>与greater<int>中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。</p>
<p>疑问1： less&lt;&gt;与greate&lt; &gt;是什么？</p>
<p>疑问2：如果set&lt;&gt;不包含int类型，而是包含自定义类型，set容器如何排序？</p>
<p>要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。</p>
<p>下面将讲解什么是functor以及用法。</p>
<p>使用stl提供的函数对象</p>
<p>set&lt;int,greater<int>&gt; setIntB;  </p>
<p>setIntB.insert(3);</p>
<p>setIntB.insert(1);</p>
<p>setIntB.insert(5);</p>
<p>setIntB.insert(2);</p>
<p>此时容器setIntB就包含了按顺序的5,3,2,1元素</p>
<h4 id="函数对象functor的用法"><a href="#函数对象functor的用法" class="headerlink" title="函数对象functor的用法"></a>函数对象functor的用法</h4><p>尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。</p>
<p>functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。</p>
<p>greater&lt;&gt;与less&lt;&gt;就是函数对象。</p>
<p>下面举出greater<int>的简易实现原理。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">greater</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; iLeft, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; iRight)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> iLeft &gt; iRight;  <span class="hljs-comment">//如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);</span><br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>容器就是调用函数对象的operator()方法去比较两个值的大小。</p>
<h5 id="仿函数练习"><a href="#仿函数练习" class="headerlink" title="仿函数练习"></a>仿函数练习</h5><p>学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//学生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CStudent</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">CStudent</span>(<span class="hljs-keyword">int</span> iID, string strName)<br>	&#123;<br>		m_iID = iID;<br>		m_strName = strName;<br>	&#125;<br>	<span class="hljs-comment">//private:</span><br>	<span class="hljs-keyword">int</span> m_iID;		<span class="hljs-comment">//学号</span><br>	string m_strName; 	<span class="hljs-comment">//姓名</span><br>&#125;;<br><span class="hljs-comment">//为保持主题鲜明，本类不写拷贝构造函数，不类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。</span><br><span class="hljs-comment">//函数对象</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StuFunctor</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CStudent&amp; stu1,<span class="hljs-keyword">const</span> CStudent&amp; stu2)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> (stu1.m_iID &lt; stu2.m_iID);<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	set&lt;CStudent, StuFunctor&gt; setStu;<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;小张&quot;</span>));<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小李&quot;</span>));<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;小王&quot;</span>));<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;小刘&quot;</span>));<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : setStu)<br>	&#123;<br>		cout &lt;&lt; i.m_iID &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="set对象的拷贝构造与赋值"><a href="#set对象的拷贝构造与赋值" class="headerlink" title="set对象的拷贝构造与赋值"></a>set对象的拷贝构造与赋值</h4><p>set(const set &amp;st);           //拷贝构造函数</p>
<p>set&amp; operator=(const set &amp;st);    //重载等号操作符</p>
<p>set.swap(st);                //交换两个集合容器</p>
<h4 id="set的大小"><a href="#set的大小" class="headerlink" title="set的大小"></a>set的大小</h4><p>set.size();    //返回容器中元素的数目</p>
<p>set.empty();//判断容器是否为空</p>
<h4 id="set的删除"><a href="#set的删除" class="headerlink" title="set的删除"></a>set的删除</h4><p>set.clear();        //清除所有元素</p>
<p>set.erase(pos);    //删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
<p>set.erase(beg,end);      //删除区间[beg,end)的所有元素    ，返回下一个元素的迭代器。</p>
<p>set.erase(elem);   //删除容器中值为elem的元素。</p>
<h4 id="set的查找"><a href="#set的查找" class="headerlink" title="set的查找"></a>set的查找</h4><p>set.find(elem);  //查找elem元素，返回指向elem元素的迭代器。</p>
<p>set.count(elem);  //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</p>
<p>set.lower_bound(elem);      //返回第一个&gt;=elem元素的迭代器。</p>
<p>set.upper_bound(elem);      //  返回第一个&gt;elem元素的迭代器。</p>
<p>set.equal_range(elem);        //返回一对迭代器，这两个迭代器分别用于发现set中其键大于指定键的第一个元素，以及集中其键等于或大于指定键的第一个元素。</p>
<p>以上函数返回两个迭代器，而这两个迭代器被封装在pair中。</p>
<h5 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h5><p>以下讲解pair的含义与使用方法。</p>
<h4 id="pair的使用"><a href="#pair的使用" class="headerlink" title="pair的使用"></a>pair的使用</h4><p>pair译为对组，可以将两个值视为一个单元。</p>
<p>pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。</p>
<p>pair.first是pair里面的第一个值，是T1类型。</p>
<p>pair.second是pair里面的第二个值，是T2类型。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>一、容器set/multiset的使用方法；</p>
<p>​            红黑树的变体，查找效率高，插入不能指定位置，插入时自动排序。</p>
<p>二、functor的使用方法；</p>
<pre><code>      类似于函数的功能，可用来自定义一些规则，如元素比较规则。
</code></pre>
<p>三、pair的使用方法。</p>
<p>​            对组，一个整体的单元，存放两个类型(T1,T2，T1可与T2一样)的两个元素。</p>
<h1 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map\multimap容器"></a>map\multimap容器</h1><h4 id="map-multimap的简介"><a href="#map-multimap的简介" class="headerlink" title="map/multimap的简介"></a>map/multimap的简介</h4><p>map是标准的关联式容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。</p>
<p>map中key值是唯一的。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。</p>
<p>map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入操作和删除操作上比vector快。</p>
<p>map可以直接存取key所对应的value，支持[]操作符，如map[key]=value。</p>
<p>multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]和at操作。</p>
<p>#include <map>  </p>
<img src="//tvax4.sinaimg.cn/large/0072YHp3ly1gjq0vc5loyj30dt04xmyx.jpg" alt="map" width="497" data-width="497" data-height="177">

<h4 id="map-multimap对象的默认构造"><a href="#map-multimap对象的默认构造" class="headerlink" title="map/multimap对象的默认构造"></a>map/multimap对象的默认构造</h4><p>map&lt;T1,T2&gt; mapTT; </p>
<p>multimap&lt;T1,T2&gt;  multimapTT;  </p>
<h4 id="map的插入与迭代器"><a href="#map的插入与迭代器" class="headerlink" title="map的插入与迭代器"></a>map的插入与迭代器</h4><p>map.insert(…);   //往容器插入元素，返回pair&lt;iterator,bool&gt;</p>
<p>在map中插入元素的三种方式：</p>
<p>假设  map&lt;int, string&gt; mapStu;</p>
<p><strong>一、通过pair的方式插入对象</strong></p>
<p>mapStu.insert(  pair&lt;int,string&gt;(3,”小张”)  );</p>
<p><strong>二、通过pair的方式插入对象</strong></p>
<p>mapStu.inset(make_pair(-1, “校长-1”));</p>
<p><strong>三、通过value_type的方式插入对象</strong></p>
<p>mapStu.insert(  map&lt;int,string&gt;::value_type(1,”小李”)  );</p>
<p><strong>四、通过数组的方式插入值</strong>(multimap不支持)</p>
<p>mapStu[3] = “小刘”;</p>
<p>mapStu.at(4) = “小王”；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-keyword">int</span>, string&gt; chess;<br>chess.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;将&quot;</span>));<br>chess.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;士&quot;</span>));<br>chess.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-keyword">int</span>, string&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;像&quot;</span>));<br>chess.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>) = <span class="hljs-string">&quot;马&quot;</span>;<br>chess[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;車&quot;</span>;<br></code></pre></td></tr></table></figure>



<p>前三种方法，采用的是insert()方法，该方法<em><strong>返回值为pair&lt;iterator,bool&gt;</strong></em> </p>
<p>第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值<em><strong>修改</strong></em>成“小刘”。若发现已存在3这个键，则修改这个键对应的value。</p>
<p>string strName = mapStu[2];  //取操作或插入操作</p>
<p>只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值。</p>
<h4 id="函数对象functor的用法-1"><a href="#函数对象functor的用法-1" class="headerlink" title="函数对象functor的用法"></a>函数对象functor的用法</h4><p>map&lt;T1,T2,less<T1> &gt;  mapA;  //该容器是按键的升序方式排列元素。未指定函数对象，默认采用less<T1>函数对象。</p>
<p>map&lt;T1,T2,greater<T1>&gt; mapB;  //该容器是按键的降序方式排列元素。</p>
<p>less<T1>与greater<T1>  可以替换成其它的函数对象functor。</p>
<p>可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。</p>
<h4 id="map对象的拷贝构造与赋值"><a href="#map对象的拷贝构造与赋值" class="headerlink" title="map对象的拷贝构造与赋值"></a>map对象的拷贝构造与赋值</h4><p>map(const map &amp;mp);           //拷贝构造函数</p>
<p>map&amp; operator=(const map &amp;mp);    //重载等号操作符</p>
<p>map.swap(mp);                //交换两个集合容器</p>
<h4 id="map的大小"><a href="#map的大小" class="headerlink" title="map的大小"></a>map的大小</h4><p>map.size();    //返回容器中元素的数目</p>
<p>map.empty();//判断容器是否为空</p>
<h4 id="map的删除"><a href="#map的删除" class="headerlink" title="map的删除"></a>map的删除</h4><p>map.clear();        //删除所有元素</p>
<p>map.erase(pos);    //删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
<p>map.erase(beg,end);      //删除区间[beg,end)的所有元素    ，返回下一个元素的迭代器。</p>
<p>map.erase(keyElem);   //删除容器中key为keyElem的对组。</p>
<h4 id="map的查找"><a href="#map的查找" class="headerlink" title="map的查找"></a>map的查找</h4><p>map.find(key);  查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</p>
<p>map.count(keyElem);  //返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</p>
<p>map.equal_range(keyElem);        //返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。 </p>
<p>以上函数返回两个迭代器，而这两个迭代器被封装在pair中。 </p>
<p>Multimap 案例:</p>
<p>//1个key值可以对应多个value  = 分组 </p>
<p>//公司有销售部 sale （员工2名）、技术研发部 development （1人）、财务部 Financial （2人） </p>
<p>//人员信息有：姓名，年龄，电话、工资等组成</p>
<p>//通过 multimap进行 信息的插入、保存、显示</p>
<p>//分部门显示员工信息 </p>
<h1 id="STL容器共性机制"><a href="#STL容器共性机制" class="headerlink" title="STL容器共性机制"></a>STL容器共性机制</h1><p>STL容器所提供的都是值（value）寓意，而非引用（reference）寓意，也就是说当我们给容器中插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另行拷贝一份放入到容器中，而不是将原数据元素直接放进容器中，也就是说我们提供的元素必须能够被拷贝。</p>
<ul>
<li><p>除了queue和stack之外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。</p>
</li>
<li><p>通过STL不会抛出异常，需要使用者传入正确参数。</p>
</li>
<li><p>每个容器都提供一个默认的构造函数和默认的拷贝构造函数。</p>
</li>
<li><p>大小相关的构造方法：</p>
<ul>
<li>（1）size()返回容器中元素的个数；</li>
<li>（2）empty()判断容器是否为空。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody><tr>
<td>内存结构</td>
<td>单端数组</td>
<td>双端数组</td>
<td>双向链表</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
</tr>
<tr>
<td>可随机存取</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>对key而言：是</td>
<td>否</td>
</tr>
<tr>
<td>元素查找速度</td>
<td>慢</td>
<td>慢</td>
<td>非常慢</td>
<td>快</td>
<td>快</td>
<td>对key而言：快</td>
<td>对key而言：快</td>
</tr>
<tr>
<td>元素添加移除</td>
<td>尾端</td>
<td>头尾两端</td>
<td>任何位置</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="各容器使用场景"><a href="#各容器使用场景" class="headerlink" title="各容器使用场景"></a>各容器使用场景</h4><p><strong>在实际使用过程中，到底选择这几种容器中的哪一个，应该根据遵循以下原则：</strong></p>
<p>１、如果需要高效的随机存取，不在乎插入和删除的效率，使用vector；</p>
<p>2、如果需要大量的插入和删除元素，不关心随机存取的效率，使用list；</p>
<p>3、如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque；</p>
<p>4、如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap；</p>
<p>5、如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。</p>
<p>6、如果要求很快的查找速度，根据情况选择使用unordered_map或unordered_set。</p>
<h1 id="STL算法"><a href="#STL算法" class="headerlink" title="STL算法"></a>STL算法</h1><h4 id="sort-排序函数"><a href="#sort-排序函数" class="headerlink" title="sort()排序函数"></a>sort()排序函数</h4><p>该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>降序排序规则），甚至还可以自定义排序规则。</p>
<p>需要注意的是，sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：</p>
<ol>
<li><p>容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 <font style="color:red">array、vector、deque</font> 这 3 个容器提供支持。</p>
</li>
<li><p>如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持<code>&lt;</code>小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；</p>
<p>sort()函数有两种用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对 [first, last) 区域内的元素做默认的升序排序</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(first, last)</span></span>;<br><span class="hljs-comment">//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(first, last, Compare comp)</span></span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="transform-转换函数"><a href="#transform-转换函数" class="headerlink" title="transform()转换函数"></a>transform()转换函数</h4><p>将指定范围内的元素进行转换，并将结果存储在从result开始的范围中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Iterator <span class="hljs-title">transform</span> <span class="hljs-params">(first, last,result, <span class="hljs-keyword">const</span> T&amp; val)</span></span>;<br><span class="hljs-built_in">transform</span>(maye.<span class="hljs-built_in">begin</span>(), maye.<span class="hljs-built_in">end</span>(), maye.<span class="hljs-built_in">begin</span>(), toupper);<span class="hljs-comment">//转大写</span><br><span class="hljs-built_in">transform</span>(maye.<span class="hljs-built_in">begin</span>(), maye.<span class="hljs-built_in">end</span>(), maye.<span class="hljs-built_in">begin</span>(), tolower);<span class="hljs-comment">//转小写</span><br></code></pre></td></tr></table></figure>

<h4 id="find-查找函数"><a href="#find-查找函数" class="headerlink" title="find()查找函数"></a>find()查找函数</h4><p>该函数专门用来对容器或普通数组中，指定范围内查找和目标元素值相等的第一个元素。</p>
<p>find()函数用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Iterator <span class="hljs-title">find</span> <span class="hljs-params">(first, last, <span class="hljs-keyword">const</span> T&amp; val)</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="find-if-查找"><a href="#find-if-查找" class="headerlink" title="find_if()查找"></a>find_if()查找</h4><p>使用自定义的比较函数代替find函数默认的 == 比较操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> i == <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_find_if</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-keyword">auto</span> temp=<span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), cmp);<br>	<span class="hljs-keyword">if</span> (temp != v.<span class="hljs-built_in">end</span>())<br>	&#123;<br>		cout &lt;&lt; *temp ;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find()"></a>adjacent_find()</h4><p>指定范围内查找连续的两个连续相等的元素，并返回第一个元素的迭代器，如果没有找到，返回end迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> i == j;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_adjacent_find</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-keyword">auto</span> temp=<span class="hljs-built_in">adjacent_find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), cmp);<br>	<span class="hljs-keyword">if</span> (temp != v.<span class="hljs-built_in">end</span>())<br>	&#123;<br>		cout &lt;&lt; *temp;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="count-统计函数"><a href="#count-统计函数" class="headerlink" title="count()统计函数"></a>count()统计函数</h4><p>该函数专门用来对容器或普通数组中，指定范围内查找和目标元素值相等的所有元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(first,last,<span class="hljs-keyword">const</span> T&amp; val)</span></span>;<br></code></pre></td></tr></table></figure>



<h4 id="for-each函数"><a href="#for-each函数" class="headerlink" title="for_each函数"></a>for_each函数</h4><p>该函数专门用来对容器或普通数组中指定范围内的元素进行处理，把处理功能用函数封装。返回一个函数对象</p>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FUNC <span class="hljs-title">for_each</span><span class="hljs-params">(first, last, 函数对象)</span></span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span> &#125;;<br>for_each(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[<span class="hljs-number">6</span>], show);<br></code></pre></td></tr></table></figure>



<h4 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy()函数"></a>copy()函数</h4><p>把一个容器指定范围内的元素，拷贝到另一个容器中（目标容器必须内存足够）。返回一个迭代器，指向目标容器被拷贝元素范围的末尾</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Iterator <span class="hljs-title">count</span><span class="hljs-params">(first,last,destit)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_copy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(v.size())</span></span>;<br>	<span class="hljs-comment">//list&lt;int&gt; v1(v.size()+10);</span><br>	cout &lt;&lt; *<span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), v1.<span class="hljs-built_in">begin</span>()) &lt;&lt; endl;;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v1)<br>	&#123;<br>		cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="更多算法"><a href="#更多算法" class="headerlink" title="更多算法"></a>更多算法</h4><p><a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/algorithm/">C++参考手册</a></p>
<h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1><h4 id="为什么要有仿函数？"><a href="#为什么要有仿函数？" class="headerlink" title="为什么要有仿函数？"></a>为什么要有仿函数？</h4><p>从一个非常简单的问题入手，来了解为什么要有仿函数。</p>
<p>假设我们现在有一个数组，数组中存有任意数量的数字，我们希望能够统计出这个数组中大于 10 的数字的数量(按照容器、迭代器、算法分离来实现)</p>
<p>一般这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">FUNC</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">arrNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* first, <span class="hljs-keyword">int</span>* last, FUNC func)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> _count = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (first != last)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">func</span>(*first))<br>		&#123;<br>			_count++;<br>		&#125;<br>		first++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> _count;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> num &gt; <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">68</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">45</span>,<span class="hljs-number">3</span>,<span class="hljs-number">164</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">64</span> &#125;;<br>	<span class="hljs-comment">//求出数组中大于5的元素个数</span><br>	<span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr[<span class="hljs-number">0</span>]);<br>	<span class="hljs-keyword">int</span> num=<span class="hljs-built_in">arrNum</span>(arr, arr + len, isRight);<br>	cout &lt;&lt; <span class="hljs-string">&quot;共有..个：&quot;</span> &lt;&lt;num &lt;&lt; endl;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>arrNum()函数的第三个参数是一个函数指针，用于回调，而 isRight() 函数也是外部定义好的，它只接受一个参数的函数。如果此时希望将判定的阈值也作为一个变量传入，变为如下函数就不可行了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> threshold)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> num &gt; threshold;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然这个函数看起来可以，但是它不能满足已经定义好的函数指针参数的要求，因为函数指针参数的类型是bool (*)(int)，与函数arrNum()的类型不兼容。如果一定要完成这个任务，按照以往的经验，我们可以考虑如下途径：<br>（1）阈值作为函数的局部变量。局部变量不能在函数调用中传递，故不可行；<br>（2）函数传参。这种方法我们已经讨论过了，多个参数不适用于已定义好的 arrNum() 函数。<br>（3）全局变量。我们可以将阈值设置成一个全局变量。这种方法虽然可行，但是不优雅，且非常容易引入 Bug，比如全局变量容易同名，造成命名空间污染。</p>
<p>那么有什么好的处理方法呢？仿函数应运而生。</p>
<h4 id="仿函数的定义"><a href="#仿函数的定义" class="headerlink" title="仿函数的定义"></a>仿函数的定义</h4><p>仿函数（Functor）又称为函数对象（Function Object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载 operator() 运算符。因为调用仿函数，实际上就是通过类对象调用重载后的 operator() 运算符。</p>
<p>如果编程者要将某种“操作”当做算法的参数，一般有两种方法：<br>（1）一个办法就是先将该“操作”设计为一个函数，再将函数指针当做算法的一个参数。上面的实例就是该做法；<br>（2）将该“操作”设计为一个仿函数（就语言层面而言是个 class），再以该仿函数产生一个对象，并以此对象作为算法的一个参数。</p>
<p>很明显第二种方法会更优秀，因为第一种方法扩展性较差，当函数参数有所变化，则无法兼容旧的代码，具体在第一小节已经阐述。正如上面的例子，在我们写代码时有时会发现有些功能代码，会不断地被使用。</p>
<p>这时就可以使用仿函数了，写一个简单类，除了维护类的基本成员函数外，只需要重载 operator() 运算符 。这样既可以免去对一些公共变量的维护，也可以使重复使用的代码独立出来，以便下次复用。</p>
<p>STL 中也大量涉及到仿函数，有时仿函数的使用是为了函数拥有类的性质，以达到安全传递函数指针、依据函数生成对象、甚至是让函数之间有继承关系、对函数进行运算和操作的效果。比如 STL 中的容器 set 就使用了仿函数 less ，而 less 继承的 binary_function，就可以看作是对于一类函数的总体声明，这是函数做不到的。</p>
<p>所以使用仿函数之后可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isRight</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-built_in">isRight</span>(<span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>):<span class="hljs-built_in">res</span>(res) &#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> num &gt; res;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">int</span> res;<br>&#125;;<br><span class="hljs-keyword">using</span> FUNC = isRight;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">arrNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* first, <span class="hljs-keyword">int</span>* last, FUNC func)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> _count = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (first != last)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">func</span>(*first))<br>		&#123;<br>			_count++;<br>		&#125;<br>		first++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> _count;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">68</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">45</span>,<span class="hljs-number">3</span>,<span class="hljs-number">164</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">64</span> &#125;;<br>	<span class="hljs-comment">//求出数组中大于5的元素个数</span><br>	<span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr[<span class="hljs-number">0</span>]);<br>	<span class="hljs-keyword">int</span> num = <span class="hljs-built_in">arrNum</span>(arr, arr + len, <span class="hljs-built_in">isRight</span>(<span class="hljs-number">10</span>));<br>	cout &lt;&lt; <span class="hljs-string">&quot;共有..个：&quot;</span> &lt;&lt; num &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h4><p>谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果<br>operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词<br>可作为一个判断式</p>
<h4 id="函数对象适配器"><a href="#函数对象适配器" class="headerlink" title="函数对象适配器"></a>函数对象适配器</h4><p>函数对象适配器是完成一些配接工作，这些配接包括绑定(bind)，否定(negate),以及对一<br>般函数或成员函数的修饰，使其成为函数对象，重点掌握函数对象适配器(红色字体):</p>
<p><font style="color:red"> bind1st</font>        将参数绑定为函数对象的第一个参数</p>
<p><font style="color:red"> bind2nd</font>        将参数绑定为函数对象的第二个参数</p>
<p><font style="color:red"> not1</font>                对一元函数对象取反</p>
<p><font style="color:red"> not2</font>                对二元函数对象取反</p>
<p>ptr_fun            将普通函数修饰成函数对象</p>
<p>mem_fun        修饰成员函数(容器里存的是对象)</p>
<p>mem_fun_ref    修饰成员函数(容器里存的是指针)</p>
<h5 id="bind1st"><a href="#bind1st" class="headerlink" title="bind1st"></a>bind1st</h5><p>将一个二元函数转换成一个一元函数。（绑定到第一个参数）</p>
<p><code>其他同下</code></p>
<h5 id="bind2nd"><a href="#bind2nd" class="headerlink" title="bind2nd"></a>bind2nd</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Operation</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br>  <span class="hljs-function">binder2nd&lt;Operation&gt; <span class="hljs-title">bind2nd</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> Operation&amp; op, <span class="hljs-keyword">const</span> T&amp; x)</span></span>;<br></code></pre></td></tr></table></figure>

<p>将一个二元函数转换成一个一元函数。（绑定到第二个参数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTest</span> :</span><span class="hljs-keyword">public</span> binary_function&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span>&gt;<br>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> val)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; val &lt;&lt;<span class="hljs-string">&quot; = &quot;</span>&lt;&lt;i+val&lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">obj3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">CTest</span>(), <span class="hljs-number">10</span>));<br>	<span class="hljs-comment">//for_each(v.begin(), v.end(), bind1st(CTest(),10));</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="not1"><a href="#not1" class="headerlink" title="not1"></a>not1</h5><p>一元函数取反适配器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Mycmp1</span>:</span><span class="hljs-keyword">public</span> unary_function&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">bool</span>&gt;<br>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1)</span><span class="hljs-keyword">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> v1 &gt; <span class="hljs-number">5</span>;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_not1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">not1</span>(<span class="hljs-built_in">Mycmp1</span>()));<br>	<span class="hljs-keyword">if</span> (it != v.<span class="hljs-built_in">end</span>())<br>	&#123;<br>		cout &lt;&lt; *it &lt;&lt; endl;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="not2"><a href="#not2" class="headerlink" title="not2"></a>not2</h5><p>二元函数取反适配器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MCMP1</span> :</span><span class="hljs-keyword">public</span> binary_function&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> a == b;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_not2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">50</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span> &#125;;<br>	<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">adjacent_find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">not2</span>(<span class="hljs-built_in">MCMP1</span>()));<br>	cout &lt;&lt; *it &lt;&lt; endl;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v)<br>	&#123;<br>		cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="ptr-fun"><a href="#ptr-fun" class="headerlink" title="ptr_fun"></a>ptr_fun</h5><p>把普通函数转成仿函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mycmp2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> v1 &gt; <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_not1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">not1</span>(<span class="hljs-built_in">ptr_fun</span>(mycmp2)));<br>	<span class="hljs-keyword">if</span> (it != v.<span class="hljs-built_in">end</span>())<br>	&#123;<br>		cout &lt;&lt; *it &lt;&lt; endl;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="mem-fun"><a href="#mem-fun" class="headerlink" title="mem_fun"></a>mem_fun</h5><p>把类的成员函数转成仿函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> id):_age(age),_id(id)&#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;id: &quot;</span> &lt;&lt; _id &lt;&lt; <span class="hljs-string">&quot;age: &quot;</span> &lt;&lt; _age &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">int</span> _age;<br>	<span class="hljs-keyword">int</span> _id;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_cref</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Person p1(1, 2), p2(3, 4), p3(5, 6);<br>	vector&lt; Person*&gt; v = &#123; &amp;p1,&amp;p2,&amp;p3 &#125;;<br>	for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fun</span>(&amp;Person::show));<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="mem-fun-ref"><a href="#mem-fun-ref" class="headerlink" title="mem_fun_ref"></a>mem_fun_ref</h5><p>同上，把类的成员函数转成仿函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> id):_age(age),_id(id)&#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;id: &quot;</span> &lt;&lt; _id &lt;&lt; <span class="hljs-string">&quot;age: &quot;</span> &lt;&lt; _age &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">int</span> _age;<br>	<span class="hljs-keyword">int</span> _id;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_cref</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Person p1(1, 2), p2(3, 4), p3(5, 6);<br>	vector&lt; Person&gt; v = &#123; p1,p2,p3 &#125;;<br>	for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fun_ref</span>(&amp;Person::show));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>mem_fun和mem_fun_ref的区别在哪？</p>
<p>当存的是<font style="color:red;">对象</font>时使用mem_fun_ref</p>
<p>存放的是<font style="color:red;">对象的指针</font>时使用mem_fun</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/STL/">STL</a></div><div class="post_share"><div class="social-share" data-image="/../../images/STL8.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/25/E_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL/STL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"><img class="prev-cover" src="/img/emotional.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">STL常用函数</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/25/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"><img class="next-cover" src="https://img.shields.io/badge/-创建型模式-blueciolet" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式之创建型模式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/11/22/E_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL/STL%E4%B9%8Bunorder_map/" title="unorder_map容器必知必会攻略🐘"><img class="cover" src="/../../images/STL2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-22</div><div class="title">unorder_map容器必知必会攻略🐘</div></div></a></div><div><a href="/2020/11/10/E_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL/STL%E4%B9%8Bdeque%E5%AE%B9%E5%99%A8/" title="deque容器必知必会攻略🐋"><img class="cover" src="/../../images/STL1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-10</div><div class="title">deque容器必知必会攻略🐋</div></div></a></div><div><a href="/2020/11/03/E_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL/STL%E4%B9%8Bmap/" title="unorder_map容器必知必会攻略🐘"><img class="cover" src="/../../images/STL2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-03</div><div class="title">unorder_map容器必知必会攻略🐘</div></div></a></div><div><a href="/2020/10/28/E_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL/STL%E4%B9%8Bset/" title="set容器必知必会攻略🐢"><img class="cover" src="/../../images/STL3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-28</div><div class="title">set容器必知必会攻略🐢</div></div></a></div><div><a href="/2020/10/19/E_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++/C++_Primer_Plus/%E9%99%84%E5%BD%95G%20%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/STL%E5%92%8CC++11/" title="STL和C++11"><img class="cover" src="/img/emotional.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">STL和C++11</div></div></a></div><div><a href="/2020/09/25/E_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/STL/STL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" title="STL常用函数"><img class="cover" src="/img/emotional.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">STL常用函数</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/../../../images/Logo_stop.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ming</div><div class="author-info__description">信仰就是力量<br><a class="subtitlehref" target="_blank" rel="noopener" href="https://yesido.icu/">yesido.icu</a></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">182</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">95</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">55</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/fole-del"><i class="fab fa-github"></i><span>一些小Demo~</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:191099862@qq.com" target="_blank" title="Email"><i class="iconfont icon-Email"></i></a><a class="social-icon" href="https://tva3.sinaimg.cn/large/0072YHp3ly1gjtbxnamacj30e80e8dgx.jpg" target="_blank" title="weixin"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=191099862&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="iconfont icon-QQ1"></i></a><a class="social-icon" href="https://blog.csdn.net/Fuel_Ming?spm=1001.2014.3001.5113" target="_blank" title="CSDN"><i class="iconfont icon-csdn"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content"><div id="balls"><div>固执无<span style="background:white;border-radius:25px;color:black">罪</span>❗❗❗</div><div class="snake-spinner"><span></span><span></span><span></span><span></span><span></span></div><div><span style="background:white;border-radius:25px;color:black">梦</span>想有价🌈🌈🌈</div></div><div class="twopeople"><div class="twopeople"><div class="container"style="height:200px;"><canvas class="illo"width="800"height="800"style="max-width:200px; max-height:200px; touch-action:none; width:640px; height:640px;"></canvas></div><script src="https://cdn.guole.fun/js/twopeople1.js"></script><script src="https://cdn.guole.fun/js/zdog.dist.js"></script><script id="rendered-js"src="https://cdn.guole.fun/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">STL基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E4%BA%86%E8%BF%99%E4%B9%88%E5%A4%9A%EF%BC%8C%E4%BD%BF%E7%94%A8STL%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">说了这么多，使用STL有什么好处呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%AE%97%E6%B3%95%E5%88%86%E7%A6%BB%E6%A1%88%E4%BE%8B"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">容器、迭代器、算法分离案例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string%E5%AE%B9%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">string容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E6%A6%82%E5%BF%B5"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">string概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">string的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%9A%84%E5%AD%98%E5%8F%96%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">string的存取字符操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8Astring%E6%8B%B7%E8%B4%9D%E5%88%B0char-%E6%8C%87%E5%90%91%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">把string拷贝到char*指向的内存空间的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">2.0.0.5.</span> <span class="toc-text">string的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.0.0.6.</span> <span class="toc-text">string的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.0.0.7.</span> <span class="toc-text">string字符串连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E6%AF%94%E8%BE%83"><span class="toc-number">2.0.0.8.</span> <span class="toc-text">string比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="toc-number">2.0.0.9.</span> <span class="toc-text">string的子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">2.0.0.10.</span> <span class="toc-text">string的查找和替换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">2.0.0.10.1.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2"><span class="toc-number">2.0.0.10.2.</span> <span class="toc-text">替换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%9A%84%E5%8C%BA%E9%97%B4%E5%88%A0%E9%99%A4%E5%92%8C%E6%8F%92%E5%85%A5"><span class="toc-number">2.0.0.11.</span> <span class="toc-text">String的区间删除和插入</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vector%E5%AE%B9%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">vector容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">Vector容器简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">vector的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">3.0.0.3.</span> <span class="toc-text">vector的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.0.0.4.</span> <span class="toc-text">vector的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E6%9C%AB%E5%B0%BE%E7%9A%84%E6%B7%BB%E5%8A%A0%E7%A7%BB%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.0.5.</span> <span class="toc-text">vector末尾的添加移除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">3.0.0.6.</span> <span class="toc-text">vector的数据存取</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#deque%E5%AE%B9%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">deque容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Deque%E7%AE%80%E4%BB%8B"><span class="toc-number">4.0.0.1.</span> <span class="toc-text">Deque简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">4.0.0.2.</span> <span class="toc-text">deque对象的默认构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%A6%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0"><span class="toc-number">4.0.0.3.</span> <span class="toc-text">deque对象的带参数构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E6%9C%AB%E5%B0%BE%E7%9A%84%E6%B7%BB%E5%8A%A0%E7%A7%BB%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">4.0.0.4.</span> <span class="toc-text">deque末尾的添加移除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">4.0.0.5.</span> <span class="toc-text">deque的数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">4.0.0.6.</span> <span class="toc-text">deque的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.0.0.7.</span> <span class="toc-text">deque的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">4.0.0.8.</span> <span class="toc-text">deque的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">4.0.0.9.</span> <span class="toc-text">deque的删除</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">迭代器基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="toc-number">5.0.0.1.</span> <span class="toc-text">迭代器的类别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">5.0.0.2.</span> <span class="toc-text">迭代器的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.0.0.3.</span> <span class="toc-text">迭代器实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initializer-list%E8%81%9A%E5%90%88%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.0.0.4.</span> <span class="toc-text">initializer_list聚合初始化</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#list%E5%AE%B9%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">list容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%AE%80%E4%BB%8B"><span class="toc-number">6.0.0.1.</span> <span class="toc-text">list简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">6.0.0.2.</span> <span class="toc-text">list对象的默认构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%A4%B4%E5%B0%BE%E7%9A%84%E6%B7%BB%E5%8A%A0%E7%A7%BB%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">6.0.0.3.</span> <span class="toc-text">list头尾的添加移除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">6.0.0.4.</span> <span class="toc-text">list的数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">6.0.0.5.</span> <span class="toc-text">list与迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%A6%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0"><span class="toc-number">6.0.0.6.</span> <span class="toc-text">list对象的带参数构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">6.0.0.7.</span> <span class="toc-text">list的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">6.0.0.8.</span> <span class="toc-text">list的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">6.0.0.9.</span> <span class="toc-text">list的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">6.0.0.10.</span> <span class="toc-text">list的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E5%8F%8D%E5%BA%8F%E6%8E%92%E5%88%97"><span class="toc-number">6.0.0.11.</span> <span class="toc-text">list的反序排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.0.0.12.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stack%E5%AE%B9%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">stack容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">7.0.0.1.</span> <span class="toc-text">stack对象的默认构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">7.0.0.2.</span> <span class="toc-text">stack元素获取与删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">7.0.0.3.</span> <span class="toc-text">stack对象的拷贝构造与赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">7.0.0.4.</span> <span class="toc-text">stack的大小</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Queue%E5%AE%B9%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">Queue容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue%E7%AE%80%E4%BB%8B"><span class="toc-number">8.0.0.1.</span> <span class="toc-text">Queue简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">8.0.0.2.</span> <span class="toc-text">queue对象的默认构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-number">8.0.0.3.</span> <span class="toc-text">queue的数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">8.0.0.4.</span> <span class="toc-text">queue对象的拷贝构造与赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">8.0.0.5.</span> <span class="toc-text">queue的大小</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#set-multiset%E5%AE%B9%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">set&#x2F;multiset容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">9.0.0.1.</span> <span class="toc-text">set&#x2F;multiset的简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">9.0.0.2.</span> <span class="toc-text">set&#x2F;multiset对象的默认构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">9.0.0.3.</span> <span class="toc-text">set的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88%E7%9A%84%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F"><span class="toc-number">9.0.0.4.</span> <span class="toc-text">Set集合的元素排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1functor%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">9.0.0.5.</span> <span class="toc-text">函数对象functor的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E7%BB%83%E4%B9%A0"><span class="toc-number">9.0.0.5.1.</span> <span class="toc-text">仿函数练习</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">9.0.0.6.</span> <span class="toc-text">set对象的拷贝构造与赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">9.0.0.7.</span> <span class="toc-text">set的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">9.0.0.8.</span> <span class="toc-text">set的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">9.0.0.9.</span> <span class="toc-text">set的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pair"><span class="toc-number">9.0.0.9.1.</span> <span class="toc-text">pair</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pair%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.0.0.10.</span> <span class="toc-text">pair的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">9.0.0.11.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#map-multimap%E5%AE%B9%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">map\multimap容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map-multimap%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">10.0.0.1.</span> <span class="toc-text">map&#x2F;multimap的简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-multimap%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="toc-number">10.0.0.2.</span> <span class="toc-text">map&#x2F;multimap对象的默认构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.0.0.3.</span> <span class="toc-text">map的插入与迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1functor%E7%9A%84%E7%94%A8%E6%B3%95-1"><span class="toc-number">10.0.0.4.</span> <span class="toc-text">函数对象functor的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">10.0.0.5.</span> <span class="toc-text">map对象的拷贝构造与赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">10.0.0.6.</span> <span class="toc-text">map的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">10.0.0.7.</span> <span class="toc-text">map的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">10.0.0.8.</span> <span class="toc-text">map的查找</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E5%AE%B9%E5%99%A8%E5%85%B1%E6%80%A7%E6%9C%BA%E5%88%B6"><span class="toc-number">11.</span> <span class="toc-text">STL容器共性机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">11.0.0.1.</span> <span class="toc-text">各容器使用场景</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E7%AE%97%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">STL算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0"><span class="toc-number">12.0.0.1.</span> <span class="toc-text">sort()排序函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transform-%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">12.0.0.2.</span> <span class="toc-text">transform()转换函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0"><span class="toc-number">12.0.0.3.</span> <span class="toc-text">find()查找函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-if-%E6%9F%A5%E6%89%BE"><span class="toc-number">12.0.0.4.</span> <span class="toc-text">find_if()查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#adjacent-find"><span class="toc-number">12.0.0.5.</span> <span class="toc-text">adjacent_find()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count-%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0"><span class="toc-number">12.0.0.6.</span> <span class="toc-text">count()统计函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-each%E5%87%BD%E6%95%B0"><span class="toc-number">12.0.0.7.</span> <span class="toc-text">for_each函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-%E5%87%BD%E6%95%B0"><span class="toc-number">12.0.0.8.</span> <span class="toc-text">copy()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%AE%97%E6%B3%95"><span class="toc-number">12.0.0.9.</span> <span class="toc-text">更多算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">仿函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">13.0.0.1.</span> <span class="toc-text">为什么要有仿函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">13.0.0.2.</span> <span class="toc-text">仿函数的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%93%E8%AF%8D"><span class="toc-number">13.0.0.3.</span> <span class="toc-text">谓词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">13.0.0.4.</span> <span class="toc-text">函数对象适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#bind1st"><span class="toc-number">13.0.0.4.1.</span> <span class="toc-text">bind1st</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bind2nd"><span class="toc-number">13.0.0.4.2.</span> <span class="toc-text">bind2nd</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#not1"><span class="toc-number">13.0.0.4.3.</span> <span class="toc-text">not1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#not2"><span class="toc-number">13.0.0.4.4.</span> <span class="toc-text">not2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ptr-fun"><span class="toc-number">13.0.0.4.5.</span> <span class="toc-text">ptr_fun</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mem-fun"><span class="toc-number">13.0.0.4.6.</span> <span class="toc-text">mem_fun</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mem-fun-ref"><span class="toc-number">13.0.0.4.7.</span> <span class="toc-text">mem_fun_ref</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/03/09/F_%E6%9D%82%E8%AE%B0/Git%E6%9C%80%E5%85%A8%E6%89%8B%E5%86%8C/" title="git命令手册💪_从新建项目开始"><img src="/../../../images/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AEhooks/git.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git命令手册💪_从新建项目开始"/></a><div class="content"><a class="title" href="/2021/03/09/F_%E6%9D%82%E8%AE%B0/Git%E6%9C%80%E5%85%A8%E6%89%8B%E5%86%8C/" title="git命令手册💪_从新建项目开始">git命令手册💪_从新建项目开始</a><time datetime="2021-11-01T04:17:08.916Z" title="更新于 2021-11-01 12:17:08">2021-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/18/%E8%87%AA%E8%BF%B0/" title="明明是我"><img src="/../images/%E8%87%AA%E8%BF%B0/%E6%83%85%E6%84%9F8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="明明是我"/></a><div class="content"><a class="title" href="/2021/03/18/%E8%87%AA%E8%BF%B0/" title="明明是我">明明是我</a><time datetime="2021-11-01T04:13:04.743Z" title="更新于 2021-11-01 12:13:04">2021-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/25/F_%E6%9D%82%E8%AE%B0/Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/" title="Windows平台下的内存泄露检测"><img src="/../../images/Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/AAAAA_01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows平台下的内存泄露检测"/></a><div class="content"><a class="title" href="/2020/11/25/F_%E6%9D%82%E8%AE%B0/Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/" title="Windows平台下的内存泄露检测">Windows平台下的内存泄露检测</a><time datetime="2021-10-30T12:58:05.861Z" title="更新于 2021-10-30 20:58:05">2021-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/13/F_%E6%9D%82%E8%AE%B0/%E5%88%86%E4%BA%AB/%E6%8E%A8%E8%8D%90%E4%B8%80%E9%83%A8%E5%89%A7/%E3%80%8A%E6%88%91%E7%9A%84%E5%9B%A2%E9%95%BF%E6%88%91%E7%9A%84%E5%9B%A2%E3%80%8B/" title="《我的团长我的团》"><img src="https://gitee.com/fole-del/img/raw/master/20210613210525.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《我的团长我的团》"/></a><div class="content"><a class="title" href="/2021/06/13/F_%E6%9D%82%E8%AE%B0/%E5%88%86%E4%BA%AB/%E6%8E%A8%E8%8D%90%E4%B8%80%E9%83%A8%E5%89%A7/%E3%80%8A%E6%88%91%E7%9A%84%E5%9B%A2%E9%95%BF%E6%88%91%E7%9A%84%E5%9B%A2%E3%80%8B/" title="《我的团长我的团》">《我的团长我的团》</a><time datetime="2021-10-30T07:11:01.856Z" title="更新于 2021-10-30 15:11:01">2021-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/25/C_%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%8A%9F%E8%83%BD/" title="计算机网络协议"><img src="/../../../images/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%8A%9F%E8%83%BD/%E5%AF%B9%E5%BA%94%E5%8D%8F%E8%AE%AE.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络协议"/></a><div class="content"><a class="title" href="/2020/11/25/C_%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%8A%9F%E8%83%BD/" title="计算机网络协议">计算机网络协议</a><time datetime="2021-10-28T09:06:30.656Z" title="更新于 2021-10-28 17:06:30">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/10/F_%E6%9D%82%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AEhooks/" title="自动化部署项目hook"><img src="/../../../images/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AEhooks/git.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自动化部署项目hook"/></a><div class="content"><a class="title" href="/2021/03/10/F_%E6%9D%82%E8%AE%B0/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AEhooks/" title="自动化部署项目hook">自动化部署项目hook</a><time datetime="2021-10-28T09:06:23.201Z" title="更新于 2021-10-28 17:06:23">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/19/F_%E6%9D%82%E8%AE%B0/%E6%89%80%E8%A7%81%E5%8D%B3%E6%89%80%E5%BE%97/" title="Markdown用法"><img src="/../images/markdown.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Markdown用法"/></a><div class="content"><a class="title" href="/2020/10/19/F_%E6%9D%82%E8%AE%B0/%E6%89%80%E8%A7%81%E5%8D%B3%E6%89%80%E5%BE%97/" title="Markdown用法">Markdown用法</a><time datetime="2021-10-28T09:06:19.068Z" title="更新于 2021-10-28 17:06:19">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/02/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之行为型模式"><img src="/img/emotional.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式之行为型模式"/></a><div class="content"><a class="title" href="/2020/10/02/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之行为型模式">设计模式之行为型模式</a><time datetime="2021-10-28T08:20:16.887Z" title="更新于 2021-10-28 16:20:16">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/01/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之结构型模式"><img src="/img/emotional.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式之结构型模式"/></a><div class="content"><a class="title" href="/2020/10/01/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之结构型模式">设计模式之结构型模式</a><time datetime="2021-10-28T08:20:03.273Z" title="更新于 2021-10-28 16:20:03">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/25/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之创建型模式"><img src="https://img.shields.io/badge/-创建型模式-blueciolet" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式之创建型模式"/></a><div class="content"><a class="title" href="/2020/09/25/A_%E7%A8%8B%E5%BA%8F%E5%91%98%E5%86%85%E5%8A%9F/B_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="设计模式之创建型模式">设计模式之创建型模式</a><time datetime="2021-10-28T08:19:50.468Z" title="更新于 2021-10-28 16:19:50">2021-10-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Ming</div><div class="footer_custom_text"><div id="mouseMove">&nbsp;</div><i class="fas faa-bounce animated-hover">勇敢就是接受发生在你身上的事，并把它尽力做到最好！</i><br> Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="animation:bgbreath 4s infinite;">Hexo</a> | 主题 <a target="_blank" rel="noopener" href="https://butterfly.js.org/" style="animation:bgbreath 4s infinite;">butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'dark',
      })
      false && mermaid.init()
    })
  }
}</script></div><canvas id="universe"></canvas><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11"></script><script src="https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@3.0.8/js/instantclick-1.2.2.js" type="module"></script><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script><script src="https://myhkw.cn/player/js/player.js" id="myhk" key="160318399252" m="0"></script><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/zdoj.js"></script><script src="/js/twoPeople.js"></script><script src="/js/twoPeople1.js"></script><script src="/js/qipao.js"></script><script src="/js/universe.js"></script><script src="/js/mouseMove.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/03/18/自述/" alt=""><img width="48" height="48" src="../images/自述/情感8.jpg" alt="" onerror="this.src=https://cdn.jsdelivr.net/npm/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-03-18</span><a class="blog-slider__title" href="2021/03/18/自述/" alt="">明明是我</a><div class="blog-slider__text">不起眼分母</div><a class="blog-slider__button" href="2021/03/18/自述/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/03/09/F_杂记/Git最全手册/" alt=""><img width="48" height="48" src="../../../images/自动化部署项目hooks/git.jpg" alt="" onerror="this.src=https://cdn.jsdelivr.net/npm/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-03-09</span><a class="blog-slider__title" href="2021/03/09/F_杂记/Git最全手册/" alt="">git命令手册💪_从新建项目开始</a><div class="blog-slider__text">git_新建项目并提交远程仓库|以及git强化命令手册</div><a class="blog-slider__button" href="2021/03/09/F_杂记/Git最全手册/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2020/11/25/C_面试/计算机网络/五层协议及功能/" alt=""><img width="48" height="48" src="../../../images/五层协议及功能/对应协议.png" alt="" onerror="this.src=https://cdn.jsdelivr.net/npm/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2020-11-25</span><a class="blog-slider__title" href="2020/11/25/C_面试/计算机网络/五层协议及功能/" alt="">计算机网络协议</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2020/11/25/C_面试/计算机网络/五层协议及功能/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2020/11/25/F_杂记/Windows平台下的内存泄露检测/" alt=""><img width="48" height="48" src="../../images/Windows平台下的内存泄露检测/AAAAA_01.jpg" alt="" onerror="this.src=https://cdn.jsdelivr.net/npm/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2020-11-25</span><a class="blog-slider__title" href="2020/11/25/F_杂记/Windows平台下的内存泄露检测/" alt="">Windows平台下的内存泄露检测</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2020/11/25/F_杂记/Windows平台下的内存泄露检测/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/03/10/F_杂记/自动化部署项目hooks/" alt=""><img width="48" height="48" src="../../../images/自动化部署项目hooks/git.jpg" alt="" onerror="this.src=https://cdn.jsdelivr.net/npm/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-03-10</span><a class="blog-slider__title" href="2021/03/10/F_杂记/自动化部署项目hooks/" alt="">自动化部署项目hook</a><div class="blog-slider__text">如何“自动化”部署git hook（C++项目）</div><a class="blog-slider__button" href="2021/03/10/F_杂记/自动化部署项目hooks/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2020/10/19/F_杂记/所见即所得/" alt=""><img width="48" height="48" src="../images/markdown.jpg" alt="" onerror="this.src=https://cdn.jsdelivr.net/npm/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2020-10-19</span><a class="blog-slider__title" href="2020/10/19/F_杂记/所见即所得/" alt="">Markdown用法</a><div class="blog-slider__text">所见即所得，总结的一些MarkDown常用方法</div><a class="blog-slider__button" href="2020/10/19/F_杂记/所见即所得/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>