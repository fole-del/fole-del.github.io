<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式</title>
    <url>/posts/364ea8cc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="除了“设计模式”，你还应该知道什么"><a href="#除了“设计模式”，你还应该知道什么" class="headerlink" title="除了“设计模式”，你还应该知道什么"></a>除了“设计模式”，你还应该知道什么</h1><p>程序员内功之设计模式🔥</p>
<blockquote>
<p>推荐学习视频<a href="https://www.bilibili.com/video/BV1W7411M7vB">C++常用设计模式</a></p>
</blockquote>
<span id="more"></span>

<h1 id="设计模式从何而来"><a href="#设计模式从何而来" class="headerlink" title="设计模式从何而来"></a>设计模式从何而来</h1><p>四人组（Gang of Four)，简称<mark style="color:green;font-size:30px;">GoF</mark>.</p>
<p>GoF将模式的概念引入软件工程领域，这标志着<mark>软件模式</mark>的诞生。软件模式（Software Pattern是）是将模式的一半概念应用于软件开发领域，即<b>软件开发的总体指导思路或参照样板</b>.</p>
<p>需要了解软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等。</p>
<blockquote>
<p>“软件设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可充用代码，让代码更容易被他人理解并且保证代码可靠性。”</p>
<div style="text-align:right;font-weight:900;font-size:20px;">——软件设计模式的定义</div>
</blockquote>
<p>一句大白话就是：“<mark>在一定环境下，用固定套路解决问题</mark>”。</p>
<h1 id="软件设计模式的种类"><a href="#软件设计模式的种类" class="headerlink" title="软件设计模式的种类"></a>软件设计模式的种类</h1><p><strong>GoF提出的设计模式有23个，包括：</strong></p>
<ul>
<li><p><a href="./%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><mark><a href="/posts/3dfd8b5b.html" title="设计模式之创建型模式">设计模式之创建型模式</a></mark></a>(Creational)：如何创建对象; </p>
<div class="note blue no-icon simple"><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p>
<ol>
<li><p>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p>
</li>
<li><p>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p>
</li>
<li><p>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</p>
</li>
<li><p>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p>
</li>
<li><p>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p>
</li>
</ol>
</div></li>
</ul>
<ul>
<li><p><a href="%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F.md"><mark><a href="/posts/eea0cb26.html" title="设计模式之结构型模式">设计模式之结构型模式</a></mark></a>(Structional)：如何实现类或对象的组合；</p>
<div class="note green no-icon simple"><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>，前者采用<strong>继承机制</strong>来组织接口和类，后者釆用<strong>组合或聚合</strong>来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ol>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ol>
</div></li>
<li><p><a href="./%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.md"><mark><a href="/posts/69f2f423.html" title="设计模式之行为型模式">设计模式之行为型模式</a></mark></a>(Behavioral)：类或对象怎样交互以及怎么分配职责。</p>
<div class="note pink no-icon simple"><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式是 GoF <a href="http://c.biancheng.net/design_pattern/">设计模式</a>中最为庞大的一类，它包含以下 11 种模式。</p>
<ol>
<li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>
<p>以上 11 种行为型模式，除了模板方法模式和<a href="http://c.biancheng.net/view/1402.html">解释器模式</a>是类行为型模式，其他的全部属于对象行为型模式。</p>
</div></li>
</ul>
<p>设计模式目前的种类：GoF的23种 +“简答工厂模式” = <mark>24</mark>种 </p>
<h1 id="软件设计模式有什么用？"><a href="#软件设计模式有什么用？" class="headerlink" title="软件设计模式有什么用？"></a>软件设计模式有什么用？</h1><p><mark>有助于更加深入地理解面向对象思想</mark>，让你知道：</p>
<pre><code>1. 如何将代码分散在几个不同的类中
2. 为什么要有“接口”
3. 何为针对抽象编程
4. 合适不应该使用继承
5. 如何不修改源代码增加新功能
6. 更好地阅读和理解现有类库与其他系统中的源代码
</code></pre>
<h1 id="如何学好设计模式"><a href="#如何学好设计模式" class="headerlink" title="如何学好设计模式"></a>如何学好设计模式</h1><p>设计模式的基础是：<mark style="font-size:18px">多态</mark>，参考书上给的建议就是：</p>
<p>初学者：积累案例，不要盲目的背类图（我就是）</p>
<p>初级开发人员：多思考，多梳理，归纳总结，尊重事物的认知规律，注意临界点的突破，不要浮躁。</p>
<p>中级开发人员：合适的开发环境，寻找合适的设计模式来解决问题。多应用，对经典的组合设计模式，大量自由的运用，要不断地追求。</p>
<h1 id="关于语言"><a href="#关于语言" class="headerlink" title="关于语言"></a>关于语言</h1><p>语言是基础，学习设计模式之前一定要对自己现在使用和运用的语言加以了解；熟悉、掌握多态。</p>
<p>C++学习者建议可以读一遍《c++ Primer Plus》，尤其是面向对象部分</p>
<h1 id="设计模式总览"><a href="#设计模式总览" class="headerlink" title="设计模式总览"></a>设计模式总览</h1><h2 id="创建型模式（Creational）"><a href="#创建型模式（Creational）" class="headerlink" title="创建型模式（Creational）"></a>创建型模式（Creational）</h2><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gjvts4pq4ij30k207ljs6.jpg" alt="创建型模式" width="722" data-width="722" data-height="273">

<h2 id="结构型模式-Structural"><a href="#结构型模式-Structural" class="headerlink" title="结构型模式(Structural)"></a>结构型模式(Structural)</h2><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjvtri85hgj31430gttfr.jpg" alt="结构型模式" width="722" data-width="1443" data-height="605">

<h2 id="行为型模式（Behavioral）"><a href="#行为型模式（Behavioral）" class="headerlink" title="行为型模式（Behavioral）"></a>行为型模式（Behavioral）</h2><img src="https://cdn.jsdelivr.net/gh/pic-cdn/cdn2@782567680f7acccab170d2fe9b08cfa2726c7a22/2020/10/10/388b31a1de6af885d18daa816f9342f5.png" width="722px" height="auto" alt="行为型模式">



<h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单一职责原则<br>（Single Responsibility Principle,SRP)<br>⭐️⭐️⭐️⭐️</td>
<td align="center">类的职责单一，对外只提供一种可能，而引起类变化的原因都应该只有一个。</td>
</tr>
<tr>
<td align="center">开闭原则<br>（Open-Closed Principle,OCP)<br>⭐️⭐️⭐️⭐️⭐️</td>
<td align="center"><strong>类的改动是通过增加代码进行的，而不是修改源代码</strong></td>
</tr>
<tr>
<td align="center">里氏代换原则<br>(Liskov Substitution Principle,LSP)<br>⭐️⭐️⭐️⭐️⭐️</td>
<td align="center">任何抽象类出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。</td>
</tr>
<tr>
<td align="center">依赖倒转原则<br>（Dependence Inversion Priciple,DIP)<br>⭐️⭐️⭐️⭐️⭐️</td>
<td align="center"><font color="red">依赖于抽象（接口），不要依赖具体的实现（类），也就是针对接口编程。</font></td>
</tr>
<tr>
<td align="center">接口隔离原则<br>（Interface Segregation Principle,ISP)<br>⭐️⭐️</td>
<td align="center"><strong>不应该强迫用户的程序依赖他们不需要的接口方法。一个接口只提供一种对外功能，不应该把所有操作都封装到一个接口中去。</strong></td>
</tr>
<tr>
<td align="center">合成复用原则<br>（Composite Reuse Principle，CRP)<br>⭐️⭐️⭐️⭐️</td>
<td align="center">如果使用继承，会导致父类的任何变化都可能影响到子类的行为，如果使用对象组合，就降低了这种依赖关系，对于继承和类，优先使用该组合。</td>
</tr>
<tr>
<td align="center">迪米特法则<br>（Law of Demeter,LoD)<br>⭐️⭐️⭐️</td>
<td align="center">一个对象应当对其他对象尽可能少的了解,从而降低各个对象之间的耦合,提高系统的可维护性。例如在一个程序中,各个模块之间相互调用时,通常会提供- -个统- -的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节, 这样当一个模块内部的实现发生改变时,不会影响其他模块的使用。( 黑盒原理)</td>
</tr>
</tbody></table>
<blockquote>
<p>借鉴了《Easy搞定设计模式》</p>
</blockquote>
]]></content>
      <categories>
        <category>程序员内功</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣高效算法入门</title>
    <url>/posts/8cb5320c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>  <strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code> 的算法吗？</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i,x := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br>            <span class="hljs-keyword">if</span> x+nums[j] == target &#123;<br>                <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;i,j&#125; <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h1><p>给定一个已按照**非递减顺序排列 ** 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p>
<p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值_。_<code>numbers</code> 的下标 <strong>从 1 开始计数</strong> ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code> 。</p>
<p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：numbers &#x3D; [2,3,4], target &#x3D; 6<br>输出：[1,3]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：numbers &#x3D; [-1,0], target &#x3D; -1<br>输出：[1,2]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= numbers.length &lt;= 3 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
<li>  <code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li>
<li>  <code>-1000 &lt;= target &lt;= 1000</code></li>
<li>  <strong>仅存在一个有效答案</strong></li>
</ul>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>#双指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(numbers []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    left,right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        sum := numbers[left] + numbers [right]<br>        <span class="hljs-keyword">if</span> sum == target &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &lt; target &#123;<br>            left++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h1><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 _a，b，c ，_使得 <em>a + b + c =</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; []<br>输出：[]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [0]<br>输出：[]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= nums.length &lt;= 3000</code></li>
<li>  <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>#三指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">class Solution &#123;<br>public:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; threeSum(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 先排序</span><br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        sort(nums.begin(), nums.end());<br><br>        <span class="hljs-comment">// 定义首指针==target</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> ( i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <br>                <span class="hljs-keyword">continue</span>;<br>            <br>            <span class="hljs-keyword">int</span> k = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 内层首指针</span><br>            <span class="hljs-keyword">int</span> target = -nums[i];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) <span class="hljs-comment">// 内层尾指针</span><br>            &#123; <br>                <span class="hljs-keyword">if</span>( j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>]) <br>                    <span class="hljs-keyword">continue</span>;<br><br>                while (j &lt; k &amp;&amp; nums[j] + nums[k] &gt; target) &#123; <span class="hljs-comment">// 遍历尾指针，找合适序列</span><br>                    --k;<br>                &#125;<br><br>                <span class="hljs-comment">// 当前i不满足</span><br>                <span class="hljs-keyword">if</span>(j == k) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 得到符合条件序列</span><br>                <span class="hljs-keyword">if</span>(nums[j] + nums[k] == target) &#123;<br>                    ans.push_back(&#123;nums[i],nums[j],nums[k]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h1><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li>  <code>0 &lt;= a, b, c, d &lt; n</code></li>
<li>  <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li>  <code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">class Solution &#123;<br>public:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; fourSum(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        sort(nums.begin(), nums.end());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> ((long) nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((long) nums[i] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>])<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((long) nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> ((long) nums[i] + nums[j] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 最内层首尾指针</span><br>                <span class="hljs-keyword">int</span> m = n - <span class="hljs-number">1</span>, k = j + <span class="hljs-number">1</span>;<br>                while(k &lt; m) &#123;<br>                    <span class="hljs-keyword">int</span> sum = nums[i] + nums[j] + nums[k] + nums[m];<br>                    <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                        ans.push_back(&#123;nums[i], nums[j], nums[k], nums[m]&#125;);<br>                        while (k &lt; m &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]) &#123;<br>                            k++;<br>                        &#125;<br>                        k++;<br>                        while (k &lt; m &amp;&amp; nums[m] == nums[m - <span class="hljs-number">1</span>]) &#123;<br>                            m--;<br>                        &#125;<br>                        m--;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                        k++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        m--;<br>                    &#125;<br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h1><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">F(0) &#x3D; 0，F(1) &#x3D; 1<br>F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1<br></code></pre></td></tr></table></figure>

<p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：2<br>输出：1<br>解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：3<br>输出：2<br>解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：4<br>输出：3<br>解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= n &lt;= 30</code></li>
</ul>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-2</span>) + fib(n<span class="hljs-number">-1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1\.  1 阶 + 1 阶<br>2\.  2 阶<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1\.  1 阶 + 1 阶 + 1 阶<br>2\.  1 阶 + 2 阶<br>3\.  2 阶 + 1 阶<br></code></pre></td></tr></table></figure>


<h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    pre1,pre2 := <span class="hljs-number">2</span>,<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>        cur := pre1 + pre2<br>        pre2 = pre1<br>        pre1 = cur<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre1<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1]<br>输出：1<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [5,4,-1,7,8]<br>输出：23<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h2 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    sum := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] + nums[i<span class="hljs-number">-1</span>] &gt; nums[i] &#123;<br>            nums[i] += nums[i<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-keyword">if</span>  nums[i] &gt; sum &#123;<br>            sum = nums[i]<br>        &#125;<br>    &#125;  <br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h1><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>
<li>  <code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h2 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划 #背包问题 #difficult</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    sum, maxNum := <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _,num := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += num<br>        <span class="hljs-keyword">if</span> num &gt; maxNum &#123;<br>            maxNum = num<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断总和是不是奇数</span><br>    <span class="hljs-keyword">if</span> sum%<span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    target := sum / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> target &lt; maxNum &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, target+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        v := nums[i]<br>        <span class="hljs-keyword">for</span> j := target; j &gt;= v; j-- &#123;<br>            dp[j] = dp[j] || dp[j-v]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target]<br><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h1><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3 <br>解释：11 &#x3D; 5 + 5 + 1<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1], amount &#x3D; 1<br>输出：1<br></code></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1], amount &#x3D; 2<br>输出：2<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= coins.length &lt;= 12</code></li>
<li>  <code>1 &lt;= coins[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li>
<li>  <code>0 &lt;= amount &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-keyword">int</span>, amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, amount + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 初始化为math.MaxInt32</span><br>	<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= amount; j++ &#123;<br>		dp[j] = math.MaxInt32<br>	&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(coins); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := coins[i]; j &lt;= amount ; j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[j-coins[i]] != math.MaxInt32 &#123;<br>                dp[j] = min(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 没找到能装满背包的, 就返回-1</span><br>	<span class="hljs-keyword">if</span> dp[amount] == math.MaxInt32 &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[amount]<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li> 左括号必须用相同类型的右括号闭合。</li>
<li> 左括号必须以正确的顺序闭合。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;(]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;([)]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;&#123;[]&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<h2 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h2><p>#栈</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">byte</span> &#123;<br>        <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-string">&#x27;(&#x27;</span>,<br>        <span class="hljs-string">&#x27;]&#x27;</span>:<span class="hljs-string">&#x27;[&#x27;</span>,<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>:<span class="hljs-string">&#x27;&#123;&#x27;</span>,<br>    &#125;<br><br>    stack := []<span class="hljs-keyword">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> pairs[s[i]] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != pairs[s[i]] &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack,s[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="20-有效的括号-1"><a href="#20-有效的括号-1" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li> 左括号必须用相同类型的右括号闭合。</li>
<li> 左括号必须以正确的顺序闭合。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;(]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;([)]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;&#123;[]&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<h2 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h2><p>#栈</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">byte</span> &#123;<br>        <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-string">&#x27;(&#x27;</span>,<br>        <span class="hljs-string">&#x27;]&#x27;</span>:<span class="hljs-string">&#x27;[&#x27;</span>,<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>:<span class="hljs-string">&#x27;&#123;&#x27;</span>,<br>    &#125;<br><br>    stack := []<span class="hljs-keyword">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> pairs[s[i]] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != pairs[s[i]] &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack,s[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h1><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code>大的元素。</p>
<p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>
<p>返回一个长度为 <code>nums1.length</code> 的数组<code>ans</code>作为答案，满足<code>ans[i]</code>是如上所述的 <strong>下一个更大元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].<br>输出：[-1,3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：<br>- 4 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br>- 1 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。下一个更大元素是 3 。<br>- 2 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].<br>输出：[3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：<br>- 2 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。下一个更大元素是 3 。<br>- 4 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
<li>  <code>0 &lt;= nums1[i], nums2[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>
<li>  <code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>
</ul>
<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>
<h2 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h2><p>/#暴力解</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(nums1 []<span class="hljs-keyword">int</span>, nums2 []<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    m,n := <span class="hljs-built_in">len</span>(nums1),<span class="hljs-built_in">len</span>(nums2)<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        j := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j &lt; n &amp;&amp; nums2[j] != nums1[i] &#123;<br>            j++<br>        &#125;<br>        k := j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> k &lt; n &amp;&amp; nums2[k] &lt; nums2[j] &#123;<br>            k++<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> k &lt; n &#123;<br>            res[i] = nums2[k]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[i] = <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="456-132-模式"><a href="#456-132-模式" class="headerlink" title="456. 132 模式"></a><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式</a></h1><p>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。<strong>132 模式的子序列</strong> 由三个整数 <code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 组成，并同时满足：<code>i &lt; j &lt; k</code> 和 <code>nums[i] &lt; nums[k] &lt; nums[j]</code> 。</p>
<p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,2,3,4]<br>输出：false<br>解释：序列中不存在 132 模式的子序列。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [3,1,4,2]<br>输出：true<br>解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [-1,3,2,0]<br>输出：true<br>解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>n == nums.length</code></li>
<li>  <code>1 &lt;= n &lt;= 2 * 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
</ul>
<h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h4><p>#栈 #单调栈</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    candidateK := []<span class="hljs-keyword">int</span>&#123;nums[n<span class="hljs-number">-1</span>]&#125;<br><br>    maxK := math.MinInt64<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &lt; maxK &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(candidateK) &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt; candidateK[<span class="hljs-built_in">len</span>(candidateK)<span class="hljs-number">-1</span>] &#123;<br>            maxK = candidateK[<span class="hljs-built_in">len</span>(candidateK)<span class="hljs-number">-1</span>]<br>            candidateK = candidateK[:<span class="hljs-built_in">len</span>(candidateK)<span class="hljs-number">-1</span>]<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> nums[i] &gt; maxK &#123;<br>            candidateK = <span class="hljs-built_in">append</span>(candidateK, nums[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></h1><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code>行。</p>
<p><small style="display: inline;">在「杨辉三角」中，每个数是它左上方和右上方的数的和。</small></p>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: rowIndex &#x3D; 3<br>输出: [1,3,3,1]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: rowIndex &#x3D; 0<br>输出: [1]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: rowIndex &#x3D; 1<br>输出: [1,1]<br></code></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>  <code>0 &lt;= rowIndex &lt;= 33</code></li>
</ul>
<p><strong>进阶：</strong></p>
<p>你可以优化你的算法到 <code>_O_(_rowIndex_)</code> 空间复杂度吗？</p>
<h2 id="Solution-13"><a href="#Solution-13" class="headerlink" title="Solution"></a>Solution</h2><p>#数学</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRow</span><span class="hljs-params">(rowIndex <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    C := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, rowIndex+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> C &#123;<br>        C[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,i+<span class="hljs-number">1</span>)<br>        C[i][<span class="hljs-number">0</span>],C[i][i] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; i; j++ &#123;<br>            C[i][j] = C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + C[i<span class="hljs-number">-1</span>][j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> C[rowIndex]<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h1><p>给定正整数 _n_，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 _n_。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：n &#x3D; 12<br>输出：3 <br>解释：12 &#x3D; 4 + 4 + 4<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：n &#x3D; 13<br>输出：2<br>解释：13 &#x3D; 4 + 9<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-14"><a href="#Solution-14" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    f := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        minn := math.MaxInt32<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j*j &lt;= i; j++ &#123;<br>            minn = min(minn, f[i-j*j])<br>        &#125;<br>        f[i] = minn + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：false<br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 --&gt; 2): 和为 3<br>(1 --&gt; 3): 和为 4<br>不存在 sum &#x3D; 5 的根节点到叶子节点的路径。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：root &#x3D; [], targetSum &#x3D; 0<br>输出：false<br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li>  <code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h2 id="Solution-15"><a href="#Solution-15" class="headerlink" title="Solution"></a>Solution</h2><p>#广度搜索</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    queNode := []*TreeNode&#123;&#125;<br>    queVal := []<span class="hljs-keyword">int</span>&#123;&#125;<br>    queNode = <span class="hljs-built_in">append</span>(queNode,root)<br>    queVal = <span class="hljs-built_in">append</span>(queVal,root.Val)<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queNode) != <span class="hljs-number">0</span> &#123;<br>        now := queNode[<span class="hljs-number">0</span>]<br>        queNode = queNode[<span class="hljs-number">1</span>:]<br>        temp := queVal[<span class="hljs-number">0</span>]<br>        queVal = queVal[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-keyword">if</span> now.Left == <span class="hljs-literal">nil</span> &amp;&amp; now.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> temp == targetSum &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> now.Left != <span class="hljs-literal">nil</span> &#123;<br>            queNode = <span class="hljs-built_in">append</span>(queNode,now.Left)<br>            queVal = <span class="hljs-built_in">append</span>(queVal,now.Left.Val + temp)<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> now.Right != <span class="hljs-literal">nil</span> &#123;<br>            queNode = <span class="hljs-built_in">append</span>(queNode, now.Right)<br>            queVal = <span class="hljs-built_in">append</span>(queVal, now.Right.Val + temp)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<h1 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720. 词典中最长的单词"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">720. 词典中最长的单词</a></h1><p>给出一个字符串数组<code>words</code>组成的一本英语词典。从中找出最长的一个单词，该单词是由<code>words</code>词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。</p>
<p>若无答案，则返回空字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：<br>words &#x3D; [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]<br>输出：&quot;world&quot;<br>解释： <br>单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;添加一个字母组成。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：<br>words &#x3D; [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]<br>输出：&quot;apple&quot;<br>解释：<br>&quot;apply&quot;和&quot;apple&quot;都能由词典中的单词组成。但是&quot;apple&quot;的字典序小于&quot;apply&quot;。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  所有输入的字符串都只包含小写字母。</li>
<li>  <code>words</code>数组长度范围为<code>[1,1000]</code>。</li>
<li>  <code>words[i]</code>的长度范围为<code>[1,30]</code>。</li>
</ul>
<h4 id="Solution-16"><a href="#Solution-16" class="headerlink" title="Solution"></a>Solution</h4><p>Language: ****</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestWord</span><span class="hljs-params">(words []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-comment">// 排序哈希</span><br>    sort.Strings(words)<br><br>    <span class="hljs-comment">// 字符串/是否出现</span><br>    wordsMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)<br>    res := <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-keyword">for</span> _,word := <span class="hljs-keyword">range</span> words &#123;<br>        wlen, reslen := <span class="hljs-built_in">len</span>(word), <span class="hljs-built_in">len</span>(res)<br><br>        <span class="hljs-comment">// 字符串前缀</span><br>        <span class="hljs-keyword">if</span> wlen == <span class="hljs-number">1</span> || wordsMap[word[:wlen<span class="hljs-number">-1</span>]] &#123;<br>            wordsMap[word] = <span class="hljs-literal">true</span><br>            <span class="hljs-comment">// 更新res为最长的单词</span><br>            <span class="hljs-keyword">if</span> reslen == <span class="hljs-number">0</span> || reslen &lt; wlen &#123;<br>                res = word<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 **最长子串 **的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;abcabcbb&quot;<br>输出: 3 <br>解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;bbbbb&quot;<br>输出: 1<br>解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;pwwkew&quot;<br>输出: 3<br>解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;&quot;<br>输出: 0<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= s.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<h2 id="Solution-17"><a href="#Solution-17" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">int</span>&#123;&#125;<br>    n := <span class="hljs-built_in">len</span>(s)<br><br>    rk, ans := <span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">delete</span>(m,s[i<span class="hljs-number">-1</span>])<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> rk + <span class="hljs-number">1</span> &lt; n &amp;&amp; m[s[rk+<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span> &#123;<br>            m[s[rk+<span class="hljs-number">1</span>]]++<br>            rk++<br>        &#125; <br><br>        ans = max(ans, rk - i + <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; y &#123;<br>        <span class="hljs-keyword">return</span> y<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<h1 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></h1><p>实现  函数。</p>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  <code>-1</code>。</p>
<p><strong>说明：</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的  以及 Java 的  定义相符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;<br>输出：2<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;<br>输出：-1<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;<br>输出：0<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= haystack.length, needle.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>
</ul>
<h2 id="Solution-18"><a href="#Solution-18" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strStr</span><span class="hljs-params">(haystack <span class="hljs-keyword">string</span>, needle <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n,m := <span class="hljs-built_in">len</span>(haystack), <span class="hljs-built_in">len</span>(needle)<br>outer:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i + m &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j:= <span class="hljs-keyword">range</span> needle &#123;<br>            <span class="hljs-keyword">if</span> haystack[i+j] != needle[j] &#123;<br>                <span class="hljs-keyword">continue</span> outer<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= prices.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>0 &lt;= prices[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-19"><a href="#Solution-19" class="headerlink" title="Solution"></a>Solution</h2><p>#贪心 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(max <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    min := prices[<span class="hljs-number">0</span>]<br>    max = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _,price := <span class="hljs-keyword">range</span> prices &#123;<br>        <span class="hljs-keyword">if</span> price &lt; min &#123;<br>            min = price<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> max &gt; price - min &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                max = price - min<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Python端口占用测试（检测Socket）</title>
    <url>/posts/2498e501.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="windows-端口相关"><a href="#windows-端口相关" class="headerlink" title="windows 端口相关"></a>windows 端口相关</h1><h2 id="动态端口查询"><a href="#动态端口查询" class="headerlink" title="动态端口查询"></a>动态端口查询</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">netsh int ipv4 show dynamicport tcp<br><br>协议 tcp 动态端口范围<br>---------------------------------<br>启动端口        : <span class="hljs-number">49152</span><br>端口数          : <span class="hljs-number">16384</span><br></code></pre></td></tr></table></figure>

<h2 id="动态端口设置"><a href="#动态端口设置" class="headerlink" title="动态端口设置"></a>动态端口设置</h2><p>需要再管理员命令行下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">netsh int ipv4 <span class="hljs-built_in">set</span> dynamicport tcp <span class="hljs-built_in">start</span>=<span class="hljs-number">49152</span> num=<span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure>

<h1 id="Python实现的端口测试接口"><a href="#Python实现的端口测试接口" class="headerlink" title="Python实现的端口测试接口"></a>Python实现的端口测试接口</h1><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-comment"># 文件名：client.py</span><br> <br><span class="hljs-keyword">from</span> ast <span class="hljs-keyword">import</span> Try<br><span class="hljs-keyword">import</span> socket               <span class="hljs-comment"># 导入 socket 模块</span><br><span class="hljs-keyword">import</span> sys<br><br>socketList = []<br><br>host = socket.gethostname() <span class="hljs-comment"># 获取本地主机名</span><br>remoteHost = <span class="hljs-string">&#x27;192.168.3.171&#x27;</span><br>remotePort = <span class="hljs-number">6000</span>                <span class="hljs-comment"># 设置端口号</span><br><br>errNum = <span class="hljs-number">0</span><br>ToTalNum = <span class="hljs-number">0</span><br>errPorts = &#123;&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请通过\&#x27;netsh int ipv4 show dynamicport tcp\&#x27;查看启动端口和端口数,一般情况下该值为49152&quot;</span>)<br>start = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;启动端口:&quot;</span>))<br>end = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;终止端口:&quot;</span>))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start , end): <br>    ToTalNum += <span class="hljs-number">1</span><br>    s = socket.socket()         <span class="hljs-comment"># 创建 socket 对象</span><br>    localHostAndPort = (host,i)<br>    <span class="hljs-keyword">try</span>:<br>        s.bind(localHostAndPort)<br>        <span class="hljs-keyword">if</span> s.connect((remoteHost, remotePort)) == socket.error:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;FAILED&#x27;</span>, i)<br>        <span class="hljs-built_in">print</span>(s.recv(<span class="hljs-number">1024</span>).decode(), i)<br>        socketList.append(s)<br>    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<br>        errNum += <span class="hljs-number">1</span><br>        errPorts[i] = (localHostAndPort, <span class="hljs-string">&quot;OSError:&quot;</span>, e)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Total Port Number(%r)&quot;</span>%ToTalNum, <span class="hljs-string">&quot;Error Port Number(%r)&quot;</span>%errNum)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error Ports:&quot;</span>)<br><span class="hljs-keyword">for</span> err <span class="hljs-keyword">in</span> errPorts.keys():<br>    <span class="hljs-built_in">print</span>(err, errPorts[err])<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(errPorts) == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;All Ports success (%d) ~&quot;</span>%start, <span class="hljs-string">&quot;(%d)&quot;</span>% end)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入\&#x27;exit\&#x27;关闭CLIENT:&quot;</span>)<br>char = <span class="hljs-built_in">input</span>()<br><span class="hljs-keyword">while</span> char != <span class="hljs-string">&quot;exit&quot;</span>:<br>	<span class="hljs-comment"># print(char)</span><br>	char = <span class="hljs-built_in">input</span>()<br><br><span class="hljs-keyword">for</span> skt <span class="hljs-keyword">in</span> socketList:<br>    skt.close()<br><span class="hljs-comment"># print(socketList)</span><br></code></pre></td></tr></table></figure>



<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-comment"># 文件名：server.py</span><br> <br><span class="hljs-keyword">import</span> socket               <span class="hljs-comment"># 导入 socket 模块</span><br> <br>s = socket.socket()         <span class="hljs-comment"># 创建 socket 对象</span><br>host = socket.gethostname() <span class="hljs-comment"># 获取本地主机名</span><br>port = <span class="hljs-number">12345</span>                <span class="hljs-comment"># 设置端口</span><br>s.bind((host, port))        <span class="hljs-comment"># 绑定端口</span><br><br>msg = <span class="hljs-string">&#x27;Success！&#x27;</span>  <span class="hljs-comment">#strip默认取出字符串的头尾空格</span><br> <br>s.listen(<span class="hljs-number">5</span>)                 <span class="hljs-comment"># 等待客户端连接</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    c,addr = s.accept()     <span class="hljs-comment"># 建立客户端连接</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;连接地址：&#x27;</span>, addr)<br>    c.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    c.close()                <span class="hljs-comment"># 关闭连接</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣高效算法入门</title>
    <url>/posts/8cb5320c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p>
<hr>
<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>  <strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code> 的算法吗？</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i,x := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br>            <span class="hljs-keyword">if</span> x+nums[j] == target &#123;<br>                <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;i,j&#125; <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h1><p>给定一个已按照**非递减顺序排列 ** 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p>
<p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值_。_<code>numbers</code> 的下标 <strong>从 1 开始计数</strong> ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code> 。</p>
<p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：numbers &#x3D; [2,3,4], target &#x3D; 6<br>输出：[1,3]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：numbers &#x3D; [-1,0], target &#x3D; -1<br>输出：[1,2]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= numbers.length &lt;= 3 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
<li>  <code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li>
<li>  <code>-1000 &lt;= target &lt;= 1000</code></li>
<li>  <strong>仅存在一个有效答案</strong></li>
</ul>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>#双指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(numbers []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    left,right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        sum := numbers[left] + numbers [right]<br>        <span class="hljs-keyword">if</span> sum == target &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &lt; target &#123;<br>            left++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h1><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 _a，b，c ，_使得 <em>a + b + c =</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; []<br>输出：[]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [0]<br>输出：[]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= nums.length &lt;= 3000</code></li>
<li>  <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>#三指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">class Solution &#123;<br>public:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; threeSum(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 先排序</span><br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        sort(nums.begin(), nums.end());<br><br>        <span class="hljs-comment">// 定义首指针==target</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> ( i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <br>                <span class="hljs-keyword">continue</span>;<br>            <br>            <span class="hljs-keyword">int</span> k = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 内层首指针</span><br>            <span class="hljs-keyword">int</span> target = -nums[i];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) <span class="hljs-comment">// 内层尾指针</span><br>            &#123; <br>                <span class="hljs-keyword">if</span>( j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>]) <br>                    <span class="hljs-keyword">continue</span>;<br><br>                while (j &lt; k &amp;&amp; nums[j] + nums[k] &gt; target) &#123; <span class="hljs-comment">// 遍历尾指针，找合适序列</span><br>                    --k;<br>                &#125;<br><br>                <span class="hljs-comment">// 当前i不满足</span><br>                <span class="hljs-keyword">if</span>(j == k) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 得到符合条件序列</span><br>                <span class="hljs-keyword">if</span>(nums[j] + nums[k] == target) &#123;<br>                    ans.push_back(&#123;nums[i],nums[j],nums[k]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h1><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li>  <code>0 &lt;= a, b, c, d &lt; n</code></li>
<li>  <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li>  <code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">class Solution &#123;<br>public:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; fourSum(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        sort(nums.begin(), nums.end());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> ((long) nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((long) nums[i] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>])<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((long) nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> ((long) nums[i] + nums[j] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 最内层首尾指针</span><br>                <span class="hljs-keyword">int</span> m = n - <span class="hljs-number">1</span>, k = j + <span class="hljs-number">1</span>;<br>                while(k &lt; m) &#123;<br>                    <span class="hljs-keyword">int</span> sum = nums[i] + nums[j] + nums[k] + nums[m];<br>                    <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                        ans.push_back(&#123;nums[i], nums[j], nums[k], nums[m]&#125;);<br>                        while (k &lt; m &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]) &#123;<br>                            k++;<br>                        &#125;<br>                        k++;<br>                        while (k &lt; m &amp;&amp; nums[m] == nums[m - <span class="hljs-number">1</span>]) &#123;<br>                            m--;<br>                        &#125;<br>                        m--;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                        k++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        m--;<br>                    &#125;<br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h1><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">F(0) &#x3D; 0，F(1) &#x3D; 1<br>F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1<br></code></pre></td></tr></table></figure>

<p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：2<br>输出：1<br>解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：3<br>输出：2<br>解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：4<br>输出：3<br>解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= n &lt;= 30</code></li>
</ul>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-2</span>) + fib(n<span class="hljs-number">-1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1\.  1 阶 + 1 阶<br>2\.  2 阶<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1\.  1 阶 + 1 阶 + 1 阶<br>2\.  1 阶 + 2 阶<br>3\.  2 阶 + 1 阶<br></code></pre></td></tr></table></figure>


<h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    pre1,pre2 := <span class="hljs-number">2</span>,<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>        cur := pre1 + pre2<br>        pre2 = pre1<br>        pre1 = cur<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre1<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1]<br>输出：1<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [5,4,-1,7,8]<br>输出：23<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h2 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    sum := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] + nums[i<span class="hljs-number">-1</span>] &gt; nums[i] &#123;<br>            nums[i] += nums[i<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-keyword">if</span>  nums[i] &gt; sum &#123;<br>            sum = nums[i]<br>        &#125;<br>    &#125;  <br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h1><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>
<li>  <code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h2 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划 #背包问题 #difficult</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    sum, maxNum := <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _,num := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += num<br>        <span class="hljs-keyword">if</span> num &gt; maxNum &#123;<br>            maxNum = num<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断总和是不是奇数</span><br>    <span class="hljs-keyword">if</span> sum%<span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    target := sum / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> target &lt; maxNum &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, target+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        v := nums[i]<br>        <span class="hljs-keyword">for</span> j := target; j &gt;= v; j-- &#123;<br>            dp[j] = dp[j] || dp[j-v]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target]<br><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h1><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3 <br>解释：11 &#x3D; 5 + 5 + 1<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1], amount &#x3D; 1<br>输出：1<br></code></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1], amount &#x3D; 2<br>输出：2<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= coins.length &lt;= 12</code></li>
<li>  <code>1 &lt;= coins[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li>
<li>  <code>0 &lt;= amount &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-keyword">int</span>, amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, amount + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 初始化为math.MaxInt32</span><br>	<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= amount; j++ &#123;<br>		dp[j] = math.MaxInt32<br>	&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(coins); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := coins[i]; j &lt;= amount ; j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[j-coins[i]] != math.MaxInt32 &#123;<br>                dp[j] = min(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 没找到能装满背包的, 就返回-1</span><br>	<span class="hljs-keyword">if</span> dp[amount] == math.MaxInt32 &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[amount]<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li> 左括号必须用相同类型的右括号闭合。</li>
<li> 左括号必须以正确的顺序闭合。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;(]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;([)]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;&#123;[]&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<h2 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h2><p>#栈</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">byte</span> &#123;<br>        <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-string">&#x27;(&#x27;</span>,<br>        <span class="hljs-string">&#x27;]&#x27;</span>:<span class="hljs-string">&#x27;[&#x27;</span>,<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>:<span class="hljs-string">&#x27;&#123;&#x27;</span>,<br>    &#125;<br><br>    stack := []<span class="hljs-keyword">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> pairs[s[i]] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != pairs[s[i]] &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack,s[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="20-有效的括号-1"><a href="#20-有效的括号-1" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li> 左括号必须用相同类型的右括号闭合。</li>
<li> 左括号必须以正确的顺序闭合。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;(]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;([)]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;&#123;[]&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<h2 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h2><p>#栈</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">byte</span> &#123;<br>        <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-string">&#x27;(&#x27;</span>,<br>        <span class="hljs-string">&#x27;]&#x27;</span>:<span class="hljs-string">&#x27;[&#x27;</span>,<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>:<span class="hljs-string">&#x27;&#123;&#x27;</span>,<br>    &#125;<br><br>    stack := []<span class="hljs-keyword">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> pairs[s[i]] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != pairs[s[i]] &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack,s[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h1><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code>大的元素。</p>
<p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>
<p>返回一个长度为 <code>nums1.length</code> 的数组<code>ans</code>作为答案，满足<code>ans[i]</code>是如上所述的 <strong>下一个更大元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].<br>输出：[-1,3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：<br>- 4 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br>- 1 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。下一个更大元素是 3 。<br>- 2 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].<br>输出：[3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：<br>- 2 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。下一个更大元素是 3 。<br>- 4 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
<li>  <code>0 &lt;= nums1[i], nums2[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>
<li>  <code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>
</ul>
<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>
<h2 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h2><p>/#暴力解</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(nums1 []<span class="hljs-keyword">int</span>, nums2 []<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    m,n := <span class="hljs-built_in">len</span>(nums1),<span class="hljs-built_in">len</span>(nums2)<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        j := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j &lt; n &amp;&amp; nums2[j] != nums1[i] &#123;<br>            j++<br>        &#125;<br>        k := j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> k &lt; n &amp;&amp; nums2[k] &lt; nums2[j] &#123;<br>            k++<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> k &lt; n &#123;<br>            res[i] = nums2[k]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[i] = <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="456-132-模式"><a href="#456-132-模式" class="headerlink" title="456. 132 模式"></a><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式</a></h1><p>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。<strong>132 模式的子序列</strong> 由三个整数 <code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 组成，并同时满足：<code>i &lt; j &lt; k</code> 和 <code>nums[i] &lt; nums[k] &lt; nums[j]</code> 。</p>
<p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,2,3,4]<br>输出：false<br>解释：序列中不存在 132 模式的子序列。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [3,1,4,2]<br>输出：true<br>解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [-1,3,2,0]<br>输出：true<br>解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>n == nums.length</code></li>
<li>  <code>1 &lt;= n &lt;= 2 * 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
</ul>
<h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h4><p>#栈 #单调栈</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    candidateK := []<span class="hljs-keyword">int</span>&#123;nums[n<span class="hljs-number">-1</span>]&#125;<br><br>    maxK := math.MinInt64<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &lt; maxK &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(candidateK) &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt; candidateK[<span class="hljs-built_in">len</span>(candidateK)<span class="hljs-number">-1</span>] &#123;<br>            maxK = candidateK[<span class="hljs-built_in">len</span>(candidateK)<span class="hljs-number">-1</span>]<br>            candidateK = candidateK[:<span class="hljs-built_in">len</span>(candidateK)<span class="hljs-number">-1</span>]<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> nums[i] &gt; maxK &#123;<br>            candidateK = <span class="hljs-built_in">append</span>(candidateK, nums[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></h1><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code>行。</p>
<p><small style="display: inline;">在「杨辉三角」中，每个数是它左上方和右上方的数的和。</small></p>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: rowIndex &#x3D; 3<br>输出: [1,3,3,1]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: rowIndex &#x3D; 0<br>输出: [1]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: rowIndex &#x3D; 1<br>输出: [1,1]<br></code></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>  <code>0 &lt;= rowIndex &lt;= 33</code></li>
</ul>
<p><strong>进阶：</strong></p>
<p>你可以优化你的算法到 <code>_O_(_rowIndex_)</code> 空间复杂度吗？</p>
<h2 id="Solution-13"><a href="#Solution-13" class="headerlink" title="Solution"></a>Solution</h2><p>#数学</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRow</span><span class="hljs-params">(rowIndex <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    C := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, rowIndex+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> C &#123;<br>        C[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,i+<span class="hljs-number">1</span>)<br>        C[i][<span class="hljs-number">0</span>],C[i][i] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; i; j++ &#123;<br>            C[i][j] = C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + C[i<span class="hljs-number">-1</span>][j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> C[rowIndex]<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h1><p>给定正整数 _n_，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 _n_。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：n &#x3D; 12<br>输出：3 <br>解释：12 &#x3D; 4 + 4 + 4<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：n &#x3D; 13<br>输出：2<br>解释：13 &#x3D; 4 + 9<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-14"><a href="#Solution-14" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    f := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        minn := math.MaxInt32<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j*j &lt;= i; j++ &#123;<br>            minn = min(minn, f[i-j*j])<br>        &#125;<br>        f[i] = minn + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：false<br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 --&gt; 2): 和为 3<br>(1 --&gt; 3): 和为 4<br>不存在 sum &#x3D; 5 的根节点到叶子节点的路径。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：root &#x3D; [], targetSum &#x3D; 0<br>输出：false<br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li>  <code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h2 id="Solution-15"><a href="#Solution-15" class="headerlink" title="Solution"></a>Solution</h2><p>#广度搜索</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    queNode := []*TreeNode&#123;&#125;<br>    queVal := []<span class="hljs-keyword">int</span>&#123;&#125;<br>    queNode = <span class="hljs-built_in">append</span>(queNode,root)<br>    queVal = <span class="hljs-built_in">append</span>(queVal,root.Val)<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queNode) != <span class="hljs-number">0</span> &#123;<br>        now := queNode[<span class="hljs-number">0</span>]<br>        queNode = queNode[<span class="hljs-number">1</span>:]<br>        temp := queVal[<span class="hljs-number">0</span>]<br>        queVal = queVal[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-keyword">if</span> now.Left == <span class="hljs-literal">nil</span> &amp;&amp; now.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> temp == targetSum &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> now.Left != <span class="hljs-literal">nil</span> &#123;<br>            queNode = <span class="hljs-built_in">append</span>(queNode,now.Left)<br>            queVal = <span class="hljs-built_in">append</span>(queVal,now.Left.Val + temp)<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> now.Right != <span class="hljs-literal">nil</span> &#123;<br>            queNode = <span class="hljs-built_in">append</span>(queNode, now.Right)<br>            queVal = <span class="hljs-built_in">append</span>(queVal, now.Right.Val + temp)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<h1 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720. 词典中最长的单词"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">720. 词典中最长的单词</a></h1><p>给出一个字符串数组<code>words</code>组成的一本英语词典。从中找出最长的一个单词，该单词是由<code>words</code>词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。</p>
<p>若无答案，则返回空字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：<br>words &#x3D; [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]<br>输出：&quot;world&quot;<br>解释： <br>单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;添加一个字母组成。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：<br>words &#x3D; [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]<br>输出：&quot;apple&quot;<br>解释：<br>&quot;apply&quot;和&quot;apple&quot;都能由词典中的单词组成。但是&quot;apple&quot;的字典序小于&quot;apply&quot;。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  所有输入的字符串都只包含小写字母。</li>
<li>  <code>words</code>数组长度范围为<code>[1,1000]</code>。</li>
<li>  <code>words[i]</code>的长度范围为<code>[1,30]</code>。</li>
</ul>
<h4 id="Solution-16"><a href="#Solution-16" class="headerlink" title="Solution"></a>Solution</h4><p>Language: ****</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestWord</span><span class="hljs-params">(words []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-comment">// 排序哈希</span><br>    sort.Strings(words)<br><br>    <span class="hljs-comment">// 字符串/是否出现</span><br>    wordsMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)<br>    res := <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-keyword">for</span> _,word := <span class="hljs-keyword">range</span> words &#123;<br>        wlen, reslen := <span class="hljs-built_in">len</span>(word), <span class="hljs-built_in">len</span>(res)<br><br>        <span class="hljs-comment">// 字符串前缀</span><br>        <span class="hljs-keyword">if</span> wlen == <span class="hljs-number">1</span> || wordsMap[word[:wlen<span class="hljs-number">-1</span>]] &#123;<br>            wordsMap[word] = <span class="hljs-literal">true</span><br>            <span class="hljs-comment">// 更新res为最长的单词</span><br>            <span class="hljs-keyword">if</span> reslen == <span class="hljs-number">0</span> || reslen &lt; wlen &#123;<br>                res = word<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<hr>
<hr>
<h1 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></h1><p>实现  函数。</p>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  <code>-1</code>。</p>
<p><strong>说明：</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的  以及 Java 的  定义相符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;<br>输出：2<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;<br>输出：-1<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;<br>输出：0<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= haystack.length, needle.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>
</ul>
<h2 id="Solution-17"><a href="#Solution-17" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strStr</span><span class="hljs-params">(haystack <span class="hljs-keyword">string</span>, needle <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n,m := <span class="hljs-built_in">len</span>(haystack), <span class="hljs-built_in">len</span>(needle)<br>outer:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i + m &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j:= <span class="hljs-keyword">range</span> needle &#123;<br>            <span class="hljs-keyword">if</span> haystack[i+j] != needle[j] &#123;<br>                <span class="hljs-keyword">continue</span> outer<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 **最长子串 **的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;abcabcbb&quot;<br>输出: 3 <br>解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;bbbbb&quot;<br>输出: 1<br>解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;pwwkew&quot;<br>输出: 3<br>解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;&quot;<br>输出: 0<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= s.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<h2 id="Solution-18"><a href="#Solution-18" class="headerlink" title="Solution"></a>Solution</h2><p>Language: ****</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">int</span>&#123;&#125;<br>    n := <span class="hljs-built_in">len</span>(s)<br><br>    rk, ans := <span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">delete</span>(m,s[i<span class="hljs-number">-1</span>])<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> rk + <span class="hljs-number">1</span> &lt; n &amp;&amp; m[s[rk+<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span> &#123;<br>            m[s[rk+<span class="hljs-number">1</span>]]++<br>            rk++<br>        &#125; <br><br>        ans = max(ans, rk - i + <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; y &#123;<br>        <span class="hljs-keyword">return</span> y<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Go</category>
        <category>学习笔记</category>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>(Golang)链表学习记录</title>
    <url>/posts/85980731.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p>
<hr>
<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  链表中节点的数目范围是 <code>[0, 10&lt;sup&gt;4&lt;/sup&gt;]</code></li>
<li>  <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>#快慢指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-comment">// 快慢指针</span><br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    slow, fast := head, head.Next<br><br>    <span class="hljs-keyword">for</span> fast != slow &#123;<br>        <span class="hljs-keyword">if</span> fast == <span class="hljs-literal">nil</span> || fast.Next == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br><br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  链表中节点的数目范围在范围 <code>[0, 10&lt;sup&gt;4&lt;/sup&gt;]</code> 内</li>
<li>  <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    seen := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> _,ok := seen[head]; ok &#123;<br>            <span class="hljs-keyword">return</span> head<br>        &#125;<br>        seen[head] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>        head = head.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>#快慢指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        <span class="hljs-keyword">if</span> fast.Next == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        fast = fast.Next.Next<br><br>        <span class="hljs-keyword">if</span> fast == slow &#123;<br>            p := head<br>            <span class="hljs-keyword">for</span> p != slow &#123;<br>                p = p.Next<br>                slow = slow.Next<br>            &#125;<br>            <span class="hljs-keyword">return</span> p<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h1><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li>  <code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li>  <code>listA</code> - 第一个链表</li>
<li>  <code>listB</code> - 第二个链表</li>
<li>  <code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li>  <code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at &#39;8&#39;<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at &#39;2&#39;<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>listA</code> 中节点数目为 <code>m</code></li>
<li>  <code>listB</code> 中节点数目为 <code>n</code></li>
<li>  <code>1 &lt;= m, n &lt;= 3 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>1 &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>0 &lt;= skipA &lt;= m</code></li>
<li>  <code>0 &lt;= skipB &lt;= n</code></li>
<li>  如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>  如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> || headB == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    pa,pb := headA, headB<br>    <span class="hljs-keyword">for</span> pa != pb &#123;<br>        <span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>            pa = headB<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pa = pa.Next<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> pb == <span class="hljs-literal">nil</span> &#123;<br>            pb = headA<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pb = pb.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pa<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h1><p>Difficulty: **给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。   示例 1： 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1]   提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz   进阶：你能尝试使用一趟扫描实现吗？ **</p>
<p>给你一个链表，删除链表的倒数第 <code>n</code>个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  链表中结点的数目为 <code>sz</code></li>
<li>  <code>1 &lt;= sz &lt;= 30</code></li>
<li>  <code>0 &lt;= Node.val &lt;= 100</code></li>
<li>  <code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><p>#双指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> cur <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>,head&#125;<br>    first, second := head, dummy<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        first = first.Next<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> ; first != <span class="hljs-literal">nil</span>; first = first.Next &#123;<br>        second = second.Next<br>    &#125;<br><br>    second.Next = second.Next.Next<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题</title>
    <url>/posts/206c9e3b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[Toc]</p>
<h1 id="382-链表随机节点"><a href="#382-链表随机节点" class="headerlink" title="382. 链表随机节点"></a><a href="https://leetcode-cn.com/problems/linked-list-random-node/">382. 链表随机节点</a></h1><p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 <strong>被选中的概率一样</strong> 。</p>
<p>实现 <code>Solution</code> 类：</p>
<ul>
<li>  <code>Solution(ListNode head)</code> 使用整数数组初始化对象。</li>
<li>  <code>int getRandom()</code> 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。</li>
</ul>
<p><strong>示例：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入<br>[&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;]<br>[[[1, 2, 3]], [], [], [], [], []]<br>输出<br>[null, 1, 3, 2, 2, 3]<br><br>解释<br>Solution solution &#x3D; new Solution([1, 2, 3]);<br>solution.getRandom(); &#x2F;&#x2F; 返回 1<br>solution.getRandom(); &#x2F;&#x2F; 返回 3<br>solution.getRandom(); &#x2F;&#x2F; 返回 2<br>solution.getRandom(); &#x2F;&#x2F; 返回 2<br>solution.getRandom(); &#x2F;&#x2F; 返回 3<br>&#x2F;&#x2F; getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  链表中的节点数在范围 <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code> 内</li>
<li>  <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  至多调用 <code>getRandom</code> 方法 <code>10&lt;sup&gt;4&lt;/sup&gt;</code> 次</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>  如果链表非常大且长度未知，该怎么处理？</li>
<li>  你能否在不使用额外空间的情况下解决此问题？</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>#链表</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">type</span> Solution []<span class="hljs-keyword">int</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-params">(s Solution)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> node := head; node != <span class="hljs-literal">nil</span>; node = node.Next &#123;<br>        s = <span class="hljs-built_in">append</span>(s, node.Val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Solution)</span> <span class="hljs-title">GetRandom</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> s[rand.Intn(<span class="hljs-built_in">len</span>(s))]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(head);</span><br><span class="hljs-comment"> * param_1 := obj.GetRandom();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_hard_Algorithm</title>
    <url>/posts/24feca74.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="913-猫和老鼠-图-dfs-dp"><a href="#913-猫和老鼠-图-dfs-dp" class="headerlink" title="913. 猫和老鼠 #图 #dfs #dp"></a><a href="https://leetcode-cn.com/problems/cat-and-mouse/">913. 猫和老鼠</a> #图 #dfs #dp</h1><p>两位玩家分别扮演猫和老鼠，在一张 <strong>无向</strong> 图上进行游戏，两人轮流行动。</p>
<p>图的形式是：<code>graph[a]</code> 是一个列表，由满足 <code>ab</code> 是图中的一条边的所有节点 <code>b</code> 组成。</p>
<p>老鼠从节点 <code>1</code> 开始，第一个出发；猫从节点 <code>2</code> 开始，第二个出发。在节点 <code>0</code> 处有一个洞。</p>
<p>在每个玩家的行动中，他们 <strong>必须</strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 <code>1</code> ，那么它必须移动到 <code>graph[1]</code> 中的任一节点。</p>
<p>此外，猫无法移动到洞中（节点 <code>0</code>）。</p>
<p>然后，游戏在出现以下三种情形之一时结束：</p>
<ul>
<li>  如果猫和老鼠出现在同一个节点，猫获胜。</li>
<li>  如果老鼠到达洞中，老鼠获胜。</li>
<li>  如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li>
</ul>
<p>给你一张图 <code>graph</code> ，并假设两位玩家都都以最佳状态参与游戏：</p>
<ul>
<li>  如果老鼠获胜，则返回 <code>1</code>；</li>
<li>  如果猫获胜，则返回 <code>2</code>；</li>
<li>  如果平局，则返回 <code>0</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：graph &#x3D; [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]<br>输出：0<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/17/cat2.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：graph &#x3D; [[1,3],[0],[3],[0,2]]<br>输出：1<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>3 &lt;= graph.length &lt;= 50</code></li>
<li>  <code>1 &lt;= graph[i].length &lt; graph.length</code></li>
<li>  <code>0 &lt;= graph[i][j] &lt; graph.length</code></li>
<li>  <code>graph[i][j] != i</code></li>
<li>  <code>graph[i]</code> 互不相同</li>
<li>  猫和老鼠在游戏中总是移动</li>
</ul>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOUSE_WIN = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> CAT_WIN = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> DRAW = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">51</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> dp[MAXN][MAXN][MAXN*<span class="hljs-number">2</span>];<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; graph;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">catMouseGame</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;graph = graph;<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dp));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getResult</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mouse, <span class="hljs-keyword">int</span> cat, <span class="hljs-keyword">int</span> turns)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(turns == n * <span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> DRAW;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( dp[mouse][cat][turns] &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mouse == <span class="hljs-number">0</span>)<br>            &#123;<br>                dp[mouse][cat][turns] = MOUSE_WIN;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cat == mouse)<br>            &#123;<br>                dp[mouse][cat][turns] = CAT_WIN;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">getNextResult</span>(mouse, cat, turns);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[mouse][cat][turns];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNextResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mouse, <span class="hljs-keyword">int</span> cat, <span class="hljs-keyword">int</span> turns)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> curMove = turns % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? mouse : cat;<br>        <span class="hljs-keyword">int</span> defaultResult = curMove == mouse ? CAT_WIN : MOUSE_WIN;<br>        <span class="hljs-keyword">int</span> result = defaultResult;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> next : graph[curMove])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(curMove == cat &amp;&amp; next == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> nextMouse = curMove == mouse ? next : mouse;<br>            <span class="hljs-keyword">int</span> nextCat = curMove == cat ? next : cat;<br>            <span class="hljs-keyword">int</span> nextResult = <span class="hljs-built_in">getResult</span>(nextMouse, nextCat, turns+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(nextResult != defaultResult)<br>            &#123;<br>                result = nextResult;<br>                <span class="hljs-keyword">if</span>(result != DRAW)<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        dp[mouse][cat][turns] = result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    draw = <span class="hljs-number">0</span><br>    mouseWin = <span class="hljs-number">1</span><br>    catWin = <span class="hljs-number">2</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">catMouseGame</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(graph)<br>    dp := <span class="hljs-built_in">make</span>([][][]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i:= <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br>        <span class="hljs-keyword">for</span> j:= <span class="hljs-keyword">range</span> dp[i] &#123;<br>            dp[i][j] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n*<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">for</span> k:= <span class="hljs-keyword">range</span> dp[i][j] &#123;<br>                dp[i][j][k] = <span class="hljs-number">-1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> getResult, getNextResult <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> <br>    getResult = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(mouse, cat, turns <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>        <span class="hljs-keyword">if</span> turns == n*<span class="hljs-number">2</span> &#123;<br>            <span class="hljs-keyword">return</span> draw<br>        &#125;<br><br>        res := dp[mouse][cat][turns]<br>        <span class="hljs-keyword">if</span> res != <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">return</span> res<br>        &#125;<br>        <span class="hljs-keyword">if</span> mouse == <span class="hljs-number">0</span> &#123;<br>            res = mouseWin<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cat == mouse &#123;<br>            res = catWin<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res = getNextResult(mouse, cat, turns)<br>        &#125;<br>        dp[mouse][cat][turns] = res<br>        <span class="hljs-keyword">return</span> res<br>        &#125;<br><br>        getNextResult = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(mouse, cat, turns <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>        curMove := mouse<br>        <span class="hljs-keyword">if</span> turns % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>            curMove = cat<br>        &#125;<br>        defaultRes := mouseWin<br>        <span class="hljs-keyword">if</span> curMove == mouse &#123;<br>            defaultRes = catWin<br>        &#125;<br>        <br>        res := defaultRes<br>        <span class="hljs-keyword">for</span> _,next := <span class="hljs-keyword">range</span> graph[curMove] &#123;<br>            <span class="hljs-keyword">if</span> curMove == cat &amp;&amp; next == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            nextMouse, nextCat := mouse,cat<br>            <span class="hljs-keyword">if</span> curMove == mouse &#123;<br>                nextMouse = next<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> curMove == cat &#123;<br>                nextCat = next<br>            &#125;<br><br>            nextRes := getResult(nextMouse, nextCat, turns + <span class="hljs-number">1</span> )<br>            <span class="hljs-keyword">if</span> nextRes != defaultRes &#123;<br>                res = nextRes<br>                <span class="hljs-keyword">if</span> res != draw &#123;<br>                    <span class="hljs-keyword">break</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> getResult(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="思路（转自力扣官方）"><a href="#思路（转自力扣官方）" class="headerlink" title="思路（转自力扣官方）"></a>思路（转自力扣官方）</h2><p>这道题是博弈问题，猫和老鼠都按照最优策略参与游戏。</p>
<p>在阐述具体解法之前，首先介绍博弈问题中的三个概念：必胜状态、必败状态与必和状态。</p>
<ol>
<li><p>对于特定状态，如果游戏已经结束，则根据结束时的状态决定必胜状态、必败状态与必和状态。</p>
<ul>
<li><p>如果分出胜负，则该特定状态对于获胜方为必胜状态，对于落败方为必败状态。</p>
</li>
<li><p>如果是平局，则该特定状态对于双方都为必和状态。</p>
</li>
</ul>
</li>
<li><p>从特定状态开始，如果存在一种操作将状态变成必败状态，则当前玩家可以选择该操作，将必败状态留给对方玩家，因此该特定状态对于当前玩家为必胜状态。</p>
</li>
<li><p>从特定状态开始，如果所有操作都会将状态变成必胜状态，则无论当前玩家选择哪种操作，都会将必胜状态留给对方玩家，因此该特定状态对于当前玩家为必败状态。</p>
</li>
<li><p>从特定状态开始，如果任何操作都不能将状态变成必败状态，但是存在一种操作将状态变成必和状态，则当前玩家可以选择该操作，将必和状态留给对方玩家，因此该特定状态对于双方玩家都为必和状态。</p>
</li>
</ol>
<p>对于每个玩家，最优策略如下：</p>
<ol>
<li><p>争取将必胜状态留给自己，将必败状态留给对方玩家。</p>
</li>
<li><p>在自己无法到达必胜状态的情况下，争取将必和状态留给自己。</p>
</li>
</ol>
<p>方法一：动态规划<br>博弈问题通常可以使用动态规划求解。</p>
<p>使用三维数组 $dp$ 表示状态，$dp[mouse][cat][turns] $表示从老鼠位于节点 $\textit{mouse}mouse$、猫位于节点 $\textit{cat}cat$、游戏已经进行了 $\textit{turns}turns $轮的状态开始，猫和老鼠都按照最优策略的情况下的游戏结果。假设图中的节点数是 nn，则有 $0 \le \textit{mouse}, \textit{cat} &lt; n0≤mouse,cat&lt;n$。</p>
<p>由于游戏的初始状态是老鼠位于节点 11，猫位于节点 22，因此$ \textit{dp}[1][2][0]dp[1][2][0] $为从初始状态开始的游戏结果。</p>
<p>动态规划的边界条件为可以直接得到游戏结果的状态，包括以下三种状态：</p>
<ul>
<li><p>如果$ \textit{mouse} = 0mouse=0$，老鼠躲入洞里，则老鼠获胜，因此对于任意$ \textit{cat}cat$ 和 $\textit{turns}turns 都有 \textit{dp}[0][\textit{cat}][\textit{turns}] = 1dp[0][cat][turns]=1$，该状态为老鼠的必胜状态，猫的必败状态。</p>
</li>
<li><p>如果$ \textit{cat} = \textit{mouse}cat=mouse$，猫和老鼠占据相同的节点，则猫获胜，因此当 $\textit{cat} = \textit{mouse}cat=mouse $时，对于任意 $\textit{mouse}mouse、\textit{cat}cat $和 $\textit{turns}turns$ 都有$ \textit{dp}[\textit{mouse}][\textit{cat}][\textit{turns}] = 2dp[mouse][cat][turns]=2$，该状态为老鼠的必败状态，猫的必胜状态。注意猫不能移动到节点 00，因此当$ \textit{mouse} = 0mouse=0$ 时，一定有$ \textit{cat} \ne \textit{mouse}cat =mouse$。</p>
</li>
<li><p>如果$ \textit{turns} \ge 2nturns≥2n$，则是平局，该状态为双方的必和状态。</p>
</li>
</ul>
<blockquote>
<p>为什么当 $\textit{turns} \ge 2nturns≥2n$时，游戏结果是平局呢？</p>
<p>如果游戏已经进行了$ 2n2n$ 轮，但是仍然没有任何一方获胜，此时猫和老鼠各移动了 nn 次，该移动次数等于图中的节点数，因此一定存在一个老鼠到达过至少两次的节点，以及一定存在一个猫到达过至少两次的节点。</p>
<p>对于老鼠而言，即使按照最优策略，也无法躲入洞内，而是只能回到一个已经到达过的节点。当老鼠回到一个在过去的某个回合已经到达过的节点时，猫可能回到在相同回合已经到达过的节点，也可能移动到一个更有利于猫获胜的节点，不可能移动到一个更有利于老鼠获胜的节点（否则猫就不是按照最优策略参与游戏）。如果猫回到在相同回合已经到达过的节点，则形成循环，因此是平局；如果猫移动到一个更有利于猫获胜的节点，则老鼠的获胜机会更小，因此老鼠无法获胜。</p>
<p>同理可知，如果猫按照最优策略也只能回到一个已经到达过的节点，则猫无法获胜。<br>因此当猫和老鼠分别回到一个已经到达过的节点时，猫和老鼠都无法获胜，游戏结果是平局。</p>
</blockquote>
<p>动态规划的状态转移需要考虑当前玩家所有可能的移动，选择最优策略的移动。<br>由于老鼠先开始移动，猫后开始移动，因此可以根据游戏已经进行的轮数 $\textit{turns}turns $的奇偶性决定当前轮到的玩家，当$ \textit{turns}turns $是偶数时轮到老鼠移动，当 $\textit{turns}turns $是奇数时轮到猫移动。</p>
<ol>
<li>如果轮到老鼠移动，则对于老鼠从当前节点移动一次之后可能到达的每个节点，进行如下操作：</li>
<li>如果存在一个节点，老鼠到达该节点之后，老鼠可以获胜，则老鼠到达该节点之后的状态为老鼠的必胜状态，猫的必败状态，因此在老鼠移动之前的当前状态为老鼠的必胜状态。<br>如果老鼠到达任何节点之后的状态都不是老鼠的必胜状态，但是存在一个节点，老鼠到达该节点之后，结果是平局，则老鼠到达该节点之后的状态为双方的必和状态，因此在老鼠移动之前的当前状态为双方的必和状态。</li>
<li>如果老鼠到达任何节点之后的状态都不是老鼠的必胜状态或必和状态，则老鼠到达任何节点之后的状态都为老鼠的必败状态，猫的必胜状态，因此在老鼠移动之前的当前状态为老鼠的必败状态。</li>
</ol>
<p>如果轮到猫移动，则对于猫从当前节点移动一次之后可能到达的每个节点，进行如下操作：</p>
<ol>
<li>如果存在一个节点，猫到达该节点之后，猫可以获胜，则猫到达该节点之后的状态为猫的必胜状态，老鼠的必败状态，因此在猫移动之前的当前状态为猫的必胜状态。</li>
<li>如果猫到达任何节点之后的状态都不是猫的必胜状态，但是存在一个节点，猫到达该节点之后，结果是平局，则猫到达该节点之后的状态为双方的必和状态，因此在猫移动之前的当前状态为双方的必和状态。</li>
<li>如果猫到达任何节点之后的状态都不是猫的必胜状态或必和状态，则猫到达任何节点之后的状态都为猫的必败状态，老鼠的必胜状态，因此在猫移动之前的当前状态为猫的必败状态。</li>
</ol>
<p>实现方面，由于双方移动的策略相似，因此可以使用一个函数实现移动策略，根据游戏已经进行的轮数的奇偶性决定当前轮到的玩家。对于特定玩家的移动，实现方法如下：</p>
<ol>
<li><p>如果当前玩家存在一种移动方法到达非必败状态，则用该状态更新游戏结果。</p>
<ul>
<li><p>如果该移动方法到达必胜状态，则将当前状态（移动前的状态）设为必胜状态，结束遍历其他可能的移动。</p>
</li>
<li><p>如果该移动方法到达必和状态，则将当前状态（移动前的状态）设为必和状态，继续遍历其他可能的移动，因为可能存在到达必胜状态的移动方法。</p>
</li>
</ul>
</li>
<li><p>如果当前玩家的任何移动方法都到达必败状态，则将当前状态（移动前的状态）设为必败状态。</p>
</li>
</ol>
<p>特别地，如果当前玩家是猫，则不能移动到节点 00。</p>
<blockquote>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/cat-and-mouse/solution/mao-he-lao-shu-by-leetcode-solution-444x/">https://leetcode-cn.com/problems/cat-and-mouse/solution/mao-he-lao-shu-by-leetcode-solution-444x/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Go</category>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_Easy_Algorithm</title>
    <url>/posts/a0a70754.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p>
<h1 id="7-整数反转-for-整型"><a href="#7-整数反转-for-整型" class="headerlink" title="7. 整数反转 #for #整型"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a> #for #整型</h1><p>Difficulty: **给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。   示例 1： 输入：x = 123 输出：321 示例 2： 输入：x = -123 输出：-321 示例 3： 输入：x = 120 输出：21 示例 4： 输入：x = 0 输出：0   提示： -231 &lt;= x &lt;= 231 - 1 **</p>
<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31 &lt;/sup&gt;− 1]</code> ，就返回 0。</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：x &#x3D; 123<br>输出：321<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：x &#x3D; -123<br>输出：-321<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：x &#x3D; 120<br>输出：21<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：x &#x3D; 0<br>输出：0<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>-2&lt;sup&gt;31&lt;/sup&gt; &lt;= x &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Language: <strong>go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(rev <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> x != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> rev &lt; math.MinInt32/<span class="hljs-number">10</span> || rev &gt; math.MaxInt32/<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br><br>        digit := x % <span class="hljs-number">10</span><br>        x /= <span class="hljs-number">10</span><br>        rev = rev*<span class="hljs-number">10</span> + digit<br>    &#125;<br>    <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="1614-括号的最大嵌套深度-字符串-for"><a href="#1614-括号的最大嵌套深度-字符串-for" class="headerlink" title="1614. 括号的最大嵌套深度 #字符串 #for"></a><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/">1614. 括号的最大嵌套深度</a> #字符串 #for</h1><p>如果字符串满足以下条件之一，则可以称之为 <strong>有效括号字符串****（valid parentheses string</strong>，可以简写为 <strong>VPS</strong>）：</p>
<ul>
<li>  字符串是一个空字符串 <code>&quot;&quot;</code>，或者是一个不为 <code>&quot;(&quot;</code> 或 <code>&quot;)&quot;</code> 的单字符。</li>
<li>  字符串可以写为 <code>AB</code>（<code>A</code> 与 <code>B</code> 字符串连接），其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong> 。</li>
<li>  字符串可以写为 <code>(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong> 。</li>
</ul>
<p>类似地，可以定义任何有效括号字符串 <code>S</code> 的 <strong>嵌套深度</strong> <code>depth(S)</code>：</p>
<ul>
<li>  <code>depth(&quot;&quot;) = 0</code></li>
<li>  <code>depth(C) = 0</code>，其中 <code>C</code> 是单个字符的字符串，且该字符不是 <code>&quot;(&quot;</code> 或者 <code>&quot;)&quot;</code></li>
<li>  <code>depth(A + B) = max(depth(A), depth(B))</code>，其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong></li>
<li>  <code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong></li>
</ul>
<p>例如：<code>&quot;&quot;</code>、<code>&quot;()()&quot;</code>、<code>&quot;()(()())&quot;</code> 都是 <strong>有效括号字符串</strong>（嵌套深度分别为 0、1、2），而 <code>&quot;)(&quot;</code> 、<code>&quot;(()&quot;</code> 都不是 <strong>有效括号字符串</strong> 。</p>
<p>给你一个 <strong>有效括号字符串</strong> <code>s</code>，返回该字符串的<code>s</code> <strong>嵌套深度</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;(1+(2*3)+((8)&#x2F;4))+1&quot;<br>输出：3<br>解释：数字 8 在嵌套的 3 层括号中。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;(1)+((2))+(((3)))&quot;<br>输出：3<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;1+(2*3)&#x2F;(2-1)&quot;<br>输出：1<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;1&quot;<br>输出：0<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 100</code></li>
<li>  <code>s</code> 由数字 <code>0-9</code> 和字符 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code>、<code>&#39;/&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 组成</li>
<li>  题目数据保证括号表达式 <code>s</code> 是 <strong>有效的括号表达式</strong></li>
</ul>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>Language: <strong>go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(ans <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    dept := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _,ch := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-keyword">if</span> ch == <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br>            dept++;<br>            <span class="hljs-keyword">if</span> dept &gt;= ans &#123;<br>                ans = dept<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ch == <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>            dept--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="71-简化路径-字符串切割-栈"><a href="#71-简化路径-字符串切割-栈" class="headerlink" title="71. 简化路径 #字符串切割 #栈"></a><a href="https://leetcode-cn.com/problems/simplify-path/">71. 简化路径</a> #字符串切割 #栈</h1><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39;</code> 。 对于此问题，任何其他格式的点（例如，<code>&#39;...&#39;</code>）均被视为文件/目录名称。</p>
<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>
<ul>
<li>  始终以斜杠 <code>&#39;/&#39;</code> 开头。</li>
<li>  两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> 。</li>
<li>  最后一个目录名（如果存在）<strong>不能</strong> 以 <code>&#39;/&#39;</code> 结尾。</li>
<li>  此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>&#39;.&#39;</code> 或 <code>&#39;..&#39;</code>）。</li>
</ul>
<p>返回简化后得到的 <strong>规范路径</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：path &#x3D; &quot;&#x2F;home&#x2F;&quot;<br>输出：&quot;&#x2F;home&quot;<br>解释：注意，最后一个目录名后面没有斜杠。 <br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：path &#x3D; &quot;&#x2F;..&#x2F;&quot;<br>输出：&quot;&#x2F;&quot;<br>解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：path &#x3D; &quot;&#x2F;home&#x2F;&#x2F;foo&#x2F;&quot;<br>输出：&quot;&#x2F;home&#x2F;foo&quot;<br>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：path &#x3D; &quot;&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;&quot;<br>输出：&quot;&#x2F;c&quot;<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= path.length &lt;= 3000</code></li>
<li>  <code>path</code> 由英文字母，数字，<code>&#39;.&#39;</code>，<code>&#39;/&#39;</code> 或 <code>&#39;_&#39;</code> 组成。</li>
<li>  <code>path</code> 是一个有效的 Unix 风格绝对路径。</li>
</ul>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>Language: <strong>go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">simplifyPath</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    stack := []<span class="hljs-keyword">string</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _,name := <span class="hljs-keyword">range</span> strings.Split(path, <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>        <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;..&quot;</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>                stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]   <br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> name != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; name != <span class="hljs-string">&quot;.&quot;</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, name)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/&quot;</span> + strings.Join(stack,<span class="hljs-string">&quot;/&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="1576-替换所有的问号-字符串"><a href="#1576-替换所有的问号-字符串" class="headerlink" title="1576. 替换所有的问号 #字符串"></a><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">1576. 替换所有的问号</a> #字符串</h1><p>给你一个仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符的字符串 <code>s</code>，请你将所有的 <code>&#39;?&#39;</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p>
<p>注意：你 <strong>不能</strong> 修改非 <code>&#39;?&#39;</code> 字符。</p>
<p>题目测试用例保证 <strong>除</strong> <code>&#39;?&#39;</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p>
<p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;?zs&quot;<br>输出：&quot;azs&quot;<br>解释：该示例共有 25 种解决方案，从 &quot;azs&quot; 到 &quot;yzs&quot; 都是符合题目要求的。只有 &quot;z&quot; 是无效的修改，因为字符串 &quot;zzs&quot; 中有连续重复的两个 &#39;z&#39; 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;ubv?w&quot;<br>输出：&quot;ubvaw&quot;<br>解释：该示例共有 24 种解决方案，只有替换成 &quot;v&quot; 和 &quot;w&quot; 不符合题目要求。因为 &quot;ubvvw&quot; 和 &quot;ubvww&quot; 都包含连续重复的字符。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;j?qg??b&quot;<br>输出：&quot;jaqgacb&quot;<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;??yw?ipkj?&quot;<br>输出：&quot;acywaipkja&quot;<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><p>  <code>1 &lt;= s.length &lt;= 100</code></p>
</li>
<li><p>  <code>s</code> 仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符</p>
</li>
</ul>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><p>Language: <strong>go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modifyString</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    res := []<span class="hljs-keyword">byte</span>(s)<br>    n := <span class="hljs-built_in">len</span>(res)<br>    <span class="hljs-keyword">for</span> i,ch := <span class="hljs-keyword">range</span> res &#123;<br>        <span class="hljs-keyword">if</span> ch == <span class="hljs-string">&#x27;?&#x27;</span> &#123;<br>            <span class="hljs-keyword">for</span> b := <span class="hljs-keyword">byte</span>(<span class="hljs-string">&#x27;a&#x27;</span>); b &lt;= <span class="hljs-string">&#x27;c&#x27;</span>; b++ &#123;<br>                <span class="hljs-keyword">if</span> !(i &gt; <span class="hljs-number">0</span> &amp;&amp; res[i<span class="hljs-number">-1</span>] == b || i &lt; n - <span class="hljs-number">1</span> &amp;&amp; res[i+<span class="hljs-number">1</span>] == b) &#123;<br>                    res[i] = b<br>                    <span class="hljs-keyword">break</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(res)<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="1629-按键持续时间最长的键-数组"><a href="#1629-按键持续时间最长的键-数组" class="headerlink" title="1629. 按键持续时间最长的键 #数组"></a><a href="https://leetcode-cn.com/problems/slowest-key/">1629. 按键持续时间最长的键</a> #数组</h1><p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 <code>n</code> 个），每次一个。</p>
<p>给你一个长度为 <code>n</code> 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 <code>i</code> 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 <code>i</code> 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p>
<p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code>次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>
<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>
<p>请返回按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：releaseTimes &#x3D; [9,29,49,50], keysPressed &#x3D; &quot;cbcd&quot;<br>输出：&quot;c&quot;<br>解释：按键顺序和持续时间如下：<br>按下 &#39;c&#39; ，持续时间 9（时间 0 按下，时间 9 松开）<br>按下 &#39;b&#39; ，持续时间 29 - 9 &#x3D; 20（松开上一个键的时间 9 按下，时间 29 松开）<br>按下 &#39;c&#39; ，持续时间 49 - 29 &#x3D; 20（松开上一个键的时间 29 按下，时间 49 松开）<br>按下 &#39;d&#39; ，持续时间 50 - 49 &#x3D; 1（松开上一个键的时间 49 按下，时间 50 松开）<br>按键持续时间最长的键是 &#39;b&#39; 和 &#39;c&#39;（第二次按下时），持续时间都是 20<br>&#39;c&#39; 按字母顺序排列比 &#39;b&#39; 大，所以答案是 &#39;c&#39;<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：releaseTimes &#x3D; [12,23,36,46,62], keysPressed &#x3D; &quot;spuda&quot;<br>输出：&quot;a&quot;<br>解释：按键顺序和持续时间如下：<br>按下 &#39;s&#39; ，持续时间 12<br>按下 &#39;p&#39; ，持续时间 23 - 12 &#x3D; 11<br>按下 &#39;u&#39; ，持续时间 36 - 23 &#x3D; 13<br>按下 &#39;d&#39; ，持续时间 46 - 36 &#x3D; 10<br>按下 &#39;a&#39; ，持续时间 62 - 46 &#x3D; 16<br>按键持续时间最长的键是 &#39;a&#39; ，持续时间 16<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>releaseTimes.length == n</code></li>
<li>  <code>keysPressed.length == n</code></li>
<li>  <code>2 &lt;= n &lt;= 1000</code></li>
<li>  <code>1 &lt;= releaseTimes[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>  <code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>
<li>  <code>keysPressed</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><p>Language: <strong>go</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slowestKey</span><span class="hljs-params">(releaseTimes []<span class="hljs-keyword">int</span>, keysPressed <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">byte</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(releaseTimes)<br>    <span class="hljs-keyword">var</span> ans <span class="hljs-keyword">byte</span> = keysPressed[<span class="hljs-number">0</span>]<br>    maxTime := releaseTimes[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>); i &lt; n; i++ &#123;<br>        key := keysPressed[i]<br>        time := releaseTimes[i] - releaseTimes[i<span class="hljs-number">-1</span>]<br><br>        <span class="hljs-keyword">if</span>(time &gt; maxTime || (time == maxTime &amp;&amp; key &gt; ans)) &#123;<br>            ans = key<br>            maxTime = time<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="206-反转链表-链表"><a href="#206-反转链表-链表" class="headerlink" title="206. 反转链表 #链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a> #链表</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1,2]<br>输出：[2,1]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; []<br>输出：[]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li>  <code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">var</span> prev * ListNode<br>    curr := head<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        next := curr.Next<br><br>        curr.Next = prev<br>        prev = curr<br><br>        curr = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="121-买卖股票的最佳时机-数组-dp"><a href="#121-买卖股票的最佳时机-数组-dp" class="headerlink" title="121. 买卖股票的最佳时机 #数组 #dp"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a> #数组 #dp</h1><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= prices.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>0 &lt;= prices[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(max <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    min := prices[<span class="hljs-number">0</span>]<br>    max = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _,price := <span class="hljs-keyword">range</span> prices &#123;<br>        <span class="hljs-keyword">if</span> price &lt; min &#123;<br>            min = price<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> max &gt; price - min &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                max = price - min<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="剑指-Offer-03-数组中重复的数字-数组-坐标交换"><a href="#剑指-Offer-03-数组中重复的数字-数组-坐标交换" class="headerlink" title="剑指 Offer 03. 数组中重复的数字 #数组 #坐标交换"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a> #数组 #坐标交换</h1><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 <br></code></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<p><code>2 &lt;= n &lt;= 100000</code></p>
<h2 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h2><p>坐标交换：通俗讲就是每个人都有一个自己位置，坐标交换就是先把每个人都放到自己的位置上，当发现自己的位置被人占了以后，就说明出现了重复元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">func findRepeatNumber(nums []int) int &#123;<br>    i :&#x3D; 0<br>    for i &lt; len(nums) &#123;<br>        if nums[i] &#x3D;&#x3D; i &#123;<br>            i++<br>            continue<br>        &#125;<br><br>        if nums[nums[i]] &#x3D;&#x3D; nums[i] &#123;<br>            return nums[i]<br>        &#125;<br><br>        nums[nums[i]], nums[i] &#x3D; nums[i], nums[nums[i]]<br>    &#125;<br>    return -1<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
        <category>学习笔记</category>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc编译可执行文件的各个过程</title>
    <url>/posts/d710f2d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><ol>
<li>【预处理阶段】：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件🔻。</li>
<li>【编译阶段】：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件🔻。==根据当前源代码编译成二进制目标文件（即.obj文件）==</li>
<li>【汇编阶段】：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件🔻。</li>
<li>【链接阶段】：将多个目标文件及所需要的库连接成最终的可执行目标文件。==将生成的.obj文件与库文件.lib等文件链接，生成可执行文件（.exe文件）。==</li>
</ol>
<h1 id="gcc的编译过程"><a href="#gcc的编译过程" class="headerlink" title="gcc的编译过程"></a>gcc的编译过程</h1><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> .i 中间文件，基本不会用到</span><br>gcc -E main.c -o main.i<br><span class="hljs-meta">#</span><span class="bash"> .s 汇编语言文件</span><br>gcc -S main.i -o main.s<br><span class="hljs-meta">#</span><span class="bash"> .o 汇编文件</span><br><span class="hljs-meta">#</span><span class="bash"> -c 只编译不链接，生成.obj文件也就是上述对应的汇编文件</span><br>gcc -c main.s -o main.o<br><span class="hljs-meta">#</span><span class="bash"> 生成可执行文件</span><br>gcc main.o -o main<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>explicit关键字</title>
    <url>/posts/58412853.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>如下代码收拾</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weight</span> &#123;</span><br>	<span class="hljs-built_in">Weight</span>(<span class="hljs-keyword">int</span> wh, <span class="hljs-keyword">double</span> lbs);<br>    <span class="hljs-built_in">Weight</span>(<span class="hljs-keyword">double</span> lbs);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m_wh;<br>    <span class="hljs-keyword">double</span> m_lbs;<br>&#125;;<br><br>Weight::<span class="hljs-built_in">Weight</span>(<span class="hljs-keyword">int</span> wh, <span class="hljs-keyword">double</span> lbs)<br>&#123;<br>    m_wh = wh;<br>    m_lbs = lbs;<br>&#125;<br><br>Weight::<span class="hljs-built_in">Weight</span>(<span class="hljs-keyword">double</span> lbs)<br>&#123;<br>    m_wh = lbs / <span class="hljs-number">2</span>;<br>    m_lbs = lbs;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Weight</code>类并非真的需要声明构造函数，因为自动生成的默认构造函数就很好。但是<code>Weight</code>类提供了两个构造函数。一个是<code>int,double</code>类型的，一个是<code>double</code>类型的，每个构造函数都给私有成员全部赋了值。因为创建<code>Weight</code>对象时，将会自动设置这两种重量表示。</p>
<p>因为<code>Weight</code>对象表示一个重量，因为可以提供一种整数值或者浮点值转换为<code>Weight</code>对象的方法。即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">Weight wh;<br>wh = <span class="hljs-number">19.6</span>;<br></code></pre></td></tr></table></figure>

<p>程序将使用构造函数<code>Weight(double)</code>来创建一个临时的<code>Weight</code>对象。随后采用逐成员赋值方式将该临时对象的内容复制到<code>wh</code>中。这一过程称为隐式转换，因为它是自动进行的，而不需要显式强制类型转换。</p>
<p>但情况是，只有接受一个参数的构造函数才能作为转换函数。如<code>Weight(int,double)</code>就不可以。</p>
<p>然而，如果第二个参数提供了==默认值==，它便可以用于转换<code>int</code>。</p>
<p><code>Weight(int, double lbs = 0);</code></p>
<p>在这个时候，便会导致意外的类型转换。因此，C++新增了关键字<code>explicit</code>，用于关闭这种特性。也就是在声明构造函数时加上<code>explicit</code>关键字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weight</span> &#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Weight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> wh, <span class="hljs-keyword">double</span> lbs)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Weight</span><span class="hljs-params">(<span class="hljs-keyword">double</span> lbs)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> m_wh;<br>    <span class="hljs-keyword">double</span> m_lbs;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>添加<code>explicit</code>关键字之后，便可以关闭上述中的隐式转换，但仍然允许显式转换，即显式强制类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">Weight weight; 			<span class="hljs-comment">// create a Stonewt object</span><br>weight = <span class="hljs-number">19.6</span>;				<span class="hljs-comment">// not valid if Stonevt(double) is declared as expliclt</span><br>weight = <span class="hljs-built_in">Weight</span>(<span class="hljs-number">19.61</span>);	<span class="hljs-comment">// ok,an explicit corversion</span><br>weight = (Weight)<span class="hljs-number">19.6</span>;		<span class="hljs-comment">//ok,old form for explicit typecat</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QPROPETRY属性</title>
    <url>/posts/8aa93b6e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Q_PROPERTY 是 Qt 中的一个宏，是用类中声明属性。如果需要使用该宏，必须要继承 QObject 类或者其子类。QPushButton 则是 QObject 的间接子类，所以继承 QPushButton 类后同样可以使用 Q_PROPERTY 宏。</p>
<p>Q_PROPERTY 属性自带了一些属性，同样程序可以自定义。本实验中只讲解 Q_PROPERTY 自带的属性。</p>
<p>在自定义导航按钮的程序中同样使用了 Q_PROPERTY，且程序中只使用了 Q_PROPERTY 的 READ 属性和 WRITE 属性。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>Q_PROPERTY 自带属性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs Cpp"><span class="hljs-built_in">Q_PROPERTY</span>(type name<br>           READ getFunction<br>           [WRITE setFunction]<br>           [RESET resetFunction]<br>           [NOTIFY notifySignal]<br>           [DESIGNABLE <span class="hljs-keyword">bool</span>]<br>           [SCRIPTABLE <span class="hljs-keyword">bool</span>]<br>           [STORED <span class="hljs-keyword">bool</span>]<br>           [USER <span class="hljs-keyword">bool</span>]<br>           [CONSTANT]<br>           [FINAL])<br></code></pre></td></tr></table></figure>

<ul>
<li>在上面的代码中，方括号 [] 中的内容属性可选。</li>
<li>必选 <code>READ</code> 属性：用来读取属性值，因此使用 const 限制，返回值类型必须为属性类型或者属性类型的引用或者指针。</li>
<li>可选 <code>WRITE</code> 属性：用来设置属性值，返回值必须为 void 类型，需要一个参数。</li>
<li>可选 <code>RESET</code> 属性：能够将值设置为默认状态，返回值为 void 类型且不带参数。</li>
<li>可选 <code>NOTIFY</code> 属性：提供一个信号，当值发送改变是该信号会自动被触发。</li>
<li>可选 <code>DESIGNABLE</code> 属性：是否在界面设计器的属性编辑器中出现。大多数属性是可见的，除了可以为变量传入 true 或 false 还可以执行一个 bool 行的成员函数。</li>
<li>可选 <code>SCRIPTABLE</code> 属性：是够可以被脚本引擎操作（默认为 true）。可以赋予 true 或者 false 或 bool 类型的函数。</li>
<li>可选 <code>STORED</code> 属性：是否被认为是独立存在还是依赖于其他的值而存在，也可以表明是否在保存对象状态时保存此属性的值。大多数属性都是需要保存的，但也有例外，例如 <code>QWidget::minimumWidth()</code> 就是不被保存的，因为它的值是从另一个属性 <code>QWidget::minimumSize()</code> 得来的。</li>
<li>可选 <code>USER</code> 属性：是否被设计为面向用户的或用户可修改的类属性。通常，每个类只有一个 USER 属性。例如 <code>QAbstractButton::checked</code> 是按钮类的用户可修改属性。注意 QItemDelegate 获取和设置 widget 的 USER 属性。</li>
<li>可选 <code>CONSTANT</code> 属性：表示属性的值是不变的。</li>
<li>可选 <code>FINAL</code> 属性：表示属性不能被派生类所重写。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Cmd命令整理</title>
    <url>/posts/4d62d9f3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Cmd高级用法整理"><a href="#Cmd高级用法整理" class="headerlink" title="Cmd高级用法整理"></a>Cmd高级用法整理</h1><h2 id="查看路由"><a href="#查看路由" class="headerlink" title="查看路由"></a>查看路由</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">route print<br></code></pre></td></tr></table></figure>

<h2 id="无限ping"><a href="#无限ping" class="headerlink" title="无限ping"></a>无限ping</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ping 192.168.1.1 /t<br></code></pre></td></tr></table></figure>

<h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本地5分钟关机</span><br>shutdown/s<br><br><span class="hljs-comment"># 本地定时关机</span><br>shutdown/s /t XXX（时间，按秒记）<br><br><span class="hljs-comment"># 网络关机</span><br>shutdown/s /m xxx.xxx.xxx.xxx（IP地址）<br><br><span class="hljs-comment"># 取消关机</span><br>shutdown/a<br></code></pre></td></tr></table></figure>

<h2 id="sfc命令"><a href="#sfc命令" class="headerlink" title="sfc命令"></a>sfc命令</h2><p>检查系统完整性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sfc /scannow<br></code></pre></td></tr></table></figure>

<h2 id="Talnet命令"><a href="#Talnet命令" class="headerlink" title="Talnet命令"></a>Talnet命令</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Talnet IP:端口号<br></code></pre></td></tr></table></figure>

<h2 id="vol"><a href="#vol" class="headerlink" title="vol"></a>vol</h2><p>检查硬盘分区</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>SYSTEM</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>C++常识与通识</title>
    <url>/posts/9d0d833e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><h3 id="将引用作为返回值的通常原因是避免创建副本以提高效率，包括其他的函数传参亦是如此"><a href="#将引用作为返回值的通常原因是避免创建副本以提高效率，包括其他的函数传参亦是如此" class="headerlink" title="将引用作为返回值的通常原因是避免创建副本以提高效率，包括其他的函数传参亦是如此"></a>将引用作为返回值的通常原因是避免创建副本以提高效率，包括其他的函数传参亦是如此</h3></li>
<li><h3 id="std-nothrow可以消除抛出异常"><a href="#std-nothrow可以消除抛出异常" class="headerlink" title="std::nothrow可以消除抛出异常"></a><code>std::nothrow</code>可以消除抛出异常</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;new&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100000000ul</span>];   <span class="hljs-comment">// throwing overload</span><br>        &#125;<br>    &#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword">const</span> std::bad_alloc&amp; e) &#123;<br>        std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">int</span>* p = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(std::nothrow) <span class="hljs-keyword">int</span>[<span class="hljs-number">100000000ul</span>]; <span class="hljs-comment">// non-throwing overload</span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Allocation returned nullptr\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>输出：<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">std::bad_alloc<br>Allocation returned nullptr<br></code></pre></td></tr></table></figure></p>
<ol start="3">
<li><h3 id="枚举用法——类静态成员"><a href="#枚举用法——类静态成员" class="headerlink" title="枚举用法——类静态成员"></a>枚举用法——类静态成员</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">year</span> &#123;</span><br>	<span class="hljs-keyword">private</span>:<br>    	<span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>MONTH = <span class="hljs-number">12</span>&#125;; <span class="hljs-comment">// 可以当做一个 static const</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>具体使用场景自己探索哦~</p>
</li>
<li><h3 id="可以通过terminate-（默认行为）、abort-、exit-来终止程序"><a href="#可以通过terminate-（默认行为）、abort-、exit-来终止程序" class="headerlink" title="可以通过terminate()（默认行为）、abort()、exit()来终止程序"></a>可以通过<code>terminate()（默认行为）、abort()、exit()</code>来终止程序</h3></li>
<li><h3 id="虽然算法、数据结构是基础，但是设计模式也一定要看"><a href="#虽然算法、数据结构是基础，但是设计模式也一定要看" class="headerlink" title="虽然算法、数据结构是基础，但是设计模式也一定要看"></a>虽然算法、数据结构是基础，但是设计模式也一定要看</h3></li>
<li><h3 id><a href="#" class="headerlink" title></a></h3></li>
</ol>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>windows Terminal 打开 Git Bash</title>
    <url>/posts/352e7838.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="添加Bash到环境变量中"><a href="#添加Bash到环境变量中" class="headerlink" title="添加Bash到环境变量中"></a>添加Bash到环境变量中</h1><h2 id="1-添加git到环境变量"><a href="#1-添加git到环境变量" class="headerlink" title="1. 添加git到环境变量"></a>1. 添加<code>git</code>到环境变量</h2><p>这一步的目的是方便使用系统命令调用<code>git bash</code>。</p>
<h2 id="①-操作"><a href="#①-操作" class="headerlink" title="① 操作"></a>① 操作</h2><p>右击<code>我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;Path-&gt;添加Git/bin路径即可</code></p>
<p><img src="../../../images/Windows%20Terminal%20&%20GitBase/1.png" alt="Git目录"></p>
<p>如图所示：找到<code>bin</code>目录后，将其添加到path目录</p>
<h2 id="②-验证"><a href="#②-验证" class="headerlink" title="② 验证"></a>② 验证</h2><p><kbd>Win</kbd><code>+</code><kbd>R</kbd>输入<code>Bash</code>能打开Git则说明添加到环境变量成功。</p>
<p><img src="../../../images/Windows%20Terminal%20&%20GitBase/3.png" alt="Win+R-&gt;bash"></p>
<h1 id="2-修改Windows-Terminal配置"><a href="#2-修改Windows-Terminal配置" class="headerlink" title="2. 修改Windows Terminal配置"></a>2. 修改Windows Terminal配置</h1><p>打开Windows Terminal进入到设置界面，然后点击左下角<code>打开Json文件</code>，在Json文件中找到<code>Profile</code>对象，然后在其子对象list中添加下述代码即可。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;acrylicOpacity&quot;</span> : <span class="hljs-number">0.75</span>,<br>    <span class="hljs-attr">&quot;closeOnExit&quot;</span> : <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;colorScheme&quot;</span> : <span class="hljs-string">&quot;Campbell&quot;</span>,<br>    <span class="hljs-attr">&quot;commandline&quot;</span> : <span class="hljs-string">&quot;bash.exe&quot;</span>,<br>    <span class="hljs-attr">&quot;cursorColor&quot;</span> : <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>    <span class="hljs-attr">&quot;cursorShape&quot;</span> : <span class="hljs-string">&quot;bar&quot;</span>,<br>    <span class="hljs-attr">&quot;fontFace&quot;</span> : <span class="hljs-string">&quot;Consolas&quot;</span>,<br>    <span class="hljs-attr">&quot;fontSize&quot;</span> : <span class="hljs-number">12</span>,<br>    <span class="hljs-attr">&quot;historySize&quot;</span> : <span class="hljs-number">9001</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span> : <span class="hljs-string">&quot;git-bash&quot;</span>,<br>    <span class="hljs-attr">&quot;padding&quot;</span> : <span class="hljs-string">&quot;0, 0, 0, 0&quot;</span>,<br>    <span class="hljs-attr">&quot;snapOnInput&quot;</span> : <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&quot;startingDirectory&quot;</span> : <span class="hljs-string">&quot;%USERPROFILE%&quot;</span>,<br>    <span class="hljs-attr">&quot;useAcrylic&quot;</span> : <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>关于<code>Icon</code>，可以邮件下载下边这张图，下载后修改后缀名为<code>ico</code>,在上述代码中添加<code>Icon</code>字段即可：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">&quot;icon&quot;: &quot;图片路径\\git-for-windows.ico&quot;<br></code></pre></td></tr></table></figure>

<p><img src="../../../images/Windows%20Terminal%20&%20GitBase/git-for-windows.png" alt="git-for-windows"></p>
<h1 id="补充-添加主题代码"><a href="#补充-添加主题代码" class="headerlink" title="补充 添加主题代码"></a>补充 添加主题代码</h1><p>直接复制替换Json配置文件中的<code>schemes</code>字段即可。</p>
<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>Windows Terminal 主题相关配置</span></div>
    <div class="hide-content"><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&quot;schemes&quot;: <br>[<br>    &#123;<br>        <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#0C0C0C&quot;</span>,<br>        <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#0C0C0C&quot;</span>,<br>        <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#0037DA&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#767676&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#3B78FF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#61D6D6&quot;</span>,<br>        <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#16C60C&quot;</span>,<br>        <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#B4009E&quot;</span>,<br>        <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#E74856&quot;</span>,<br>        <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#F2F2F2&quot;</span>,<br>        <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#F9F1A5&quot;</span>,<br>        <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#3A96DD&quot;</span>,<br>        <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#CCCCCC&quot;</span>,<br>        <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#13A10E&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Campbell&quot;</span>,<br>        <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#881798&quot;</span>,<br>        <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#C50F1F&quot;</span>,<br>        <span class="hljs-attr">&quot;selectionBackground&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#CCCCCC&quot;</span>,<br>        <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#C19C00&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#012456&quot;</span>,<br>        <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#0C0C0C&quot;</span>,<br>        <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#0037DA&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#767676&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#3B78FF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#61D6D6&quot;</span>,<br>        <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#16C60C&quot;</span>,<br>        <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#B4009E&quot;</span>,<br>        <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#E74856&quot;</span>,<br>        <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#F2F2F2&quot;</span>,<br>        <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#F9F1A5&quot;</span>,<br>        <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#3A96DD&quot;</span>,<br>        <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#CCCCCC&quot;</span>,<br>        <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#13A10E&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Campbell Powershell&quot;</span>,<br>        <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#881798&quot;</span>,<br>        <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#C50F1F&quot;</span>,<br>        <span class="hljs-attr">&quot;selectionBackground&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#CCCCCC&quot;</span>,<br>        <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#C19C00&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#282C34&quot;</span>,<br>        <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#282C34&quot;</span>,<br>        <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#61AFEF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#5A6374&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#61AFEF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#56B6C2&quot;</span>,<br>        <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#98C379&quot;</span>,<br>        <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#C678DD&quot;</span>,<br>        <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#E06C75&quot;</span>,<br>        <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#DCDFE4&quot;</span>,<br>        <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#E5C07B&quot;</span>,<br>        <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#56B6C2&quot;</span>,<br>        <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#DCDFE4&quot;</span>,<br>        <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#98C379&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;One Half Dark&quot;</span>,<br>        <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#C678DD&quot;</span>,<br>        <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#E06C75&quot;</span>,<br>        <span class="hljs-attr">&quot;selectionBackground&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#DCDFE4&quot;</span>,<br>        <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#E5C07B&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#FAFAFA&quot;</span>,<br>        <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#383A42&quot;</span>,<br>        <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#0184BC&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#4F525D&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#61AFEF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#56B5C1&quot;</span>,<br>        <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#98C379&quot;</span>,<br>        <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#C577DD&quot;</span>,<br>        <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#DF6C75&quot;</span>,<br>        <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#E4C07A&quot;</span>,<br>        <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#4F525D&quot;</span>,<br>        <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#0997B3&quot;</span>,<br>        <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#383A42&quot;</span>,<br>        <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#50A14F&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;One Half Light&quot;</span>,<br>        <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#A626A4&quot;</span>,<br>        <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#E45649&quot;</span>,<br>        <span class="hljs-attr">&quot;selectionBackground&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#FAFAFA&quot;</span>,<br>        <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#C18301&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#002B36&quot;</span>,<br>        <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#002B36&quot;</span>,<br>        <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#268BD2&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#073642&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#839496&quot;</span>,<br>        <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#93A1A1&quot;</span>,<br>        <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#586E75&quot;</span>,<br>        <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#6C71C4&quot;</span>,<br>        <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#CB4B16&quot;</span>,<br>        <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#FDF6E3&quot;</span>,<br>        <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#657B83&quot;</span>,<br>        <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#2AA198&quot;</span>,<br>        <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#839496&quot;</span>,<br>        <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#859900&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Solarized Dark&quot;</span>,<br>        <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#D33682&quot;</span>,<br>        <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#DC322F&quot;</span>,<br>        <span class="hljs-attr">&quot;selectionBackground&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#EEE8D5&quot;</span>,<br>        <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#B58900&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#FDF6E3&quot;</span>,<br>        <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#002B36&quot;</span>,<br>        <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#268BD2&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#073642&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#839496&quot;</span>,<br>        <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#93A1A1&quot;</span>,<br>        <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#586E75&quot;</span>,<br>        <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#6C71C4&quot;</span>,<br>        <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#CB4B16&quot;</span>,<br>        <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#FDF6E3&quot;</span>,<br>        <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#657B83&quot;</span>,<br>        <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#002B36&quot;</span>,<br>        <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#2AA198&quot;</span>,<br>        <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#657B83&quot;</span>,<br>        <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#859900&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Solarized Light&quot;</span>,<br>        <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#D33682&quot;</span>,<br>        <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#DC322F&quot;</span>,<br>        <span class="hljs-attr">&quot;selectionBackground&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#EEE8D5&quot;</span>,<br>        <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#B58900&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>        <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>        <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#3465A4&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#555753&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#729FCF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#34E2E2&quot;</span>,<br>        <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#8AE234&quot;</span>,<br>        <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#AD7FA8&quot;</span>,<br>        <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#EF2929&quot;</span>,<br>        <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#EEEEEC&quot;</span>,<br>        <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#FCE94F&quot;</span>,<br>        <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#06989A&quot;</span>,<br>        <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#D3D7CF&quot;</span>,<br>        <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#4E9A06&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Tango Dark&quot;</span>,<br>        <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#75507B&quot;</span>,<br>        <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#CC0000&quot;</span>,<br>        <span class="hljs-attr">&quot;selectionBackground&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#D3D7CF&quot;</span>,<br>        <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#C4A000&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>        <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#3465A4&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#555753&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#729FCF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#34E2E2&quot;</span>,<br>        <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#8AE234&quot;</span>,<br>        <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#AD7FA8&quot;</span>,<br>        <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#EF2929&quot;</span>,<br>        <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#EEEEEC&quot;</span>,<br>        <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#FCE94F&quot;</span>,<br>        <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>        <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#06989A&quot;</span>,<br>        <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#555753&quot;</span>,<br>        <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#4E9A06&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Tango Light&quot;</span>,<br>        <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#75507B&quot;</span>,<br>        <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#CC0000&quot;</span>,<br>        <span class="hljs-attr">&quot;selectionBackground&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#D3D7CF&quot;</span>,<br>        <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#C4A000&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>        <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>        <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#000080&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#808080&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#0000FF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#00FFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#00FF00&quot;</span>,<br>        <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#FF00FF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#FF0000&quot;</span>,<br>        <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#FFFF00&quot;</span>,<br>        <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#008080&quot;</span>,<br>        <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#C0C0C0&quot;</span>,<br>        <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#008000&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Vintage&quot;</span>,<br>        <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#800080&quot;</span>,<br>        <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#800000&quot;</span>,<br>        <span class="hljs-attr">&quot;selectionBackground&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#C0C0C0&quot;</span>,<br>        <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#808000&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;black&quot;</span>: <span class="hljs-string">&quot;#073642&quot;</span>,<br>        <span class="hljs-attr">&quot;blue&quot;</span>: <span class="hljs-string">&quot;#268BD2&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlack&quot;</span>: <span class="hljs-string">&quot;#002B36&quot;</span>,<br>        <span class="hljs-attr">&quot;brightBlue&quot;</span>: <span class="hljs-string">&quot;#949800&quot;</span>,<br>        <span class="hljs-attr">&quot;brightCyan&quot;</span>: <span class="hljs-string">&quot;#93A1A1&quot;</span>,<br>        <span class="hljs-attr">&quot;brightGreen&quot;</span>: <span class="hljs-string">&quot;#00BC00&quot;</span>,<br>        <span class="hljs-attr">&quot;brightPurple&quot;</span>: <span class="hljs-string">&quot;#6C71C4&quot;</span>,<br>        <span class="hljs-attr">&quot;brightRed&quot;</span>: <span class="hljs-string">&quot;#CB4B16&quot;</span>,<br>        <span class="hljs-attr">&quot;brightWhite&quot;</span>: <span class="hljs-string">&quot;#FDF6E3&quot;</span>,<br>        <span class="hljs-attr">&quot;brightYellow&quot;</span>: <span class="hljs-string">&quot;#657B83&quot;</span>,<br>        <span class="hljs-attr">&quot;cursorColor&quot;</span>: <span class="hljs-string">&quot;#FFFFFF&quot;</span>,<br>        <span class="hljs-attr">&quot;cyan&quot;</span>: <span class="hljs-string">&quot;#2AA198&quot;</span>,<br>        <span class="hljs-attr">&quot;foreground&quot;</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>        <span class="hljs-attr">&quot;green&quot;</span>: <span class="hljs-string">&quot;#FFE79E&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;lwz_solarized_light&quot;</span>,<br>        <span class="hljs-attr">&quot;purple&quot;</span>: <span class="hljs-string">&quot;#D33682&quot;</span>,<br>        <span class="hljs-attr">&quot;red&quot;</span>: <span class="hljs-string">&quot;#DC322F&quot;</span>,<br>        <span class="hljs-attr">&quot;selectionBackground&quot;</span>: <span class="hljs-string">&quot;#BFBFBF&quot;</span>,<br>        <span class="hljs-attr">&quot;white&quot;</span>: <span class="hljs-string">&quot;#EEE8D5&quot;</span>,<br>        <span class="hljs-attr">&quot;yellow&quot;</span>: <span class="hljs-string">&quot;#B58900&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure></div></div>]]></content>
      <tags>
        <tag>技巧</tag>
        <tag>杂记</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>前端样式整理</title>
    <url>/posts/3ec63883.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="span-list"><a href="#span-list" class="headerlink" title="span list"></a>span list</h1>   <figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">1<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fas faa-ring animated-hover&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-bottom:3px solid green&quot;</span>&gt;</span>《半小时漫画中国哲学史》<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>2<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align:center;font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;&quot;</span>&gt;</span>“ 既许一人以偏爱，愿尽余生之慷慨 ”<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>3<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;class: faa-bounce animated-hover;border-bottom: 5px solid #8F81EF;&quot;</span>&gt;</span>[data.json文件链接](https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA )<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> 4  <br><span class="hljs-tag">&lt;<span class="hljs-name">mark</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas&quot;</span>&gt;</span>当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。<span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span><br>5<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900&quot;</span>&gt;</span>存储结构管理主要就是通过对表空间的管理来实现的<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>6<br><span class="hljs-tag">&lt;<span class="hljs-name">mark</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background:green;border-radius:10px;color:white&quot;</span>&gt;</span>效果如下：<span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span><br>7<br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">10px</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-weight:700;font-family:&#x27;华文彩云&#x27;;color:rgb(100,190,100)&quot;</span>&gt;</span>基本语言(一)<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br>8<br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-bottom: 2px dashed #000000&quot;</span>&gt;</span>代码段、数据段、BSS段、堆区、文件映射区以及栈区<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>9<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background:black;font:conloas;color:white;&quot;</span>&gt;</span><br><span class="hljs-symbol">&amp;nbsp;</span>数组长度为：3<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-symbol">&amp;nbsp;</span>请按任意键继续. . .<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>10<br><span class="hljs-tag">&lt;<span class="hljs-name">mark</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:white;background:red;font-weight:600;border_radius:100px&quot;</span>&gt;</span>但效率更高<span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span><br></code></pre></td></tr></table></figure>

<hr>
<ol>
<li><span class="fas faa-ring animated-hover" style="border-bottom:3px solid green">《半小时漫画中国哲学史》</span></li>
</ol>
<hr>
<ol start="2">
<li><span style="text-align:center;font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;">“ 既许一人以偏爱，愿尽余生之慷慨 ”</span></li>
</ol>
<hr>
<ol start="3">
<li><span style="class: faa-bounce animated-hover;border-bottom: 5px solid #8F81EF;"><a href="https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA">data.json文件链接</a></span></li>
</ol>
<hr>
<ol start="4">
<li><mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。</mark></li>
</ol>
<hr>
<ol start="5">
<li><span style="background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900">存储结构管理主要就是通过对表空间的管理来实现的</span></li>
</ol>
<hr>
<ol start="6">
<li><mark style="background:green;border-radius:10px;color:white;padding: 5px">效果如下：</mark></li>
</ol>
<hr>
<ol start="7">
<li><font size="10px" style="font-weight:700;font-family:'华文彩云';color:rgb(100,190,100)">基本语言(一)</font></li>
</ol>
<hr>
<ol start="8">
<li><span style="border-bottom: 2px dashed #000000">代码段、数据段、BSS段、堆区、文件映射区以及栈区</span></li>
</ol>
<hr>
<ol start="9">
<li><div style="background:black;font:conloas;color:white;">
&nbsp;
 数组长度为：3
 <br>
&nbsp;
 请按任意键继续. . .
</div></li>
<li><p><mark style="color:white;background:red;font-weight:600;border_radius:100px">但效率更高</mark></p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>初识VUE</title>
    <url>/posts/f1706fda.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>总想学点什么，又不知道学点什么的好，刚好一直也在美化博客，就学点前端的知识，总比不学的好。希望能把自己的学习经验和学习经历记录整理，也便于以后用的时候复习该方面的知识。</p>
</blockquote>
<p>VUE是国人尤雨溪开发的一款前端框架，初步了解之后，确实很神奇，但由于仅仅只是学习，缺乏项目经验，因此本篇文章只记录Vue的相关语法。</p>
<p>我自己也是参考B站视频教程学习：<a href="https://www.bilibili.com/video/BV12J411m7MG?p=1">黑马程序员vue前端基础教程-4个小时带你快速入门vue</a></p>
<hr>
<p>[toc]</p>
<hr>
<p>在使用之前，有必要去vue官网查看相关的简介和快速开始，以便于对vue整体有一个初步的了解。</p>
<p>要是用vue，首先得引入相关js，即：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>其次，学习Vue可能需要不断地去创建html文件，因此，最好整一个模板文件，每次都复制模板文件即可，这里po一个通用的vue-html文件模板：</p>
<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>Vue文件模板</span></div>
    <div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue_01_Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        &#123;&#123; message &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data: &#123;<br><span class="javascript">                message: <span class="hljs-string">&#x27;Hello World!&#x27;</span></span><br>            &#125;<br>        &#125;);<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>


</div></div>

<h1 id="el挂载点"><a href="#el挂载点" class="headerlink" title="el挂载点"></a>el挂载点</h1><p>也是实现标签和js绑定的一个最基础的实现，大致语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br>            el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>            data: &#123;<br>                message: <span class="hljs-string">&#x27;Hello World!&#x27;</span><br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure>

<p>这里的<code>#app</code>就是所说的挂载点，如上代码便是实现<code>id</code>为<code>app</code>的标签的挂载。有了上述js代码，还得添加专门的标签才能生效和使用，语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        &#123;&#123; message &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>以上标签就基本实现了一个初步的vue程序。</p>
<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>完整代码</span></div>
    <div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue_01_Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        &#123;&#123; message &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data: &#123;<br><span class="javascript">                message: <span class="hljs-string">&#x27;Hello World!&#x27;</span></span><br>            &#125;<br>        &#125;);<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
</div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>结果相关函数的一些高级用法</span></div>
    <div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Auraro<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>修改输入框的值，查看效果：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;* message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 字符串连接 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message + &#x27;官网地址：www.mingsrc.work&#x27; &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 字符串反转 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span> <br><span class="javascript">  <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>    data:&#123;<br><span class="javascript">      message: <span class="hljs-string">&quot;学习Vue&quot;</span>,</span><br>    &#125;<br>  &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
</div></div>

<p>上述代码就是Vue的最基础的入门实例了，关于Vue的其他用法则需要一步一步了解。</p>
<div class="note green icon modern"><i class="note-icon fas fa-bullhorn"></i><p>其实不难发现，<code>new</code>出来的<code>Vue</code>的内容就是<code>json</code>格式的串。</p>
<ul>
<li><p>el作为一个挂载点出现在Json对象中</p>
</li>
<li><p>data则保存数据</p>
</li>
<li><p>相应的还有<code>methods</code>方法用来实现函数、交互等。</p>
</li>
</ul>
</div>

<h1 id="本地应用"><a href="#本地应用" class="headerlink" title="本地应用"></a>本地应用</h1><p>什么是本地应用？通俗理解就是js基于dom来获取并操作页面元素的方法，在Vue中使用以<code>v-</code>开头的特殊语法来实现，如<code>v-text</code>、<code>v-html</code>、<code>v-on</code>、<code>v-show</code>、<code>v-if</code>、<code>v-on</code>等一系列vue指令。</p>
<div class="tabs" id="选项卡二(默认为2)"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#选项卡二(默认为2)-1">v-text</button></li><li class="tab active"><button type="button" data-href="#选项卡二(默认为2)-2">v-html</button></li><li class="tab"><button type="button" data-href="#选项卡二(默认为2)-3">v-on</button></li><li class="tab"><button type="button" data-href="#选项卡二(默认为2)-4">v-show</button></li><li class="tab"><button type="button" data-href="#选项卡二(默认为2)-5">v-if</button></li><li class="tab"><button type="button" data-href="#选项卡二(默认为2)-6">v-bind</button></li><li class="tab"><button type="button" data-href="#选项卡二(默认为2)-7">v-for</button></li><li class="tab"><button type="button" data-href="#选项卡二(默认为2)-8">v-on补充</button></li><li class="tab"><button type="button" data-href="#选项卡二(默认为2)-9">v-model</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="选项卡二(默认为2)-1"><h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><p>就是把内容直接输出为内容，不进行渲染，以下为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data: &#123;<br><span class="handlebars"><span class="xml">               content: &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.mingsrc.work&quot;</span>&gt;</span>Auraro<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>&#x27;,</span></span><br>            &#125;<br>        &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>其输出就是 ：<code>&lt;a href=&quot;https://www.mingsrc.work&quot;&gt;Auraro&lt;/a&gt;</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="选项卡二(默认为2)-2"><h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p>会把Json对象指向的内容渲染为HTML元素，同上代码，如果<code>v-text</code>替换为<code>v-html</code>，其输出就会变为：</p>
<p><a href="https://www.mingsrc.work">Auraro</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡二(默认为2)-3"><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>即交互事件，当发生点击事件时的处理，v-on有多种写法，可以使用<code>v-on</code>，也可以使用简写的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;v-on指令&quot;</span> v-on:click=<span class="hljs-string">&quot;doIt&quot;</span>&gt;<br>&lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;v-on简写&quot;</span> @click=<span class="hljs-string">&quot;doIt&quot;</span>&gt;<br>&lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;双击事件&quot;</span> @dblclick=<span class="hljs-string">&quot;doIt&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p>直接pao一个代码：</p>
<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>v-on</span></div>
    <div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>vue_04_交互<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;v-on指令&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doIt&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;v-on简写&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doIt&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;双击事件&quot;</span> @<span class="hljs-attr">dblclick</span>=<span class="hljs-string">&quot;doIt&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> @<span class="hljs-attr">dblclick</span>=<span class="hljs-string">&quot;changeFood&quot;</span>&gt;</span>&#123;&#123; food &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">  el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>  data: &#123;<br><span class="javascript">    food: <span class="hljs-string">&quot;西蓝花炒蛋&quot;</span>,</span><br>    todos: [<br><span class="javascript">      &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;菜鸟教程&#x27;</span> &#125;,</span><br><span class="javascript">      &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;www.runoob.com&#x27;</span> &#125;,</span><br><span class="javascript">      &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;www.w3cschool.cc&#x27;</span> &#125;</span><br>    ]<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    doIt:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        alert(<span class="hljs-string">&quot;this is &#x27;Hello World&#x27; Button&quot;</span>);</span><br>    &#125;,<br><span class="javascript">    changeFood:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.food);</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.food+=<span class="hljs-string">&quot;好好吃！&quot;</span>;</span><br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
</div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>使用v-on实现一个简单的计数器</span></div>
    <div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    #app&#123;<br><span class="css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">        <span class="hljs-attribute">vertical-align</span>: middle;</span><br><span class="css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100px</span>;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-tag">button</span>&#123;</span><br><span class="css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue_05_+-<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-num&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sub&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data: &#123;<br><span class="javascript">                message: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,</span><br>                num: 1<br>            &#125;,<br>            methods: &#123;<br><span class="javascript">                add: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;add&quot;</span>);</span><br><span class="javascript">                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.num &lt; <span class="hljs-number">10</span>) &#123;</span><br><span class="javascript">                        <span class="hljs-built_in">this</span>.num++;</span><br><span class="javascript">                    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">                        alert(<span class="hljs-string">&quot;已经是最大值了&quot;</span>);</span><br>                    &#125;<br>                &#125;,<br><span class="javascript">                sub: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sub&quot;</span>);</span><br><span class="javascript">                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.num &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="javascript">                        <span class="hljs-built_in">this</span>.num--;</span><br><span class="javascript">                    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">                        alert(<span class="hljs-string">&quot;已经是最小值了&quot;</span>);</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
</div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡二(默认为2)-4"><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p><code>v-show</code>为标签的显示开关，可以通过设置<code>v-show</code>的值选择组件是否展示。</p>
<blockquote>
<p>#注意：v-show相当于通过设置标签的<code>visibility</code>为<code>hidden</code>，在源码中还是能看到该元素标签，对内存消耗较小。</p>
</blockquote>
<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>v-show用法示例</span></div>
    <div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeIsShow&quot;</span>&gt;</span>图片显示开关<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addArg&quot;</span>&gt;</span>累加Arg &#123;&#123; isShowArg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/1.jpg&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;v-show test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/2.jpg&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShowArg&gt;=10&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;v-show test&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data: &#123;<br><span class="javascript">            message: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,</span><br><span class="javascript">            isShow: <span class="hljs-literal">false</span>,</span><br>            isShowArg: 1<br>        &#125;,<br>        methods: &#123;<br><span class="javascript">            changeIsShow:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.isShow = !<span class="hljs-built_in">this</span>.isShow;</span><br>            &#125;,<br><span class="javascript">            addArg:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.isShowArg++;</span><br>            &#125;<br>        &#125;<br>    &#125;);<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
</div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡二(默认为2)-5"><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>与<code>v-show</code>功能类似的还有<code>v-if</code>，但不同的是，<code>v-if</code>会直接隐藏掉源码，即通过修改HTML源码<del style="color:red">删除相应的标签</del>修改页面展示</p>
<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>v-if用法示例</span></div>
    <div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;切换文字显示状态&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleIsShow&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span> &gt;</span> &#123;&#123; message &#125;&#125; 测试文字<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data: &#123;<br><span class="javascript">            message: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,</span><br><span class="javascript">            isShow: <span class="hljs-literal">true</span></span><br>        &#125;,<br>        methods:&#123;<br><span class="javascript">            toggleIsShow:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.isShow = !<span class="hljs-built_in">this</span>.isShow;</span><br>            &#125;<br>        &#125;<br>    &#125;);<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
</div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡二(默认为2)-6"><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>v-bind就是绑定的意思，可以绑定标签的一些属性，写法为<code>v-bind:src=“imgSrc”</code>，即绑定标签的src属性，设置其值为<code>Json</code>对象<code>imgSrc</code>的值。</p>
<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>v-bind用法示例</span></div>
    <div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;切换&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleActive&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgSrc&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;isActive?&#x27;active&#x27;:&#x27;&#x27;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgSrc&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;active:isActive&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data: &#123;<br><span class="javascript">            message: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,</span><br><span class="javascript">            imgSrc: <span class="hljs-string">&quot;../img/4.jpg&quot;</span>,</span><br><span class="javascript">            imgTitle: <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="javascript">            isActive: <span class="hljs-literal">false</span></span><br>        &#125;,<br>        methods:&#123;<br><span class="javascript">            toggleActive:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.isActive = !<span class="hljs-built_in">this</span>.isActive;</span><br>            &#125;<br>        &#125;<br>    &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
</div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡二(默认为2)-7"><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>即Vue的遍历插件，会对Json数组对象的每个成员访问。下边使用v-for打印李商隐的《荷花》。</p>
<div class="note blue simple icon simple"><i class="note-icon fa fa-quote-left"></i><center>

<p><a href="https://so.gushiwen.cn/shiwenv_2c99bc7b0323.aspx">荷花      </a><br><a href="https://so.gushiwen.cn/authorv.aspx?name=%E6%9D%8E%E5%95%86%E9%9A%90">李商隐</a><a href="https://so.gushiwen.cn/shiwens/default.aspx?cstr=%E5%94%90%E4%BB%A3">〔唐代〕</a><br>都无色可并，不奈此香何。<br>瑶席乘凉设，金羁落晚过。<br>回衾灯照绮，渡袜水沾罗。<br>预想前秋别，离居梦棹歌。</p>
</center></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>v-for代码示例</span></div>
    <div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in msgArr&quot;</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data: &#123;<br><span class="javascript">                message: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,</span><br>                msgArr: [<br><span class="javascript">                <span class="hljs-string">&quot;荷花&quot;</span>,</span><br><span class="javascript">                <span class="hljs-string">&quot;李商隐〔唐代〕&quot;</span>,</span><br><span class="javascript">                <span class="hljs-string">&quot;都无色可并，不奈此香何。&quot;</span>,</span><br><span class="javascript">                <span class="hljs-string">&quot;瑶席乘凉设，金羁落晚过。&quot;</span>,</span><br><span class="javascript">                <span class="hljs-string">&quot;回衾灯照绮，渡袜水沾罗。&quot;</span>,</span><br><span class="javascript">                <span class="hljs-string">&quot;预想前秋别，离居梦棹歌。&quot;</span></span><br>                ]<br>            &#125;<br>        &#125;);<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>浏览器就会输出这首《荷花》。</p>
</div></div>

<p>需要注意的几个用法：</p>
<ul>
<li><p><code>v-for</code>的作用是：根据列表生成列表结构</p>
</li>
<li><p><code>v-for</code>主要和数组结合使用</p>
</li>
<li><p>语法<code>(item,index) in 数据</code> || <code>item in 数据</code></p>
</li>
<li><p><code>item</code>和<code>index</code>可以结合其他指令一起使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 指定标签title为it --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(it,index) in msg&quot;</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;it&quot;</span>&gt;</span>&#123;&#123; it &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>当然，也支持Json数组的解析。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs json">msg_2:&#123;<br>    title:&quot;荷花&quot;,<br>    author:&quot;李商隐〔唐代〕&quot;,<br>    content:[<br>        &#123;<br>            sentence: &quot;都无色可并，不奈此香何。&quot;,<br>        &#125;,<br>        &#123;<br>            sentence: &quot;瑶席乘凉设，金羁落晚过。&quot;,<br>        &#125;,<br>		&#123;<br>            sentence: &quot;回衾灯照绮，渡袜水沾罗。&quot;,<br>        &#125;,<br>		&#123;<br>            sentence: &quot;预想前秋别，离居梦棹歌。&quot;,<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用上述Json数据时，则需要更改<code>v-for</code>的格式才能有效遍历：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;it_2 in msg_2.content&quot;</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;it_2&quot;</span>&gt;</span>&#123;&#123; it_2.secntence &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡二(默认为2)-8"><p>使用了<code>v-model</code>绑定了<code>input</code>，每点击一次按钮，界面就会增加输入框中的内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue_01_Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;打印输入内容&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;print(&#x27;hello&#x27;)&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;inputValue&quot;</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;msgBox&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;it in showValue&quot;</span>&gt;</span>&#123;&#123; it.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data: &#123;<br><span class="javascript">                message: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,</span><br><span class="javascript">                inputValue:<span class="hljs-string">&#x27;&#x27;</span>,</span><br>                showValue:[]<br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                print:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.showValue.push(&#123;<span class="hljs-attr">name</span>:<span class="hljs-built_in">this</span>.inputValue&#125;)</span><br>                &#125;,<br><span class="javascript">                msgBox:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                    alert(<span class="hljs-string">&quot;ok&quot;</span>);</span><br>                &#125;<br>            &#125;<br>        &#125;);<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡二(默认为2)-9"><p>简而言之就是实现标签的绑定，应用于关联标签之间的数据绑定。在<code>v-on</code>补充中有相应的用法可以参考使用。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#123;% hideToggle 分割线 %&#125;<br><br>&#123;% endhideToggle %&#125;<br></code></pre></td></tr></table></figure>



<h2 id="综合上述所学，实现首页图片切换的功能"><a href="#综合上述所学，实现首页图片切换的功能" class="headerlink" title="综合上述所学，实现首页图片切换的功能"></a>综合上述所学，实现首页图片切换的功能</h2><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>代码</span></div>
    <div class="hide-content"><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-tag">a</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;</span><br><span class="css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0.5</span>);</span><br><span class="css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">            <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">25px</span>;</span><br><span class="css">            <span class="hljs-attribute">position</span>: relative;</span><br><span class="css">            <span class="hljs-attribute">z-index</span>: <span class="hljs-number">99</span>;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">            <span class="hljs-attribute">color</span>: black;</span><br><span class="css">            <span class="hljs-attribute">top</span>: <span class="hljs-number">510px</span>;</span><br>        &#125;<br><span class="css">        <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">color</span>: white;</span><br>        &#125;<br><span class="css">        <span class="hljs-selector-tag">body</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">align-items</span>: center;</span><br><span class="css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">            <span class="hljs-comment">/* padding: 20%; */</span></span><br>        &#125;<br>        .imgShift&#123;<br><span class="css">            zoom: <span class="hljs-number">100%</span>;</span><br><span class="css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid white;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">1960px</span>;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">1060px</span>;</span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue_09_ShiftImg<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mask&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:void(0)&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;prev&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;right:45%&quot;</span>&gt;</span>←<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:void(0)&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;next&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;left:45%&quot;</span>&gt;</span>→<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgArr[index]&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#x27;imgShift&#x27;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el: <span class="hljs-string">&#x27;#mask&#x27;</span>,</span><br>            data: &#123;<br>                imgArr: [<br><span class="javascript">                    <span class="hljs-string">&quot;../img/2.jpg&quot;</span>,</span><br><span class="javascript">                    <span class="hljs-string">&quot;../img/3.jpg&quot;</span>,</span><br><span class="javascript">                    <span class="hljs-string">&quot;../img/4.jpg&quot;</span>,</span><br><span class="javascript">                    <span class="hljs-string">&quot;../img/1.jpg&quot;</span></span><br>                ],<br><span class="javascript">                message: <span class="hljs-string">&#x27;Hello World!&#x27;</span>,</span><br>                index: 0<br>            &#125;,<br>            methods: &#123;<br><span class="javascript">                prev: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.index--;</span><br><span class="javascript">                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.index &lt; <span class="hljs-number">0</span>)</span><br>                    &#123;<br><span class="javascript">                        <span class="hljs-built_in">this</span>.index = <span class="hljs-number">3</span>;</span><br>                    &#125;<br>                &#125;,<br><span class="javascript">                next: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.index++;</span><br><span class="javascript">                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.index &gt; <span class="hljs-number">3</span>)</span><br>                    &#123;<br><span class="javascript">                        <span class="hljs-built_in">this</span>.index = <span class="hljs-number">0</span>;</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
</div></div>

<h1 id="小黑记事本的实现"><a href="#小黑记事本的实现" class="headerlink" title="小黑记事本的实现"></a>小黑记事本的实现</h1><blockquote>
<p>结合以上所学，实现一个记事本功能，CSS样式修饰比较麻烦，仅就功能敲一下代码</p>
</blockquote>
<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>Temp_Code</span></div>
    <div class="hide-content"><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vue_01_Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    #todoapp&#123;<br><span class="css">        <span class="hljs-attribute">display</span>:grid;</span><br><span class="css">        <span class="hljs-attribute">border</span>: none;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">        <span class="hljs-attribute">align-self</span>: center;</span><br><span class="css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">        <span class="hljs-attribute">max-width</span>: <span class="hljs-number">550px</span>;</span><br><span class="css">        <span class="hljs-attribute">min-width</span>: <span class="hljs-number">230px</span>;</span><br><span class="css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4em</span>;</span><br><span class="css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="css">        <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">300</span>;</span><br><span class="css">        <span class="hljs-attribute">filter</span><span class="hljs-selector-pseudo">:drop</span>-shadow(<span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">5px</span> rgb(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));</span><br><span class="css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">25px</span>;</span><br><span class="css">        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale3d</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);</span><br><span class="css">        <span class="hljs-attribute">transition</span>: <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.215</span>, <span class="hljs-number">0.610</span>, <span class="hljs-number">0.355</span>, <span class="hljs-number">1</span>);</span><br><span class="css">        <span class="hljs-attribute">background-color</span>: white;</span><br>    &#125;<br>    #footer &#123;<br><span class="css">        <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">138</span>, <span class="hljs-number">133</span>, <span class="hljs-number">133</span>);</span><br><span class="css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-built_in">rgb</span>(<span class="hljs-number">182</span>, <span class="hljs-number">180</span>, <span class="hljs-number">180</span>) solid;</span><br><span class="css">        <span class="hljs-attribute">display</span>:inline-block;</span><br><span class="css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">15px</span>;</span><br><span class="css">        <span class="hljs-attribute">border-bottom</span>: none;</span><br><span class="css">        <span class="hljs-attribute">border-radius</span>: inherit;</span><br>    &#125;<br>    #main&#123;<br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">30%</span>;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;       </span><br>    &#125;<br>    #todo-list &#123;<br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br>    &#125;<br>    #todo&#123;<br><span class="css">        <span class="hljs-attribute">list-style-type</span>: none;</span><br><span class="css">        <span class="hljs-attribute">font</span>: <span class="hljs-string">&#x27;微软雅黑&#x27;</span>;</span><br><span class="css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;</span><br><span class="css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-built_in">rgb</span>(<span class="hljs-number">194</span>, <span class="hljs-number">192</span>, <span class="hljs-number">192</span>) solid;</span><br><span class="css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br>    &#125;<br>    .new-todo&#123;<br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">90%</span>;</span><br><span class="css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;</span><br><span class="css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-built_in">rgb</span>(<span class="hljs-number">194</span>, <span class="hljs-number">192</span>, <span class="hljs-number">192</span>) solid;</span><br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">30%</span>;</span><br><span class="css">        <span class="hljs-attribute">display</span>:flexbox;</span><br><span class="css">        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">opacity</span>(<span class="hljs-number">1</span>);</span><br><span class="css">        <span class="hljs-attribute">background-color</span>: transparent<span class="hljs-meta">!important</span>;</span><br>    &#125;<br>    #view &#123;<br>    <br>    &#125;<br>    #index&#123;<br><span class="css">        <span class="hljs-attribute">text-align</span>: left;</span><br><span class="css">        <span class="hljs-attribute">float</span>: left;</span><br>    &#125;<br>    #destroy &#123;<br><span class="css">        <span class="hljs-attribute">float</span>: right;</span><br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">10%</span>;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">9%</span>;</span><br><span class="css">        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">opacity</span>(<span class="hljs-number">0</span>);</span><br><span class="css">        <span class="hljs-attribute">border</span>: none;</span><br><span class="css">        <span class="hljs-attribute">background-color</span>: none;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-id">#destroy</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">opacity</span>(<span class="hljs-number">1</span>);</span><br><span class="css">        <span class="hljs-attribute">background-color</span>: none;</span><br><span class="css">        <span class="hljs-attribute">color</span>: black;</span><br><span class="css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">color</span>: white;</span><br><span class="css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">46</span>, <span class="hljs-number">115</span>, <span class="hljs-number">243</span>);</span><br>    &#125;<br>    #info &#123;<br><span class="css">        <span class="hljs-attribute">bottom</span>: -<span class="hljs-number">850px</span>;</span><br><span class="css">        <span class="hljs-attribute">text-align</span>: center<span class="hljs-meta">!important</span>;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-tag">button</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">background-color</span>: transparent;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">10%</span>;</span><br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">        <span class="hljs-attribute">border</span>: none;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">46</span>, <span class="hljs-number">115</span>, <span class="hljs-number">243</span>);</span><br><span class="css">        <span class="hljs-attribute">color</span>: white;</span><br><span class="css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">25px</span>;</span><br><span class="css">        <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">drop-shadow</span>(<span class="hljs-number">1px</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgb</span>(<span class="hljs-number">229</span>, <span class="hljs-number">221</span>, <span class="hljs-number">230</span>));</span><br><span class="css">        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>,<span class="hljs-number">1.5</span>);</span><br><span class="css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;</span><br><span class="css">        <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Franklin Gothic Medium&#x27;</span>, <span class="hljs-string">&#x27;Arial Narrow&#x27;</span>, Arial, sans-serif;</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 主题区域 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;todoapp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> 记事本 <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;inputValue&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入任务&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;new-todo&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 列表区域 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;todo-list&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;todo&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in list&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span>&#123;&#123; index+1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align: left;&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;destroy&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;remove(index)&quot;</span>&gt;</span>×<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--统计和清空 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float: left;&quot;</span>&gt;</span>&#123;&#123; list.length &#125;&#125; items left<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float: right;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;clear&quot;</span>&gt;</span>clear<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 底部 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>CopyRight By mignming.shi<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el: <span class="hljs-string">&#x27;#todoapp&#x27;</span>,</span><br>            data: &#123;<br><span class="javascript">                list:[<span class="hljs-string">&quot;牺牲你宝贵的时间去干了更宝贵的事情吗？&quot;</span>,<span class="hljs-string">&quot;保持思考&quot;</span>],</span><br><span class="javascript">                inputValue:<span class="hljs-string">&quot;&quot;</span></span><br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                add:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.inputValue.length != <span class="hljs-number">0</span>)&#123;</span><br><span class="javascript">                        <span class="hljs-built_in">this</span>.list.push(<span class="hljs-built_in">this</span>.inputValue);</span><br><span class="javascript">                        <span class="hljs-built_in">this</span>.inputValue = <span class="hljs-string">&quot;&quot;</span>;</span><br>                    &#125;<br>                &#125;,<br><span class="javascript">                remove:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">console</span>.log(x);</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.list.splice(x,<span class="hljs-number">1</span>);</span><br>                &#125;,<br><span class="javascript">                clear:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.list = [];</span><br>                &#125;<br>            &#125;<br>        &#125;);<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="../../../images/VUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/jsb.png" alt="image-20211123143018679"></p>
</div></div>

]]></content>
      <categories>
        <category>学习笔记，前端</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>《Effective C++》条款20~21</title>
    <url>/posts/93488446.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>条款20：宁以<code>pass-by-reference-to-const</code>替换<code>pass-by-value</code></li>
<li>条款21：必须返回对象时，别往相反其reference</li>
</ul>
<blockquote>
<p><code>pass-by-value</code>和<code>pass-by-reference</code></p>
<p>20、21章 讲了<b>函数传参</b>过程<b>引用传值</b>和<b>值传递</b>应该以什么样的形式去处理。从函数的<u>入口</u>和<u>出口</u>两个方面讲了</p>
</blockquote>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>软件分享</title>
    <url>/posts/a80b6d86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Utools"><a href="#Utools" class="headerlink" title="Utools"></a>Utools</h1><p>可能是Windows里边最好的快捷方式呼出工具了，个人使用非常顺手。具体看<a href="https://u.tools/">官网</a>介绍吧！我只能说确实好用，也是把这个软件放在第一位的原因。</p>
<h1 id="Everything"><a href="#Everything" class="headerlink" title="Everything"></a>Everything</h1><p>全局搜索工具</p>
<h1 id="TrayS"><a href="#TrayS" class="headerlink" title="TrayS"></a>TrayS</h1><p>绿色版任务栏透明居中软件</p>
<h1 id="语雀"><a href="#语雀" class="headerlink" title="语雀"></a>语雀</h1><p>多端协同笔记短剑</p>
<h2 id="Mouse-Without-Borders"><a href="#Mouse-Without-Borders" class="headerlink" title="Mouse Without Borders"></a>Mouse Without Borders</h2><p>局域网内多台主机键鼠共享</p>
<h1 id="SpaceDesk"><a href="#SpaceDesk" class="headerlink" title="SpaceDesk"></a>SpaceDesk</h1><p>局域网内多台主机屏幕共享</p>
<h1 id="浏览器插件类"><a href="#浏览器插件类" class="headerlink" title="浏览器插件类"></a>浏览器插件类</h1><h2 id="油猴"><a href="#油猴" class="headerlink" title="油猴"></a>油猴</h2><p>可以下载和使用各种脚本，目前已经有大量的脚本可以直接去下载使用，非常方便</p>
<h2 id="微博图床"><a href="#微博图床" class="headerlink" title="微博图床"></a>微博图床</h2><p>可以建一个免费的专属于你个人的图床</p>
<h2 id="infinity-Pro"><a href="#infinity-Pro" class="headerlink" title="infinity Pro"></a>infinity Pro</h2><p>一个极简风格的标签页</p>
<h1 id="笔记类软件"><a href="#笔记类软件" class="headerlink" title="笔记类软件"></a>笔记类软件</h1><p>一款好用的markdown软件（可以配合百度云实现同步功能）</p>
<p><a href="https://typora.io/#">https://typora.io/#</a></p>
<p><img src="../../../images/AllOFSW/image-20201012181725937.png" alt="image-20201012181725937"></p>
<p>博客框架Hexo</p>
<p><a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<p><img src="../../../images/AllOFSW/image-20201012181648993.png"></p>
<p><img src="../../../images/AllOFSW/image-20201012181701043.png"></p>
<p>在线图片处理</p>
<p><a href="https://www.yasuotu.com/">https://www.yasuotu.com/</a></p>
<p><img src="../../../images/AllOFSW/image-20201012181632367.png"></p>
<p>快用工具（文档、视频、图片、文件解压缩、数据分析）</p>
<p><a href="https://www.fastools.cn/doc">https://www.fastools.cn/doc</a></p>
<p><img src="../../../images/AllOFSW/image-20201012182144932.png"></p>
<p>奶牛快传（文件快传）</p>
<p><a href="https://cowtransfer.com/?utm_source=nicelinks.site">https://cowtransfer.com/?utm_source=nicelinks.site</a></p>
<p><img src="../../../images/AllOFSW/image-20201012182128085.png"></p>
<p>PPT网站资源整合</p>
<p><a href="https://www.hippter.com/?utm_source=nicelinks.site">https://www.hippter.com/?utm_source=nicelinks.site</a></p>
<p><img src="../../../images/AllOFSW/image-20201012182235016.png"></p>
<p>标签生成器（shields.io）</p>
<p><img src="../../../images/AllOFSW/image-20201012182319292.png"></p>
<p><img src="../../../images/AllOFSW/image-20201012182346086.png"></p>
<p>语雀（在线笔记平台-阿里开发）</p>
<p><a href="https://www.yuque.com/dashboard">https://www.yuque.com/dashboard</a></p>
<p><img src="../../../images/AllOFSW/yuque.png"></p>
]]></content>
  </entry>
  <entry>
    <title>《我的团长我的团》</title>
    <url>/posts/f5df8c81.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="color:black;backdrop-filter: blur(10px) brightness(110%);font:25px 华文行楷;text-align:center;background-image:url(https://gitee.com/fole-del/img/raw/master/%E4%BF%A1.jpg);border-radius:25px;line-height:1.5;background-repeat: no-repeat;background-size: 65% 100%;background-position: center;">
    <br>
    我有眼泪给别人，但不愿<br>
    为自己痛哭；我没有使自己<br>
    适合于这世界，也没有美丽的<br>
    自辟的国土，就只好永远<br>
    <br>
    渴望：为希望而生；在希望里<br>
    死去，终于承认了不知道<br>
    生命；接受了它又挥霍掉，<br>
    只是历史的工具，长路上的<br>
    <br>
    一粒沙，所以拼命摆脱<br>
    那黑影，而他们因此讥笑我；<br>
    这就选择了寂寞，热闹的寂寞，<br>
    <br>
    用笑声骗自己，漂浮在庸俗<br>
    生活的涡流里，而渐渐，我就说，<br>
    我是个庸俗主义者，无心痛哭。<br>
    <span style="text-align:right;">——杜运燮《赠友》</span>
    <br>    <br>   
</div>


<h2 id="剧情简介"><a href="#剧情简介" class="headerlink" title="剧情简介"></a>剧情简介</h2><div class="note success modern"><p>1942年，中缅边境有座叫禅达的小镇。时不时受到炮火袭击的地方，聚集着一群来自五湖四海的溃兵。他们是小太爷孟烦了（张译 饰）、军医郝兽医（罗京民 饰）、东北佬迷龙（张国强 饰）、阿译长官（王往 饰）、湖南人不辣（王大治 饰）等。他们只求有吃的死不了，如同活死尸。这时，师 长虞啸卿（邢佳栋 饰）出现了，他想利用这群散兵重组川军团，空降缅甸参加战争。但到达战场的小分队面对的却是已成定局的溃败。最后剩下的孟烦了一行人被逼退到四面楚歌的小屋里。外面是不断靠近的日本兵，危机的最高点，拯救他们的是自称团长的龙文章（段奕宏 饰）。<br>　　龙文章其人，由来不明，不按常理出牌，却奇迹地带领着孟烦了一行人渡过怒江，回到了禅达。等待他们的不是嘉奖，而是看守。而龙文章则被发现根本不是什么团长，而是摘了军衔自己挂帅的中尉。就在大家都猜测龙文章凶多吉少时，龙文章不仅没死还被虞啸卿任命为川军团团长，但等待他们的是更深的漩涡……</p>
</div>

<p><span style="border-bottom: 2px dashed #000000">主演： <a href="https://movie.douban.com/celebrity/1274291/">段奕宏</a> / <a href="https://movie.douban.com/celebrity/1274761/">张译</a> / <a href="https://movie.douban.com/celebrity/1274258/">张国强</a> / <a href="https://movie.douban.com/celebrity/1274762/">邢佳栋</a> / <a href="https://movie.douban.com/celebrity/1274252/">李晨</a> / <a href="https://movie.douban.com/celebrity/1320815/">曹海涛</a> / <a href="https://movie.douban.com/celebrity/1313992/">刘威葳</a> / <a href="https://movie.douban.com/celebrity/1275669/">高峰</a> / <a href="https://movie.douban.com/celebrity/1313471/">罗京民</a> / <a href="https://movie.douban.com/celebrity/1316774/">王往</a> / <a href="https://movie.douban.com/celebrity/1314858/">王大治</a> / <a href="https://movie.douban.com/celebrity/1313486/">范雷</a> / <a href="https://movie.douban.com/celebrity/1317139/">王迅</a> / <a href="https://movie.douban.com/celebrity/1325197/">王东栋</a> / <a href="https://movie.douban.com/celebrity/1318324/">刘天佐</a> / <a href="https://movie.douban.com/celebrity/1314488/">谢孟伟</a> / <a href="https://movie.douban.com/celebrity/1321566/">左腾云</a> / <a href="https://movie.douban.com/celebrity/1355785/">赵志君</a> / <a href="https://movie.douban.com/celebrity/1321805/">王大奇</a> / <a href="https://movie.douban.com/celebrity/1320314/">袁菲</a> / <a href="https://movie.douban.com/celebrity/1355786/">江奇翰</a> / <a href="https://movie.douban.com/celebrity/1275728/">李泓良</a> / <a href="https://movie.douban.com/celebrity/1331309/">杜建桥</a> / <a href="https://movie.douban.com/celebrity/1318417/">张衡平</a> / <a href="https://movie.douban.com/celebrity/1355787/">宿宇杰</a> / <a href="https://movie.douban.com/subject_search?search_text=%E9%A9%AC%E4%BA%91">马云</a> / <a href="https://movie.douban.com/celebrity/1355788/">何杰</a> / <a href="https://movie.douban.com/celebrity/1327332/">白恩</a> / <a href="https://movie.douban.com/celebrity/1316812/">柯志凌</a> / <a href="https://movie.douban.com/celebrity/1274972/">曹操</a> / <a href="https://movie.douban.com/celebrity/1355789/">吴有才</a> / <a href="https://movie.douban.com/celebrity/1355790/">哈斯其其格</a> / <a href="https://movie.douban.com/celebrity/1275948/">史航</a> / <a href="https://movie.douban.com/celebrity/1355791/">邓宝</a> / <a href="https://movie.douban.com/celebrity/1274763/">陈思诚</a> / <a href="https://movie.douban.com/celebrity/1355792/">张衍</a> / <a href="https://movie.douban.com/celebrity/1341886/">李京</a> / <a href="https://movie.douban.com/celebrity/1355793/">杨在景</a> / <a href="https://movie.douban.com/celebrity/1318613/">李博</a> / <a href="https://movie.douban.com/celebrity/1330631/">刁海明</a> / <a href="https://movie.douban.com/celebrity/1275188/">兰晓龙</a></span></p>
<h2 id="夸一夸"><a href="#夸一夸" class="headerlink" title="夸一夸"></a>夸一夸</h2><div class="note red no-icon simple"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;🎉实在惊叹于<span style="border-bottom: 2px dashed #000000">演员演技的扎实和剧情的波澜起伏</span>。<br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 看的过程中实在是有太多的感慨。既是军人，也是逃兵，也是英雄，对角色的塑立实在犹如神来之笔。但这还仅仅只是个开始，文中人物谈吐皆具深意，随性一首便是对处境、遭遇、生死的感慨，借用网友一句来形容，那就是：</p>
<blockquote><p>“拍摄如电影，表演似话剧，以远征军历史为背景，探讨鲁迅式的国民性以及哈姆莱特式的生存命题。”</p>
<footer><strong>@抛书人</strong></footer></blockquote>

<p>就像剧中有句话说的那样，这世上，没有哪个人经得起挑剔</p>
</div>

<h2 id="豆瓣评价"><a href="#豆瓣评价" class="headerlink" title="豆瓣评价"></a>豆瓣评价</h2><iframe height="500px" width="100%" src="https://movie.douban.com/subject/2997325/comments?status=P"></iframe>

<h2 id="剧照"><a href="#剧照" class="headerlink" title="剧照"></a>剧照</h2><div class="justified-gallery"><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2052563604,1680387617&fm=26&gp=0.jpg" alt="img"></p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201901%2F01%2F20190101225255_LMiUN.thumb.700_0.jpeg&refer=http%3A%2F%2Fb-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626186531&t=80e4bcb1c0b8027413f55b8302ab34e0" alt="img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fvsd-picture.cdn.bcebos.com%2Fe4ca2e2ec63a5127fe292e97e607587d61f4e429.jpg&refer=http%3A%2F%2Fvsd-picture.cdn.bcebos.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626186531&t=74fe0aacea0448c5b84803adfc33e07f" alt="img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20171125%2F1bcc16716d6f46a896f0f470e79d521b.jpeg&refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626186531&t=fb9080dfbeb4adc7e38c6f57b496e956" alt="img"><img src="https://ss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/728da9773912b31be8075e9f8d18367adab4e119.jpg" alt="img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.tv.cctv.com%2Fimage%2F20090310%2FIMAG1236649173204252.jpg&refer=http%3A%2F%2Fimg.tv.cctv.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626186531&t=f448f2c7947ee6771cc8ac46ee1208d7" alt="img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg6.itiexue.net%2F2660%2F26603010.jpg&refer=http%3A%2F%2Fimg6.itiexue.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626186613&t=808253a9ab2bd082aa3413c49a35a82b" alt="img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fgss0.baidu.com%2F-fo3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2Fd009b3de9c82d1589a4c2bf78b0a19d8bd3e42ad.jpg&refer=http%3A%2F%2Fgss0.baidu.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626186613&t=7de8666ab70264e331d13905c6c9ca9c" alt="img"></p>
          </div>

]]></content>
      <tags>
        <tag>分享</tag>
        <tag>好剧</tag>
      </tags>
  </entry>
  <entry>
    <title>ipad访问🐾电脑文件</title>
    <url>/posts/cdc0a7f6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ipad访问电脑文件夹"><a href="#ipad访问电脑文件夹" class="headerlink" title="ipad访问电脑文件夹"></a>ipad访问电脑文件夹</h1><div class="note green icon simple"><i class="note-icon fab fa fa-dot-circle-o"></i><p>最终目标：ipad上可以访问电脑共享的文件夹</p>
</div>

<h2 id="一、前提条件"><a href="#一、前提条件" class="headerlink" title="一、前提条件"></a>一、前提条件</h2><img src="https://gitee.com/fole-del/img/raw/master/20210611173034.png" style="zoom:50%;float:right;">

<div class="checkbox plus green checked"><input type="checkbox" checked="checked">
            <p>ipad与电脑是在同一个局域网内</p>
            </div>

<div class="checkbox red checked"><input type="checkbox" checked="checked">
            <p>当然，你还得有一个pad</p>
            </div>

<div class="checkbox red checked"><input type="checkbox" checked="checked">
            <p>你还得知道你电脑账户名以及账户密码</p>
            </div>

<h2 id="二、设置共享文件夹"><a href="#二、设置共享文件夹" class="headerlink" title="二、设置共享文件夹"></a>二、设置共享文件夹</h2><blockquote>
<p>本文以<code>share-folders文件夹</code>为例<img src="https://gitee.com/fole-del/img/raw/master/20210611173240.png" alt="就是这个文件夹" style="zoom:80%;"></p>
</blockquote>
<h3 id="1-设置共享文件夹-跟着步骤来"><a href="#1-设置共享文件夹-跟着步骤来" class="headerlink" title="1. 设置共享文件夹(跟着步骤来)"></a>1. 设置共享文件夹(跟着步骤来)</h3><ol>
<li><p>右击文件夹</p>
<img src="https://gitee.com/fole-del/img/raw/master/20210611173435.png" alt="step 1" style="zoom: 80%;"></li>
<li><p>点击共享</p>
<img src="https://gitee.com/fole-del/img/raw/master/20210611173602.png" alt="step 2" style="zoom:80%;"></li>
<li><p>选择被共享的用户，这里我选择<code>ming Ming</code>，选择用户之后点击右下角<kbd>🀄共享(H)</kbd>按钮即可</p>
   <img src="https://gitee.com/fole-del/img/raw/master/20210611174022.png" alt="step 3" style="zoom:67%;"></li>
<li><p>到这一步，共享文件夹就设置完毕了，如图所示</p>
</li>
</ol>
<img src="https://gitee.com/fole-del/img/raw/master/20210611174511.png" alt="step 4" style="zoom:80%;">

<h3 id="2-查看windows的IP地址"><a href="#2-查看windows的IP地址" class="headerlink" title="2. 查看windows的IP地址"></a>2. 查看windows的IP地址</h3><ol>
<li>按<kbd>Win+R</kbd>输入<code>cmd</code>，打开命令提示符（或者右击左下角<img src="https://gitee.com/fole-del/img/raw/master/20210611181912.png" style>按钮，点击运行)</li>
<li>输入<code>ipconfig</code>查看本机IP地址</li>
<li>如下图所示为我本人电脑的IP地址<i id="2-3"></i></li>
</ol>
<img src="https://gitee.com/fole-del/img/raw/master/20210611175249.png" alt="IP地址" style="zoom:80%;">

<h3 id="3-在ipad连接"><a href="#3-在ipad连接" class="headerlink" title="3. 在ipad连接"></a>3. 在ipad连接</h3><ol>
<li>打开文件，没有的可以去<code>app store</code>下载</li>
</ol>
<p><img src="https://gitee.com/fole-del/img/raw/master/20210611175804.png" alt="step 1"></p>
<ol start="2">
<li><p>点击文件右上角菜单栏<kbd style="color:#3493FE;font-family:黑体;font-weight:900;">···</kbd></p>
<img src="https://gitee.com/fole-del/img/raw/master/20210611180014.png" alt="step 2" style="zoom: 33%;"></li>
<li><p>输入IP地址，然后点击<kbd style="color:#3493FE;font-family:黑体;font-weight:900;">连接</kbd></p>
</li>
</ol>
<p><a href="#2-3">也就是<code>2-3</code>得到的地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">smb:&#x2F;&#x2F;192.168.1.113<br></code></pre></td></tr></table></figure>

<img src="https://gitee.com/fole-del/img/raw/master/20210611180648.png" alt="step 3" style="zoom:33%;">

<ol start="4">
<li><p>输入名称和密码（也就是你的windows用户和密码），点击<kbd style="color:#3493FE;font-family:黑体;font-weight:900;font-size:14px;">下一步</kbd></p>
<p><span style="border-bottom: 2px dashed #000000">注1：如果你电脑是中文名，那你就输入中文名即可</span></p>
</li>
</ol>
<img src="https://gitee.com/fole-del/img/raw/master/20210611181344.png" alt="step 4" style="zoom:33%;">

<p><span style="border-bottom: 2px dashed #000000">注2：用户名带空格的如果登录失败，可以删除空格再尝试一遍</span></p>
<h2 id="三、连接成功"><a href="#三、连接成功" class="headerlink" title="三、连接成功"></a>三、连接成功</h2><p>如图所示，ipad文件已共享出现了我们刚才连接的网络位置，打开<code>share-folders</code>文件夹也能看到仅有的一张图片。同样的，在电脑的网络位置，点进去也能看到我们已经共享的文件夹。</p>
<div class="justified-gallery"><p><img src="https://gitee.com/fole-del/img/raw/master/20210611182955.png" alt="ipad-over"></p><p><img src="https://gitee.com/fole-del/img/raw/master/20210611182953.png" alt="windows-over"></p><p><img src="https://gitee.com/fole-del/img/raw/master/20210611182952.png" alt="share-folders文件夹内容"></p>
          </div>



<hr>
<p><img src="https://gitee.com/fole-del/img/raw/master/20210611184500.png" alt="恭喜你，出师了"></p>
]]></content>
      <tags>
        <tag>技巧</tag>
        <tag>杂记</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter扩展技能</title>
    <url>/posts/2018b55.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Jupyter-使用相关"><a href="#Jupyter-使用相关" class="headerlink" title="Jupyter 使用相关"></a>Jupyter 使用相关</h1><h2 id="一、安装主题"><a href="#一、安装主题" class="headerlink" title="一、安装主题"></a>一、安装主题</h2><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">pip install --upgrade jupyterthemes<br></code></pre></td></tr></table></figure>

<p>查看可用主题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jt -l<br></code></pre></td></tr></table></figure>

<h3 id="设置推荐"><a href="#设置推荐" class="headerlink" title="设置推荐"></a>设置推荐</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jt -t chesterish -fs 14 -cellw 85% -ofs 13 -dfs 11 -T<br>jt -t oceans16 -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T -N<br></code></pre></td></tr></table></figure>

<h2 id="二、自动补全等功能"><a href="#二、自动补全等功能" class="headerlink" title="二、自动补全等功能"></a>二、自动补全等功能</h2>]]></content>
  </entry>
  <entry>
    <title>有书读 NO.1</title>
    <url>/posts/2d110b49.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《半小时漫画中国哲学史》"><a href="#《半小时漫画中国哲学史》" class="headerlink" title="《半小时漫画中国哲学史》"></a>《半小时漫画中国哲学史》</h1><div class="note green icon modern"><i class="note-icon fa fa-hand-peace-o"></i><p><span class="fas faa-wrench animated"><a>虽然</a></span>书名说的就是半个小时，但我是间隔这用了三天时间读了一下，从另一个角度来讲，我既是来陶冶一下最近烦躁的情绪；同时，也是因为在上党课时对哲学、批判思维的一种兴趣，发现这本书纯属意外。但确实值得推荐：</p>
<p>​    1. 作者通过漫画的形式讲了中国哲学的一些内容；</p>
<p>​    2. 诙谐幽默的讲述为本就枯燥的内容平添色彩，内容方面图一乐，毕竟好多知识课本里边都学过，但值得学习的是作者叙述的风格和语言的组织，以及文中不间断的插画内容，思维确实有趣</p>
</div>



<style>
.card--11 .card__img1,
.card--11 .card__img--hover1 {
  background-image: url("https://cdn.jsdelivr.net/gh/fole-del/img/imgservice.suning.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg");
}
.card__clock1 {
  vertical-align: middle;
  fill: #FFFFFF;
}
.card__time1 {
  color: #FFFFFF;
  vertical-align: text-bottom;
}
.card__clock-info1 {
  float: right;
}
.card__img1 {
  visibility: hidden;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  width: 100%;
  height: 200px;
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
}
.card__info-hover1 {
  position: absolute;
  padding: 16px;
  width: 100%;
  opacity: 0;
  top: 0;
}
.card__img--hover1 {
  transition: 0.2s all ease-out;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;width: 100%;
  position: absolute;
  height: 235px;
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
  top: 0;
}
.card1 {
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0, 1);
  background-color: #fff;
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0px 13px 10px -7px rgba(0, 0, 0, 0.1);
  transform: scale(0.9, 0.9);
}
.card1:hover {
  box-shadow: 0px 30px 18px -8px rgba(0, 0, 0, 0.1);
  transform: scale(1, 1);
}
.card__info1 {
  z-index: 2;
  background-color: #fff;
  border-bottom-left-radius: 12px;
  border-bottom-right-radius: 12px;
}
.card__category1 {
  text-transform: uppercase;
  font-size: 13px;
  letter-spacing: 2px;
  font-weight: 500;
  color: #868686;
}
.card__title1 {
  margin-top: 5px;
  margin-bottom: 10px;
}
.card__by1 {
  font-size: 12px;
  font-weight: 500;
}
.card__author1 {
  font-weight: 600;
  text-decoration: none;
  color: #ad7d52;
}
.card1:hover .card__img--hover1 {
  height: 100%;
  opacity: 0.1;
}
.card1:hover .card__info1 {
  background-color: transparent;
  position: relative;
}
.card:hover .card__info-hover1 {
  opacity: 1;
}
/** 
 * CSS Locks
 * min viewport 576px 
 * max viewport 1400px
**/
   .card1 {
    /*
   * min width = 300
   * max width = 600 
    */
      width: calc(300px + (600 - 300) * ((100vw - 576px) / (1400 - 576)));
    }
    .card__like1 {
     /*
   * min width = 18
   * max width = 36 
    */
      width: calc(36px + (36 - 18) * ((100vw - 576px) / (1400 - 576)));
    }
    .card__clock1 {
     /*
   * min width = 20
   * max width = 40 
    */
      width: calc(20px + (40 - 20) * ((100vw - 576px) / (1400 - 576)));
    }
    .card__time1 {
     /*
   * min font-size = 12
   * max font-size = 24 
    */
     font-size: calc(24px + (24 - 12) * ((100vw - 576px) / (1400 - 576)));
     margin-left: calc(5px + (10 - 5) * ((100vw - 576px) / (1400 - 576)));
    }
    .card__info1 {
     padding: calc(16px + (32 - 16) * ((100vw - 576px) / (1400 - 576)))
     calc(24px + (48 - 24) * ((100vw - 576px) / (1400 - 576)))
     calc(24px + (48 - 24) * ((100vw - 576px) / (1400 - 576)))
     calc(24px + (48 - 24) * ((100vw - 576px) / (1400 - 576)));
    }</style>





<h1 id><a href="#" class="headerlink" title></a><div class="checkbox plus red checked"><input type="checkbox" checked="checked">
            <p><a href="https://weread.qq.com/web/reader/90f3285071ff6efe90f1363kc81322c012c81e728d9d180">链接直达</a></p>
            </div></h1> <article class="card1 card--11">
    <div class="card__info-hover1">
      <svg class="card__like1" viewbox="0 0 24 24"><path fill="#FFFFFF" d="M12.1,18.55L12,18.65L11.89,18.55C7.14,14.24 4,11.39 4,8.5C4,6.5 5.5,5 7.5,5C9.04,5 10.54,6 11.07,7.36H12.93C13.46,6 14.96,5 16.5,5C18.5,5 20,6.5 20,8.5C20,11.39 16.86,14.24 12.1,18.55M16.5,3C14.76,3 13.09,3.81 12,5.08C10.91,3.81 9.24,3 7.5,3C4.42,3 2,5.41 2,8.5C2,12.27 5.4,15.36 10.55,20.03L12,21.35L13.45,20.03C18.6,15.36 22,12.27 22,8.5C22,5.41 19.58,3 16.5,3Z"/></svg>
      <!-- 右上角时间 -->
      <div class="card__clock-info1">
        <svg class="card__clock1" viewbox="0 0 24 24">
          <path d="M12,20A7,7 0 0,1 5,13A7,7 0 0,1 12,6A7,7 0 0,1 19,13A7,7 0 0,1 12,20M19.03,7.39L20.45,5.97C20,5.46 19.55,5 19.04,4.56L17.62,6C16.07,4.74 14.12,4 12,4A9,9 0 0,0 3,13A9,9 0 0,0 12,22C17,22 21,17.97 21,13C21,10.88 20.26,8.93 19.03,7.39M11,14H13V8H11M15,1H9V3H15V1Z"/>
            <span class="card__time1"><p>《半小时漫画中国哲学史》</p></span>
        </svg>
      </div>
    </div>
    <div class="card__img1"></div>
    <a href="https://weread.qq.com/web/reader/90f3285071ff6efe90f1363kc81322c012c81e728d9d180" class="card_link1">
      <div class="card__img--hover1"></div>
    </a>
    <div class="card__info1">
      <p class="card__title1">古人都在思考些什么？</p>
      <span class="card__by1">by <a href="https://weread.qq.com/web/reader/90f3285071ff6efe90f1363kc81322c012c81e728d9d180" class="card__author1" title="author">《半小时漫画中国哲学史》</a></span>
    </div>
  </article>


<p>一些文中的插画</p>
<div class="justified-gallery"><p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/image-20210530231154622.png" alt="插画"></p><p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/image-20210530231220611.png" alt="插画"></p><p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/image-20210530231238611.png" alt="插画"></p>
          </div>
]]></content>
      <categories>
        <category>杂记</category>
        <category>分享</category>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>书单</tag>
        <tag>好书</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy\pandas\random查询手册集合</title>
    <url>/posts/1804fe66.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-设置小数点位数"><a href="#1-设置小数点位数" class="headerlink" title="1. 设置小数点位数"></a>1. 设置小数点位数</h4><ol>
<li>~~~python<br>df[‘a’] = df[‘a’].round(decimals=2)<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2. ~~~python<br>   decimals &#x3D; pd.Series([1, 0, 2], index&#x3D;[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])<br>   df.round(decimals)<br></code></pre></td></tr></table></figure></li>
</ol>
<div style="display:right"><img src="https://cdn.jsdelivr.net/gh/fole-del/img/tempImage1622100945784.gif" style="zoom:50%;float:right;display:block;z-index:99;"></div>

<h4 id="2-pandas统计每行的个数"><a href="#2-pandas统计每行的个数" class="headerlink" title="2. pandas统计每行的个数"></a>2. pandas统计每行的个数</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">zero_col_count = <span class="hljs-built_in">dict</span>(df[<span class="hljs-number">0</span>].value_counts())<span class="hljs-comment">#统计第0列元素的值的个数</span><br>three_row_count = <span class="hljs-built_in">dict</span>(df.loc[<span class="hljs-number">3</span>].value_counts())<span class="hljs-comment">#统计第3行元素的值的个数</span><br></code></pre></td></tr></table></figure>



<p><a href="https://mingsrc.work/player/">🎵我喜欢的音乐-Ming</a></p>
<h4 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a>3. 全局变量</h4><ol>
<li><p>global</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">i = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">a,b</span>):</span><br>    <span class="hljs-keyword">global</span> i<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第&#x27;</span>+i+<span class="hljs-string">&#x27;次计算&#x27;</span>)<br>    <span class="hljs-keyword">return</span> a+b<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(add(i,i+<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-pandas中apply列的输入输出"><a href="#4-pandas中apply列的输入输出" class="headerlink" title="4. pandas中apply列的输入输出"></a>4. pandas中apply列的输入输出</h4><ol>
<li><p>1  to 1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">judge</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>df[<span class="hljs-string">&#x27;new_col&#x27;</span>] = df[<span class="hljs-string">&#x27;exist_col&#x27;</span>].apply(judge)<br></code></pre></td></tr></table></figure></li>
<li><p>N to 1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">judge</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">if</span>(x[<span class="hljs-string">&#x27;old_col_1&#x27;</span>] &lt; <span class="hljs-number">10</span> &amp;&amp; x[<span class="hljs-string">&#x27;old_col_2&#x27;</span>] == <span class="hljs-string">&#x27;boy&#x27;</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;child&#x27;</span><br>df[<span class="hljs-string">&#x27;new_col&#x27;</span>] = df.apply(judge,axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li>
<li><p>1 to N</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">就是针对输出的三行写三个函数即可，或者使用<span class="hljs-keyword">lambda</span>分别处理就行<br>df_test = pd.DataFrame([<br>    &#123;<span class="hljs-string">&#x27;dir&#x27;</span>: <span class="hljs-string">&#x27;/Users/uname1&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-number">994933</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;dir&#x27;</span>: <span class="hljs-string">&#x27;/Users/uname2&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>: <span class="hljs-number">109338711</span>&#125;,<br>])<br><br>df_test[<span class="hljs-string">&#x27;size_kb&#x27;</span>] = df_test[<span class="hljs-string">&#x27;size&#x27;</span>].astype(<span class="hljs-built_in">int</span>).apply(<span class="hljs-keyword">lambda</span> x: locale.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%.1f&quot;</span>, x / <span class="hljs-number">1024.0</span>, grouping=<span class="hljs-literal">True</span>) + <span class="hljs-string">&#x27; KB&#x27;</span>)<br>df_test[<span class="hljs-string">&#x27;size_mb&#x27;</span>] = df_test[<span class="hljs-string">&#x27;size&#x27;</span>].astype(<span class="hljs-built_in">int</span>).apply(<span class="hljs-keyword">lambda</span> x: locale.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%.1f&quot;</span>, x / <span class="hljs-number">1024.0</span> ** <span class="hljs-number">2</span>, grouping=<span class="hljs-literal">True</span>) + <span class="hljs-string">&#x27; MB&#x27;</span>)<br>df_test[<span class="hljs-string">&#x27;size_gb&#x27;</span>] = df_test[<span class="hljs-string">&#x27;size&#x27;</span>].astype(<span class="hljs-built_in">int</span>).apply(<span class="hljs-keyword">lambda</span> x: locale.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%.1f&quot;</span>, x / <span class="hljs-number">1024.0</span> ** <span class="hljs-number">3</span>, grouping=<span class="hljs-literal">True</span>) + <span class="hljs-string">&#x27; GB&#x27;</span>)<br><br>df_test<br><br><br>             <span class="hljs-built_in">dir</span>       size       size_kb   size_mb size_gb<br><span class="hljs-number">0</span>  /Users/uname1     <span class="hljs-number">994933</span>      <span class="hljs-number">971.6</span> KB    <span class="hljs-number">0.9</span> MB  <span class="hljs-number">0.0</span> GB<br><span class="hljs-number">1</span>  /Users/uname2  <span class="hljs-number">109338711</span>  <span class="hljs-number">106</span>,<span class="hljs-number">776.1</span> KB  <span class="hljs-number">104.3</span> MB  <span class="hljs-number">0.1</span> GB<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-删除空值"><a href="#5-删除空值" class="headerlink" title="5. 删除空值"></a>5. 删除空值</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">cond = df.isnull().<span class="hljs-built_in">any</span>(axis = <span class="hljs-number">1</span>)<br>index = df[cond].index<br>df2 = df.drop(labels=index)<br></code></pre></td></tr></table></figure>

<h4 id="6-根据条件删除值"><a href="#6-根据条件删除值" class="headerlink" title="6. 根据条件删除值"></a>6. 根据条件删除值</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">cond = (df &lt; <span class="hljs-number">60</span>).<span class="hljs-built_in">any</span>(axis=<span class="hljs-number">1</span>)<br>index = df[cond].index<br>df3 = df.drop[labels=index]<br></code></pre></td></tr></table></figure>

<h4 id="7-规范化到-0-1"><a href="#7-规范化到-0-1" class="headerlink" title="7. 规范化到[0,1]"></a>7. 规范化到<code>[0,1]</code></h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> preprocessing<br><span class="hljs-comment"># 规范化到 [0,1] 空间</span><br>min_max_scaler=preprocessing.MinMaxScaler()<br>car_x=min_max_scaler.fit_transform(car_x)<br>pd.DataFrame(car_x).to_csv(<span class="hljs-string">&#x27;temp.csv&#x27;</span>, index=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(car_x)<br></code></pre></td></tr></table></figure>



<div style="display:box;float:right;"><img src="https://cdn.jsdelivr.net/gh/fole-del/img/tempImage1622112659415-1622112665508.gif" style="zoom:50%;"></div>

<h4 id="8-pandas删除行、列"><a href="#8-pandas删除行、列" class="headerlink" title="8. pandas删除行、列"></a>8. pandas删除行、列</h4><ul>
<li>删除行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 按行名指定</span><br><span class="hljs-built_in">print</span>(df.drop(<span class="hljs-string">&#x27;Charlie&#x27;</span>, axis=<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(df.drop(<span class="hljs-string">&#x27;Charlie&#x27;</span>))<br><span class="hljs-built_in">print</span>(df.drop(index=<span class="hljs-string">&#x27;Charlie&#x27;</span>))<br><span class="hljs-comment">## 一次删除多行</span><br><span class="hljs-built_in">print</span>(df.drop([<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-string">&#x27;Frank&#x27;</span>]))<br><span class="hljs-built_in">print</span>(df.drop(index=[<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-string">&#x27;Frank&#x27;</span>]))<br><span class="hljs-comment"># 按行号指定</span><br><span class="hljs-built_in">print</span>(df.index[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]])<br><span class="hljs-built_in">print</span>(df.drop(df.index[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]]))<br><span class="hljs-built_in">print</span>(df.drop(index=df.index[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]]))<br></code></pre></td></tr></table></figure>



<ul>
<li>删除列</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  按列名指定</span><br><span class="hljs-built_in">print</span>(df.drop(<span class="hljs-string">&#x27;state&#x27;</span>, axis=<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(df.drop(columns=<span class="hljs-string">&#x27;state&#x27;</span>))<br><span class="hljs-comment">## 一次删除多行</span><br><span class="hljs-built_in">print</span>(df.drop([<span class="hljs-string">&#x27;state&#x27;</span>, <span class="hljs-string">&#x27;point&#x27;</span>], axis=<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(df.drop(columns=[<span class="hljs-string">&#x27;state&#x27;</span>, <span class="hljs-string">&#x27;point&#x27;</span>]))<br><span class="hljs-comment"># 按列号指定</span><br><span class="hljs-built_in">print</span>(df.columns[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]])<br><span class="hljs-built_in">print</span>(df.drop(df.columns[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]], axis=<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(df.drop(columns=df.columns[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]))<br></code></pre></td></tr></table></figure>

<ul>
<li>删除多行多列</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.drop(index=[<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-string">&#x27;Frank&#x27;</span>],<br>              columns=[<span class="hljs-string">&#x27;state&#x27;</span>, <span class="hljs-string">&#x27;point&#x27;</span>]))<br><br><span class="hljs-built_in">print</span>(df.drop(index=df.index[[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]],<br>              columns=df.columns[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]))<br><br>df_org = df.copy()<br>df_org.drop(index=[<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Dave&#x27;</span>, <span class="hljs-string">&#x27;Frank&#x27;</span>],<br>            columns=[<span class="hljs-string">&#x27;state&#x27;</span>, <span class="hljs-string">&#x27;point&#x27;</span>], inplace=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>

<div style="display:flex;float:right"><img src="https://cdn.jsdelivr.net/gh/fole-del/img/tempImage1622194258914.gif" style="zoom:50%;border-radius:20px;"></div>

<h4 id="9-删除缺失值的行"><a href="#9-删除缺失值的行" class="headerlink" title="9. 删除缺失值的行"></a>9. 删除缺失值的行</h4><br>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df = df[~df[<span class="hljs-string">&#x27;col&#x27;</span>].isnull()]<br></code></pre></td></tr></table></figure>

<h4 id="10-删除索引"><a href="#10-删除索引" class="headerlink" title="10. 删除索引"></a>10. 删除索引</h4><p>在读取的时候不要读取索引列！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">qs = pd.read_excel(<span class="hljs-string">&#x27;./2018-QS-World-University-Rankings-Top200.xlsx&#x27;</span>,index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>

<h4 id="11-matplotlib画图"><a href="#11-matplotlib画图" class="headerlink" title="11. matplotlib画图"></a>11. matplotlib画图</h4><p><a href="https://blog.csdn.net/ICERON/article/details/80069680">看这个就完事了</a></p>
<h4 id="12-你问我怎么添加图例"><a href="#12-你问我怎么添加图例" class="headerlink" title="12. 你问我怎么添加图例"></a>12. 你问我怎么添加图例</h4><h4 id="13-设置行的索引为一列"><a href="#13-设置行的索引为一列" class="headerlink" title="13. 设置行的索引为一列"></a>13. 设置行的索引为一列</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">data[<span class="hljs-string">&#x27;user_geohash&#x27;</span>] = data._stat_axis.values.tolist() <span class="hljs-comment"># 行名称</span><br></code></pre></td></tr></table></figure>

<h4 id="14-pandas修改列名"><a href="#14-pandas修改列名" class="headerlink" title="14. pandas修改列名"></a>14. pandas修改列名</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df1.rename(columns=&#123;<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-string">&#x27;D&#x27;</span>&#125;,inplace=<span class="hljs-literal">True</span>) <br></code></pre></td></tr></table></figure>

<h4 id="15-pandas修改列顺序"><a href="#15-pandas修改列顺序" class="headerlink" title="15. pandas修改列顺序"></a>15. pandas修改列顺序</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">order = [<span class="hljs-string">&#x27;date&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;high&#x27;</span>, <span class="hljs-string">&#x27;low&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;volumefrom&#x27;</span>, <span class="hljs-string">&#x27;volumeto&#x27;</span>]<br>df = df[order]<br></code></pre></td></tr></table></figure>

<img src="https://gitee.com/fole-del/img/raw/master/20210614062947.png" alt="来了姐妹" style="zoom:50%;">

<h4 id="16-pandas获取指定列中某个值（范围）所属的行"><a href="#16-pandas获取指定列中某个值（范围）所属的行" class="headerlink" title="16. pandas获取指定列中某个值（范围）所属的行"></a>16. pandas获取指定列中某个值（范围）所属的行</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df[df[<span class="hljs-string">&#x27;colName&#x27;</span>].isin([left,right])]<br></code></pre></td></tr></table></figure>



<h4 id="17-pandas合并表"><a href="#17-pandas合并表" class="headerlink" title="17. pandas合并表"></a>17. pandas合并表</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df.join()<br>pd.conact()<br>df.merge()<br></code></pre></td></tr></table></figure>

<h4 id="18-三目运算符"><a href="#18-三目运算符" class="headerlink" title="18. 三目运算符"></a>18. 三目运算符</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = b <span class="hljs-keyword">if</span> b &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">else</span> c<br></code></pre></td></tr></table></figure>

<h4 id="19-查看列名"><a href="#19-查看列名" class="headerlink" title="19. 查看列名"></a>19. 查看列名</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">~~~<br><br><span class="hljs-comment">#### 20. 添加说明</span><br><br></code></pre></td></tr></table></figure>
<p>plt.annotate(s=’’,xy = (6,30),xytext = (8,32),arrowprops={‘arrowstyle’:’-&gt;’})</p>
<pre><code>

</code></pre>
]]></content>
  </entry>
  <entry>
    <title>python 读取Json文件</title>
    <url>/posts/c54b070b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="解析Json的常见代码"><a href="#解析Json的常见代码" class="headerlink" title="解析Json的常见代码"></a>解析Json的常见代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json <span class="hljs-comment"># 导入json解析需要的包</span><br></code></pre></td></tr></table></figure>

<h3 id="1-json-loads-读取字符串到json-object"><a href="#1-json-loads-读取字符串到json-object" class="headerlink" title="1. json.loads()读取字符串到json object"></a>1. <code>json.loads()</code>读取字符串到<code>json object</code></h3><p><code>json.loads()</code>是将<code>str\bytes\bytearray</code>等格式的文件读取到<code>json object</code>中。但是在使用的时候往往会因为一些小问题导致读取错误等。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Docstring:<br>Deserialize &#96;&#96;s&#96;&#96; (a &#96;&#96;str&#96;&#96;, &#96;&#96;bytes&#96;&#96; or &#96;&#96;bytearray&#96;&#96; instance<br>containing a JSON document) to a Python object.<br><br>&#96;&#96;object_hook&#96;&#96; is an optional function that will be called with the<br>result of any object literal decode (a &#96;&#96;dict&#96;&#96;). The return value of<br>&#96;&#96;object_hook&#96;&#96; will be used instead of the &#96;&#96;dict&#96;&#96;. This feature<br>can be used to implement custom decoders (e.g. JSON-RPC class hinting).<br><br>&#96;&#96;object_pairs_hook&#96;&#96; is an optional function that will be called with the<br>result of any object literal decoded with an ordered list of pairs.  The<br>return value of &#96;&#96;object_pairs_hook&#96;&#96; will be used instead of the &#96;&#96;dict&#96;&#96;.<br>This feature can be used to implement custom decoders.  If &#96;&#96;object_hook&#96;&#96;<br>is also defined, the &#96;&#96;object_pairs_hook&#96;&#96; takes priority.<br><br>&#96;&#96;parse_float&#96;&#96;, if specified, will be called with the string<br>of every JSON float to be decoded. By default this is equivalent to<br>float(num_str). This can be used to use another datatype or parser<br>for JSON floats (e.g. decimal.Decimal).<br><br>&#96;&#96;parse_int&#96;&#96;, if specified, will be called with the string<br>of every JSON int to be decoded. By default this is equivalent to<br>int(num_str). This can be used to use another datatype or parser<br>for JSON integers (e.g. float).<br><br>&#96;&#96;parse_constant&#96;&#96;, if specified, will be called with one of the<br>following strings: -Infinity, Infinity, NaN.<br>This can be used to raise an exception if invalid JSON numbers<br>are encountered.<br><br>To use a custom &#96;&#96;JSONDecoder&#96;&#96; subclass, specify it with the &#96;&#96;cls&#96;&#96;<br>kwarg; otherwise &#96;&#96;JSONDecoder&#96;&#96; is used.<br></code></pre></td></tr></table></figure>
</blockquote>
<p><b><span style="class: faa-bounce animated-hover;border-bottom: 5px solid #8F81EF;"><a href="https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA">data.json文件链接</a></span></b></p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA">https://pan.baidu.com/s/1omzU65YMpJr0jPPFItZ7SA</a><br>提取码：ysly<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p>
</blockquote>
<p>上述文件相对常见的Json文件来说，还是有点区别的，用python的json库操作相对有点困难。</p>
<p>报错<code>Expection \，delimiter</code>，看了好些解决办法仍然没能成功解决：<i id="1"></i></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 常见的Json读取</span><br>JsonText = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.json&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment"># 打开data.json</span><br>Json = JsonText.readlines() <span class="hljs-comment"># 把json中的文件全部读取到Json对象中。</span><br><br><br><br><span class="hljs-comment"># 读取上述data.json为json对象的代码</span><br>list_data = <span class="hljs-built_in">list</span>()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_Json_file</span>(<span class="hljs-params">i,x</span>):</span><br>    <span class="hljs-comment"># 返回有效的Json字段</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;行:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(x)<br>    <span class="hljs-comment"># 关于expectint的报错，我这处理就是但凡报错，直接返回空字段，如果你有别的解决办法，一定指教一下，不胜感激</span><br>    <span class="hljs-keyword">try</span>:<br>        JsonStr = x.replace(<span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&#x27;&quot;&#x27;</span>).replace(<span class="hljs-string">&#x27;/ &#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>).replace(<span class="hljs-string">&#x27;, &#x27;</span>,<span class="hljs-string">&#x27;,&#x27;</span>)<br>        ret = json.loads(JsonStr,strict=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">except</span> json.JSONDecodeError:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span><br>        <br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;categories&#x27;</span> <span class="hljs-keyword">in</span> ret):<br>        <span class="hljs-built_in">print</span>(ret[<span class="hljs-string">&#x27;categories&#x27;</span>])<br>        <span class="hljs-keyword">return</span> ret[<span class="hljs-string">&#x27;categories&#x27;</span>]<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span><br>    <br>list_data = <span class="hljs-built_in">list</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(Json)):<br>	list_data.append(read_Json_file(<span class="hljs-built_in">str</span>(i+<span class="hljs-number">1</span>),Json[i]))<br></code></pre></td></tr></table></figure>

<h3 id="2-常见错误及解决办法"><a href="#2-常见错误及解决办法" class="headerlink" title="2. 常见错误及解决办法"></a>2. 常见错误及解决办法</h3><div class="tabs" id="tab-hide"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tab-hide-1">描述</button></li><li class="tab"><button type="button" data-href="#tab-hide-2">解决办法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tab-hide-1"><p>Json文件的单双引号不对，如下所示Python中的一个<code>str</code>，Json中的<code>Key值</code>都是用单引号<code>&#39;</code>括起来的，就会报错<code>Expecting property name enclosed in double quotes</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;&#123;&#x27;asin&#x27;: &#x27;0000032069&#x27;, &#x27;title&#x27;: &#x27;Adult Ballet Tutu Cheetah Pink&#x27;, &#x27;price&#x27;: 7.89, &#x27;imUrl&#x27;: &#x27;http://ecx.images-amazon.com/images/I/51EzU6quNML._SX342_.jpg&#x27;, &#x27;related&#x27;: &#123;&#x27;also_bought&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;0000032034&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00EXVN9PU&#x27;, &#x27;B0041EOTJO&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B001GTKPDQ&#x27;, &#x27;B00EON0SJ2&#x27;, &#x27;B005HMHOQ4&#x27;, &#x27;B002XZMGGQ&#x27;], &#x27;also_viewed&#x27;: [&#x27;B00D0F450I&#x27;, &#x27;0000032050&#x27;, &#x27;B00D2JTMS2&#x27;, &#x27;0000032042&#x27;, &#x27;B004PYEE8G&#x27;, &#x27;B00JHNSNSM&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;B00D2JSRFQ&#x27;, &#x27;B00D0FCQQI&#x27;, &#x27;B00D2JRWWA&#x27;, &#x27;B003AVNY6I&#x27;, &#x27;B0071KR2LC&#x27;, &#x27;B00GOR07RE&#x27;, &#x27;B00D0FIIJM&#x27;, &#x27;B005F50FXC&#x27;, &#x27;B0079MCIMU&#x27;, &#x27;B00D0FDUAY&#x27;, &#x27;B00H3RYN3I&#x27;, &#x27;B005C4Y4F6&#x27;, &#x27;B007IEFT84&#x27;, &#x27;B00D0D5F6S&#x27;, &#x27;B002BZX8Z6&#x27;, &#x27;B00JHONN1S&#x27;, &#x27;B008F0SU0Y&#x27;, &#x27;B00FNNFXAG&#x27;, &#x27;B007R2RM8W&#x27;, &#x27;B007VM3AMK&#x27;, &#x27;B00C0PLENA&#x27;, &#x27;B00BJGG6VG&#x27;, &#x27;B00E1YRI4C&#x27;, &#x27;B00IIK61WA&#x27;, &#x27;B009UC638W&#x27;, &#x27;B00KZN6RVI&#x27;, &#x27;B00CSFEENY&#x27;, &#x27;B002GZGI4E&#x27;, &#x27;B00HSOJJ94&#x27;, &#x27;B00LIPP4VG&#x27;, &#x27;B009RXWNSI&#x27;, &#x27;B00E87F196&#x27;, &#x27;B005HMHOQY&#x27;, &#x27;B00J6S9MSS&#x27;, &#x27;0000032034&#x27;, &#x27;B00CJQGNJK&#x27;, &#x27;B008FCA0F0&#x27;, &#x27;B0056LG7GY&#x27;, &#x27;B00DPQWCZ2&#x27;, &#x27;B00I3PV0US&#x27;, &#x27;B00KZN6IVW&#x27;, &#x27;B0054TBWKO&#x27;, &#x27;B00I2S01I8&#x27;, &#x27;B00BXF12P8&#x27;, &#x27;B00GVHU678&#x27;, &#x27;B005NWENGC&#x27;, &#x27;B003AVKOP2&#x27;, &#x27;B00JK8MQ4Q&#x27;, &#x27;B00FZIMVQS&#x27;, &#x27;B008BB19VE&#x27;, &#x27;B00GTEXPOE&#x27;, &#x27;B009WPT2RQ&#x27;, &#x27;B00E37SBBG&#x27;], &#x27;bought_together&#x27;: [&#x27;0000032050&#x27;, &#x27;B00D0DJAEG&#x27;, &#x27;0000032042&#x27;, &#x27;B00D0F450I&#x27;]&#125;, &#x27;brand&#x27;: &#x27;BubuBibi&#x27;, &#x27;categories&#x27;: [[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]]&#125;&quot;</span><br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab-hide-2"><p>替换掉<code>str</code>中的<code>&#39;</code>为<code>&quot;</code>，替换<code>/_（空格）</code>为<code>/</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">text.replace(<span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&#x27;&quot;&#x27;</span>).replace(<span class="hljs-string">&#x27;/ &#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>)<br></code></pre></td></tr></table></figure>



<p>再接着读取就不会报错了！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">JsonValue[<span class="hljs-string">&#x27;categories&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">[[&#x27;Sports &amp; Outdoors&#x27;, &#x27;Other Sports&#x27;, &#x27;Dance&#x27;, &#x27;Clothing&#x27;, &#x27;Girls&#x27;, &#x27;Skirts&#x27;]]<br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<div class="tabs" id="tab-hide1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tab-hide1-1">描述</button></li><li class="tab"><button type="button" data-href="#tab-hide1-2">问题解决</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tab-hide1-1"><p>这个问题真的被搞得头疼，到目前还没解决，<code>Json</code>字段是没有问题的，但是<code>loads()函数</code>就是会报错</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab-hide1-2"><p><a href="#1">解决办法</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>python</category>
        <category>应用实例</category>
      </categories>
      <tags>
        <tag>python应用实例</tag>
      </tags>
  </entry>
  <entry>
    <title>根据地名获取经纬度</title>
    <url>/posts/2a450757.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本文是通过调用百度开放平台的API实现的经纬度查询。因此在使用前需要你去注册一个应用。</p>
</blockquote>
<h1 id="相关步骤"><a href="#相关步骤" class="headerlink" title="相关步骤"></a>相关步骤</h1><ol>
<li>打开链接</li>
</ol>
<p><a href="https://lbsyun.baidu.com/apiconsole/key#/home">百度地图开放平台</a></p>
<ol start="2">
<li>创建应用</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/image-20210523093840891.png" alt="创建应用"></p>
<ol start="3">
<li>获取AK</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/image-20210523094102002.png" alt="获取AK"></p>
<ol start="4">
<li>替换程序中的AK，运行就能得到返回的JSON字符串</li>
</ol>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure>

<ol>
<li>数据准备</li>
</ol>
<p>CSV文件中有一列是<code>city</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df = pd.DataFrame()<br>df = pd.read_csv(<span class="hljs-string">r&#x27;./city.csv&#x27;</span>,encoding=<span class="hljs-string">&quot;gbk&quot;</span>)<br>df[<span class="hljs-string">&#x27;city&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p>得到的数据如下所示，总共有一百条：</p>
<pre><code>0      昆山市
1      江阴市
2     张家港市
3      晋江市
4      常熟市
      ... 
95     福安市
96     射阳县
97     邹平县
98     海城市
99     青州市
Name: city, Length: 100, dtype: object
</code></pre>
<div>
<style scoped>.dataframe tbody tr th:only-of-type { vertical-align: middle;}
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>user_geohash</th>
      <th>num</th>
      <th>city</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>94ek6ke</td>
      <td>1028</td>
      <td>昆山市</td>
    </tr>
    <tr>
      <th>1</th>
      <td>94ek6lj</td>
      <td>980</td>
      <td>江阴市</td>
    </tr>
    <tr>
      <th>2</th>
      <td>94ek6lw</td>
      <td>919</td>
      <td>张家港市</td>
    </tr>
    <tr>
      <th>3</th>
      <td>94ek6kn</td>
      <td>908</td>
      <td>晋江市</td>
    </tr>
    <tr>
      <th>4</th>
      <td>94ek6l5</td>
      <td>517</td>
      <td>常熟市</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>95</th>
      <td>9q0ltaw</td>
      <td>243</td>
      <td>福安市</td>
    </tr>
    <tr>
      <th>96</th>
      <td>99s4avh</td>
      <td>242</td>
      <td>射阳县</td>
    </tr>
    <tr>
      <th>97</th>
      <td>9519pwt</td>
      <td>240</td>
      <td>邹平县</td>
    </tr>
    <tr>
      <th>98</th>
      <td>94jrlp3</td>
      <td>240</td>
      <td>海城市</td>
    </tr>
    <tr>
      <th>99</th>
      <td>946hodd</td>
      <td>240</td>
      <td>青州市</td>
    </tr>
  </tbody>
</table>
<p>100 rows × 3 columns</p></div>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">showLocation&amp;&amp;showLocation(&#123;&quot;status&quot;:0,&quot;result&quot;:&#123;&quot;location&quot;:&#123;&quot;lng&quot;:120.98745249794995,&quot;lat&quot;:31.390863425081866&#125;,&quot;precise&quot;:0,&quot;confidence&quot;:20,&quot;comprehension&quot;:100,&quot;level&quot;:&quot;区县&quot;&#125;&#125;)<br>showLocation&amp;&amp;showLocation(&#123;&quot;status&quot;:0,&quot;result&quot;:&#123;&quot;location&quot;:&#123;&quot;lng&quot;:120.29156800752115,&quot;lat&quot;:31.926044909769045&#125;,&quot;precise&quot;:0,&quot;confidence&quot;:20,&quot;comprehension&quot;:100,&quot;level&quot;:&quot;区县&quot;&#125;&#125;)<br>showLocation&amp;&amp;showLocation(&#123;&quot;status&quot;:0,&quot;result&quot;:&#123;&quot;location&quot;:<br></code></pre></td></tr></table></figure>

<hr>
<p>因为使用的是API，因此得到是上述的Json字符串。</p>
<p>代码如下：</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_ll</span>(<span class="hljs-params">x</span>):</span><br>    Post_url = <span class="hljs-string">&quot;http://api.map.baidu.com/geocoding/v3/?address=&quot;</span> + x + <span class="hljs-string">&quot;&amp;output=json&amp;ak=（百度API开放平台获取的AK）&amp;callback=showLocation&quot;</span> <span class="hljs-comment">#自己想办法弄到key</span><br>    Post_data = &#123;<br>        <span class="hljs-string">&#x27;address&#x27;</span>: x<br>    &#125;<br>    Text = se.post(Post_url, data=Post_data).text.replace(<span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&#x27;&quot;&#x27;</span>).replace(<span class="hljs-string">&#x27;/ &#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">27</span>:-<span class="hljs-number">1</span>] <span class="hljs-comment"># 提取为Json格式，去掉‘showLocation&amp;&amp;showLocation()’这些额外的字符</span><br>    jsonValue = json.loads(Text) <span class="hljs-comment"># 转化为Json对象</span><br>    <span class="hljs-comment"># print(jsonValue) # 打印Json值</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;result&#x27;</span> <span class="hljs-keyword">in</span> jsonValue):<br>        <span class="hljs-built_in">print</span>(jsonValue[<span class="hljs-string">&#x27;result&#x27;</span>][<span class="hljs-string">&#x27;location&#x27;</span>][<span class="hljs-string">&#x27;lng&#x27;</span>])<br>        <span class="hljs-keyword">return</span> [jsonValue[<span class="hljs-string">&#x27;result&#x27;</span>][<span class="hljs-string">&#x27;location&#x27;</span>][<span class="hljs-string">&#x27;lng&#x27;</span>],jsonValue[<span class="hljs-string">&#x27;result&#x27;</span>][<span class="hljs-string">&#x27;location&#x27;</span>][<span class="hljs-string">&#x27;lat&#x27;</span>]]<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span><br>    <br>address = df[<span class="hljs-string">&#x27;city&#x27;</span>].apply(calc_ll)<br>se = requests.session()<br></code></pre></td></tr></table></figure>

<pre><code>&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.98745249794995, &#39;lat&#39;: 31.390863425081864&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.98745249794995
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.29156800752115, &#39;lat&#39;: 31.926044909769043&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.29156800752115
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.56155363871446, &#39;lat&#39;: 31.88114053634028&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.56155363871446
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.55843052000408, &#39;lat&#39;: 24.787824575144548&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
118.55843052000408
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.75949588665195, &#39;lat&#39;: 31.65953827674108&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.75949588665195
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.27259613631863, &#39;lat&#39;: 30.175256610720446&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
121.27259613631863
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.83160603216115, &#39;lat&#39;: 31.342956624267874&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.83160603216115
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.08755916595523, &#39;lat&#39;: 28.251818487944462&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
113.08755916595523
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.08158099305928, &#39;lat&#39;: 29.31114987541007&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.08158099305928
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.13559529350024, &#39;lat&#39;: 31.464599352977785&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
121.13559529350024
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.64939823850789, &#39;lat&#39;: 28.169832216070507&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
113.64939823850789
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 110.50542966826288, &#39;lat&#39;: 38.848544495220935&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
110.50542966826288
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.18843649817478, &#39;lat&#39;: 31.87361172603022&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
121.18843649817478
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.80341550029883, &#39;lat&#39;: 25.03694981503913&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
118.80341550029883
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.25340833196779, &#39;lat&#39;: 29.714934649194955&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.25340833196779
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 106.4075265551776, &#39;lat&#39;: 27.797752158542853&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
106.4075265551776
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.39257197205464, &#39;lat&#39;: 24.966362350467605&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
118.39257197205464
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 112.55840691564445, &#39;lat&#39;: 28.284104536209348&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
112.55840691564445
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.57946558109177, &#39;lat&#39;: 32.37785148610902&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.57946558109177
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.9925018561657, &#39;lat&#39;: 28.118179995228274&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.9925018561657
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.39046524748903, &#39;lat&#39;: 25.72634329903456&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.39046524748903
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.16058507482123, &#39;lat&#39;: 30.042734639570824&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
121.16058507482123
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.66347374677267, &#39;lat&#39;: 31.81423284964318&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
121.66347374677267
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.03953537126692, &#39;lat&#39;: 36.27034908804922&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.03953537126692
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.47443309577918, &#39;lat&#39;: 32.53919574424043&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.47443309577918
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.61250060471407, &#39;lat&#39;: 32.01592027416992&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.61250060471407
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.39258889457587, &#39;lat&#39;: 28.377655489850408&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
121.39258889457587
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.05859939046078, &#39;lat&#39;: 32.17747402371212&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.05859939046078
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.48536852807433, &#39;lat&#39;: 37.65255512549617&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.48536852807433
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.19243791023843, &#39;lat&#39;: 32.33587288615511&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
121.19243791023843
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 115.95046017276752, &#39;lat&#39;: 28.551604186108275&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
115.95046017276752
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.68656506738283, &#39;lat&#39;: 30.51792376977565&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.68656506738283
&#123;&#39;status&#39;: 1, &#39;msg&#39;: &#39;Internal Service Error:无相关结果&#39;, &#39;results&#39;: []&#125;
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.66158218606775, &#39;lat&#39;: 27.783950736231652&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.66158218606775
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.28353203592053, &#39;lat&#39;: 31.988170075210594&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.28353203592053
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.57154315530762, &#39;lat&#39;: 30.63631118771037&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.57154315530762
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.0191233013022, &#39;lat&#39;: 34.34464551932591&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
118.0191233013022
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.70645736056483, &#39;lat&#39;: 40.00418392493125&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
118.70645736056483
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 104.03757322351338, &#39;lat&#39;: 30.648477494759213&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 75, &#39;comprehension&#39;: 0, &#39;level&#39;: &#39;购物&#39;&#125;&#125;
104.03757322351338
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.32653706475246, &#39;lat&#39;: 32.872716312488244&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.32653706475246
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 122.49250463073764, &#39;lat&#39;: 37.171317939253235&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
122.49250463073764
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.65451902647484, &#39;lat&#39;: 24.737665160882703&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
118.65451902647484
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.98563754334361, &#39;lat&#39;: 39.63274074738802&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
121.98563754334361
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.85751406137442, &#39;lat&#39;: 32.917824213889254&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.85751406137442
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.44960935856369, &#39;lat&#39;: 30.33358775114635&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;城市&#39;&#125;&#125;
113.44960935856369
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 111.24639840545701, &#39;lat&#39;: 39.87054026503683&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
111.24639840545701
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.46561561653884, &#39;lat&#39;: 32.787147020528316&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.46561561653884
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 112.9054740908161, &#39;lat&#39;: 30.40835793241892&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;城市&#39;&#125;&#125;
112.9054740908161
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.01440416129005, &#39;lat&#39;: 35.40752093244999&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
117.01440416129005
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.16455781372443, &#39;lat&#39;: 31.712962132716886&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
117.16455781372443
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.02843100495258, &#39;lat&#39;: 34.754096888696935&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
113.02843100495258
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 116.94258562390337, &#39;lat&#39;: 34.76515195541547&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
116.94258562390337
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.19146705795117, &#39;lat&#39;: 32.27809048316069&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.19146705795117
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.7974153748082, &#39;lat&#39;: 36.86192174647094&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
118.7974153748082
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.49522360557991, &#39;lat&#39;: 34.14826652246125&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
113.49522360557991
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.17256521920983, &#39;lat&#39;: 35.120034809573916&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
117.17256521920983
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.13848201812112, &#39;lat&#39;: 26.156035214577336&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.13848201812112
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 109.75459043995566, &#39;lat&#39;: 39.570092815192666&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
109.75459043995566
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.74643447195358, &#39;lat&#39;: 34.40176637910559&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
113.74643447195358
&#123;&#39;status&#39;: 1, &#39;msg&#39;: &#39;Internal Service Error:无相关结果&#39;, &#39;results&#39;: []&#125;
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 112.77847075950989, &#39;lat&#39;: 32.13472991431875&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
112.77847075950989
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 86.18149430993829, &#39;lat&#39;: 41.7323732214122&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
86.18149430993829
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.43643177294247, &#39;lat&#39;: 29.294317441105566&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
121.43643177294247
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.91749832197264, &#39;lat&#39;: 31.0325793268347&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.91749832197264
&#123;&#39;status&#39;: 1, &#39;msg&#39;: &#39;Internal Service Error:无相关结果&#39;, &#39;results&#39;: []&#125;
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 112.60858070620743, &#39;lat&#39;: 35.072907226846525&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;城市&#39;&#125;&#125;
112.60858070620743
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.36153652101795, &#39;lat&#39;: 34.37561095463685&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
118.36153652101795
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.9944142939757, &#39;lat&#39;: 36.78269225408944&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.9944142939757
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 113.39739094909922, &#39;lat&#39;: 34.54589798344474&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
113.39739094909922
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.44060165264568, &#39;lat&#39;: 37.36113714256612&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.44060165264568
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 111.456515837124, &#39;lat&#39;: 30.38440427431352&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
111.456515837124
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.94859307736998, &#39;lat&#39;: 37.18263660907421&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.94859307736998
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.17543320290359, &#39;lat&#39;: 31.950923490521372&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.17543320290359
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.4335951222883, &#39;lat&#39;: 27.523066788446513&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.4335951222883
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.2484219279141, &#39;lat&#39;: 29.295861065150863&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.2484219279141
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 114.21051607638233, &#39;lat&#39;: 36.70248828627979&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
114.21051607638233
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 122.97449548262718, &#39;lat&#39;: 39.686956078878055&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
122.97449548262718
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.41640221866636, &#39;lat&#39;: 36.00200885807568&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.41640221866636
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.77460624826666, &#39;lat&#39;: 35.9146198665876&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
117.77460624826666
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.26472938795023, &#39;lat&#39;: 23.0309091042802&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 25, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;乡镇&#39;&#125;&#125;
120.26472938795023
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 116.1724489811672, &#39;lat&#39;: 23.30363452186039&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
116.1724489811672
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 114.72642585137605, &#39;lat&#39;: 22.991443112002415&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
114.72642585137605
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 114.98643626401979, &#39;lat&#39;: 30.10166780010339&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
114.98643626401979
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 104.47858183931757, &#39;lat&#39;: 25.715651258076416&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
104.47858183931757
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.23851297084417, &#39;lat&#39;: 28.14186298682908&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
121.23851297084417
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 116.45556614759954, &#39;lat&#39;: 33.93480147585089&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
116.45556614759954
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 116.1056050954973, &#39;lat&#39;: 38.717348630774524&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
116.1056050954973
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.17356009256213, &#39;lat&#39;: 32.483722623763164&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
117.17356009256213
&#123;&#39;status&#39;: 1, &#39;msg&#39;: &#39;Internal Service Error:无相关结果&#39;, &#39;results&#39;: []&#125;
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 121.02257525525401, &#39;lat&#39;: 30.682240998057836&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
121.02257525525401
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.41349864392043, &#39;lat&#39;: 37.059638498906146&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
118.41349864392043
&#123;&#39;status&#39;: 1, &#39;msg&#39;: &#39;Internal Service Error:无相关结果&#39;, &#39;results&#39;: []&#125;
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.93251060584033, &#39;lat&#39;: 30.83712219382042&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.93251060584033
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 114.29657265142765, &#39;lat&#39;: 23.178805592432578&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
114.29657265142765
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 103.72553503682038, &#39;lat&#39;: 36.10975375497273&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
103.72553503682038
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 119.65440636047963, &#39;lat&#39;: 27.094323508059915&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
119.65440636047963
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 120.26444564891948, &#39;lat&#39;: 33.78101359213001&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
120.26444564891948
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 117.74947848721935, &#39;lat&#39;: 36.8700322166973&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
117.74947848721935
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 109.12452136754654, &#39;lat&#39;: 21.481065838235963&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
109.12452136754654
&#123;&#39;status&#39;: 0, &#39;result&#39;: &#123;&#39;location&#39;: &#123;&#39;lng&#39;: 118.48653672086745, &#39;lat&#39;: 36.690416508705376&#125;, &#39;precise&#39;: 0, &#39;confidence&#39;: 20, &#39;comprehension&#39;: 100, &#39;level&#39;: &#39;区县&#39;&#125;&#125;
118.48653672086745
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">address<br></code></pre></td></tr></table></figure>




<pre><code>0     [120.98745249794995, 31.390863425081864]
1     [120.29156800752115, 31.926044909769043]
2      [120.56155363871446, 31.88114053634028]
3     [118.55843052000408, 24.787824575144548]
4      [120.75949588665195, 31.65953827674108]
                        ...                   
95    [119.65440636047963, 27.094323508059915]
96     [120.26444564891948, 33.78101359213001]
97      [117.74947848721935, 36.8700322166973]
98    [109.12452136754654, 21.481065838235963]
99    [118.48653672086745, 36.690416508705376]
Name: city, Length: 100, dtype: object
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">address<br></code></pre></td></tr></table></figure>




<pre><code>1     [120.29156800752115, 31.926044909769043]
2      [120.56155363871446, 31.88114053634028]
3     [118.55843052000408, 24.787824575144548]
4      [120.75949588665195, 31.65953827674108]
5     [121.27259613631863, 30.175256610720446]
                        ...                   
94     [103.72553503682038, 36.10975375497273]
95    [119.65440636047963, 27.094323508059915]
96     [120.26444564891948, 33.78101359213001]
97      [117.74947848721935, 36.8700322166973]
98    [109.12452136754654, 21.481065838235963]
Name: city, Length: 98, dtype: object
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;pos&#x27;</span>] = df1 <span class="hljs-comment"># 保存到df文件中</span><br></code></pre></td></tr></table></figure>






<div><style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>user_geohash</th>
      <th>num</th>
      <th>city</th>
      <th>pos</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>94ek6ke</td>
      <td>1028</td>
      <td>昆山市</td>
      <td>[120.98745249794995, 31.390863425081864]</td>
    </tr>
    <tr>
      <th>1</th>
      <td>94ek6lj</td>
      <td>980</td>
      <td>江阴市</td>
      <td>[120.29156800752115, 31.926044909769043]</td>
    </tr>
    <tr>
      <th>2</th>
      <td>94ek6lw</td>
      <td>919</td>
      <td>张家港市</td>
      <td>[120.56155363871446, 31.88114053634028]</td>
    </tr>
    <tr>
      <th>3</th>
      <td>94ek6kn</td>
      <td>908</td>
      <td>晋江市</td>
      <td>[118.55843052000408, 24.787824575144548]</td>
    </tr>
    <tr>
      <th>4</th>
      <td>94ek6l5</td>
      <td>517</td>
      <td>常熟市</td>
      <td>[120.75949588665195, 31.65953827674108]</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>95</th>
      <td>9q0ltaw</td>
      <td>243</td>
      <td>福安市</td>
      <td>[119.65440636047963, 27.094323508059915]</td>
    </tr>
    <tr>
      <th>96</th>
      <td>99s4avh</td>
      <td>242</td>
      <td>射阳县</td>
      <td>[120.26444564891948, 33.78101359213001]</td>
    </tr>
    <tr>
      <th>97</th>
      <td>9519pwt</td>
      <td>240</td>
      <td>邹平县</td>
      <td>[117.74947848721935, 36.8700322166973]</td>
    </tr>
    <tr>
      <th>98</th>
      <td>94jrlp3</td>
      <td>240</td>
      <td>海城市</td>
      <td>[109.12452136754654, 21.481065838235963]</td>
    </tr>
    <tr>
      <th>99</th>
      <td>946hodd</td>
      <td>240</td>
      <td>青州市</td>
      <td>[118.48653672086745, 36.690416508705376]</td>
    </tr>
  </tbody>
</table>
<p>100 rows × 4 columns</p></div>


<h2 id="计算两者之间的距离"><a href="#计算两者之间的距离" class="headerlink" title="计算两者之间的距离"></a>计算两者之间的距离</h2><p>在得到相关地名的经纬度之后，进一步就是根据经纬度，输入的是度数（°）</p>
<hr>
<p>根据经纬度计算实际距离的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br>Earth_Radius=<span class="hljs-number">6378.137</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sin_square</span>(<span class="hljs-params">a</span>):</span><br>    result=math.sin(a)<br>    <span class="hljs-keyword">return</span> result*result<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rad</span>(<span class="hljs-params">ang</span>):</span><br>    <span class="hljs-keyword">return</span> math.pi*ang/<span class="hljs-number">180.0</span><br><span class="hljs-comment">#a,b参数是数组</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distance_calculate</span>(<span class="hljs-params">a,b</span>):</span><br>    lata,lnga=a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>]<br>    latb,lngb=b[<span class="hljs-number">0</span>],b[<span class="hljs-number">1</span>]<br><br>    radlata,radlnga=rad(lata),rad(lnga)<br>    radlatb, radlngb = rad(latb), rad(lngb)<br><br>    <span class="hljs-comment">#纬度差</span><br>    minus_a=radlata-radlatb<br>    <span class="hljs-comment">#经度差</span><br>    minus_b=radlnga-radlngb<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*math.asin( math.sqrt(sin_square(minus_a/<span class="hljs-number">2</span>) + math.cos(radlata)*math.cos(radlatb)*sin_square(minus_b/<span class="hljs-number">2</span>)))*Earth_Radius<br><br><span class="hljs-comment">#坐标测试</span><br><span class="hljs-comment">#google</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1000</span>*distance_calculate((<span class="hljs-number">30.26848247</span>,<span class="hljs-number">119.9499548338</span>),(<span class="hljs-number">30.2688658749</span>,<span class="hljs-number">119.9628533571</span>)))<br><span class="hljs-comment">#baidu</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1000</span>*distance_calculate((<span class="hljs-number">30.274671</span>,<span class="hljs-number">119.969392</span>),(<span class="hljs-number">30.274261</span>,<span class="hljs-number">119.956631</span>)))<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>python</category>
        <category>应用实例</category>
      </categories>
      <tags>
        <tag>python应用实例</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy使用案例</title>
    <url>/posts/1df7a3e4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>python</category>
        <category>python数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML图片位置相关设置</title>
    <url>/posts/d047e518.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTML-img标签"><a href="#HTML-img标签" class="headerlink" title="HTML  img标签"></a>HTML  img标签</h1><h2 id="1-相关属性"><a href="#1-相关属性" class="headerlink" title="1. 相关属性"></a>1. 相关属性</h2><ul>
<li><input disabled type="checkbox"> </li>
</ul>
<h2 id="2-CSS案例"><a href="#2-CSS案例" class="headerlink" title="2. CSS案例"></a>2. CSS案例</h2><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">&lt;style&gt;<span class="hljs-selector-class">.b-game-card</span>&#123;<span class="hljs-attribute">position</span>:relative;<span class="hljs-attribute">z-index</span>:<span class="hljs-number">1</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">50%</span>;<span class="hljs-attribute">padding-bottom</span>:<span class="hljs-number">150%</span>;<span class="hljs-attribute">perspective</span>:<span class="hljs-number">1000px</span>&#125;<span class="hljs-selector-class">.b-game-card</span>&#123;<span class="hljs-attribute">position</span>:relative;<span class="hljs-attribute">z-index</span>:<span class="hljs-number">1</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<span class="hljs-attribute">padding-bottom</span>:<span class="hljs-number">150%</span>;<span class="hljs-attribute">perspective</span>:<span class="hljs-number">1000px</span>&#125;<span class="hljs-selector-class">.b-game-card__cover</span>&#123;<span class="hljs-attribute">position</span>:absolute;<span class="hljs-attribute">z-index</span>:<span class="hljs-number">1</span>;<span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;<span class="hljs-attribute">overflow</span>:hidden;<span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">120deg</span>,<span class="hljs-number">#f6d365</span> <span class="hljs-number">0</span>,<span class="hljs-number">#fda085</span> <span class="hljs-number">100%</span>);<span class="hljs-attribute">background-size</span>:cover;<span class="hljs-attribute">perspective-origin</span>:<span class="hljs-number">50%</span> <span class="hljs-number">50%</span>;<span class="hljs-attribute">transform-style</span>:preserve-<span class="hljs-number">3</span>d;<span class="hljs-attribute">transform-origin</span>:top center;will-change:transform;<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">skewX</span>(<span class="hljs-number">0.001deg</span>);<span class="hljs-attribute">transition</span>:transform .<span class="hljs-number">35s</span> ease-in-out&#125;<span class="hljs-selector-class">.b-game-card__cover</span><span class="hljs-selector-pseudo">::after</span>&#123;<span class="hljs-attribute">display</span>:block;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-attribute">position</span>:absolute;<span class="hljs-attribute">z-index</span>:<span class="hljs-number">100</span>;<span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">120%</span>;<span class="hljs-attribute">background</span>:<span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">226deg</span>,<span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.4</span>) <span class="hljs-number">0</span>,<span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.4</span>) <span class="hljs-number">35%</span>,<span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.2</span>) <span class="hljs-number">42%</span>,<span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>) <span class="hljs-number">60%</span>);<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateY</span>(-<span class="hljs-number">20%</span>);will-change:transform;<span class="hljs-attribute">transition</span>:transform .<span class="hljs-number">65s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.18</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">0.58</span>,<span class="hljs-number">1</span>)&#125;<span class="hljs-selector-class">.b-game-card</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.b-game-card__cover</span>&#123;<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">rotateX</span>(<span class="hljs-number">7deg</span>) <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">6px</span>)&#125;<span class="hljs-selector-class">.b-game-card</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.b-game-card__cover</span><span class="hljs-selector-pseudo">::after</span>&#123;<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateY</span>(<span class="hljs-number">0%</span>)&#125;<span class="hljs-selector-class">.b-game-card</span><span class="hljs-selector-pseudo">::before</span>&#123;<span class="hljs-attribute">display</span>:block;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-attribute">position</span>:absolute;<span class="hljs-attribute">top</span>:<span class="hljs-number">5%</span>;<span class="hljs-attribute">left</span>:<span class="hljs-number">5%</span>;<span class="hljs-attribute">width</span>:<span class="hljs-number">90%</span>;<span class="hljs-attribute">height</span>:<span class="hljs-number">90%</span>;<span class="hljs-attribute">background</span>:<span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<span class="hljs-attribute">box-shadow</span>:<span class="hljs-number">0</span> <span class="hljs-number">6px</span> <span class="hljs-number">12px</span> <span class="hljs-number">12px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.4</span>);will-change:opacity;<span class="hljs-attribute">transform-origin</span>:top center;<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">skewX</span>(<span class="hljs-number">0.001deg</span>);<span class="hljs-attribute">transition</span>:transform .<span class="hljs-number">35s</span> ease-in-out,opacity .<span class="hljs-number">5s</span> ease-in-out&#125;<span class="hljs-selector-class">.b-game-card</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">::before</span>&#123;<span class="hljs-attribute">opacity</span>:.<span class="hljs-number">6</span>;<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">rotateX</span>(<span class="hljs-number">7deg</span>) <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">6px</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.05</span>)&#125;&lt;/style&gt;<br></code></pre></td></tr></table></figure>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><style>.b-game-card{position:relative;z-index:1;width:50%;padding-bottom:150%;perspective:1000px}.b-game-card{position:relative;z-index:1;width:100%;padding-bottom:150%;perspective:1000px}.b-game-card__cover{position:absolute;z-index:1;top:0;left:0;width:100%;height:100%;overflow:hidden;background-image:linear-gradient(120deg,#f6d365 0,#fda085 100%);background-size:cover;perspective-origin:50% 50%;transform-style:preserve-3d;transform-origin:top center;will-change:transform;transform:skewX(0.001deg);transition:transform .35s ease-in-out}.b-game-card__cover::after{display:block;content:"";position:absolute;z-index:100;top:0;left:0;width:100%;height:120%;background:linear-gradient(226deg,rgba(255,255,255,0.4) 0,rgba(255,255,255,0.4) 35%,rgba(255,255,255,0.2) 42%,rgba(255,255,255,0) 60%);transform:translateY(-20%);will-change:transform;transition:transform .65s cubic-bezier(0.18,0.9,0.58,1)}.b-game-card:hover .b-game-card__cover{transform:rotateX(7deg) translateY(-6px)}.b-game-card:hover .b-game-card__cover::after{transform:translateY(0%)}.b-game-card::before{display:block;content:"";position:absolute;top:5%;left:5%;width:90%;height:90%;background:rgba(0,0,0,0.5);box-shadow:0 6px 12px 12px rgba(0,0,0,0.4);will-change:opacity;transform-origin:top center;transform:skewX(0.001deg);transition:transform .35s ease-in-out,opacity .5s ease-in-out}.b-game-card:hover::before{opacity:.6;transform:rotateX(7deg) translateY(-6px) scale(1.05)}</style>

<div class="b-game-card">
        <div class="b-game-card__cover" style="background-image:url(https://cdn.jsdelivr.net/gh/fole-del/img/game_3.jpg);zoom:50%;"></div>
    </div>
]]></content>
      <categories>
        <category>学习笔记，前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>函数指针与指针函数</title>
    <url>/posts/a4d65dab.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数指针和指针函数"><a href="#函数指针和指针函数" class="headerlink" title="函数指针和指针函数"></a>函数指针和指针函数</h1><p>参考了@<a href="https://blog.csdn.net/luoyayun361/article/details/80428882">函数指针和指针函数用法和区别_luoyayun361的专栏-CSDN博客_指针函数</a></p>
<blockquote>
<ul>
<li>指针函数：简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>;<br>            <br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">Data</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>&#125;Data;<br>             <br><span class="hljs-comment">//指针函数</span><br><span class="hljs-function">Data* <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    Data * data = <span class="hljs-keyword">new</span> Data;<br>    data-&gt;a = a;<br>    data-&gt;b = b;<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br>             <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    <span class="hljs-comment">//调用指针函数</span><br>    Data * myData = <span class="hljs-built_in">f</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;f(4,5) = &quot;</span> &lt;&lt; myData-&gt;a &lt;&lt; myData-&gt;b;<br>             <br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>函数指针：其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*fun)(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y);                  <br>    <span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x-y;<br>&#125;<br><span class="hljs-comment">//函数指针</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*fun)(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y);<br>                     <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    <span class="hljs-comment">//第一种写法</span><br>    fun = add;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;(*fun)(1,2) = &quot;</span> &lt;&lt; (*fun)(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) ;<br>   	<span class="hljs-comment">//第二种写法</span><br>    fun = &amp;sub;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;(*fun)(5,3) = &quot;</span> &lt;&lt; (*fun)(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)  &lt;&lt; <span class="hljs-built_in">fun</span>(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)；<br>                     <br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果你对这两个概念的区分不是很清晰也可以这么记：</p>
<p>指针函数与整型函数一样，都是返回一个东西，不同的是指针函数返回的是一个指针。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++易混点</tag>
      </tags>
  </entry>
  <entry>
    <title>易混点😖：函数指针与指针函数</title>
    <url>/posts/3e98108d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数指针与指针函数"><a href="#函数指针与指针函数" class="headerlink" title="函数指针与指针函数"></a>函数指针与指针函数</h1>]]></content>
  </entry>
  <entry>
    <title>我|❤️</title>
    <url>/posts/f2745b45.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><style>body {background:white}
    h1.post-title{color:red;}div#post {
    background: fixed;
    color: antiquewhite;
}.meta {
    background: black;
    width: fit-content;
    padding-right: 10px;
    border-radius: 50px;
    filter: drop-shadow(2px 4px 6px black);
}
.meta p {
    color: white;
}
div.timenode .body {
    margin: 14px 0 16px 24px;
}
</style>
<script>var t2 = window.setInterval(function () {
        divMe.className = imglist[index];
        index++;
        index %= imglist.length;
        console.log('每隔5秒钟执行一次')    }, 5000)</script>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=33756016&auto=0&height=66"></iframe>

<div class="timeline"><p class="p h2">2021</p> 

<div class="timenode"><div class="meta"><p></p><p>2021-04-02 从今天开始啦</p>
<p></p></div><div class="body"><p><span style="text-align:center;font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;">“ 既许一人以偏爱，愿尽余生之慷慨 ”</span></p></div></div>

<div class="timenode"><div class="meta"><p></p><p>2021-04-02 闲着就容易犯愁</p>
<p></p></div><div class="body"><p><span class="animated-hover" style="font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;">“ 如果运气不行那就试试勇气 ”</span></p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210403154845.jpg" style="zoom: 25%; border-radius: 50px;"></div></div>

<div class="timenode"><div class="meta"><p></p><p>2021-05-17 营养</p>
<p></p></div><div class="body"><p><span class="faa-passing-reverse animated-hover" style="font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;">“ 你说，营养是什么！ ”</span></p></div></div>

<div class="timenode"><div class="meta"><p></p><p>2021-10-25 DAY100</p>
<p></p></div><div class="body"><p><span class="faa-passing-reverse animated-hover" style="font-size:20px;font:30px 汉仪尚巍手书简;color:blueviolent;word-spacing:30px;">“ One For You ”</span></p></div></div>

</div>

]]></content>
  </entry>
  <entry>
    <title>Hexo 搭建博客</title>
    <url>/posts/b6159bfb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用hexo搭建博客"><a href="#使用hexo搭建博客" class="headerlink" title="使用hexo搭建博客"></a>使用hexo搭建博客</h1><p>首先安装</p>
<ul>
<li><a href="https://npm.taobao.org/mirrors/node">Node.js Mirror</a><ul>
<li><a href="https://www.cnblogs.com/jianguo221/p/11487532.html">Node.js安装教程</a></li>
</ul>
</li>
<li><a href="https://git-scm.com/download/win">Git - Downloading Package</a></li>
</ul>
<hr>
]]></content>
  </entry>
  <entry>
    <title>痕迹</title>
    <url>/posts/252a5848.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="“M-Y-L-I-F-E”"><a href="#“M-Y-L-I-F-E”" class="headerlink" title="“M Y L I F E”"></a><span style="text-align:center;font-size:20px;font:30px 书体坊兰亭体;color:blueviolent;word-spacing:30px;">“M Y L I F E”</span></h1><div class="timeline"><p class="p h2">2021</p> 


<div class="timenode"><div class="meta"><p></p><p>2021-03-18</p>
<p></p></div><div class="body"><p><u><a href="https://www.cnblogs.com/fole-del/diary/2021/03/18/14556295.html">今天，该想的我都想了</a></u></p></div></div>

<div class="timenode"><div class="meta"><p></p><p>2021-05-14</p>
<p></p></div><div class="body"><p><u><a href="https://www.cnblogs.com/fole-del/diary/2021/05/14/14767918.html">“精神食粮”</a></u></p></div></div>

<div class="timenode"><div class="meta"><p></p><p>2021-05-17</p>
<p></p></div><div class="body"><p><u><a href="https://www.cnblogs.com/fole-del/diary/2021/05/17/14776258.html">“灵魂与肉体”</a></u></p></div></div>

<div class="timenode"><div class="meta"><p></p><p>2021-06-07</p>
<p></p></div><div class="body"><p>今天的苦算吃完了，明天的苦还远得很，这一夜的身心安适是向不属今明两天的中立时间里的躲避。</p><p><span style="align:left"> ——钱钟书《围城》</span></p><div class="note green icon modern"><i class="note-icon fas fa-key"></i><p>原来钱老的围城，可以把人世间的苦，说的这么遥远。</p></div></div></div>

<div class="timenode"><div class="meta"><p></p><p>2020-10-12</p>
<p></p></div><div class="body"><p>我希望有个如你一般的人，如山间清爽的风，如古城温暖的光，从清晨到夜晚，由山野到书房，只要最后是你就好。</p></div></div>

<div class="timenode"><div class="meta"><p></p><p>2020-10-20</p>
<p></p></div><div class="body"><p>说好了不再继续入坑，但是看了别人家的主页后······😂 😂 😂 </p></div></div>

<div class="timenode"><div class="meta"><p></p><p>2020-10-24</p>
<p></p></div><div class="body"><p>今天你不快乐的原因是因为什么？</p></div></div>

<div class="timenode"><div class="meta"><p></p><p>2020-12-14</p>
<p></p></div><div class="body"><p>也许，一个人要是想在茫茫人海中要保持一点独立性，那么他必须让自己显得古怪些才成。可我不喜欢这句话，最近实在是太烂了。</p></div></div>

<div class="timenode"><div class="meta"><p></p><p>2021-2-24</p>
<p></p></div><div class="body"><p>及时当勉励，岁月不待人。</p></div></div>



<div class="timenode"><div class="meta"><p></p><p>2021-10-27</p>
<p></p></div><div class="body"><p>见字如面，既爱又恨，那段时光</p></div></div>


</div>]]></content>
  </entry>
  <entry>
    <title>关于QByteArray中的URL编解码</title>
    <url>/posts/e35c7634.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关于Qt中的URL编解码的使用"><a href="#关于Qt中的URL编解码的使用" class="headerlink" title="关于Qt中的URL编解码的使用"></a>关于Qt中的URL编解码的使用</h1><p>QByteArray中的<code>toPercentEncoding</code>和<code>fromPercentEncoding</code>支持对URL的编解码工作。</p>
<hr>
<p>先看一下<code>toPercentEncoding</code>的官方文档。</p>
<p><img src="../../../images/toPercentEncoding()%E5%87%BD%E6%95%B0/image-20210316171016958.png" alt="toPercentEncoding"></p>
<p><img src="../../../images/toPercentEncoding()%E5%87%BD%E6%95%B0/image-20210316171000365.png" alt="翻译"></p>
<p>说明非常简单了。<code>fromPercentEncoding()</code>就刚好相反。说白了就是把你的这个输入转换为网址的格式。可以理解为URL编码的过程</p>
<p>demo：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">QByteArray text = &#123;<span class="hljs-string">&quot;http://www.baidu.com/s?ie=utf-8&amp;f=8&amp;tn=baidu&amp;wd=临时邮箱&quot;</span>&#125;;<br>QByteArray urlEncode = text.<span class="hljs-built_in">toPercentEncoding</span>();<br><span class="hljs-built_in">qDebug</span>(<span class="hljs-string">&quot;编码后&quot;</span>);<br><span class="hljs-built_in">qDebug</span>(urlEncode.<span class="hljs-built_in">constData</span>());<br><br>QByteArray urlDecode = QByteArray::<span class="hljs-built_in">fromPercentEncoding</span>(urlEncode);<br><span class="hljs-built_in">qDebug</span>(<span class="hljs-string">&quot;-------------------------------------------------&quot;</span>);        <br><span class="hljs-built_in">qDebug</span>(<span class="hljs-string">&quot;解码后&quot;</span>);    <br><span class="hljs-built_in">qDebug</span>(urlDecode.<span class="hljs-built_in">constData</span>());<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<div style="color:white;background:black;font-family:consolas">编码后：<br>http0.0000000.0000000.000000www.baidu.com0.000000s0.000000ie%3Dutf-8                  0.000000%3D8                          %3Dbaidu%26wd%3D5.185438E-3164%B8%B48.694087E-3156%97%B65.190920E-3169%820.000000E5.182199E-31670.000000E%B1<br>----------------------------------<br>解码后：<br>http://www.baidu.com/s?ie=utf-8&f=8&tn=baidu&wd=临时邮箱</div>

<hr>
<p>所以当你需要把解码后的网址作为数据发送或使用时就可以使用Encoding，需要解码URL的网址是就使用Decoding。</p>
]]></content>
      <categories>
        <category>Qt</category>
        <category>QByteArray</category>
      </categories>
  </entry>
  <entry>
    <title>线程demo</title>
    <url>/posts/e6507a53.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Demo-of-Thread"><a href="#Demo-of-Thread" class="headerlink" title="Demo of Thread"></a>Demo of Thread</h1><p>苦于每次写就忘的经历，我又写了一个简单的没有质量的Demo，因为太闲了，写完这篇就开始刷题吧</p>
<p>三个文件，<code>People.h</code>,<code>People.cpp</code>,<code>main.cpp</code>。三个文件，两样东西，一个是People的类，一个是main函数调用线程。</p>
<p>People头文件及cpp文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// profile: People头文件</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> constructTimes = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> copyTimes = <span class="hljs-number">0</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">People</span>(string str);<br>	<span class="hljs-built_in">People</span>(<span class="hljs-keyword">const</span> People &amp;mt);<br><br>	~<span class="hljs-built_in">People</span>();<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string str)</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startWork</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">endWork</span><span class="hljs-params">(<span class="hljs-keyword">int</span> e)</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calcWorkTime</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>	string m_name;<br>	<span class="hljs-keyword">int</span> m_start;<br>	<span class="hljs-keyword">int</span> m_end;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// profile: people.cpp文件</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;People.h&quot;</span></span><br><br>People::<span class="hljs-built_in">People</span>(string str) :<span class="hljs-built_in">m_name</span>(str)<br>&#123;<br>	constructTimes++;<br>	cout &lt;&lt; <span class="hljs-string">&quot;构造次数:&quot;</span> &lt;&lt; constructTimes &lt;&lt; endl;<br>&#125;<br>People::<span class="hljs-built_in">People</span>(<span class="hljs-keyword">const</span> People &amp;mt) : <span class="hljs-built_in">m_name</span>(mt.m_name)<br>&#123;<br>	copyTimes++;<br>	cout &lt;&lt; <span class="hljs-string">&quot;构造次数:&quot;</span> &lt;&lt; copyTimes &lt;&lt; endl;<br>&#125;<br>People::~<span class="hljs-built_in">People</span>()<br>&#123;<br>	cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_name &lt;&lt; <span class="hljs-string">&quot; 调用了析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">People::setName</span><span class="hljs-params">(string str)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;更换岗位开始,需等待片刻&quot;</span> &lt;&lt; endl;<br>	<span class="hljs-keyword">int</span> i;<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>	&#123;<br>		<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>);<br>		cout &lt;&lt; <span class="hljs-string">&quot;更换岗位ing……&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-keyword">this</span>-&gt;m_name = str;<br><br>	cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot; 设置工作成功,耗时&quot;</span>&lt;&lt; i &lt;&lt;<span class="hljs-string">&quot;S&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">People::startWork</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; m_name &lt;&lt; <span class="hljs-string">&quot; 开始工作,开始时间：&quot;</span> &lt;&lt; s &lt;&lt; endl;<br>	m_start = s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">People::endWork</span><span class="hljs-params">(<span class="hljs-keyword">int</span> e)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; m_name &lt;&lt; <span class="hljs-string">&quot; 结束工作,开始时间：&quot;</span> &lt;&lt; e &lt;&lt; endl;<br>	m_end = e;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">People::calcWorkTime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; m_name &lt;&lt; <span class="hljs-string">&quot; 的工作时长为：&quot;</span>;<br>	cout &lt;&lt; m_end - m_start &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主函数文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;People.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">People <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaa&quot;</span>)</span></span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;线程:&quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot;开始&quot;</span> &lt;&lt; endl;<br>	<span class="hljs-keyword">int</span> startTime = <span class="hljs-number">1</span>,endTime;<br>	People *p1ptr = &amp;p1;<br>	<span class="hljs-comment">// 这里如果使用的是p1,则允许setName函数内部修改值，但不会对外部影响			</span><br>	<span class="hljs-comment">// 使用std::ref()不会调用拷贝构造函数，因为std::ref是引用传递，函数内部的修改影响外面，这里传的必须是指针</span><br>	<span class="hljs-comment">// 使用 std::cref() 相当于 std::const ref(),const 引用传递，函数内部不能修改</span><br>	<span class="hljs-function">std::thread <span class="hljs-title">w1</span><span class="hljs-params">(&amp;People::setName, std::ref(p1ptr), <span class="hljs-string">&quot;bbb&quot;</span>)</span></span>;	<br>	<span class="hljs-function">std::thread <span class="hljs-title">w2</span><span class="hljs-params">(std::move(w1))</span></span>; <span class="hljs-comment">// 线程为w2开始运行setName,w1不再作为一个线程对象</span><br>	<span class="hljs-keyword">bool</span> w1Joinable = w1.<span class="hljs-built_in">joinable</span>();<br>	cout &lt;&lt; <span class="hljs-string">&quot;w1的joinable：&quot;</span> &lt;&lt; w1Joinable &lt;&lt; endl;<br>	w2.<span class="hljs-built_in">detach</span>(); <span class="hljs-comment">// detach 是脱离主线程，单独在一个线程中进行，屏幕输出就会乱序</span><br>				 <span class="hljs-comment">// w1.join() 是加入到线程</span><br><br><br>	cout &lt;&lt; <span class="hljs-string">&quot;-----------&quot;</span> &lt;&lt; endl;<br>	p1.<span class="hljs-built_in">startWork</span>(<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>	&#123;<br>		<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>);<br>		cout &lt;&lt; <span class="hljs-string">&quot;工作ing……&quot;</span> &lt;&lt; endl;<br>		endTime = i;<br>	&#125;<br>	p1.<span class="hljs-built_in">endWork</span>(endTime);<br>	p1.<span class="hljs-built_in">calcWorkTime</span>();<br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<div style="color:white;background:black;font-family:consolas">构造次数:1<br>
线程:17668开始<br>
更换岗位开始,需等待片刻w1的joinable：
0<br>
-----------<br>
aaa 开始工作,开始时间：1<br>
工作ing……<br>
更换岗位ing……<br>
更换岗位ing……<br>
工作ing……<br>
更换岗位ing……<br>
bbb 设置工作成功,耗时3S<br>
工作ing……<br>
工作ing……<br>
工作ing……<br>
bbb 结束工作,开始时间：4<br>
bbb 的工作时长为：3</div>

<p>因为是<code>detach()</code>的方式，因此更换岗位与工作是异步进行的。也就是这是两个单独的线程在进行。</p>
]]></content>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>git 测试文档</title>
    <url>/posts/3f6965b2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本文档用于记录git命令及其结果"><a href="#本文档用于记录git命令及其结果" class="headerlink" title="本文档用于记录git命令及其结果"></a>本文档用于记录git命令及其结果</h1><p>期间每执行一步就会在本文档记录，通过编写本文档以及使用<code>git</code>+<code>show log tag status</code>命令可以帮你更快了解git的工作原理。</p>
<h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir git_repost_test<br>cd git_repost_test<br>git init # 初始化文件<br>git remote add origin git@gitee.com:fole-del/git-command-test-project.git #与远程仓库连接<br>git pull --allow-unrelated-histories origin master # 从远程仓库拉文件初始化本地仓，本地仓=本地仓+远程仓<br>git commit -m &quot;fix(fole-del):添加了log记录文档&quot;<br>git tag V1.0 # 添加标签V1.0<br></code></pre></td></tr></table></figure>

<h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir setting #添加setting文件夹<br>cd setting #切换到setting文件夹<br>touch autoHooks.bat #添加批处理文件，可以使用vim编辑<br>vi autoHooks.bat<br>---------------------------- # 添加框内代码到autoHooks.bat<br>@echo off<br>set &quot;curDir=%cd%&quot;<br>echo -------------------------------<br>set &quot;curDir=%curDir:setting=%&quot;<br><br>set source=%cd%\commit-msg.sample<br>set dest=%curDir%.git\hooks\commit-msg<br>echo %source%<br>echo %dest%<br>copy &quot;%source%&quot; &quot;%dest%&quot;<br><br>echo -------------------------------<br><br>----------------------------<br><br>touch commit-msg #创建commit-msg文件<br><br>----------------------------- # 添加框内文件到commit-msg<br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>MSG=`awk &#x27;&#123;printf(&quot;%s&quot;,$0)&#125;&#x27; $1`<br>if [[ $MSG =~ ^(feat|fix|test|refactor|docs|style|chroe)\(.*\):.*$ ]]<br>then<br>	echo -e &quot;\033[32m commit success! \033[0m&quot;<br>else<br>    echo -e &quot;\033[31m Error: the commit message is irregular \033[m&quot;<br>	  echo -e &quot;\033[31m Error: type must be one of [feat,fix,docs,style,refactor,test,chore] \033[m&quot;<br>    echo -e &quot;\033[31m eg: feat(文件): add the user login \033[m&quot;<br>	exit 1<br>fi<br>-----------------------------<br><br>./autoHooks.bat # 执行批处理命令<br><br>git tag V1.01 # 因为配置了部署，加一个标签<br></code></pre></td></tr></table></figure>

<h2 id="使用develop分支开发"><a href="#使用develop分支开发" class="headerlink" title="使用develop分支开发"></a>使用develop分支开发</h2><p><a href="https://blog.csdn.net/u012726702/article/details/78038028">Git分支管理策略 develop分支_黄昏的大树-CSDN博客</a><i id="develop"></i></p>
<p>关于develop分支的介绍可以看上述链接的博客。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git checkout -b develop master # 从master分支创建develop分支并切换到develop分支<br>cd .. # 退到上一级<br>git add * # 把刚才创建的setting文件夹以及随时更改的本文档（log.md）添加到缓存区<br>git status # 查看本地仓库  该命令用于查看在你上次提交之后是否有对文件进行再次修改<br>git tags &quot;setting&quot; # 添加setting标签<br>git commit -m &quot;fix(setting):自动化部署&quot;<br>---------------------------------------------------<br><span class="hljs-meta">#</span><span class="bash"> 接下里合并develop分支到mastter分支</span><br>git checkout master #切换到master分支，此时文档变为创建develop分支时的状态<br>git merge --no-ff develop #此时应该会看到提示，并且log.md文档内容修改为你刚才在develop分支最后保存的状态<br>git push # 提交到远程仓库<br>git push origin --tags # 将本地的所有标签一次性提交到远程仓库<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210312184159.png" alt="仓库概况"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210312184201.png" alt="标签页面"></p>
<h2 id="使用feature分支"><a href="#使用feature分支" class="headerlink" title="使用feature分支"></a>使用feature分支</h2><p>关于feature分支不明白的可以看这篇文章<a href="#develop">柳暗花明又一村</a></p>
<p><u>之后的命令就会减少注释了，不懂得可以自己查阅</u></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git checkout develop<br>git checkout -b feature-sayHello develop<br>touch main.cpp<br>vi main.cpp	 # 随便写点什么都行<br>git add main.pp<br>git tag V1.02<br><span class="hljs-meta">#</span><span class="bash"> 删除分支</span><br>git branch -D develop<br><span class="hljs-meta">#</span><span class="bash"> 删除远程分支</span><br>git branch --delete develop<br></code></pre></td></tr></table></figure>

<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>在<code>feat</code>分支的<code>main.cpp</code>文件中添加一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">intConflit</span><span class="hljs-params">()</span></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;conflict testing&quot;</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>写完保存，然后执行git命令提交本次修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git add *<br>git commit -m <span class="hljs-string">&quot;merge test --conflit&quot;</span><br>git checkout master<br></code></pre></td></tr></table></figure>

<p>切换到<code>master</code>分支后也修改<code>main.cpp</code>文件，随便增加一个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testConflict</span><span class="hljs-params">()</span></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;测试conflict&quot;</span> &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;这里是增加了一行代码&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后也提交本次修改，再执行<code>merge</code>，来看一下<code>main.cpp</code>发生了什么变化：</p>
<p><code>feat分支</code>与<code>master分支</code>的修改合并了<u>HEAD下之后等号之前</u>显示当前分支代码的改变，<u>feat之前等号之后显示</u>的分支改变合并到当前分支的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/image-20210416092535633.png" alt="changed of main"></p>
<blockquote>
<p>这里推荐一个vscode的插件<code>GitLens</code>，借助插件可以选择保留<code>current change</code>|<code>incoming change</code>|<code>both change</code>|<code>compare change</code>，方便你分支的合并</p>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/image-20210416092935767.png" alt="GitLens"></p>
<ol>
<li>Current change</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/image-20210416093822746.png" alt="Current change"></p>
<ol>
<li>Incoming change</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/image-20210416093927959.png" alt="Incoming change"></p>
<ol>
<li>Both change</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/image-20210416093954472.png" alt="Both change"></p>
<ol>
<li>compare change</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/image-20210416093603416.png" alt="compare change"></p>
</blockquote>
<p>提交标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push origin v1.02<br><span class="hljs-comment"># 提交所有标签👇</span><br>git push origin tags<br></code></pre></td></tr></table></figure>





















]]></content>
  </entry>
  <entry>
    <title>自动化部署项目hook</title>
    <url>/posts/7b9b5177.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在研究如何更好使用<code>git log</code>的过程中，学习了很多非常强有力的技能，这些技能极大地方便了我们对项目的管理，更好、更加规范、更加流程的帮助我们管理一个项目从开发到维护的过程。😛</p>
<blockquote>
<p>看到一篇文章，讲了关于<code>git commit</code>的信息填写的格式进行规范。<a href="https://mp.weixin.qq.com/s/mbx4zih_idwpRuyex8B9mQ">git 的 hook 操作强大到难以置信，效率为王！</a></p>
<p>文章中还讲到了如何使用自动化部署对项目团队中每个人的<code>git commit</code>进行规范，闲来无事玩两下，借着这篇文章，我就开始了并不是自动化的“自动化”，简单的几句代码，却是几个小时的尝试，从sample到批处理命令的编写，都是泪啊~~~</p>
<blockquote>
<p>其中关于如何获取文件路径的尝试也是耗费不少时间，尝试几次之后才得以成功。</p>
</blockquote>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先列出期间我用到的几个网站，以便你操作的时候查阅相关的资料</p>
<ol>
<li><a href="https://www.w3cschool.cn/pclrmsc/">批处理入门手册_w3cschool</a>，w3c对于批处理的各个命令的解说挺详细的，但是排版太难看，实在是不忍下眼，但是作为手册，还是有参考的价值，“<u>环境变量延迟扩展</u>”一节对文件路径的修改与获取相对重要一点，可以先看一下。</li>
<li><a href="https://blog.csdn.net/weixin_30952103/article/details/99384339">批处理获取路径_weixin_30952103的博客-CSDN博客</a>，这篇博客对批处理中文你的bat文件在<code>e:/mybat/test.bat</code>,则<code>%0</code>就是<code>e:/mybat/test.bat</code>, <code>%~dp0</code>是<code>e:/mybat/</code>。</li>
</ol>
<h3 id="关于钩子（hooks）"><a href="#关于钩子（hooks）" class="headerlink" title="关于钩子（hooks）"></a><u>关于钩子（hooks）</u></h3><p>钩子都被存储在 Git 目录下的 <code>hooks</code> 子目录中。 也即绝大部分项目中的 <code>.git/hooks</code> 。 当你用 <code>git init</code> 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。 这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。 所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或任何你熟悉的语言编写它们。 这些示例的名字都是以 <code>.sample</code> 结尾，如果你想启用它们，得先移除这个后缀。</p>
<h2 id="sample文件"><a href="#sample文件" class="headerlink" title="sample文件"></a>sample文件</h2><p>在开头提及的那篇文章中关于<code>commit-msg</code>的代码已经有说明，感兴趣的同学可以自己去研究怎么写这个脚本。当然，除了<code>commit-msg</code>还有其他几个脚本用来规范你的项目部署。<code>git hooks</code>即git 钩子，都是以sample结尾的脚文件，存放在<code>.git/hooks</code>目录下。最终要做的事情也是将写好的脚本文件存放到hooks目录下。</p>
<p>如下图所示的smaple文件都可以通过自定义的形式实现相应的功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210310192937.png" alt="hooks文件说明"></p>
<p>这里添加一个我从不知名博客找到的一段<code>commit-msg</code>的代码行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br>MSG=`awk <span class="hljs-string">&#x27;&#123;printf(&quot;%s&quot;,$0)&#125;&#x27;</span> <span class="hljs-variable">$1</span>`<br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$MSG</span> =~ ^(feat|fix|<span class="hljs-built_in">test</span>|refactor|docs|style|chroe)\(.*\):.*$ ]]<br><span class="hljs-keyword">then</span><br>	<span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[32m commit success! \033[0m&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31m Error: the commit message is irregular \033[m&quot;</span><br>	  <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31m Error: type must be one of [feat,fix,docs,style,refactor,test,chore] \033[m&quot;</span><br>    <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31m eg: feat(user): add the user login \033[m&quot;</span><br>	<span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>



<h2 id="批处理命令"><a href="#批处理命令" class="headerlink" title="批处理命令"></a>批处理命令</h2><p>献上代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">rem autoSetHooks.bat<br>@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">set</span> <span class="hljs-string">&quot;curDir=%cd%&quot;</span><br><span class="hljs-built_in">set</span> <span class="hljs-string">&quot;curDir=%curDir:setting=%&quot;</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">source</span>=%<span class="hljs-built_in">cd</span>%\commit-msg.sample<br><span class="hljs-built_in">set</span> dest=%curDir%.git\hooks\commit-msg<br>copy <span class="hljs-string">&quot;%source%&quot;</span> <span class="hljs-string">&quot;%dest%&quot;</span><br></code></pre></td></tr></table></figure>

<p>虽然只有短短几行代码，但却费了我不少时间。唯一的功能也很简单，主要就是<code>copy</code>命令，将同路径下的<code>commit-msg.sample</code>拷贝到<code>.git\hooks\</code>路径下。</p>
<p>如果你看懂了批处理链接中关于环境变量延迟扩展，那么上述代码就是一个简单的Hello World~</p>
<p>如果你没看也无妨，关键的几句代码我会说明一下：</p>
<ol>
<li><code>set &quot;curDir=%cd%&quot;</code> 打开终端执行<code>cd</code>命令，屏幕输出和这里的<code>%cd%</code>是一致的，这句话的意思就是获取当前批处理程序的的路径保存到curDir变量中。</li>
<li>比较重要的一个操作就是<code>:</code>（冒号），在这里可以将<code>:A=B</code>理解为<code>replace(A,B)</code>，就是用B替换A。注：替换为空的话等号<code>=</code>后边就和第4行一样就行</li>
<li>确定source文件和destination之后执行copy命令就行。</li>
<li>最后，在clone项目到本地之后，找到上述批处理运行即可在<code>.git/hooks/</code>目录下生成<code>commit-msg.sample</code>文件。</li>
</ol>
<p>感觉我的做法不是很标准，应该是在程序编译期间自动执行bat命令最好，这样就不用去特意运行一下批处理命令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210315134203.png" alt="git提交规范说明"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令手册💪_从新建项目开始</title>
    <url>/posts/5487447e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>在写这篇文章期间发现了这么几个网站<a href="http://gitref.justjavac.com/">Git参考手册</a>、<a href="https://www.yiibai.com/git">Git教程™ (yiibai.com)</a>，希望对你的学习有所帮助</p>
</blockquote>
<h1 id="git-新建项目并提交远程仓库💪"><a href="#git-新建项目并提交远程仓库💪" class="headerlink" title="git_新建项目并提交远程仓库💪"></a>git_新建项目并提交远程仓库💪</h1><p>先从最简单的说起，新手如何快速的新建项目并提交到仓库，以及当你本地有项目时，如何与远程空仓链接。</p>
<ol>
<li><p>在本地项目所在文件夹执行<code>git init</code> 命令<code>--&gt;</code>会生成一个<code>.git</code>的隐藏文件夹</p>
</li>
<li><p>使用<code>git add file</code>命令将改变添加到<u>暂存区</u>，<code>git add *</code>是添加所有文件。</p>
</li>
<li><p>添加完毕后可以使用<code>git commit -m &quot;注释&quot;</code>将暂存区内容提交到仓库。如果已经关联了远程仓库，就可以执行<code>push</code>命令就行。如果是第一次为关联的情况，<u>则需要绑定仓库</u>。</p>
<ol>
<li><p>登录仓库并创建仓库，这一步的目的是为了获取一个仓库的<code>URL</code>或者<code>SSH</code>，用来和本地关联；</p>
</li>
<li><p>获取<code>SSH</code>之后就可以继续绑定了。执行<code>git remote add origin(远程仓库的别名，可以自己命名) ‘URL\SSH’</code>，就可以将本地与远程仓关联起来。</p>
</li>
<li><blockquote>
<p>但是这时候如果你在新建仓库时选择了初始化文件，就会导致本地和远程仓文件不一致，实际上尽管已经关联，但是还是两个单独的仓库，因此需要一些初始化操作让本地和远程同步。建议就是把远程仓的东西拉到本地。</p>
<p>执行<code>git pull origin master --allow-unrelated-histories</code>就可以把远程仓的东西拉到本地。</p>
</blockquote>
</li>
<li><p>将本地文件推送到远程仓库，使用<code>git push origin master</code>开始推送。</p>
<ol>
<li><code>git push</code>将当前分支推送至远程同名分支</li>
<li><code>git push origin [branch]:[branch]</code>推送本地某分支至远程某分支</li>
<li><code>git push -u origin [branch]:[branch]</code>推送本地某分支至远程某分支，并跟踪</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<p>当你查不多已经提交了几个项目之后，我想你就需要更多的一些使用方法帮助你更快的管理你的项目。以下是我在实际使用过程中的一些记录。仅供参考</p>
<hr>
<h1 id="git-log最强命令合集"><a href="#git-log最强命令合集" class="headerlink" title="git log最强命令合集"></a>git log最强命令合集</h1><p><code>git log</code>可以说是你在提交或者查看项目时比较常用的一个命令，方便你快速的查看日志，配合参数使用更强大。</p>
<p><a href="#id1">1. git log</a>、<a href="#id2">2. git log -n</a>、<a href="#id3">3. git log –start -n</a>、<a href="#id4">4. 指定日期、关键字、作者</a>、<a href="#id5">5. 查看某次commit做了哪些修改</a>、</p>
<p><a href="#id6">最强推荐版</a></p>
<p><i id="id1">1. git log</i></p>
<p>- 查看历史提交记录</p>
<p>不传入任何参数的默认情况下，<code>git log</code> 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><i id="id2">2. git log -n</i></p>
<p>如果不想向上面那样全部显示，可以选择显示前N条。</p>
<p><i id="id3">3. git log -start -n</i></p>
<p>显示简要的增改行数统计,每次提交文件的变更统计，-n 同上，前n条，可省略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210309104214.png" alt="gitlogstartn"></p>
<p><i id="id4">4. 指定日志、关键字、作者</i></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">如两天前的提交历史：git log --since&#x3D;2.days<br>如指定作者为&quot;BeginMan&quot;的所有提交:$ git log --author&#x3D;BeginMan<br>如指定关键字为“init”的所有提交：$ git log --grep&#x3D;init<br>如指定提交者为&quot;Jack&quot;的所有提交：$ git log --committer&#x3D;Jack<br>注意作者与提交者的关系：作者是程序的修改者，提交者是代码提交人。<br></code></pre></td></tr></table></figure>

<p>如指定2天前，作者为“BeginMan”的提交含有关键字’init’的前2条记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">git log --since&#x3D;2.days --author&#x3D;BeginMan --grep&#x3D;init -2<br></code></pre></td></tr></table></figure>

<p><i id="id5">5. 查看某次commit做了哪些修改</i></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">git log                       #查看commit的历史<br>git show &lt;commit-hash-id&gt;     #查看某次commit的修改内容<br></code></pre></td></tr></table></figure>



<hr>
<center><i id="id6" style="color:green;font-family:华文彩云;font-weight:900;font-size:100px">最强推荐版</i></center>

<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">git log --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date&#x3D;relative<br></code></pre></td></tr></table></figure>

<p>参考的stormZhang的教程：</p>
<p>效果炫酷，但是命令较长。但是，可以通过设置别名来使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">git config --global alias.lg &quot;log --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date&#x3D;relative&quot;<br></code></pre></td></tr></table></figure>

<p>设置别名之后就可以通过<code>git lg</code>来调用上述自定义语句了，感兴趣的猿猿可以自己了解一下。</p>
<hr>
<p>当然还有其他一些命令方便日志查询：</p>
<ol>
<li><code>git log --oneline</code></li>
<li><code>git log --stat</code></li>
<li><code>git log -p</code></li>
<li><code>git shortlog</code></li>
<li><code>git log --graph --oneline --decorate</code></li>
</ol>
<h2 id="git-branch常用命令"><a href="#git-branch常用命令" class="headerlink" title="git branch常用命令"></a>git branch常用命令</h2><ol>
<li><code>git branch</code> 查看本地所有分支</li>
<li><code>git branch -r</code> 查看远程所有分支 </li>
<li><code>git branch -a</code> 查看本地和远程的所有分支 </li>
<li><code>git branch &lt;branchname&gt;</code> 新建分支 </li>
<li><code>git branch -d &lt;branchname&gt;</code> 删除本地分支 </li>
<li><code>git branch -d -r &lt;branchname&gt;</code> 删除远程分支，删除后还需推送到服务器 </li>
<li><code>git push origin:&lt;branchname&gt;</code>  删除后推送至服务器 </li>
<li><code>git branch -m &lt;oldbranch&gt; &lt;newbranch&gt;</code> 重命名本地分支</li>
</ol>
<h3 id="分支补充"><a href="#分支补充" class="headerlink" title="分支补充"></a>分支补充</h3><ol>
<li><p><code>git checkout</code>命令用于切换分支或恢复工作树文件。<code>git checkout</code>是git最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。<br><strong>示例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git checkout master				 	#(1)<br>git checkout master~2 Makefile 		 #(2)<br>rm -f hello.c<br>git checkout hello.c				#(3)<br></code></pre></td></tr></table></figure>

<p>（1）切换分支、（2）从另一个提交中取出文件、（3）从索引中回复hello.c</p>
</li>
<li></li>
</ol>
<h2 id="git-常用命令-一"><a href="#git-常用命令-一" class="headerlink" title="git 常用命令 一"></a>git 常用命令 一</h2><ol>
<li><code>git show</code> 命令用于显示各种类型的对象</li>
<li><code>git push -u origin master -f</code> 强制推送</li>
</ol>
<h2 id="git-查看远程仓"><a href="#git-查看远程仓" class="headerlink" title="git 查看远程仓"></a>git 查看远程仓</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git remote -v<br></code></pre></td></tr></table></figure>





<h1 id="git-commit-emoji"><a href="#git-commit-emoji" class="headerlink" title="git commit emoji"></a>git commit emoji</h1><p>example:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git commit -m &quot;:tada: Initial commit&quot;<br></code></pre></td></tr></table></figure>

<p>|        emoji         |          emoji 代码           |         commit 说明          |<br>| :——————: | :—————————: | :————————–: | :–: |<br>|      🎨 (调色板)      |            <code>:art:</code>            |   改进代码结构 / 代码格式    |<br>|  ⚡️ (闪电) 🐎 (赛马)   |     <code>:zap:</code> <code>:racehorse:</code>     |           提升性能           |<br>|       🔥 (火焰)       |           <code>:fire:</code>            |        移除代码或文件        |<br>|       🐛 (bug)        |            <code>:bug:</code>            |           修复 bug           |<br>|      🚑 (急救车)      |         <code>:ambulance:</code>         |           重要补丁           |<br>|       ✨ (火花)       |         <code>:sparkles:</code>          |          引入新功能          |<br>|      📝 (备忘录)      |           <code>:memo:</code>            |           撰写文档           |<br>|       🚀 (火箭)       |          <code>:rocket:</code>           |           部署功能           |<br>|       💄 (口红)       |         <code>:lipstick:</code>          |      更新 UI 和样式文件      |<br>|       🎉 (庆祝)       |           <code>:tada:</code>            |           初次提交           |<br>|    ✅ (白色复选框)    |     <code>:white_check_mark:</code>      |           更新测试           |<br>|        🔒 (锁)        |           <code>:lock:</code>            |         修复安全问题         |<br>|       🍎 (苹果)       |           <code>:apple:</code>           |     修复 macOS 下的问题      |<br>|       🐧 (企鹅)       |          <code>:penguin:</code>          |     修复 Linux 下的问题      |<br>|       🏁 (旗帜)       |      <code>:checkered_flag:</code>       |    修复 Windows 下的问题     |<br>|     🤖（机器人）      |           <code>:robot:</code>           |    修复 Android 下的问题     |<br>|      🍏 (绿苹果)      |        <code>:green_apple:</code>        |      修复 iOS 下的问题       |<br>|       🔖 (书签)       |         <code>:bookmark:</code>          |       发行 / 版本标签        |<br>|      🚨 (警车灯)      |      <code>:rotating_light:</code>       |       移除 linter 警告       |<br>|       🚧 (施工)       |       <code>:construction:</code>        |          工作进行中          |<br>|       👷 (工人)       |    <code>:construction_worker:</code>    |       添加 CI 构建系统       |<br>|       💚 (绿心)       |        <code>:green_heart:</code>        |       修复 CI 构建问题       |<br>|     ⬆️ (上升箭头)     |         <code>:arrow_up:</code>          |           升级依赖           |<br>|     ⬇️ (下降箭头)     |        <code>:arrow_down:</code>         |           降级依赖           |<br>|       📌 (图钉)       |          <code>:pushpin:</code>          |    将依赖项固定到特定版本    |<br>|    📈 (上升趋势图)    | <code>:chart_with_upwards_trend:</code>  |      添加分析或跟踪代码      |<br>|      ♻️ （回收）      |          <code>:recycle:</code>          |           重构代码           |<br>|       🐳 (鲸鱼)       |           <code>:whale:</code>           |       Docker 相关工作        |<br>| 🌐 (带子午线的地球仪) |   <code>:globe_with_meridians:</code>    |        国际化与本地化        |<br>|       ➕ (加号)       |      <code>:heavy_plus_sign:</code>      |         增加一个依赖         |<br>|       ➖ (减号)       |     <code>:heavy_minus_sign:</code>      |         减少一个依赖         |<br>|       🔧 (扳手)       |          <code>:wrench:</code>           |         修改配置文件         |<br>|       🔨 (锤子)       |          <code>:hammer:</code>           |           重大重构           |<br>|       ✏️ (铅笔)       |          <code>:pencil2:</code>          |          修复 typo           |<br>|      💩 (粑粑…)       |          <code>:hankey:</code>           |     写了辣鸡代码需要优化     |<br>|       ⏪ (倒带)       |          <code>:rewind:</code>           |           恢复更改           |<br>|  🔀 (交叉向右的箭头)  | <code>:twisted_rightwards_arrows:</code> |           合并分支           |<br>|       📦 (包裹)       |          <code>:package:</code>          |      更新编译的文件或包      |<br>|      👽 (外星人)      |           <code>:alien:</code>           | 由于外部 API 更改而更新代码  |<br>|       🚚 (货车)       |           <code>:truck:</code>           |      移动或者重命名文件      |<br>|  📄 (正面朝上的页面)  |      <code>:page_facing_up:</code>       |      增加或更新许可证书      |<br>|       💥 (爆炸)       |           <code>:boom:</code>            |       引入突破性的变化       |<br>|       🍱 (铅笔)       |           <code>:bento:</code>           |        增加或更新资源        |<br>|     👌 (OK 手势)      |          <code>:ok_hand:</code>          |  由于代码审查更改而更新代码  |<br>|       ♿️ (轮椅)       |        <code>:wheelchair:</code>         |        改善无障碍交互        |<br>|       💡 (灯泡)       |           <code>:bulb:</code>            |        给代码添加注释        |<br>|       🍻 (啤酒)       |           <code>:beers:</code>           |       醉醺醺地写代码…        |<br>|     💬 (消息气泡)     |      <code>:speech_balloon:</code>       |         更新文本文档         |<br>|    🗃 (卡片文件盒)    |       <code>:card_file_box:</code>       |    执行与数据库相关的更改    |<br>|      🔊 (音量大)      |        <code>:loud_sound:</code>         |           增加日志           |<br>|       🔇 (静音)       |           <code>:mute:</code>            |           移除日志           |<br>|  👥 (轮廓中的半身像)  |    <code>:busts_in_silhouette:</code>    |          增加贡献者          |<br>|     🚸 (孩童通行)     |     <code>:children_crossing:</code>     |     优化用户体验、可用性     |<br>|     🏗 (建筑建造)     |   <code>:building_construction:</code>   |           结构变动           |<br>|      📱 (iPhone)      |          <code>:iphone:</code>           |         做响应式设计         |<br>|      🤡 (小丑脸)      |        <code>:clown_face:</code>         | 嘲弄事物（直译，这个没明白） |<br>|       🥚 (鸡蛋)       |            <code>:egg:</code>            |           增加彩蛋           |<br>|    🙈 (看不见邪恶)    |        <code>:see_no_evil:</code>        |     增加或更改 gitignore     |<br>|   📸 (照相机闪光灯)   |       <code>:camera_flash:</code>        |        增加或更新截图        |<br>|      ⚗️ (蒸馏器)      |          <code>:alembic:</code>          |          尝试新东西          |<br>|      🔍 (放大镜)      |            <code>:mag:</code>            |           SEO 优化           |<br>|    ☸️ (船的方向盘)    |      <code>:wheel_of_dharma:</code>      |    关于 Kubernetes 的工作    |<br>|       🏷 (标签)       |           <code>:label:</code>           | 增加类型（FLow、Typescript） |</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>proto 学习记录（闲了再写）</title>
    <url>/posts/3d271314.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="../../../images/proto%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/pic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<p>使用命令行生成proto文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">proto -I ./ --cpp_out=./ proto文件<br></code></pre></td></tr></table></figure>

<p><img src="../../../images/proto%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Net.png" alt="网络通信"></p>
]]></content>
  </entry>
  <entry>
    <title>用MarkDown画图,你敢想？</title>
    <url>/posts/227fcf6f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很早以前我就了解到了使用typora可以画图这件事，应该说是当我知道typora这个软件时，很大一部分程序上，typora这款软件极大的方便了我记录自己的学习笔记，发博客等，通过picGo，我可以方便快捷的使用github的免费存储空间。同时，我可以更快捷方便的通过hexo来发布我编辑的文章到我的博客。而当我了解到typora画图之后，似乎我又发现了新大陆，借此记录了自己学习typora画图的一些语法以及技巧，使用体验真的很好的画图软件——typora</p>
<p><a href="#lct">1.流程图</a></p>
<p><a href="#sxt">2.时序图</a></p>
<p><a href="#ztt">3.状态图</a></p>
<p><a href="#lt">4.类图</a></p>
<p><a href="#gtt">5.甘特图</a></p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图<a id="lct"></a></h2><p>语法解释：<code>graph</code> 关键字就是声明一张流程图，<code>TD</code> 表示的是方向，这里的含义是 Top-Down 由上至下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mermaid">graph LR;<br>	a[&quot;起点!&quot;]&#x3D;&#x3D;粗线带文字&#x3D;&#x3D;&gt;b;<br>	b&#123;菱形节点&#125;--&gt;c;<br>	a-.-虚线带文字-.-&gt;d((具有圆边的节点));<br>	b---|不带箭头的线|e;<br>	e--带箭头的线--&gt;f;<br>	c&gt;非对称形状]--&gt;e;<br>	d--实现特殊字符--&gt;g[&quot;特殊字符:#9829;&quot;];<br>	style a fill:lightblue,stroke:black,stroke-width:4px<br></code></pre></td></tr></table></figure>

<div class="mermaid">graph LR;
	a[&quot;起点!&quot;]&#x3D;&#x3D;粗线带文字&#x3D;&#x3D;&gt;b;
	b{菱形节点}--&gt;c;
	a-.-虚线带文字-.-&gt;d((具有圆边的节点));
	b---|不带箭头的线|e;
	e--带箭头的线--&gt;f;
	c&gt;非对称形状]--&gt;e;
	d--实现特殊字符--&gt;g[&quot;特殊字符:#9829;&quot;];
	style a fill:lightblue,stroke:black,stroke-width:4px
</div>



<h3 id="子图的语法规范"><a href="#子图的语法规范" class="headerlink" title="子图的语法规范"></a>子图的语法规范</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mermaid">graph TB<br>    c1--&gt;a2<br>    b1 --&gt; a<br>    subgraph one<br>    a1--&gt;a2<br>    end<br>    subgraph two<br>    b1--&gt;b2<br>    end<br>    subgraph three<br>    c1--&gt;c2<br>    end<br></code></pre></td></tr></table></figure>

<div class="mermaid">graph TB
    c1--&gt;a2
    subgraph one
    a1--&gt;a2
    end
    subgraph two
    b1--&gt;b2
    end
    subgraph three
    c1--&gt;c2
    end
</div>



<h3 id="样式链接"><a href="#样式链接" class="headerlink" title="样式链接"></a>样式链接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mermaid">graph LR<br>    id1(Start)--&gt;id2(Stop)<br>    style id1 fill:#f9f,stroke:#333,stroke-width:4px<br>    style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5<br></code></pre></td></tr></table></figure>

<div class="mermaid">graph LR
    id1(Start)--&gt;id2(Stop)
    style id1 fill:#f9f,stroke:#333,stroke-width:4px
    style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5
</div>

<h3 id="fontawesome"><a href="#fontawesome" class="headerlink" title="fontawesome"></a>fontawesome</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mermaid">graph TD<br>    B[&quot;fa:fa-twitter 和平&quot;]<br>    B--&gt;C[fa:fa-ban 禁止]<br>    B--&gt;D(fa:fa-spinner);<br>    B--&gt;E(A fa:fa-camera-retro 也许?);<br></code></pre></td></tr></table></figure>





<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图<a id="sxt"></a></h2><p>语法解释：<code>-&gt;&gt;</code> 代表实线箭头，<code>--&gt;&gt;</code> 则代表虚线。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>	Alice-&gt;&gt;Jhon: 你好啊！<br>	activate Jhon<br>	Jhon--&gt;&gt;+Alice: 你好，最近怎么样！<br>	deactivate Jhon	<br>	Alice-&gt;&gt;-Jhon: 挺好的，学了Typora画图，你呢？<br>	loop every minute<br>		note over Alice,Jhon:数秒之后~~~<br>	end<br>	par Jhon思考时间<br>		rect rgb(100,215,180)<br>			Jhon--&gt;&gt;Jhon: 心理活动，我要不要也学一学#9829;<br>		end<br>	end<br></code></pre></td></tr></table></figure>

<p>一些比较复杂的时序图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mermaid">sequenceDiagram<br>    Alice -&gt;&gt; Bob: Hello Bob, how are you?<br>    Bob--&gt;&gt;John: How about you John?<br>    Bob--x Alice: I am good thanks!<br>    Bob-x John: I am good thanks!<br>    Note right of John: Bob thinks a long&lt;br&#x2F;&gt;long time, so long&lt;br&#x2F;&gt;that the text does&lt;br&#x2F;&gt;not fit on a row.<br>	Note left of Alice: what does he think about?<br>    Bob--&gt;Alice: Checking with John...<br>    Alice-&gt;John: Yes... John, how are you?<br></code></pre></td></tr></table></figure>



<hr>
<h2 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图<a id="ztt"></a></h2><p>语法解释：<code>[*]</code> 表示开始或者结束，如果在箭头右边则表示结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mermaid">stateDiagram<br>	[*]--&gt; s1<br>	s1--&gt;s2<br>	s2--&gt;[*]<br></code></pre></td></tr></table></figure>



<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图<a id="lt"></a></h2><p>语法解释：<code>&lt;|--</code> 表示继承，<code>+</code> 表示 <code>public</code>，<code>-</code> 表示 <code>private</code>，学过 Java 的应该都知道。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mermaid">classDiagram<br>      Animal &lt;|-- Duck<br>      Animal &lt;|-- Fish<br>      Animal &lt;|-- Zebra<br>      Animal : +int age<br>      Animal : +String gender<br>      Animal: +isMammal()<br>      Animal: +mate()<br>      class Duck&#123;<br>          +String beakColor<br>          +swim()<br>          +quack()<br>      &#125;<br>      class Fish&#123;<br>          -int sizeInFeet<br>          -canEat()<br>      &#125;<br>      class Zebra&#123;<br>          +bool is_wild<br>          +run()<br>      &#125;<br></code></pre></td></tr></table></figure>

<h2 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图<a id="gtt"></a></h2><p>甘特图一般用来表示项目的计划排期，目前在工作中经常会用到。</p>
<p>语法也非常简单，从上到下依次是图片标题、日期格式、项目、项目细分的任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mermaid">gantt<br>    title 工作计划 3.8~3.12<br>    dateFormat YYYY-MM-DD<br>    excludes weekends<br>    section 运控项目<br>    Completed task            :done,    des1, 2021-03-06,2021-03-09<br>    Active task               :active,  des2, 2021-03-09, 3d<br>    Future task               :crit,     des3, after des2, 5d<br>    Future task2              :         des4, after des3, 5d<br>    section  站控项目<br>    实现弹出式消息框		:a1, 2021-03-01, 2d<br>    继续下一项目			  :after a1, 2d<br>    section Documentation<br>    Describe gantt syntax               :active, a1, after des1, 3d<br>    Add gantt diagram to demo page      :after a1  , 20h<br>    Add another diagram to demo page    :doc1, after a1  , 48h<br><br></code></pre></td></tr></table></figure>

<p>甘特图简单用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mermaid">gantt<br>       apple :a, 2017-07-20, 30d<br>       banana :crit, b, 2017-07-23, 1d<br>       cherry :active, c, after b a, 1d<br>       <br></code></pre></td></tr></table></figure>

<h3 id="关于甘特图的input和output的format"><a href="#关于甘特图的input和output的format" class="headerlink" title="关于甘特图的input和output的format"></a>关于甘特图的input和output的format</h3><blockquote>
<p>在甘特图中有两个属性一个为dateFormat，用以控制甘特图时间的输入；另一个为axisFormat，用以控制甘特图输出时间的格式，两者均可以根据下边两个表来实现自定义的时间格式。</p>
</blockquote>
<p>以下为input的dateFormat：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Input       Example             Description:<br>YYYY        2014                4 digit year<br>YY          14                  2 digit year<br>Q           1..4                Quarter of year. Sets month to first month in quarter.<br>M MM        1..12               Month number<br>MMM MMMM    January..Dec        Month name in locale set by moment.locale()<br>D DD        1..31               Day of month<br>Do          1st..31st           Day of month with ordinal<br>DDD DDDD    1..365              Day of year<br>X           1410715640.579      Unix timestamp<br>x           1410715640579       Unix ms timestamp<br>H HH        0..23               24 hour time<br>h hh        1..12               12 hour time used with a A.<br>a A         am pm               Post or ante meridiem<br>m mm        0..59               Minutes<br>s ss        0..59               Seconds<br>S           0..9                Tenths of a second<br>SS          0..99               Hundreds of a second<br>SSS         0..999              Thousandths of a second<br>Z ZZ        +12:00              Offset from UTC as +-HH:mm, +-HHmm, or Z<br></code></pre></td></tr></table></figure>

<p>Example：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">dateFormat YYYY-MM-DD<br></code></pre></td></tr></table></figure>

<hr>
<p>这个是output的axisFormat：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">%a - abbreviated weekday name.<br>%A - full weekday name.<br>%b - abbreviated month name.<br>%B - full month name.<br>%c - date and time, as &quot;%a %b %e %H:%M:%S %Y&quot;.<br>%d - zero-padded day of the month as a decimal number [01,31].<br>%e - space-padded day of the month as a decimal number [ 1,31]; equivalent to %_d.<br>%H - hour (24-hour clock) as a decimal number [00,23].<br>%I - hour (12-hour clock) as a decimal number [01,12].<br>%j - day of the year as a decimal number [001,366].<br>%m - month as a decimal number [01,12].<br>%M - minute as a decimal number [00,59].<br>%L - milliseconds as a decimal number [000, 999].<br>%p - either AM or PM.<br>%S - second as a decimal number [00,61].<br>%U - week number of the year (Sunday as the first day of the week) as a decimal number [00,53].<br>%w - weekday as a decimal number [0(Sunday),6].<br>%W - week number of the year (Monday as the first day of the week) as a decimal number [00,53].<br>%x - date, as &quot;%m&#x2F;%d&#x2F;%Y&quot;.<br>%X - time, as &quot;%H:%M:%S&quot;.<br>%y - year without century as a decimal number [00,99].<br>%Y - year with century as a decimal number.<br>%Z - time zone offset, such as &quot;-0700&quot;.<br>%% - a literal &quot;%&quot; character.<br></code></pre></td></tr></table></figure>

<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">axisFormat  %Y-%m-%d<br></code></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>Markdown</tag>
        <tag>画图</tag>
      </tags>
  </entry>
  <entry>
    <title>类型转换</title>
    <url>/posts/61165acd.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>标准类型转换太不严格。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Doof</span> &#123;</span><br>    <span class="hljs-keyword">double</span> feeb;<br>    <span class="hljs-keyword">double</span> steeb;<br>    <span class="hljs-keyword">char</span> sgif[<span class="hljs-number">10</span>];<br>&#125;;<br>Doof leam;<br>shart * ps = (<span class="hljs-keyword">short</span> *) &amp; leam;<br><span class="hljs-keyword">int</span> * pi = <span class="hljs-keyword">int</span> * (&amp;leam);<br></code></pre></td></tr></table></figure>

<p>《C++ Prime Plus》中的例子。C语言不能防止将一种类型的指针转换为另一种完全不相关的类型的指针。</p>
<p>因此，C++中使用了：</p>
<ul>
<li><code>dynamic_cast</code></li>
<li><code>static_cast</code></li>
<li><code>const_cast</code></li>
<li><code>reinterpret_cast</code></li>
</ul>
<p>四种类型转换运算符来执行涉及指针的类型转换。</p>
</blockquote>
<h2 id="1-dynamic-cast"><a href="#1-dynamic-cast" class="headerlink" title="1. dynamic_cast"></a><font color font-weight="900">1. dynamic_cast</font></h2><p>该运算符的用途是，<span style="border-bottom:3px solid green">使得能够在类层次结构中进行向上转换（由于is-a关系，这样的类型转换是安全的），而不允许其他转换。</span>用法如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">dynamic_cast</span> &lt;type-name&gt; (expression)<br></code></pre></td></tr></table></figure>

<p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化是，如果是非法的对于指针返回NULL,对于引用跑一场。要深入了解内部转换的原理。</p>
<ul>
<li>向上转换：指的是子类向基类的转换</li>
<li>向下转换：指的是基类想子类的转换</li>
</ul>
<p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够向下转换。</p>
<h2 id="2-const-cast"><a href="#2-const-cast" class="headerlink" title="2. const_cast"></a>2. const_cast</h2><p><code>const_cast</code>运算符用于执行只有一种用途的类型转换，及改变值为<code>const</code>为<code>volatile</code>，其语法与<code>dynamic_cast</code>运算符相同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const_cast</span>&lt;type-name&gt; (expression)<br></code></pre></td></tr></table></figure>

<p>通俗讲，就是const_cast用于（is-a）关系中将const转换为非const。</p>
<p>提供该运算符的原因是，有时候可能需要这样一个值，它在大多数时候是常量，而有时又是可以修改的。在这种情况下，可以将这个值声明为const，并在需要修改它的时候，使用const_cast。</p>
<p>此外，还用于将const变量转为非const</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> age = <span class="hljs-number">40</span>;<br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> agep = age;<br>	cout &lt;&lt; <span class="hljs-string">&quot;const of age:&quot;</span> &lt;&lt; agep &lt;&lt; endl;<br>	<span class="hljs-keyword">int</span> &amp;nConstAge = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span>&amp;&gt;(agep);<br>	<span class="hljs-comment">// 修改nConstAge的值看看是否能成功修改age的值</span><br>	nConstAge = <span class="hljs-number">18</span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;new const of age：&quot;</span> &lt;&lt; agep &lt;&lt; endl;<br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20210111134448789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1ZWxfTWluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-static-cast"><a href="#3-static-cast" class="headerlink" title="3. static_cast"></a>3. static_cast</h2><p><code>static_cast</code>运算符的语法与其它运算符一致,用于将const变量转为非const：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">static_cast</span> &lt;type-name&gt; (expression)<br></code></pre></td></tr></table></figure>

<p>仅当type_name可被隐式转换为expression所属的类型或expression可被隐式转换为type_name所属类型时，上述转换才是合法的，否则将出错。</p>
<blockquote>
<p>假设High是Low的基类，而Pond是一个无关的类，则从High到Low的转换、从Low到High的转换都是合法的，而从Low到Pond的转换是不允许的：</p>
</blockquote>
<h2 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. reinterpret_cast</h2><p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
  </entry>
  <entry>
    <title>Pointer And Const</title>
    <url>/posts/7d0efebf.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一文搞懂指针常量与常量指针"><a href="#一文搞懂指针常量与常量指针" class="headerlink" title="一文搞懂指针常量与常量指针"></a>一文搞懂指针常量与常量指针</h1><h1 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h1><p>通俗点，你可以理解为<code>const *</code>，声明一个指针常量就是 <code>const int* a</code>，如果你容易混淆它只能修改指向的位置，可以试着按这种方式去理解。</p>
<h1 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h1><p><code>const int* ptr</code>或者<code>int const* ptr</code>，两者都表示常量指针。表示一个指针指向常量地址，使用就是可以修改指针指向的位置，但是不能修改指针指向位置的值。定义时可以不赋初值。</p>
<p>那么如何在以后的使用中更加准确地记住？倒着读！</p>
<p>上述两个定义方式可以理解为：</p>
<blockquote>
<p><code>const int *ptr</code>：a ptr is pointer to <u>int const</u>，一个变量ptr指向常整型</p>
<p><code>int const* ptr</code>: a ptr is pointer to const int，含义同上</p>
</blockquote>
<h1 id="指针常量-1"><a href="#指针常量-1" class="headerlink" title="指针常量"></a>指针常量</h1><p><code>int * const ptr</code>,即指针常量，表示一个常指针指向整型变量。使用就是可以修改指针指向位置的值，但是不能修改指针的指向。</p>
<p>同上，定义方式可以倒着理解：</p>
<blockquote>
<p><code>int * const ptr</code>：a ptr is a const pointer to int，ptr是一个指向整型变量的常指针</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>;<br>	<span class="hljs-comment">//常量指针</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* ptr; <span class="hljs-comment">//指针指向的地址所存储的值不可以被修改</span><br>				<span class="hljs-comment">//可以理解为pointer to const int</span><br>	ptr = &amp;i;<br><br>	<span class="hljs-keyword">int</span> i_2 = <span class="hljs-number">120</span>;<br>	<span class="hljs-comment">// *a = 1090; // 这里会报错，因为a是一个常量指针，不可以修改指向位置的值</span><br>	ptr = &amp;i_2; <span class="hljs-comment">//但是可以修改常量指针a所指向的位置</span><br>	cout &lt;&lt; &amp;ptr &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; *ptr &lt;&lt; endl;<br><br><br>	<span class="hljs-comment">//指针常量</span><br>	<span class="hljs-keyword">int</span>* <span class="hljs-keyword">const</span> ptr2 = &amp;i_2; <span class="hljs-comment">//可以理解为a const pointer to int,必须赋初值</span><br>	<br>	<span class="hljs-comment">//ptr2 = &amp;i; //因为ptr2是一个const pointer to int。就是指针指向的位置不能改变，但是指针指向的值可以改变</span><br>	*ptr2 = <span class="hljs-number">10000</span>; <span class="hljs-comment">//修改指针指向位置的值</span><br>	cout &lt;&lt; &amp;a &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; *a &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>附上运行结果（vs2017）：</p>
<p>![image-20210202090917363](../../../images/pointer and const/image-20210202090917363.png)</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>bash中与美元符$连用的符号含义说明——($?/$0/$?/$!/$$/$*/$#/$@)</title>
    <url>/posts/91f0715b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="bash中与美元符-连用的符号含义说明——-0"><a href="#bash中与美元符-连用的符号含义说明——-0" class="headerlink" title="bash中与美元符$连用的符号含义说明——($?/$0/$?/$!/$$/$*/$#/$@)"></a>bash中与美元符$连用的符号含义说明——<code>($?/$0/$?/$!/$$/$*/$#/$@)</code></h1><h2 id><a href="#" class="headerlink" title="$?"></a>$?</h2><blockquote>
</blockquote>
<h2 id="0"><a href="#0" class="headerlink" title="$0"></a>$0</h2><blockquote>
</blockquote>
<h2 id="-1"><a href="#-1" class="headerlink" title="$?"></a>$?</h2><blockquote>
</blockquote>
<h2 id="-2"><a href="#-2" class="headerlink" title="$!"></a>$!</h2><blockquote>
</blockquote>
<h2 id="-3"><a href="#-3" class="headerlink" title="$$"></a>$$</h2><blockquote>
</blockquote>
<h2 id="-4"><a href="#-4" class="headerlink" title="$*"></a>$*</h2><blockquote>
</blockquote>
<h2 id="-5"><a href="#-5" class="headerlink" title="$#"></a>$#</h2><blockquote>
</blockquote>
<h2 id="-6"><a href="#-6" class="headerlink" title="$@"></a>$@</h2><blockquote>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Linux</category>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>线程相关概念</title>
    <url>/posts/de3574a2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h1><p>进程：是表示资源分配的基本单位，又是调度运行的基本单位。</p>
<blockquote>
<p>例如：用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I/O设备等。然后。把该进程放入进程的就绪队列。进程调度程序选中它，为它分配CPU以及其它有关资源，该进程才真正运行。所以进程是系统中的并发执行的单位。</p>
</blockquote>
<hr>
<p>线程：是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。如果把线程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能的子任务之一。</p>
<blockquote>
<p>例如：假设用户启动了一个窗口中的数据库应用程序，操作系统就将对数据库的调用表示为一个进程。假设用户要从数据库中产生一份工资单报表，并传到一个文件中，这是一个子任务；在产生工资单报表的过程中，用户又可以输入数据库查询请求，这又是一个子任务。这样，操作系统则把每一个请求——工资单报表和新输入的数据查询表示为数据库进程中的独立的线程。线程可以在处理器上独立调度执行，这样，在多处理器环境下就允许几个线程各自在单独处理器上进行。操作系统提供线程就是为了方便而有效地实现这种并发性。</p>
</blockquote>
<h1 id="多进程与多线程的区别"><a href="#多进程与多线程的区别" class="headerlink" title="多进程与多线程的区别"></a>多进程与多线程的区别</h1><table>
<thead>
<tr>
<th>对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用IPC；数据是分开的，同步简单</td>
<td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>占用内存少，切换简单，CPU利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody></table>
<h2 id="优劣对比"><a href="#优劣对比" class="headerlink" title="优劣对比"></a>优劣对比</h2><table>
<thead>
<tr>
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr>
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody></table>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><ul>
<li>需要频繁创建销毁的优先用线程</li>
<li>需要进行大量计算的优先使用线程</li>
<li>强相关的处理用线程，弱相关的处理用进程</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程</li>
<li>都满足需求的情况下，用你最熟悉、最拿手的方式</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库常见面试问题</title>
    <url>/posts/42c6ad67.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库常见面试问题"><a href="#数据库常见面试问题" class="headerlink" title="数据库常见面试问题"></a>数据库常见面试问题</h1><h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1><p>索引是对数据表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。索引有助于更快的获取信息。</p>
<p>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</p>
<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><p>数据库事务（Database Transaction），是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部操作成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务时数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p>
<h1 id="数据库事务隔离"><a href="#数据库事务隔离" class="headerlink" title="数据库事务隔离"></a>数据库事务隔离</h1><p>同一时间，只允许一个事务请求统一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转钱。</p>
<h1 id="inner-join-和-left-join"><a href="#inner-join-和-left-join" class="headerlink" title="inner join  和 left join"></a><code>inner join</code>  和 <code>left join</code></h1><p>left join（左连接）返回包括左表中的所有记录和右边中联结字段相等的记录</p>
<p>right join（右连接）返回包含右表中所有记录和左表中联结字段相等的记录</p>
<p>inner join（等值连接）只返回两个表中联结字段相等的行</p>
<h1 id="数据库事务的一致性"><a href="#数据库事务的一致性" class="headerlink" title="数据库事务的一致性"></a>数据库事务的一致性</h1><p>事务是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务时DBMA中最基础的单位，事务不可分割。</p>
<p>事务具有四个特征：分别是原子性、一致性、隔离性、持续性。简称ACID。</p>
<h1 id="请你说一下索引是什么，多加索引一定会好吗？"><a href="#请你说一下索引是什么，多加索引一定会好吗？" class="headerlink" title="请你说一下索引是什么，多加索引一定会好吗？"></a>请你说一下索引是什么，多加索引一定会好吗？</h1><ol>
<li><p>索引</p>
<p>数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。</p>
<p>DB在执行一条sql语句的时候，默认的方式事根据搜索条件进行全表扫描，遇到匹配条件的就加入到搜索结果集合。如果我们对某一个字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少了遍历匹配的行数，所以能明显增加查询的速度。</p>
<p>优点：</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以加快数据的检索速度，这也是键索引的最主要的原因。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ol>
<p>缺点：</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>
<li>索引需要占物理空间，输了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要占用的空间就更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<ul>
<li>聚簇索引和非聚簇索引 <strong>聚簇索引</strong>：将数据存储与索引放到了一块，找到了索引也就找到了数据 <strong>非聚簇索引</strong>：将数据存储于索引分开结构，索引结构的叶子节点只想了数据的对应行，myisam和key-buffer把索引先缓存到内存结构中，当需要访问数据时（通过索引访问数据），当内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key-buffer命中时，速度慢的原因。</li>
<li>注：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</li>
</ul>
</li>
<li><p>添加索引的原则</p>
<ol>
<li>很少使用的或者参考的列不应该创建索引。</li>
</ol>
<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fab86238e-72f5-4359-b7b1-ae7ac6ff6c0c%2FE14911CA-4A14-4715-BCCB-819FDE9F7BF6.png?table=block&id=3d510449-89c5-4bd4-86de-0b6099d902c9&width=1400&userId=&cache=v2" alt="img"></p>
</li>
</ol>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h1 id="死锁怎么解决"><a href="#死锁怎么解决" class="headerlink" title="死锁怎么解决"></a>死锁怎么解决</h1><ul>
<li>找到进程号，kill进程</li>
</ul>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>《Effective C++》条款50~59</title>
    <url>/posts/60f246a3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>条款54：让自己熟悉包括TR1在内的标准程序库</p>
</blockquote>
<p>TR1指的是Technical Report 1，是C++程序库工作小组对该份文档的称呼。</p>
<p>主要说明了C++标准程序库的各个成分：STL、Iostream、国际化支持（wchar_t、wstring）、数值处理、异常阶层体系。C89标准程序库。</p>
<p>条款54则就命名空间tr1内的部分新组件的使用进行了详尽的介绍。</p>
<hr>
<p>智能指针（smart pointers）：嵌套在tr1命名空间内，TR1组件<code>shared_ptr</code>的全名是<code>std::tr1::shared_ptr</code>，使用时<code>std::shared_ptr</code>即可.</p>
<blockquote>
<p><span style="letter-spacing:1px;word_spacing:1px;font-family:consolas"><code>tr1::shared_ptr</code>和 <code>tr1::weak_ptr</code>。前者的作用有如内置指针，但会记录有多少个<code>tr1::shared_ptrs</code>共同指向同一个对象。这便是所谓的<u>reference couming（引用计数）</u>。一旦最后一个这样的指针被销毁，也就是一旦某对象的引用次数变成 0，这个对象会被自动删除。这在非环形（acyclic）数据结构中防止资源泄漏很有帮助，但如果两个或多个对象内含<code>tr1::shared_ptrs</code>并形成环状（cycle），这个环形会造成每个对象的引用次数都超过 0——即使指向这个环形的所有指针都已被销毁（也就是这一群对象整体看来己无法触及）。这就是为什么又有个<code>tr1::weak_ptr</code>的原因。<code>tr1::weak_ptr</code>的设计使其表现像是”非环形<code>tr1::shared_ptr-based</code>数据结构”中的环形感生指针（cycle-inducing pointers）。<code>tr1::weak_ptr</code>并不参与引用计数的计算∶当最后一个指向某对象的 <code>tr1::shared_ptr</code>被销毁，纵使还有个<code>trl∶∶weak_ptrs</code>继续指向同一对象，该对象仍旧会被删除。这种情况下的<code>tr1∶∶weak_ptrs</code>会被自动标示无效，<code>tr1∶∶shared_ptr</code>或许是拥有最广泛用途的 TR1 组件</span></p>
</blockquote>
<p>在《C++ Primer Plus》中指出“智能指针是行为类似于指针的类对象”。其存在的最重要的一点就是可帮助管理动态内存分配的智能指针模板。原理就是“析构函数的应用”。当一个对象过期时，让他的析构函数删除指向的内存即可。</p>
<ul>
<li>auto_ptr（C++98的方案，c++11已经摒弃该指针，auto_ptr最大的弊端在于允许很多几乎没有实际用处又不符合常规认知的行为，用scoped_ptr和unique_ptr可以利用静态检查早早地指出这些无意义操作的存在。文中会略谈）</li>
<li>unique_ptr</li>
<li>shared_ptr</li>
</ul>
<blockquote>
<p>为什么要使用智能指针？</p>
<p>答：因为内存管理是一件非常麻烦的事，在开发过程中会经常性的因为内存泄露问题出现严重的后果。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remodel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> *ps = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>;<br>    *ps = <span class="hljs-number">25.5</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码的问题就是进入remodel()后申请了堆内存*ps，但是return的时候又没有释放改内存空间，因为很可能会出现程序错误，当然即使你使用了<code>delete ps;</code>，也不一定就能让程序不出现该类错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remodel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> *ps = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>;<br>    *ps = <span class="hljs-number">25.5</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">weird_thing</span>())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">exception</span>();<br>    <span class="hljs-keyword">delete</span> ps;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，在抛出异常的时候，依然会出现堆内存未释放的问题。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">///****************************************************************************                                     /// @brief   : 创建一个分配堆内存的函数，但是无释放空间操作                                                             ///****************************************************************************</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo1</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">double</span> *pd = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>;<br>	*pd = <span class="hljs-number">25</span>;<br>	<span class="hljs-keyword">return</span>; <span class="hljs-comment">//删除pd，值被保留在动态内存中</span><br>&#125;<br><span class="hljs-comment">///****************************************************************************</span><br><span class="hljs-comment">/// @brief   : 创建一个分配堆内存的函数，调用auto_ptr管理内存空间</span><br><span class="hljs-comment">///****************************************************************************</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo2</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-function">auto_ptr&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">ap</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>)</span></span>;<br>	*ap = <span class="hljs-number">25.5</span>;<br>	<span class="hljs-keyword">return</span>; <span class="hljs-comment">//删除ap，ap的析构函数释放动态内存。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>智能指针的几种声明与使用方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;<span class="hljs-keyword">double</span>&gt; pd;<br><span class="hljs-keyword">double</span> *p_reg =<span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>;<br>pd = shared&lt;<span class="hljs-keyword">double</span>&gt;(p_reg); <span class="hljs-comment">//#1 </span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">psahred</span><span class="hljs-params">(p_reg)</span></span>; <span class="hljs-comment">//#2</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">sd</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>)</span></span>; <span class="hljs-comment">//#3</span><br></code></pre></td></tr></table></figure>

<p><code>#1</code>:所有智能指针类都有一个explicit构造函数，该函数将指针作为参数。因此不需要将指针转换为智能对象。</p>
<blockquote>
<p>关于<code>shared_ptr</code>的详细使用可以看这篇文章📑 <a href="#">Post not found: 学习笔记/C++_Primer_Plus/shared_ptr</a></p>
</blockquote>
<h2 id="如何创建智能指针对象"><a href="#如何创建智能指针对象" class="headerlink" title="如何创建智能指针对象"></a>如何创建智能指针对象</h2><p>创建智能指针对象必须包含头文件<code>memory</code>，然后通过模板类实现<code>auot_ptr()</code>的调用与实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">auto_ptr</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		1. explicit 避免隐式转换</span><br><span class="hljs-comment">		2. throw() 意味着构造函数不会引发异常</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">auto_ptr</span><span class="hljs-params">(X *p = <span class="hljs-number">0</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>因为使用了模板，因此可以通过使用X类型的<code>auto_ptr</code>来获得指向X类型的<code>auto_ptr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">ad</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>)</span></span>; <span class="hljs-comment">//auto_ptr to double</span><br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">as</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string)</span></span>; <span class="hljs-comment">//auto_ptr to string</span><br></code></pre></td></tr></table></figure>

<p>并且可以使用你的自定义类型,同时还可以对智能指针执行解除引用操作，用它来访问结构成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myType</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>	std::string str;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> date;<br>	<span class="hljs-built_in">myType</span>() &#123;&#125;<br>	<span class="hljs-built_in">myType</span>(<span class="hljs-keyword">const</span> std::string s):<span class="hljs-built_in">str</span>(s) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;create a myType~&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;;<br><span class="hljs-function">auto_ptr&lt;myType&gt; <span class="hljs-title">pmt</span><span class="hljs-params">(<span class="hljs-keyword">new</span> myType)</span></span>; <span class="hljs-comment">//auto_ptr to myType</span><br>pmt-&gt;date; <span class="hljs-comment">//访问myType中date成员</span><br></code></pre></td></tr></table></figure>

<h2 id="为什么摒弃auto-ptr"><a href="#为什么摒弃auto-ptr" class="headerlink" title="为什么摒弃auto_ptr"></a>为什么摒弃auto_ptr</h2><p>使用《C++ primer plus》中的一个案例，顺便说明为什么会有<code>shred_ptr</code>，以及与auto_ptr的区别。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">tableau</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;这里有一个小姐姐，单身可撩~&quot;</span>))</span></span>;<br>auot_ptr&lt;string&gt; rt;<br>rt = tableau;<br></code></pre></td></tr></table></figure>

<p>上述语句声明了两个变量，tableau和rt，如果这两个变量是常规指针，则两个变量都指向同一个地址，意即在程序结束时或者析构函数调用时，该地址会被删除两次，一次是tableau过期时，一次是rt过期时。解决这种问题的方法有多种，使share_ptr就可以解决这种所有权问题。</p>
<blockquote>
<ol>
<li><p>定义赋值运算符，进行深拷贝操作，这样两个指针指向不同的地址。</p>
</li>
<li><p>建立所有权（ownership）概念，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的构造函数会删除该对象。然后，让赋值操作转让所有权。这就是auto_ptr和unique_ptr的策略。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">tableau</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;这里有一个小姐姐，单身可撩~&quot;</span>))</span></span>; <span class="hljs-comment">//声明一个unique_ptr</span><br>unique_ptr&lt;string&gt; rt; <br>rt = tableau; <span class="hljs-comment">//非法，编译报错</span><br></code></pre></td></tr></table></figure></li>
<li><p>创建智能更高的指针，跟踪引用特定对象的智能指针数，也即引用计数（reference counting）。也就是shared_ptr的实现策略，当引用计数为0时，才会执行删除操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">tableau</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;这里有一个小姐姐，单身可撩~&quot;</span>))</span></span>;<br>shared_ptr&lt;string&gt; rt; <span class="hljs-comment">// 在这一步只需将rt声明为shared_ptr即可</span><br>rt = tableau; <span class="hljs-comment">//tableau的引用计数变为2</span><br></code></pre></td></tr></table></figure>

<p>在程序执行末尾，后声明的rt先调用析构函数，引用计数变为1；然后tableau地阿勇析构函数，引用计数变为0，该地址指向的空间被释放。</p>
</li>
</ol>
</blockquote>
<hr>
<p>相比于auto_ptr，unique_ptr还有另外一个优点。就是可以用于数组的变体。在C++中，必须将delete和new配对，将delete[]和new[]配对使用。模板auto——ptr使用delete而不是delete[]，因此，只能与new一起使用，而不能与new[]一起使用。但unique_ptr有使用new[]和delete[]的版本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">std::unique_ptr&lt;<span class="hljs-keyword">double</span>[]&gt;<span class="hljs-built_in">pda</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">//使用delete[]删除</span><br></code></pre></td></tr></table></figure>

<p>关于容器与智能指针的一个很好的demo：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">///****************************************************************************</span><br><span class="hljs-comment">/// @data    :	2021/1/17</span><br><span class="hljs-comment">/// @input   :	随机整型变量</span><br><span class="hljs-comment">/// @output  :	返回一个unique_ptr</span><br><span class="hljs-comment">/// @brief   :  </span><br><span class="hljs-comment">///****************************************************************************</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">make_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> unique_ptr&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(n));<br>&#125;<br><span class="hljs-comment">// 这里必须按引用传值，unique_ptr所有权的问题：因为如果使用值传递，</span><br><span class="hljs-comment">// 编译器会认为vui[i]不再指向有效的数据,会出现编译错误。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; &amp;pi)</span> </span>&#123;<br>	cout &lt;&lt; *pi &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>	<span class="hljs-comment">////指向容器的智能指针</span><br>	<span class="hljs-comment">//auto_ptr&lt;vector&lt;int&gt;&gt;  avi(new vector&lt;int&gt;);</span><br>	<span class="hljs-comment">//avi-&gt;push_back(5);</span><br>	<span class="hljs-comment">//cout&lt;&lt;&quot;打印容器第一个数：&quot; &lt;&lt; avi-&gt;front();</span><br><br>	<span class="hljs-comment">// 存储智能指针的容器</span><br>	vector&lt;unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">vui</span>(<span class="hljs-number">10</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; vui.<span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		vui[i] = <span class="hljs-built_in">make_int</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">1000</span>);<br>	&#125;<br>	vui.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_int</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">1000</span>));<br><br>	for_each(vui.<span class="hljs-built_in">begin</span>(),vui.<span class="hljs-built_in">end</span>(),show);<br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是，unique_ptr却可以作为右值转换为shared_ptr，还是上边的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pup</span><span class="hljs-params">(make_int(rand() % <span class="hljs-number">1000</span>))</span></span>; <span class="hljs-comment">//ok</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spp</span><span class="hljs-params">(pup)</span></span>; <span class="hljs-comment">// not allowed，pup是左值</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spr</span><span class="hljs-params">(make_int(rand() % <span class="hljs-number">1000</span>))</span></span>; <span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>C++笔记</category>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++关键字——extern</title>
    <url>/posts/510cef8a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="C-C-中extern关键字详解"><a href="#C-C-中extern关键字详解" class="headerlink" title="C/C++中extern关键字详解"></a>C/C++中extern关键字详解</h2><blockquote>
<p>一个很容易忽略的关键字</p>
</blockquote>
<h2 id="基本解释"><a href="#基本解释" class="headerlink" title="基本解释"></a>基本解释</h2><p>extern可以放在<mark style="color:white;background:rgb(101,90,225);border-radius:25px;padding:2px">变量或者函数</mark>前。表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找定义。此外<code>exrtern</code>也可以用来进行链接指定。</p>
<h3 id="1-用作外部变量的声明与使用"><a href="#1-用作外部变量的声明与使用" class="headerlink" title="1. 用作外部变量的声明与使用"></a>1. 用作外部变量的声明与使用</h3><p>如果在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用<code>extern</code>声明它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//file01.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> cat = <span class="hljs-number">20</span>; <span class="hljs-comment">//定一个flag变量并初始化</span><br><span class="hljs-keyword">int</span> dog = <span class="hljs-number">22</span>;<br><span class="hljs-keyword">int</span> fleas;<br><span class="hljs-comment">//file02.cpp</span><br><span class="hljs-comment">//使用file01的cat和dog</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> cat;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> dog;<br></code></pre></td></tr></table></figure>

<p>在上述例子中，因为file02并没有声明<code>fleas</code>变量，因此无法使用，但是声明了<code>cat</code>和<code>dog</code>，因此可以使用这两个变量。由此可见，<mark style="color:white;background:rgb(101,90,225);border-radius:25px;padding:2px">关键字extern并非必不可少的</mark>，因为即使省略它，效果也相同。</p>
<h2 id="2、函数的声明"><a href="#2、函数的声明" class="headerlink" title="2、函数的声明"></a>2、函数的声明</h2><p>函数的声明中extern关键字是可有可无的，因为函数本身不加修饰的话就是extern。但是引用的时候一样需要声明。</p>
<h3 id="3、可以多次声明，但是定义只能一次"><a href="#3、可以多次声明，但是定义只能一次" class="headerlink" title="3、可以多次声明，但是定义只能一次"></a>3、可以多次声明，但是定义只能一次</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i; <span class="hljs-comment">//声明，不是定义</span><br><span class="hljs-keyword">int</span> i; <span class="hljs-comment">//声明，也是定义</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++笔记</category>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN学习笔记</title>
    <url>/posts/a7642b15.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SVN版本控制系统（SubVersion）"><a href="#SVN版本控制系统（SubVersion）" class="headerlink" title="SVN版本控制系统（SubVersion）"></a>SVN版本控制系统（SubVersion）</h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="为什么要使用SVN系统控制软件？"><a href="#为什么要使用SVN系统控制软件？" class="headerlink" title="为什么要使用SVN系统控制软件？"></a>为什么要使用SVN系统控制软件？</h2><img src="https://tva4.sinaimg.cn/large/0072YHp3ly1glrrnrpd0yj30q90dhdil.jpg" alt style="zoom:50%;">

<h2 id="在遇到多版本时如何解决？"><a href="#在遇到多版本时如何解决？" class="headerlink" title="在遇到多版本时如何解决？"></a>在遇到多版本时如何解决？</h2><p>SCM：软件配置管理</p>
<p>所谓的软件配置管理实际就是对软件源代码进行控制与管理</p>
<pre><code>1. CVS：元老级产品
2. VSS：入门级产品
3. ClearCase：IBM公司提供技术支持
4. SVN：主流产品
</code></pre>
<h2 id="什么是SVN"><a href="#什么是SVN" class="headerlink" title="什么是SVN"></a>什么是SVN</h2><blockquote>
<p>SVN是近年来鹊起的版本管理工具，是CVS的接班人。目前，绝大多数软件公司都适用SVN作为代码版本管理软件。</p>
<p>​    特点：</p>
<pre><code>    - 操作简单，入门容易
    - 支持跨平台操作
    - 支持版本回退功能（时间机器）
</code></pre>
</blockquote>
<h2 id="获取SVN软件"><a href="#获取SVN软件" class="headerlink" title="获取SVN软件"></a>获取SVN软件</h2><p>属于C/S结构软件（客户端与服务端）</p>
<pre><code>    - 服务端软件网址 www.visualsvn.com
    - 客户端软件网址 www.tortoisesvn.com [下载网址](http://tortoisesvn.net/downloads)
</code></pre>
<h1 id="二、SVN服务端安装"><a href="#二、SVN服务端安装" class="headerlink" title="二、SVN服务端安装"></a>二、SVN服务端安装</h1><h2 id="SVN的工作流程"><a href="#SVN的工作流程" class="headerlink" title="SVN的工作流程"></a>SVN的工作流程</h2><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1glrrpotbcxj30nv0ddt9e.jpg" style="zoom:50%;">

<h3 id="1、Checkout（检出）"><a href="#1、Checkout（检出）" class="headerlink" title="1、Checkout（检出）"></a>1、Checkout（检出）</h3><h3 id="2、Update（更新）"><a href="#2、Update（更新）" class="headerlink" title="2、Update（更新）"></a>2、Update（更新）</h3><h3 id="3、Commit（提交）"><a href="#3、Commit（提交）" class="headerlink" title="3、Commit（提交）"></a>3、Commit（提交）</h3><h2 id="服务器端安装（visualSVN"><a href="#服务器端安装（visualSVN" class="headerlink" title="服务器端安装（visualSVN)"></a>服务器端安装（visualSVN)</h2><h3 id="1、双击安装"><a href="#1、双击安装" class="headerlink" title="1、双击安装"></a>1、双击安装</h3><h3 id="2、下一步"><a href="#2、下一步" class="headerlink" title="2、下一步"></a>2、下一步</h3><p>选择带有可视化界面的，第二种情况只有Dos界面</p>
<img src="https://tva4.sinaimg.cn/large/0072YHp3ly1glrrrr4qclj30jd0ff47t.jpg" alt="安装模式" style="zoom:50%;">

<h3 id="3、仓库与端口设置"><a href="#3、仓库与端口设置" class="headerlink" title="3、仓库与端口设置"></a>3、仓库与端口设置</h3><p><code>location</code>字符不要出现空格</p>
<img src="https://tva4.sinaimg.cn/large/0072YHp3ly1glrrshikhwj30jd0f7te3.jpg" alt="配置仓库与端口" style="zoom:50%;">

<h2 id="SVN服务器项目配置"><a href="#SVN服务器项目配置" class="headerlink" title="SVN服务器项目配置"></a>SVN服务器项目配置</h2><h3 id="1、创建一个项目"><a href="#1、创建一个项目" class="headerlink" title="1、创建一个项目"></a>1、创建一个项目</h3><p>​    1. 首先在SVN服务端创建一个公有目录WebApp作为项目目录</p>
<ol start="2">
<li><p>在WebApp目录下创建Shop文件夹，作为Shop（版本仓库）</p>
</li>
<li><p>在<code>SVN</code>文件夹下创建<code>WebApp</code>文件夹</p>
</li>
<li><p>在<code>WebApp</code>文件夹下创建<code>Shop</code>文件夹</p>
</li>
<li><p>创建版本仓库，Dos环境基本语法</p>
<p><code>svnadmin create Shop 文件夹路径（Shop路径）</code></p>
<p><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1glrrszx17kj30ih015q2s.jpg"></p>
</li>
<li><p>创建成功之后Shop文件目录下的文件结构</p>
<p> <img src="https://tva2.sinaimg.cn/large/0072YHp3ly1glrrszr4mkj30qr05ljtr.jpg" alt="shop文件目录结构"></p>
</li>
</ol>
<h3 id="2、进行服务端监管"><a href="#2、进行服务端监管" class="headerlink" title="2、进行服务端监管"></a>2、进行服务端监管</h3><p>Apache -&gt; <a href="http://loaclhost或(ip地址)访问到hedocs目录下的相关文件(监管)/">http://loaclhost或（IP地址）访问到hedocs目录下的相关文件（监管）</a></p>
<p>SVN -&gt; svn://localhost或（IP地址）访问到相关数据仓库（如Shop仓库）</p>
<h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><p>svnserve -d（后台运行） -r（监管目录） 版本仓库路径</p>
<p>如下图所示：</p>
<img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1glrrt00mlij30r3049dgk.jpg" alt style="zoom:50%;">

<p>通过以上指令，我们的svn://loaclhost或者IP地址就可以直接指向Shop版本仓库。</p>
<h3 id="3、权限控制"><a href="#3、权限控制" class="headerlink" title="3、权限控制"></a>3、权限控制</h3><p>默认情况下，SVN服务器是不允许匿名用户，上传文件到服务端的，所以必须更改项目的相关配置文件。</p>
<p>打开<code>Shop/conf/svnserve.conf</code>文件，修改第19行<code>aanon-access</code>字段的值为<code>write</code>。</p>
<p><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1glrrt05kruj30xb0gf7d2.jpg"></p>
<h1 id="三、SVN客户端安装"><a href="#三、SVN客户端安装" class="headerlink" title="三、SVN客户端安装"></a>三、SVN客户端安装</h1><h2 id="1、获取安装包"><a href="#1、获取安装包" class="headerlink" title="1、获取安装包"></a>1、获取安装包</h2><p>客户端有两个版本：32位和64位</p>
<h2 id="2、确认操作系统位数"><a href="#2、确认操作系统位数" class="headerlink" title="2、确认操作系统位数"></a>2、确认操作系统位数</h2><p><mark>右击电脑-&gt;属性</mark>就可以看到如下界面，确定自己的电脑是32位还是64位；</p>
<p><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1glrrt0lag7j30gh04d0sq.jpg"></p>
<h2 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h2><ol>
<li>双击安装包（TortoiseSVN）<br><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1glrrt0nzemj30cn05lmye.jpg"></li>
<li>同意许可，点击下一步</li>
</ol>
<img src="https://tva3.sinaimg.cn/large/0072YHp3ly1glrrt0tf7uj30k50ff491.jpg" alt style="zoom:50%;">

<ol start="3">
<li>选择安装路径</li>
</ol>
<img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1glrrsya5rvj30iz0ertf9.jpg" alt style="zoom:50%;">

<ol start="4">
<li>下一步，install，系统将会自动安装SVN软件，单机Finish即可</li>
</ol>
<p><font color="red">注：安装完成之后，一定要重启计算机，否则SVN图标无法正常出现</font></p>
<ol start="5">
<li>安装成功之后，鼠标右键就会出现如下两个图标，代表我们已经成功安装</li>
</ol>
<img src="https://tva3.sinaimg.cn/large/0072YHp3ly1glrrsydumuj30rz0bjgpr.jpg" alt style="zoom:50%;">

<ol start="6">
<li>如果需要汉化包，安装完成之后只需要双击汉化包即可。</li>
</ol>
<img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1glrrsyhky3j30pv09f78g.jpg" alt style="zoom:50%;">

<p>安装完成之后，在<code>Setting</code>之中选择设置语言即可：</p>
<img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1glrrsylb0gj30rh081n1r.jpg" alt style="zoom:50%;">

<ol start="7">
<li>使用客户端软件连接配置服务器</li>
</ol>
<p>首先在你的项目目录鼠标右键 –&gt; TortoiseSVN –&gt; 版本库浏览器  –&gt; svn://localhost(输入svn服务器地址)</p>
<img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1glrrsyqfgtj30it06laax.jpg" style="zoom:50%;">

<p>svn://SVN服务器地址 –&gt; Shop项目（仓库）</p>
<img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1glrrsyu9fxj30s70b979l.jpg" style="zoom:50%;">

<p>打开隐藏功能，显示隐藏文件，就可以看到<code>.svn</code>文件，此时就已经与服务端建立了联系</p>
<h1 id="四、SVN使用详解"><a href="#四、SVN使用详解" class="headerlink" title="四、SVN使用详解"></a>四、SVN使用详解</h1><h2 id="Checkout检出操作"><a href="#Checkout检出操作" class="headerlink" title="Checkout检出操作"></a>Checkout检出操作</h2><ol>
<li>连接到SVN服务器端</li>
<li>更新服务端数据到本地</li>
</ol>
<blockquote>
<p>注意：Checkout只在第一次链接时操作一次，以后如果进行更新操作使用Update（更新指令）</p>
</blockquote>
<h2 id="Commit提交操作"><a href="#Commit提交操作" class="headerlink" title="Commit提交操作"></a>Commit提交操作</h2><ol>
<li>提交本地数据到服务端</li>
</ol>
<img src="https://tva2.sinaimg.cn/large/0072YHp3ly1glrrsz0ccbj30b70fjn02.jpg" style="zoom:50%;">

<p>在Dos窗口使用<code>svn -d -r 文件路径</code>，鼠标右击出现上图，点击提交或者更新即可。</p>
<img src="https://tva1.sinaimg.cn/large/0072YHp3ly1glrrsz3jsmj30nv0k9gtl.jpg" style="zoom:50%;">

<p>出现下图，说明项目上传完毕。</p>
<img src="https://tva1.sinaimg.cn/large/0072YHp3ly1glrrsza0w5j30pt0bl79s.jpg" style="zoom:50%;">

<h2 id="项目成员如何加入项目"><a href="#项目成员如何加入项目" class="headerlink" title="项目成员如何加入项目"></a>项目成员如何加入项目</h2><ol>
<li>检出</li>
</ol>
<p>先创建自己的文件夹 –&gt; 在项目目录里边 –&gt; 鼠标右键 –&gt; Tortoise –&gt; 输入URL –&gt; 右键项目 –&gt; 检出即可</p>
<img src="https://tva3.sinaimg.cn/large/0072YHp3ly1glrrszeb91j30sf0b977s.jpg" style="zoom:50%;">

<ol start="2">
<li>提交</li>
</ol>
<p>当该项目成员需要上交文件时，执行Commit操作即可。</p>
<img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1glrrsziqi1j30xz0krjzv.jpg" style="zoom:50%;">

<h2 id="Update更新操作"><a href="#Update更新操作" class="headerlink" title="Update更新操作"></a>Update更新操作</h2><p>用于在别的项目组成员提交了文件或者数据之后更新到本地项目</p>
<h1 id="五、SVN图标详解"><a href="#五、SVN图标详解" class="headerlink" title="五、SVN图标详解"></a>五、SVN图标详解</h1><h2 id="图标及含义"><a href="#图标及含义" class="headerlink" title="图标及含义"></a>图标及含义</h2><p><img src="https://images2015.cnblogs.com/blog/792564/201601/792564-20160114122503788-1189386356.jpg" alt="img"></p>
<ol>
<li>常规<img src="../../../images/SVN/image-20201223151238087.png"></li>
</ol>
<p>当客户端文件与服务器端文件完全同步时，系统显示以上图标。</p>
<ol start="2">
<li>冲突<img src="../../../images/SVN/image-20201223151339980.png" alt="image-20201223151339980"></li>
</ol>
<p>当客户端提交的文件与服务器端数据有冲突时，系统会显示以上图标。</p>
<ol start="3">
<li>已删除<img src="../../../images/SVN/image-20201223151406918.png" alt="image-20201223151406918"></li>
</ol>
<p>当服务端数据已删除，那么客户端该文件将显示以上图标。</p>
<ol start="4">
<li>增加<img src="../../../images/SVN/image-20201223151417555.png" alt="image-20201223151417555"></li>
</ol>
<p>当我们编写文件已添加到提交队列，那么系统将自动显示该图标。</p>
<ol start="5">
<li>无版本控制<img src="../../../images/SVN/image-20201223151426461.png" alt="image-20201223151426461"></li>
</ol>
<p>当我们编写的文件没有添加到队列，那么系统将自动显示以上图标。</p>
<ol start="6">
<li>修改<img src="../../../images/SVN/image-20201223151434104.png" alt="image-20201223151434104"></li>
</ol>
<p>当客户端文件有修改但未提交，此时将自动显示以上图标。</p>
<ol start="7">
<li>只读<img src="../../../images/SVN/image-20201223151446394.png" alt="image-20201223151446394"></li>
</ol>
<p>当客户端文件以只读形式存在时，将自动显示以上图标。</p>
<ol start="8">
<li>锁定<img src="../../../images/SVN/image-20201223151457680.png" alt="image-20201223151457680"></li>
</ol>
<p>当服务端数据已锁定，那么客户端文件将自动显示锁定图标。</p>
<ol start="10">
<li>忽略<img src="../../../images/SVN/image-20201223151505792.png" alt="image-20201223151505792"></li>
</ol>
<p>客户端文件易忽略，不需要进行提交上传，那么将自动显示该图标。</p>
<h2 id="忽略功能"><a href="#忽略功能" class="headerlink" title="忽略功能"></a>忽略功能</h2><p>当你不需要将一些文件上传时，右击文件选择Tortoise中的忽略菜单即可忽略。</p>
<h1 id="六、SVN使用详解三"><a href="#六、SVN使用详解三" class="headerlink" title="六、SVN使用详解三"></a>六、SVN使用详解三</h1><p>版本回退</p>
<h2 id="什么是版本回退"><a href="#什么是版本回退" class="headerlink" title="什么是版本回退"></a>什么是版本回退</h2><p>有些时候，软件的运行可能是开发者或使用者不满意，这时我们需要把当前版本退回到以前的某个版本。</p>
<blockquote>
<p>传统的版本功能每一个版本都需要占用一定的内存空间。</p>
<table>
<thead>
<tr>
<th>v1.0</th>
<th>v2.0</th>
<th>v3.0</th>
<th>总计</th>
</tr>
</thead>
<tbody><tr>
<td>100M</td>
<td>150M</td>
<td>200M</td>
<td>450M</td>
</tr>
</tbody></table>
<p>但是SVN的存储机制只需要在原来的版本基础上添加即可<br>| v1.0 | v2.0 | v3.0 | 总计 |<br>| —- | —- | —- | —- |<br>| 100M | +50M | +50M | 200M |</p>
</blockquote>
<h2 id="如何回到某个版本？"><a href="#如何回到某个版本？" class="headerlink" title="如何回到某个版本？"></a>如何回到某个版本？</h2><p>在项目文件<code>鼠标右击</code>，选择<code>Tortoise</code>然后选择<code>更新至</code>二级菜单即可进行下一步如何更新的操作。</p>
<ul>
<li>通过日志的形式</li>
<li>通过版本号的形式</li>
</ul>
<h1 id="七、版本冲突"><a href="#七、版本冲突" class="headerlink" title="七、版本冲突"></a>七、版本冲突</h1><ol>
<li>通过安排不同开发时间解决</li>
<li>通过分配不同项目开发模块</li>
<li>通过SVN解决版本冲突问题</li>
</ol>
<h1 id="八、配置多仓库与权限控制"><a href="#八、配置多仓库与权限控制" class="headerlink" title="八、配置多仓库与权限控制"></a>八、配置多仓库与权限控制</h1><h2 id="1、配置多仓库"><a href="#1、配置多仓库" class="headerlink" title="1、配置多仓库"></a>1、配置多仓库</h2><p>在实际项目开发中，我么可能会同时开发多个项目，那么我们如何进行多项目监管呢？</p>
<p>通过svnserver进项仓库监管，但是监管指令只能监管某一个文件夹，不能同时监管多个仓库。但是可以通过监管总目录达到监管所有仓库的目的。<code>svnserver -d -r 文件路径</code></p>
<p>Shop项目：svn://loaclhost/Shop</p>
<p>Wechat项目：svn://localhost/Wechat</p>
<h2 id="2、权限控制"><a href="#2、权限控制" class="headerlink" title="2、权限控制"></a>2、权限控制</h2><p>如果要使用权限控制功能，必须先开启权限功能。</p>
<p>在每一个仓库中都有一个conf文件夹，里面有三个文件：</p>
<blockquote>
<p>authz文件：授权文件</p>
<p>告诉哪些用户具有哪些权限</p>
<p>passwd文件：认证文件</p>
<p>标识当前svn系统中某个仓库具有哪些用户以及 相应的密码</p>
<p>默认情况下，以上两个文件都是禁用的，如需要使用，首先要开启以上两个文件。</p>
</blockquote>
<p>在svnserver.conf 配置文件中：</p>
<blockquote>
<ol>
<li><p>注释匿名用户的可读写权限<code># anon-access = write</code></p>
</li>
<li><p>开启认证文件与授权选线27行与36行</p>
<p>27行<code>password-db = passwd</code></p>
<p>36行<code>auth-db = authz</code></p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础语法一遍过</title>
    <url>/posts/c7968c37.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python基础语法"><a href="#Python基础语法" class="headerlink" title="Python基础语法"></a>Python基础语法</h1><p>如果有相应的coding基础，那这篇文章对你而言的意义仅限于python的一些常见语法等，并不能有效帮助你更好地学习Python；但是如果你是和我一样刚接触Python的话，那这篇文章值得你看一遍。</p>
<h1 id="一些协助操作"><a href="#一些协助操作" class="headerlink" title="一些协助操作"></a>一些协助操作</h1><table>
<thead>
<tr>
<th>操作</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>dir()</td>
<td>返回包含的方法以及操作以及人特殊属性</td>
</tr>
<tr>
<td>help()</td>
<td>帮助函数，返回类的参考手册</td>
</tr>
<tr>
<td>id()</td>
<td>获取当前变量地址</td>
</tr>
</tbody></table>
<h1 id="先从一个小游戏开始"><a href="#先从一个小游戏开始" class="headerlink" title="先从一个小游戏开始"></a>先从一个小游戏开始</h1><p>一个简单的猜数游戏</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br>secret = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br>temp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;输入一个数\n&#x27;</span>)<br>guess = <span class="hljs-built_in">int</span>(temp)<br><span class="hljs-keyword">while</span> guess != secret:<br>    temp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;猜错了,重新猜\n&#x27;</span>)<br>    guess = <span class="hljs-built_in">int</span>(temp)<br>    <span class="hljs-keyword">if</span> guess == secret:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;猜中了&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> guess &lt; secret:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;猜小了&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;猜大了&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;游戏结束&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h1 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h1><p>Python中的数据类型有以下三种</p>
<p><code>str（字符串）、float（浮点型）、int（整型）</code></p>
<p>三种类型之间可以通过<code>int(),float(),str()</code>相互转换，但是有一定限制，比如某些时候就无法从<code>str</code>转<code>float</code></p>
<p><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gl95356z0yj30a106rdfu.jpg"></p>
<p>如上所示，str类型转float失败，但是某些情况下又是正常的，如果letter是数字的话，是可以进行类型转换的。如下所示：</p>
<p><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gl95353s4tj30a303xwed.jpg"></p>
<p>具体用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">firstStr = <span class="hljs-string">&#x27;你好&#x27;</span><br>secondStr = <span class="hljs-string">&#x27;我是小明同学&#x27;</span><br>thirdStr = firstStr + secondStr<br><span class="hljs-built_in">print</span>(thirdStr) <span class="hljs-comment"># 输出‘你好我是小明同学’</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1500000000</span>)<br><span class="hljs-comment"># 浮点型</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">1.5e9</span>) <span class="hljs-comment"># 输出1500000000.0</span><br><span class="hljs-comment"># bool 类型</span><br><span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span> + <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 三种类型的转换</span><br>    <span class="hljs-comment">## str() 转换为字符串</span><br>    <span class="hljs-comment">## int()    转换为整型</span><br>    <span class="hljs-comment">## float()  转换为浮点型</span><br>    <span class="hljs-comment">## 可以使用 type() 获取参数类型</span><br>    <span class="hljs-comment">## 使用isinstance() 函数判断两个变量类型是否一致</span><br>a = <span class="hljs-built_in">str</span>(<span class="hljs-string">&#x27;你好&#x27;</span>)<br>b = <span class="hljs-built_in">int</span> (<span class="hljs-number">1314</span>)<br>c = <span class="hljs-built_in">float</span>(<span class="hljs-number">520</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;判断a、b、c三者是否属于str字符变量&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(a,<span class="hljs-built_in">str</span>)) <span class="hljs-comment"># 输出True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(b,<span class="hljs-built_in">str</span>)) <span class="hljs-comment"># 输出False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(c,<span class="hljs-built_in">str</span>)) <span class="hljs-comment"># 输出False</span><br></code></pre></td></tr></table></figure>

<h1 id="2、操作符"><a href="#2、操作符" class="headerlink" title="2、操作符"></a>2、操作符</h1><p>python中的操作符与C++有一丝区别</p>
<blockquote>
<p>算术操作符：除了<code>+-*/</code>，多了一个<code>**(乘方) //(浮点除法(四舍五入))</code></p>
<p>比较操作符：python的标准比较操作符有：&lt;   &lt;=   &gt;    &gt;=    ==    !=    &lt;&gt;，根据表达式的真假，返回True/False布尔值数据类型</p>
<p>逻辑操作符：and、or、not是python提供的逻辑操作符，其作用是把表达式连接在一起，得到一个布尔值，</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python 中的操作符 + - * / % **(幂运算) //(浮点除法(四舍五入))</span><br><span class="hljs-comment"># //整除</span><br>a = <span class="hljs-number">8</span> // <span class="hljs-number">3</span> <span class="hljs-comment"># a=2</span><br><span class="hljs-built_in">print</span> (a)<br>b = <span class="hljs-number">8</span> / <span class="hljs-number">3</span> <span class="hljs-comment"># b=2.66666666665</span><br><span class="hljs-built_in">print</span> (b)<br>c = <span class="hljs-number">2</span> ** <span class="hljs-number">4</span><br><span class="hljs-built_in">print</span>(c)<br><span class="hljs-comment"># ** 幂运算符</span><br><br><span class="hljs-comment"># 逻辑操作符</span><br><span class="hljs-comment"># and or not</span><br>wrong  = <span class="hljs-keyword">not</span> <span class="hljs-literal">True</span><br><span class="hljs-built_in">print</span>(wrong)<br><br><span class="hljs-comment"># 三元操作符</span><br>a,b = <span class="hljs-number">4</span>,<span class="hljs-number">5</span><br><span class="hljs-built_in">max</span> = a <span class="hljs-keyword">if</span> a &gt; b <span class="hljs-keyword">else</span> b<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;max number是a&#x27;</span>) <span class="hljs-keyword">if</span> a &gt; b <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;max number是b,值为&#x27;</span>,b)<br>a = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Input a: &quot;</span>))<br>b = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Input b: &quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a大于b&quot;</span>) <span class="hljs-keyword">if</span> a &gt; b <span class="hljs-keyword">else</span> (<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a小于b&quot;</span>) <span class="hljs-keyword">if</span> a &lt; b <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a等于b&quot;</span>))<br><br><span class="hljs-comment"># 逻辑运算符</span><br><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">True</span> <span class="hljs-comment"># True</span><br><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span> <span class="hljs-comment"># False</span><br><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span> <span class="hljs-comment"># True</span><br><span class="hljs-keyword">not</span> <span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">True</span> <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure>

<h2 id="一道小的逻辑运算编写"><a href="#一道小的逻辑运算编写" class="headerlink" title="一道小的逻辑运算编写"></a>一道小的逻辑运算编写</h2><p>如下所示为简单的成绩判断代码。后边标注了悬挂else，python是根据缩进判断if-else的匹配，所以可以有效的避免else的悬挂问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">score = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入你的成绩:\n&#x27;</span>)<br>temp = <span class="hljs-built_in">int</span>(score)<br><span class="hljs-keyword">if</span> temp &gt;= <span class="hljs-number">90</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A&quot;</span>)<br><span class="hljs-keyword">elif</span> <span class="hljs-number">80</span> &lt;= temp &lt; <span class="hljs-number">90</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;B&#x27;</span>)<br><span class="hljs-keyword">elif</span> <span class="hljs-number">70</span> &lt;= temp &lt; <span class="hljs-number">80</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;C&#x27;</span>)<br><span class="hljs-keyword">elif</span> temp &lt; <span class="hljs-number">70</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;D&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;输入错误\n&#x27;</span>)<br><br><span class="hljs-comment"># 悬挂else</span><br>temp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入成绩\n&#x27;</span>);<br>temp = <span class="hljs-built_in">int</span>(temp)<br><span class="hljs-keyword">if</span> (temp &gt; <span class="hljs-number">80</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;成绩在80以上\n&#x27;</span>)<br>    <span class="hljs-keyword">if</span>(temp &gt; <span class="hljs-number">90</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;成绩优异&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;成绩良好，确认完毕&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;因为temp(&quot;</span>,temp,<span class="hljs-string">&quot;)小于80，所以这里就是所谓的悬挂else，&quot;</span><br>        <span class="hljs-string">&quot;相匹配的是上边temp&gt;90所对应的if,但是python可以避免，&quot;</span><br>        <span class="hljs-string">&quot;所以这里的else对应的是temp&gt;80所对应的if&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>什么是悬挂else？悬挂else是面试中最常见的一个问题，就是C\C++中的<code>else</code>与离他最近的<code>if</code>匹配如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>cin &gt;&gt; i;<br><span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">50</span>)<br>    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">55</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;稍微有点重&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;这个我喜欢&quot;</span>;<br></code></pre></td></tr></table></figure>

<h1 id="3、列表"><a href="#3、列表" class="headerlink" title="3、列表"></a>3、列表</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个普通列表</span><br>member = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;打印member列表：\n&#x27;</span>,member)<br><span class="hljs-comment"># 创建一个混合列表</span><br>mix = [<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;二&#x27;</span>,<span class="hljs-number">3.14</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;打印mix列表：&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;位置&#x27;</span>, <span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-string">&#x27;元素&#x27;</span>)<br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> mix:<br>    i = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-string">&#x27;|&#x27;</span>,each)<br><span class="hljs-comment"># 创建一个空列表</span><br>empty = []<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;打印empty列表&#x27;</span>,empty)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对member列表进行操作&quot;</span>)<br><span class="hljs-comment"># 向列表末尾添加元素 append()方法</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;使用append()方法插入新元素‘F’&quot;</span>)<br>member.append(<span class="hljs-string">&#x27;F&#x27;</span>)<br><span class="hljs-built_in">print</span>(member[<span class="hljs-number">5</span>]) <span class="hljs-comment"># 输出 F</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;member的长度为：&#x27;</span>,<span class="hljs-built_in">len</span>(member))<br><br><span class="hljs-comment"># extend()方法</span><br><span class="hljs-comment"># - 使用一个列表扩充另一个列表</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;使用extend()方法插入新元素‘G’‘H’&#x27;</span>)<br>member.extend([<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;H&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;member&#x27;</span>,member,<span class="hljs-string">&#x27;的长度为：&#x27;</span>,<span class="hljs-built_in">len</span>(member))<br><br><br><span class="hljs-comment"># 向列表中循环插入小写字母元素</span><br>i,j = <span class="hljs-number">1</span>,<span class="hljs-number">0</span><br>letter = <span class="hljs-string">&quot;abcdefgh&quot;</span><br><span class="hljs-keyword">while</span> i &lt; (<span class="hljs-built_in">len</span>(member)+<span class="hljs-number">1</span>):<br>    member.insert(i,letter[j])<br>    i += <span class="hljs-number">2</span><br>    j +=<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;插入小写字母后的member列表：\n&#x27;</span>,member)<br></code></pre></td></tr></table></figure>

<p>输出如下：</p>
<div style="background:black;font-family:consolas;color:white;padding-left:20px">
    打印member列表：<br>
 ['A', 'B', 'C', 'D', 'E']<br>
打印mix列表：<br>
位置 | 元素<br>
1 | 1<br>
2 | 二<br>
3 | 3.14<br>
4 | [1, 2, 3]<br>
打印empty列表 []<br>
对member列表进行操作<br>
使用append()方法插入新元素‘F’<br>
F<br>
member ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] 的长度为： 8<br>
插入小写字母后的member列表<br>
['A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f', 'G', 'g', 'H', 'h']</div>

<h2 id="操作符在列表中的应用"><a href="#操作符在列表中的应用" class="headerlink" title="操作符在列表中的应用"></a>操作符在列表中的应用<a id="lb"></a></h2><p>列表常见的一下操作符运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比较运算符</span><br>numlist1 = [<span class="hljs-number">123</span>]<br>numlist2 =[<span class="hljs-number">456</span>]<br>numlist1 &lt; numlist2 <span class="hljs-comment"># True</span><br>numlist3 = [<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-string">&#x27;456&#x27;</span>]<br>numlist4 = [<span class="hljs-string">&#x27;456&#x27;</span>,<span class="hljs-string">&#x27;123&#x27;</span>]<br>numlist3 == numlist4 <span class="hljs-comment"># False</span><br>numlist3 &lt; numlist4 <span class="hljs-comment"># True</span><br>numlist5 = [<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-string">&#x27;456&#x27;</span>]<br>numlist3 == numlist5 <span class="hljs-comment"># True</span><br>list1 = [<span class="hljs-number">123</span>]<br>list2 = [<span class="hljs-number">234</span>]<br>list1.extend(list2)<br><span class="hljs-comment"># 算术运算符</span><br>list1 <span class="hljs-comment"># [123, 234]</span><br>list1*<span class="hljs-number">3</span> <span class="hljs-comment"># [123, 234, 123, 234, 123, 234]</span><br>list1*=<span class="hljs-number">3</span><br>list1 <span class="hljs-comment"># [123, 234,123, 234,123, 234]</span><br><br><span class="hljs-comment"># 逻辑运算符</span><br><span class="hljs-number">111</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> list1 <span class="hljs-comment"># True</span><br><span class="hljs-number">123</span> <span class="hljs-keyword">in</span> list1 <span class="hljs-comment"># True</span><br><span class="hljs-comment">#混合列表的操作符运算</span><br>mixlist = [<span class="hljs-string">&#x27;小明同学&#x27;</span>,[<span class="hljs-string">&#x27;小红&#x27;</span>,<span class="hljs-string">&#x27;李华&#x27;</span>],<span class="hljs-number">456</span>]<br><span class="hljs-string">&#x27;小明同学&#x27;</span> <span class="hljs-keyword">in</span> mixlist <span class="hljs-comment"># True</span><br><span class="hljs-string">&#x27;小红&#x27;</span> <span class="hljs-keyword">in</span> mixlist <span class="hljs-comment"># False</span><br><br>mixlist[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-comment"># &#x27;李华&#x27;</span><br><br></code></pre></td></tr></table></figure>
<p>列表中常见的一些逻辑操作符使用<code>dir(list)</code>可以查看list的方法和内置函数：</p>
<p><code>&#39;append&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;, &#39;remove&#39;, &#39;reverse&#39;, &#39;sort&#39;</code></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>append</td>
<td>在末尾添加元素</td>
</tr>
<tr>
<td>clear</td>
<td>清除列表</td>
</tr>
<tr>
<td>copy</td>
<td>复制</td>
</tr>
<tr>
<td>count</td>
<td>统计元素</td>
</tr>
<tr>
<td>extend</td>
<td>添加</td>
</tr>
<tr>
<td>index</td>
<td>返回相应元素的下标</td>
</tr>
<tr>
<td>insert</td>
<td>插入元素</td>
</tr>
<tr>
<td>pop</td>
<td>删除并返回最后一个元素</td>
</tr>
<tr>
<td>remove</td>
<td>移除操作</td>
</tr>
<tr>
<td>reverse</td>
<td>翻转列表</td>
</tr>
<tr>
<td>sort</td>
<td>排序（递增）可以使用<code>list1.sort(reverse=True)</code>进行降序排列 <mark>True可以改为1</mark></td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#count</span><br>list1.count(<span class="hljs-number">123</span>) <span class="hljs-comment"># 3 统计列表中123的个数</span><br><br><span class="hljs-comment">#index</span><br>list1.index(<span class="hljs-number">123</span>) <span class="hljs-comment"># 0返回列表中第一个123的下标</span><br>list1.index(<span class="hljs-number">123</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>) <span class="hljs-comment"># 4 从第3位开始返回第一个123的下标</span><br><br><span class="hljs-comment">#sort</span><br>list3 = [<span class="hljs-number">23</span>,<span class="hljs-number">34</span>,<span class="hljs-number">654</span>,<span class="hljs-number">876</span>,<span class="hljs-number">123</span>,<span class="hljs-number">1</span>]<br>list3.sort()<br>list3 <span class="hljs-comment">#[1, 23, 34, 123, 654, 876]</span><br>list3.sort(reverse=<span class="hljs-literal">True</span>)<br>list3 <span class="hljs-comment"># [876, 654, 123, 34, 23, 1]</span><br></code></pre></td></tr></table></figure>

<h2 id="列表中的深拷贝与浅拷贝"><a href="#列表中的深拷贝与浅拷贝" class="headerlink" title="列表中的深拷贝与浅拷贝"></a>列表中的深拷贝与浅拷贝</h2><p>可以看到等号进行的浅拷贝，相当于有一个指针指向了list3，而list5则是单独开辟了一块空间进行存储</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">list5 = list3[:] <span class="hljs-comment">#使用切片拷贝属于深拷贝</span><br>list6 = list3 <span class="hljs-comment"># 等号操作符执行的是浅拷贝</span><br>list3.sort()<br>list3 <span class="hljs-comment"># [1, 23, 34, 123, 654, 876]</span><br>list5 <span class="hljs-comment"># [876, 654, 123, 34, 23, 1]</span><br>list6 <span class="hljs-comment"># [1, 23, 34, 123, 654, 876]</span><br></code></pre></td></tr></table></figure>

<h2 id="附带操作"><a href="#附带操作" class="headerlink" title="附带操作"></a>附带操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">list3 = [<span class="hljs-number">23</span>,<span class="hljs-number">34</span>,<span class="hljs-number">654</span>,<span class="hljs-number">876</span>,<span class="hljs-number">123</span>,<span class="hljs-number">1</span>]<br><span class="hljs-built_in">max</span>(list3) <span class="hljs-comment"># 876</span><br><span class="hljs-built_in">min</span>(list3) <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">sum</span>(list3) <span class="hljs-comment"># 1711</span><br></code></pre></td></tr></table></figure>

<h1 id="4、元组和列表"><a href="#4、元组和列表" class="headerlink" title="4、元组和列表"></a>4、元组和列表</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#元组 tuple</span><br><span class="hljs-comment"># 创建一个元组tuple1</span><br>tuple1 = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span><br><span class="hljs-built_in">print</span>(tuple1)<br><span class="hljs-comment"># 列表</span><br><span class="hljs-comment"># 创建一个列表</span><br>list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(list1)<br><span class="hljs-comment"># 列表和元组插入元素（拼接）</span><br>list1 = list1[:<span class="hljs-number">2</span>] + [<span class="hljs-number">3</span>] + list1[<span class="hljs-number">2</span>:] <span class="hljs-comment">#列表中使用切片插入元素时需要用[]</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;插入元素之后的列表和元组\n&#x27;</span>,list1)<br>tuple1 = tuple1[:<span class="hljs-number">2</span>] + (<span class="hljs-number">3</span>,) + tuple1[<span class="hljs-number">2</span>:] <span class="hljs-comment"># 3所在位置的逗号与括号缺一不可</span><br><span class="hljs-built_in">print</span>(tuple1)<br><span class="hljs-comment"># 删除操作</span><br>temp = tuple1[:]<br><span class="hljs-keyword">del</span> temp <span class="hljs-comment"># 释放掉temp</span><br><br>tuple2 = <span class="hljs-number">2</span>*tuple1 <span class="hljs-comment">#tuple2 = (1, 2, 3, 4, 5, 1, 2, 3, 4, 5)</span><br></code></pre></td></tr></table></figure>

<div style="background:black;font-family:consolas;color:white;padding-left:20px">
(1, 2, 4, 5, 6)<br>
[1, 2, 4, 5, 6]<br>
插入元素之后的列表和元组<br>
 [1, 2, 3, 4, 5, 6]<br>
(1, 2, 3, 4, 5, 6)<br>
</div>

<p>元组的操作符使用和<a href="#lb">列表</a>一致。</p>
<h1 id="5、字符串"><a href="#5、字符串" class="headerlink" title="5、字符串"></a>5、字符串</h1><h2 id="str字符串的一些方法："><a href="#str字符串的一些方法：" class="headerlink" title="str字符串的一些方法："></a>str字符串的一些方法：</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>capitalize()</td>
<td>大写单词首字母</td>
</tr>
<tr>
<td>casefold()</td>
<td>小写所有字母</td>
</tr>
<tr>
<td>center()</td>
<td>居中字符串</td>
</tr>
<tr>
<td>count(sub[,start,end]) # [] 表示可选</td>
<td>统计start到end区间的sub字符串个数</td>
</tr>
<tr>
<td>encode(encoding = ‘utf-8’,errors=’strict’)</td>
<td>编码设置</td>
</tr>
<tr>
<td>espandtabs([tabsize=8])</td>
<td>把字符串中的\t 都替换成空格，可设置替换的空格数量</td>
</tr>
<tr>
<td>endswith(sub[,start,end])</td>
<td>判断是否以sub字符串结尾</td>
</tr>
<tr>
<td>find(sub[,start,end])</td>
<td>检测sub是否包含在字符串中，如果有则返回索引值，否则返回-1.start和end参数表示范围，可选</td>
</tr>
<tr>
<td>index(sub[,start,end])</td>
<td>和find基本一致，但是如果sub不在string0中则会产生一个异常</td>
</tr>
<tr>
<td>isalnum()</td>
<td>如果字符串中至少有一个字母并且全都是字母或数字则返回True，否则返回False</td>
</tr>
<tr>
<td>isalpha()</td>
<td>如果字符串中至少有一个字母并且全都是字母则返回True，否则返回False</td>
</tr>
<tr>
<td>isdigit()</td>
<td>如果字符串中只包含数字则返回True，否则返回False</td>
</tr>
<tr>
<td>islower()</td>
<td>如果字符串可以区分大小写，并且都是小写，则返回Ttrue，否则返回False</td>
</tr>
<tr>
<td>isnumeric()</td>
<td>如果字符中是包含数字，则返回True，否则False</td>
</tr>
<tr>
<td>isspace()</td>
<td>如果字符只包含空格，则返回True，否则False</td>
</tr>
<tr>
<td>istitle()</td>
<td>所有单词开头字母是大写就返回True,否则返回False</td>
</tr>
<tr>
<td>isupper()</td>
<td>如果字符串可以区分大小写，并且都是大写，则返回Ttrue，否则返回False</td>
</tr>
<tr>
<td>join(sub)</td>
<td>以字符串为分隔符插入到sub中所以的字符之间</td>
</tr>
<tr>
<td>ljust()</td>
<td>左对齐</td>
</tr>
<tr>
<td>strip()</td>
<td>去掉前后的空格，对应的还有lstrip()、rstrip(),分别是去掉左边和右边的空格</td>
</tr>
<tr>
<td>partition(sub)</td>
<td>以sub字符串为分界符，把字符串划分为一个三元组，默认返回一个元组；如果字符串中不包含sub，则返回<code>(&#39;原字符串&#39;,&#39;&#39;,&#39;&#39;)</code></td>
</tr>
<tr>
<td>replace(old,new[,count])</td>
<td>替换字符串，如果指定count，则只替换指定次数</td>
</tr>
<tr>
<td>split(sep=None,maxsplit=-1)</td>
<td>不带参数默认是以空格为分解符切片字符串，如果maxsplit参数有设置，则仅分割maxsplit个子字符串，返回切片后的字符串列表</td>
</tr>
<tr>
<td>startswith(sub[,start,end])</td>
<td></td>
</tr>
<tr>
<td>title()</td>
<td></td>
</tr>
<tr>
<td>translate()</td>
<td>根据table的规则（可以由<code>str.maketrans(&#39;a&#39;,&#39;d&#39;)</code>定制）转换字符串中的字符</td>
</tr>
<tr>
<td>upper()</td>
<td>将所有字母都大写</td>
</tr>
<tr>
<td>zfill(lenght)</td>
<td>返回指定长度的字符串，如果原字符串不够，则前边用0代替</td>
</tr>
</tbody></table>
<h2 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot; ada lovelace &quot;</span><br>name<br><span class="hljs-string">&#x27; ada lovelace &#x27;</span><br>name[:<span class="hljs-number">4</span>]<br><span class="hljs-string">&#x27; ada&#x27;</span><br><span class="hljs-comment"># strip</span><br>name.rstrip() <span class="hljs-comment"># 输出“ ada lovelace”</span><br>name.lstrip() <span class="hljs-comment"># 输出“ada lovelace ”</span><br>name.strip() <span class="hljs-comment"># 输出“ada lovelace”</span><br><span class="hljs-comment"># capitalize</span><br>name.strip().capitalize() <span class="hljs-comment">#string 是去掉开头和结尾的空格</span><br><span class="hljs-string">&#x27;Ada lovelace&#x27;</span><br><span class="hljs-comment"># casefolad 小写所有字母</span><br>NAME = <span class="hljs-string">&#x27;ADA LOVELACE&#x27;</span><br>NAME.casefold()<br><span class="hljs-string">&#x27;ada lovelace&#x27;</span><br><span class="hljs-comment"># center</span><br>name.center(<span class="hljs-number">40</span>)<br><span class="hljs-string">&#x27;              ada lovelace              &#x27;</span><br><span class="hljs-comment"># count</span><br>name.count(<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-number">3</span><br><span class="hljs-comment"># endswith</span><br>name.endswith(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-literal">True</span><br>name.endswith(<span class="hljs-string">&#x27;lace&#x27;</span>)<br><span class="hljs-literal">False</span><br><br><span class="hljs-comment"># find 找到返回索引，否则返回-1</span><br>name.find(<span class="hljs-string">&#x27;ada&#x27;</span>)<br><span class="hljs-number">1</span><br>name.find(<span class="hljs-string">&#x27;cda&#x27;</span>)<br>-<span class="hljs-number">1</span><br><span class="hljs-comment"># join</span><br>name.join(<span class="hljs-string">&#x27;||||||&#x27;</span>)<br><span class="hljs-string">&#x27;| ada lovelace | ada lovelace | ada lovelace | ada lovelace | ada lovelace |&#x27;</span><br><span class="hljs-comment"># partition</span><br>listName = name.partition(<span class="hljs-string">&#x27;love&#x27;</span>)<br>listName<br>(<span class="hljs-string">&#x27; ada &#x27;</span>, <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;lace &#x27;</span>)<br><span class="hljs-built_in">type</span>(listName)<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">tuple</span>&#x27;&gt;</span><br><span class="hljs-class"># <span class="hljs-title">replace</span></span><br><span class="hljs-class"><span class="hljs-title">name</span>.<span class="hljs-title">replace</span>(<span class="hljs-params"><span class="hljs-string">&#x27;ada&#x27;</span>,<span class="hljs-string">&#x27;dad&#x27;</span></span>)</span><br><span class="hljs-class">&#x27; <span class="hljs-title">dad</span> <span class="hljs-title">lovelace</span> &#x27;</span><br><span class="hljs-class"># <span class="hljs-title">split</span></span><br><span class="hljs-class"><span class="hljs-title">name</span>.<span class="hljs-title">split</span>()</span><br>[&#x27;ada&#x27;, &#x27;lovelace&#x27;]<br><span class="hljs-comment">#translate</span><br>name.translate(<span class="hljs-built_in">str</span>.maketrans(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>))<br><span class="hljs-string">&#x27; bdb lovelbce &#x27;</span><br><span class="hljs-comment"># title</span><br>name.title()<br><span class="hljs-string">&#x27; Ada Lovelace &#x27;</span><br><span class="hljs-comment"># upper</span><br>name.upper()<br><span class="hljs-string">&#x27; ADA LOVELACE &#x27;</span><br><span class="hljs-comment"># zfill</span><br>name.zfill(<span class="hljs-number">40</span>)<br><span class="hljs-string">&#x27;00000000000000000000000000 ada lovelace &#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><p><code>format()</code>的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 第一种方式，使用数字</span><br><span class="hljs-string">&quot;&#123;0&#125;,&#123;1&#125;&#123;2&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot; ada&quot;</span>,<span class="hljs-string">&quot; love&quot;</span>,<span class="hljs-string">&quot;lace &quot;</span>)<br><span class="hljs-string">&#x27; ada, lovelace &#x27;</span><br><span class="hljs-comment"># 第二种方式，使用变量</span><br><span class="hljs-string">&quot;&#123;a&#125;&#123;b&#125;&#123;c&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a=<span class="hljs-string">&quot; ada &quot;</span>,b=<span class="hljs-string">&quot;love&quot;</span>,c=<span class="hljs-string">&quot;lace &quot;</span>)<br><span class="hljs-string">&#x27; ada lovelace &#x27;</span><br><span class="hljs-string">&quot;&#123;&#123;0&#125;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;不打印&quot;</span>)<br><span class="hljs-string">&#x27;&#123;0&#125;&#x27;</span><br><span class="hljs-comment"># 控制浮点型变量的输出格式</span><br><span class="hljs-string">&#x27;&#123;0:.1f&#125;&#123;1&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;GB&#x27;</span>)<br><span class="hljs-string">&#x27;3.1GB&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="字符串格式化符号含义"><a href="#字符串格式化符号含义" class="headerlink" title="字符串格式化符号含义"></a>字符串格式化符号含义</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>格式化字符及其ASCII码</td>
</tr>
<tr>
<td>%s</td>
<td>格式化字符串</td>
</tr>
<tr>
<td>%d</td>
<td>格式化整数</td>
</tr>
<tr>
<td>%o</td>
<td>格式化无符号八进制数（octonary，OCT）</td>
</tr>
<tr>
<td>%x</td>
<td>格式化无符号十六进制数</td>
</tr>
<tr>
<td>%f</td>
<td>格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td>%e</td>
<td>格式化定点数，可指定小数点后的精度</td>
</tr>
<tr>
<td>%E</td>
<td>用作科学技术法格式化定点数</td>
</tr>
<tr>
<td>%g</td>
<td>根据值的大小决定%f或%e</td>
</tr>
<tr>
<td>%G</td>
<td>作用同%g，根据值的大小决定使用%f或者%e</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># %的一些用法</span><br><span class="hljs-comment">#---------------</span><br>letter = <span class="hljs-string">&#x27;%c %c %c&#x27;</span> % (<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>)<br>letter<br><span class="hljs-string">&#x27;a b c&#x27;</span><br><span class="hljs-comment">#---------------</span><br>name = <span class="hljs-string">&#x27;%s&#x27;</span> % <span class="hljs-string">&#x27;ada lovelace&#x27;</span><br>name<br><span class="hljs-string">&#x27;ada lovelace&#x27;</span><br><span class="hljs-comment">#---------------</span><br><span class="hljs-string">&#x27;%f&#x27;</span> % <span class="hljs-number">3.1415</span><br><span class="hljs-string">&#x27;3.141500&#x27;</span><br><span class="hljs-comment">#---------------</span><br><span class="hljs-string">&#x27;%#x&#x27;</span> % <span class="hljs-number">18</span><br><span class="hljs-string">&#x27;0x12&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="格式化操作辅助命令"><a href="#格式化操作辅助命令" class="headerlink" title="格式化操作辅助命令"></a>格式化操作辅助命令</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>m.n</td>
<td>m是显示的最小总宽度，n是小数点后的位数</td>
</tr>
<tr>
<td>-</td>
<td>用于左对齐</td>
</tr>
<tr>
<td>+</td>
<td>在正数前面显示加号（+）</td>
</tr>
<tr>
<td>#</td>
<td>在八进制数前面显示零(‘0’)，在十六进制数前面显示’0x’或者’0x’</td>
</tr>
<tr>
<td>0</td>
<td>显示的数字前面填充’0’取代空格</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#---------------</span><br><span class="hljs-string">&#x27;%+1.2f&#x27;</span> % <span class="hljs-number">3.1415</span><br><span class="hljs-string">&#x27;+3.14&#x27;</span><br><span class="hljs-string">&#x27;%-10.2f&#x27;</span> % <span class="hljs-number">3.1415</span><br><span class="hljs-string">&#x27;3.14      &#x27;</span><br><span class="hljs-comment">#---------------</span><br><span class="hljs-string">&#x27;%#x&#x27;</span> % <span class="hljs-number">18</span><br><span class="hljs-string">&#x27;0x12&#x27;</span><br><span class="hljs-string">&#x27;%#X&#x27;</span> % <span class="hljs-number">18</span><br><span class="hljs-string">&#x27;0X12&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="字符串转义字符含义"><a href="#字符串转义字符含义" class="headerlink" title="字符串转义字符含义"></a>字符串转义字符含义</h2><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\a</td>
<td>发出系统响铃声</td>
</tr>
<tr>
<td>\b</td>
<td>退格符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符</td>
</tr>
<tr>
<td>\v</td>
<td>纵向制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\o</td>
<td>八进制数代表的字符</td>
</tr>
<tr>
<td>\x</td>
<td>十六进制数代表的字符</td>
</tr>
<tr>
<td>\0</td>
<td>表示一个字符</td>
</tr>
<tr>
<td>\\</td>
<td>反斜杠</td>
</tr>
</tbody></table>
<h2 id="列表、元组、字符串小结"><a href="#列表、元组、字符串小结" class="headerlink" title="列表、元组、字符串小结"></a>列表、元组、字符串小结</h2><p>列表、元组和字符串的共同点：</p>
<blockquote>
<ol>
<li>都可以通过索引得到每一个元素</li>
<li>默认索引值总是从0开始</li>
<li>可以通过分片的方法得到一个范围内的元素的集合</li>
<li>有很多共同的操作符（无重复操作符、拼接操作符、成员关系操作符）</li>
</ol>
</blockquote>
<h1 id="6、序列"><a href="#6、序列" class="headerlink" title="6、序列"></a>6、序列</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># list方法</span><br>name = <span class="hljs-string">&quot;ada lovelace&quot;</span><br>name = <span class="hljs-built_in">list</span>(name) <span class="hljs-comment"># 把name转换为列表 同样适用于tuple()</span><br><span class="hljs-built_in">print</span>(name)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">min</span>(name)) <span class="hljs-comment"># 输出列表中的最小值&#x27; &#x27; name最小值为空格</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(name)) <span class="hljs-comment"># 输出列表中的最大值&#x27;v&#x27; name最大值为&#x27;v&#x27;</span><br>tupleNum = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(tupleNum))<br>tupleNum = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;A&#x27;</span>)<br><span class="hljs-comment">#print(max(tupleNum)) # 在添加了A元素之后再进行比较就会出错</span><br>                     <span class="hljs-comment"># &#x27;&gt;&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27;</span><br>tupleNum2 = (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;tupleNum2:&#x27;</span>,tupleNum2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sun(tupleNum2):&#x27;</span>,<span class="hljs-built_in">sum</span>(tupleNum2))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sorted()排序之后：&#x27;</span>,<span class="hljs-built_in">sorted</span>(tupleNum2))<br><span class="hljs-comment">#reverse()反转链表</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;reversed()函数调用：&#x27;</span>,<span class="hljs-built_in">reversed</span>(tupleNum2))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;list(reversed(tumpleNum2))):&#x27;</span>,<span class="hljs-built_in">list</span>(<span class="hljs-built_in">reversed</span>(tupleNum2)))<br><br><span class="hljs-comment">#enumerate() 枚举</span><br><span class="hljs-built_in">enumerate</span>(tupleNum2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;list(enumerate(tupleNum2))：&#x27;</span>,<span class="hljs-built_in">list</span>(<span class="hljs-built_in">enumerate</span>(tupleNum2)))<br><br><span class="hljs-comment">#zip() 按最短列表的下标一一对应组合</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;tupleNum和tupleNum2：&#x27;</span>,tupleNum,tupleNum2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;list(zip(tupleNum,tupleNum2))：&#x27;</span>,<span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(tupleNum,tupleNum2)))<br></code></pre></td></tr></table></figure>

<p>上述运行结果：</p>
<div style="background:black;font-family:consolas;color:white;padding-left:20px">
['a', 'd', 'a', ' ', 'l', 'o', 'v', 'e', 'l', 'a', 'c', 'e']<br>
 <br>
v<br>
6<br>
tupleNum2: (2, 3, 1, 5, 4)<br>
sun(tupleNum2): 15<br>
sorted()排序之后： [1, 2, 3, 4, 5]<br>
reversed()函数调用： <reversed object at 0x000002941b2afe80><br>
list(reversed(tumpleNum2))): [4, 5, 1, 3, 2]<br>
list(enumerate(tupleNum2))： [(0, 2), (1, 3), (2, 1), (3, 5), (4, 4)]<br>
tupleNum和tupleNum2： (1, 2, 3, 4, 5, 6, 'A') (2, 3, 1, 5, 4)<br>
list(zip(tupleNum,tupleNum2))： [(1, 2), (2, 3), (3, 1), (4, 5), (5, 4)]<br>
</reversed></div>

<h1 id="7、函数"><a href="#7、函数" class="headerlink" title="7、函数"></a>7、函数</h1><p>使用<code>def</code>创建函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 无参函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">MyFirstFunction</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用了MyFirstFunction()函数&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;函数创建格式是 \&#x27;def 函数名():\&#x27;&quot;</span>)<br><br>MyFirstFunction()<br><span class="hljs-comment"># 带参数的函数，参数个数不限量</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">PrintName</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我的名字是：&#x27;</span>,name)<br><br>PrintName(<span class="hljs-string">&#x27;mingming&#x27;</span>)<br><br><span class="hljs-comment"># example加和函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1,num2</span>):</span><br>    <span class="hljs-keyword">return</span>(num1+num2)<br><br><span class="hljs-built_in">sum</span> = add(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>)<br><br><span class="hljs-comment"># 定义带默认参数的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printName</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;ada lovelace&#x27;</span></span>):</span><br>	<span class="hljs-built_in">print</span>(name)<br><span class="hljs-built_in">print</span>()<br><span class="hljs-comment"># 收集参数 在参数前面加上*</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">collaction</span>(<span class="hljs-params">*parameters</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;参数的长度是：&#x27;</span>,<span class="hljs-built_in">len</span>(parameters))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第二个参数是：&quot;</span>,parameters[<span class="hljs-number">1</span>])<br>collaction(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>上述代码运行结果：</p>
<div style="background:black;font-family:consolas;color:white;padding-left:20px">调用了MyFirstFunction()函数
函数创建格式是 'def 函数名():'<br>
我的名字是： mingming<br>
15<br>
ada lovelace<br>
参数的长度是： 3<br>
第二个参数是： b<br>
</div>

<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>在python中函数会自动为没有返回值的函数返回<code>None</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用列表作为返回值</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">letterList</span>():</span><br>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p>输出<code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></p>
<h2 id="函数变量的作用域"><a href="#函数变量的作用域" class="headerlink" title="函数变量的作用域"></a>函数变量的作用域</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">discount</span>(<span class="hljs-params">price,rate</span>):</span><br>    <span class="hljs-comment"># 在这里可以对old_price和rate全局变量进行修改，但是是局部变量的old_price和rate，存储位置不同</span><br>    <span class="hljs-comment"># 函数修改全局变量可以在函数开头用global+变量名</span><br>    <span class="hljs-comment"># global old_price # 取消注释old_price作为全局变量被修改</span><br>    final_price = price * rate<br>    old_price = <span class="hljs-number">1000</span><br>    <span class="hljs-keyword">return</span> final_price<br><br>old_price = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入原价：&#x27;</span>))<br>rate = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入折扣：&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;打折后的价格是：&#x27;</span>)<br><span class="hljs-built_in">print</span>(discount(old_price,rate))<br><span class="hljs-comment"># 全局变量 old_price在执行完discount()函数之后不能被修改</span><br>pritn(old_price) <span class="hljs-comment"># 打印100</span><br></code></pre></td></tr></table></figure>

<p>程序输入：</p>
<div style="background:black;font-family:consolas;color:white;padding-left:20px">
100<br>
0.8
</div>

<p>程序输出：</p>
<div style="background:black;font-family:consolas;color:white;padding-left:20px">
这里是对全局变量修改后的值 50.0<br>
80.0<br>
old_price修改后的值： 50.0<br>
</div>

<h2 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 函数嵌套</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun1</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;fun1函数正在被调用&#x27;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun2</span>():</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;fun2函数正在被调用&#x27;</span>)<br>    fun2()<br>fun1()<br><br><span class="hljs-comment"># 闭包</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FunX</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">FunY</span>(<span class="hljs-params">y</span>):</span><br>        <span class="hljs-keyword">return</span> x*y<br>  	<span class="hljs-keyword">return</span> FunY<br>Funx(<span class="hljs-number">2</span>)(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>

<p>在闭包中：外层的局部变量对内层而言也是不可以使用的，可以通过容器实现值传递。如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下列情况会报错 使用未定义变量</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun1</span>():</span><br>    x = <span class="hljs-number">5</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun2</span>():</span><br>        x *= x<br>        <span class="hljs-keyword">return</span> x<br>    <span class="hljs-keyword">return</span> fun2()<br><span class="hljs-comment">#如果fun2()想要使用fun1()的变量，可以通过容器实现</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun1</span>():</span><br>    x = [<span class="hljs-number">5</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun2</span>():</span><br>        x[<span class="hljs-number">0</span>] *= x[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> fun2()<br><span class="hljs-comment"># python3之后可以使用nonlocal+变量名使用</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun1</span>():</span><br>    x = <span class="hljs-number">5</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun2</span>():</span><br>        <span class="hljs-keyword">nonlocal</span> x<br>        x *= x<br>        <span class="hljs-keyword">return</span> x<br><span class="hljs-keyword">return</span> fun2()<br></code></pre></td></tr></table></figure>

<h1 id="8、lambda表达式"><a href="#8、lambda表达式" class="headerlink" title="8、lambda表达式"></a>8、lambda表达式</h1><p>使用lambda表达式创建匿名函数，使用lambda表达式有以下优势：</p>
<ul>
<li><p>Python写一些执行脚本时，使用lambda就可以省下定义函数的过程，可以使代码更加简洁</p>
</li>
<li><p>对于一些比较抽象，调用次数较少的函数可以使用lambda表达式</p>
</li>
<li><p>简化代码的可读性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">g = <span class="hljs-keyword">lambda</span> x : <span class="hljs-number">2</span> * x + <span class="hljs-number">1</span><br>g(<span class="hljs-number">5</span>) <span class="hljs-comment"># 输出5</span><br>h = <span class="hljs-keyword">lambda</span> x,y :  x * y<br>h(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) <span class="hljs-comment"># 返回12</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="筛选器filter"><a href="#筛选器filter" class="headerlink" title="筛选器filter"></a>筛选器<code>filter</code></h2><p>使用filter筛选器对字段进行筛选</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">temp = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">odd</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span>;<br>show = <span class="hljs-built_in">filter</span>(odd,temp)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(show))<br><span class="hljs-comment"># 使用lambda函数设置过滤条件</span><br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x : x % <span class="hljs-number">2</span>,<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))) <span class="hljs-comment"># 打印[1, 3, 5, 7, 9] 相比于上边的代码，这种方式简单明了</span><br><span class="hljs-comment"># 同样的使用方式还有：</span><br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x : x **<span class="hljs-number">2</span> ,<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br></code></pre></td></tr></table></figure>

<h1 id="9、递归"><a href="#9、递归" class="headerlink" title="9、递归"></a>9、递归</h1><h2 id="实例一：阶乘"><a href="#实例一：阶乘" class="headerlink" title="实例一：阶乘"></a>实例一：阶乘</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义阶乘函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n</span>):</span><br>    result = n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>        result *= i<br>    <span class="hljs-keyword">return</span> result<br><span class="hljs-comment"># 递归实现阶乘函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recurisionFac</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">if</span> n != <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> n * recurisionFac(n-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-comment"># 调用阶乘函数</span><br>num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入一个正整数：&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%d的阶乘是%d&#x27;</span>%(num,recurisionFac(num)))<br></code></pre></td></tr></table></figure>

<h2 id="实例二：斐波那契数列"><a href="#实例二：斐波那契数列" class="headerlink" title="实例二：斐波那契数列"></a>实例二：斐波那契数列</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 递归实现</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fibonaq</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> fibonaq(n-<span class="hljs-number">1</span>)+fibonaq(n-<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(fibonaq(<span class="hljs-number">10</span>))<br><br><span class="hljs-comment"># 迭代实现</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fab</span>(<span class="hljs-params">n</span>):</span><br>    n1 = <span class="hljs-number">1</span><br>    n2 = <span class="hljs-number">1</span><br>    n3 = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">2</span>:<br>        n3 = n2 + n1<br>        n1 = n2<br>        n2 = n3<br>        n -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> n3<br></code></pre></td></tr></table></figure>

<h2 id="实例三、汉诺塔"><a href="#实例三、汉诺塔" class="headerlink" title="实例三、汉诺塔"></a>实例三、汉诺塔</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 四个参数可以理解为：(圆盘数量，起始位置，闲置位置，终点位置)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hanoi</span>(<span class="hljs-params">n,x,y,z</span>):</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(x,<span class="hljs-string">&#x27;---&gt;&#x27;</span>,z)<br>    <span class="hljs-keyword">else</span>:<br>        hanoi(n-<span class="hljs-number">1</span>,x,z,y) <span class="hljs-comment"># 将前n-1个盘子从x移动到y上</span><br>        <span class="hljs-built_in">print</span>(x,<span class="hljs-string">&#x27;----&gt;&#x27;</span>,z) <span class="hljs-comment"># 将最底下的最后一个盘子从x移动到z上</span><br>        hanoi(n-<span class="hljs-number">1</span>,y,x,z) <span class="hljs-comment"># 将y上的n-1个盘子移动到z上</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入汉诺塔的层数：&#x27;</span>))<br>hanoi(n,<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-string">&#x27;Y&#x27;</span>,<span class="hljs-string">&#x27;Z&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h1 id="10、字典"><a href="#10、字典" class="headerlink" title="10、字典{}"></a>10、字典{}</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">brand = [<span class="hljs-string">&#x27;李宁&#x27;</span>,<span class="hljs-string">&#x27;安踏&#x27;</span>,<span class="hljs-string">&#x27;耐克&#x27;</span>,<span class="hljs-string">&#x27;阿迪&#x27;</span>]<br>slogn = [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;阿迪对应的的letter是：&#x27;</span>,slogn[brand.index(<span class="hljs-string">&#x27;阿迪&#x27;</span>)])<br><br><span class="hljs-comment"># 创建key-value键值对 dictionary</span><br>dict1 = &#123;<span class="hljs-string">&#x27;李宁&#x27;</span>:<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;安踏&#x27;</span>:<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;耐克&#x27;</span>:<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;阿迪&#x27;</span>:<span class="hljs-string">&#x27;D&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;阿迪对应的letter是（2）：&#x27;</span>,dict1[<span class="hljs-string">&#x27;阿迪&#x27;</span>])<br><br><br>dict3 = <span class="hljs-built_in">dict</span>(((<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-number">70</span>),(<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-number">15</span>),(<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">90</span>),(<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-number">123</span>)))<br><span class="hljs-built_in">print</span>(dict3)<br><br><br>dictEmp = &#123;&#125;<br>dictEmp.fromkeys((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br>dictEmp = dictEmp.fromkeys(<span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>),<span class="hljs-string">&#x27;赞&#x27;</span>)<br><span class="hljs-comment"># 改写键的值</span><br>dictEmp[<span class="hljs-number">4</span>] = <span class="hljs-string">&#x27;不赞&#x27;</span><br><span class="hljs-comment"># copy() 浅拷贝</span><br>dictcopy = dictEmp.copy()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;打印拷贝字典：&#x27;</span>,dictcopy)<br><span class="hljs-comment"># setdefault</span><br>dictEmp.setdefault(<span class="hljs-string">&#x27;最后位置&#x27;</span>)<br>dictEmp.setdefault(<span class="hljs-number">32</span>,<span class="hljs-string">&#x27;第32个位置&#x27;</span>)<br><span class="hljs-built_in">print</span>(dictEmp)<br><span class="hljs-comment"># 弹出索引位置的value</span><br><span class="hljs-built_in">print</span>(dictEmp.pop(<span class="hljs-number">4</span>))<br><span class="hljs-comment"># 随机弹出</span><br><span class="hljs-built_in">print</span>(dictEmp.popitem())<br><span class="hljs-comment"># 清空字典</span><br>dictEmp.clear()<br><span class="hljs-built_in">print</span>(dictEmp)<br></code></pre></td></tr></table></figure>

<h1 id="11、文件"><a href="#11、文件" class="headerlink" title="11、文件"></a>11、文件</h1><p><code>open()函数原型</code>Open file and return a stream.  Raise OSError upon failure.</p>
<p><code> open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></p>
<p>mode的参数：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>执行操作</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>以只读方式打开文件（默认）</td>
</tr>
<tr>
<td>w</td>
<td>以写入的当时打开文件</td>
</tr>
<tr>
<td>x</td>
<td>会覆盖已存在的文件</td>
</tr>
<tr>
<td>a</td>
<td>如果文件已经存在，使用此模式打开将引发异常</td>
</tr>
<tr>
<td>b</td>
<td>以写入模式打开，如果文件存在，则在末尾追加写入</td>
</tr>
<tr>
<td>t</td>
<td>以文本模式打开</td>
</tr>
<tr>
<td>+</td>
<td>可读写模式（可添加到其他模式中使用）</td>
</tr>
<tr>
<td>U</td>
<td>通用换行符支持</td>
</tr>
</tbody></table>
<p>code:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">Datafile = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;D:\\Groceries.csv&#x27;</span>)  <span class="hljs-comment">#双反斜杠表是转义字符</span><br>Datafile <span class="hljs-comment"># 查看返回的对象</span><br>Datafile.close()<br><span class="hljs-comment"># &lt;_io.TextIOWrapper name=&#x27;D:\\Groceries.csv&#x27; mode=&#x27;r&#x27; encoding=&#x27;cp936&#x27;&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="文件对象方法"><a href="#文件对象方法" class="headerlink" title="文件对象方法"></a>文件对象方法</h2><table>
<thead>
<tr>
<th>文件对象方法</th>
<th>执行操作</th>
</tr>
</thead>
<tbody><tr>
<td>f.close()</td>
<td>关闭文件</td>
</tr>
<tr>
<td>f.read(size=-1)</td>
<td>从文件读取size个字符，当未给定size或给定负值是，读取剩余的所有字符，然后作为字符串返回</td>
</tr>
<tr>
<td>f.readline()</td>
<td>以写入模式打开，如果文件存在，则在末尾追加写入</td>
</tr>
<tr>
<td>f.write(str)</td>
<td>将字符串str写入文件</td>
</tr>
<tr>
<td>f.writelines(seq)</td>
<td>向文件写入字符串序列seq，seq应该是一个返回字符串的可迭代对象</td>
</tr>
<tr>
<td>f.seek(offset,from)</td>
<td>在文件中移动文件指针，从from（0代表起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节</td>
</tr>
<tr>
<td>f.tell()</td>
<td>返回当前在文件中的位置</td>
</tr>
</tbody></table>
<h1 id="12、集合set"><a href="#12、集合set" class="headerlink" title="12、集合set"></a>12、集合set</h1><p>在我的世界里，你就是唯一，set()集合中只允许同值数据出现一次。:rescue_worker_helmet:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>):<br>	temp.append(i)<br>temp.append(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 此时tmep中有两个1 temp = [0,1,2,3,4,1]</span><br>temp2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(temp))  temp2 = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure>



<center>小甲鱼29：一个任务的代码</center>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;record.txt&#x27;</span>)<br>boy = []<br>girl = []<br><span class="hljs-keyword">for</span> each_line <span class="hljs-keyword">in</span> f:<br>    <span class="hljs-keyword">if</span> each_line[:<span class="hljs-number">6</span>] != <span class="hljs-string">&#x27;=======&#x27;</span>:<br>    	(role,line_spoken) = each.split(<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-number">1</span>)<br>    	<span class="hljs-keyword">if</span> role == <span class="hljs-string">&#x27;小甲鱼&#x27;</span>:<br>    		boy.append(line_spoken)<br>    	<span class="hljs-keyword">if</span> role == <span class="hljs-string">&#x27;小客服&#x27;</span>:<br>    		girl.append(line_spoken)<br>    <span class="hljs-keyword">else</span>:<br>        file_name_boy = <span class="hljs-string">&#x27;boy_&#x27;</span> + <span class="hljs-built_in">str</span>(count) + <span class="hljs-string">&#x27;.txt&#x27;</span><br>        file_name_boy = <span class="hljs-string">&#x27;girl_&#x27;</span> + <span class="hljs-built_in">str</span>(count) + <span class="hljs-string">&#x27;.txt&#x27;</span><br>        <br>        boy_file = <span class="hljs-built_in">open</span>(file_name_boy,<span class="hljs-string">&#x27;w&#x27;</span>)<br>        girl_file = <span class="hljs-built_in">open</span>(file_name_girl,<span class="hljs-string">&#x27;w&#x27;</span>)<br>        <br>        boy_file.writelines(boy)<br>        girl_file.writelines(girl)<br>        <br>        boy = []<br>        girl = []<br>        count += <span class="hljs-number">1</span><br>        <br>file_name_boy = <span class="hljs-string">&#x27;boy_&#x27;</span> + <span class="hljs-built_in">str</span>(count) + <span class="hljs-string">&#x27;.txt&#x27;</span><br>file_name_boy = <span class="hljs-string">&#x27;girl_&#x27;</span> + <span class="hljs-built_in">str</span>(count) + <span class="hljs-string">&#x27;.txt&#x27;</span><br>        <br>boy_file = <span class="hljs-built_in">open</span>(file_name_boy,<span class="hljs-string">&#x27;w&#x27;</span>)<br>girl_file = <span class="hljs-built_in">open</span>(file_name_girl,<span class="hljs-string">&#x27;w&#x27;</span>)<br>        <br>boy_file.writelines(boy)<br>girl_file.writelines(girl)<br>        <br>        <span class="hljs-comment">#用完记得关闭文件</span><br>        boy_file.close()<br>        girl_file.close()<br></code></pre></td></tr></table></figure>

<p>以上代码冗长繁琐，不够简洁，因此可以对关键部分进行封装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_file</span>(<span class="hljs-params">boy,girl,count</span>):</span><br>        file_name_boy = <span class="hljs-string">&#x27;boy_&#x27;</span> + <span class="hljs-built_in">str</span>(count) + <span class="hljs-string">&#x27;.txt&#x27;</span><br>        file_name_boy = <span class="hljs-string">&#x27;girl_&#x27;</span> + <span class="hljs-built_in">str</span>(count) + <span class="hljs-string">&#x27;.txt&#x27;</span><br>        <br>        boy_file = <span class="hljs-built_in">open</span>(file_name_boy,<span class="hljs-string">&#x27;w&#x27;</span>)<br>        girl_file = <span class="hljs-built_in">open</span>(file_name_girl,<span class="hljs-string">&#x27;w&#x27;</span>)<br>        <br>        boy_file.writelines(boy)<br>        girl_file.writelines(girl)<br>        <br>        boy_file.close()<br>        girl_file.close()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_file</span>(<span class="hljs-params">file_name</span>):</span><br>    f = <span class="hljs-built_in">open</span>(file_name)<br>	boy = []<br>	girl = []<br>	<span class="hljs-keyword">for</span> each_line <span class="hljs-keyword">in</span> f:<br>    	<span class="hljs-keyword">if</span> each_line[:<span class="hljs-number">6</span>] != <span class="hljs-string">&#x27;=======&#x27;</span>:<br>    		(role,line_spoken) = each.split(<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-number">1</span>)<br>    		<span class="hljs-keyword">if</span> role == <span class="hljs-string">&#x27;小甲鱼&#x27;</span>:<br>    			boy.append(line_spoken)<br>    		<span class="hljs-keyword">if</span> role == <span class="hljs-string">&#x27;小客服&#x27;</span>:<br>    			girl.append(line_spoken)<br>    <span class="hljs-keyword">else</span>:<br>        save_file(boy,girl.count)<br>        boy = []<br>        girl = []<br>        count += <span class="hljs-number">1</span><br>        <br>split_file(<span class="hljs-string">&#x27;record.txt&#x27;</span>)<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="13、模块"><a href="#13、模块" class="headerlink" title="13、模块"></a>13、模块</h1><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><center>os模块中关于文件/目录常用的函数使用方法</center>

<table>
<thead>
<tr>
<th><strong>函数名</strong></th>
<th><strong>使用方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>getcwd()</td>
<td>返回当前工作目录</td>
</tr>
<tr>
<td>chdir(path)</td>
<td>改变工作目录</td>
</tr>
<tr>
<td>listdir(path=’.’)</td>
<td>列举指定目录中的文件名（’.’表示当前目录，’..’表示上一级目录）</td>
</tr>
<tr>
<td>mkdir(path)</td>
<td>创建单层目录，如该目录已存在抛出异常</td>
</tr>
<tr>
<td>makedirs(path)</td>
<td>递归创建多层目录，如该目录已存在抛出异常，注意：’E:\a\b’和’E:\a\c’并不会冲突</td>
</tr>
<tr>
<td>remove(path)</td>
<td>删除文件</td>
</tr>
<tr>
<td>rmdir(path)</td>
<td>删除单层目录，如该目录非空则抛出异常</td>
</tr>
<tr>
<td>removedirs(path)</td>
<td>递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常</td>
</tr>
<tr>
<td>rename(old, new)</td>
<td>将文件old重命名为new</td>
</tr>
<tr>
<td>system(command)</td>
<td>运行系统的shell命令</td>
</tr>
<tr>
<td>walk(top)</td>
<td>遍历top路径以下所有的子目录，返回一个三元组：(路径, [包含目录], [包含文件])【具体实现方案请看：第30讲课后作业^_^】</td>
</tr>
<tr>
<td><em>以下是支持路径操作中常用到的一些定义，支持所有平台</em></td>
<td></td>
</tr>
<tr>
<td>os.curdir</td>
<td>指代当前目录（’.’）</td>
</tr>
<tr>
<td>os.pardir</td>
<td>指代上一级目录（’..’）</td>
</tr>
<tr>
<td>os.sep</td>
<td>输出操作系统特定的路径分隔符（Win下为’\‘，Linux下为’/‘）</td>
</tr>
<tr>
<td>os.linesep</td>
<td>当前平台使用的行终止符（Win下为’\r\n’，Linux下为’\n’）</td>
</tr>
<tr>
<td>os.name</td>
<td>指代当前使用的操作系统（包括：’posix’, ‘nt’, ‘mac’, ‘os2’, ‘ce’, ‘java’）</td>
</tr>
</tbody></table>
<center>os.path模块中关于路径常用的函数使用方法</center>

<table>
<thead>
<tr>
<th><strong>函数名</strong></th>
<th><strong>使用方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>basename(path)</td>
<td>去掉目录路径，单独返回文件名</td>
</tr>
<tr>
<td>dirname(path)</td>
<td>去掉文件名，单独返回目录路径</td>
</tr>
<tr>
<td>join(path1[, path2[, …]])</td>
<td>将path1, path2各部分组合成一个路径名</td>
</tr>
<tr>
<td>split(path)</td>
<td>分割文件名与路径，返回(f_path, f_name)元组。如果完全使用目录，它也会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在</td>
</tr>
<tr>
<td>splitext(path)</td>
<td>分离文件名与扩展名，返回(f_name, f_extension)元组</td>
</tr>
<tr>
<td>getsize(file)</td>
<td>返回指定文件的尺寸，单位是字节</td>
</tr>
<tr>
<td>getatime(file)</td>
<td>返回指定文件最近的访问时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td>
</tr>
<tr>
<td>getctime(file)</td>
<td>返回指定文件的创建时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td>
</tr>
<tr>
<td>getmtime(file)</td>
<td>返回指定文件最新的修改时间（浮点型秒数，可用time模块的gmtime()或localtime()函数换算）</td>
</tr>
<tr>
<td><em>以下为函数返回 True 或 False</em></td>
<td></td>
</tr>
<tr>
<td>exists(path)</td>
<td>判断指定路径（目录或文件）是否存在</td>
</tr>
<tr>
<td>isabs(path)</td>
<td>判断指定路径是否为绝对路径</td>
</tr>
<tr>
<td>isdir(path)</td>
<td>判断指定路径是否存在且是一个目录</td>
</tr>
<tr>
<td>isfile(path)</td>
<td>判断指定路径是否存在且是一个文件</td>
</tr>
<tr>
<td>islink(path)</td>
<td>判断指定路径是否存在且是一个符号链接</td>
</tr>
<tr>
<td>ismount(path)</td>
<td>判断指定路径是否存在且是一个挂载点</td>
</tr>
<tr>
<td>samefile(path1, paht2)</td>
<td>判断path1和path2两个路径是否指向同一个文件</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">os.mkdir(<span class="hljs-string">&#x27;E:\\A&#x27;</span>) <span class="hljs-comment">#会在盘创建一个A文件夹</span><br>os.getcwd().split()<br>[<span class="hljs-string">&#x27;C:\\Users\\明明\\PycharmProjects\\StudyFirstDay&#x27;</span>]<br>os.getcwd().split(<span class="hljs-string">&#x27;\\&#x27;</span>)<br>[<span class="hljs-string">&#x27;C:&#x27;</span>, <span class="hljs-string">&#x27;Users&#x27;</span>, <span class="hljs-string">&#x27;明明&#x27;</span>, <span class="hljs-string">&#x27;PycharmProjects&#x27;</span>, <span class="hljs-string">&#x27;StudyFirstDay&#x27;</span>]<br>os.getcwd().split(<span class="hljs-string">&#x27;\\&#x27;</span>)[<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;明明&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a><code>pickle</code>模块</h2><p>下面代码上和通过pkl文件把<code>my_list</code>列表读取到<code>my_list2</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-number">123</span>,<span class="hljs-number">3.14</span>,<span class="hljs-string">&#x27;小甲鱼&#x27;</span>,[<span class="hljs-string">&#x27;another list&#x27;</span>]]<br>pickle.dump(my_list,pickle_file)<br>pickle_file.close()<br>pickle_file=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;my_list.pkl&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>)<br>my_list2 = pickle.load(pickle_file)<br><span class="hljs-built_in">print</span>(my_list2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-number">123</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&#x27;小甲鱼&#x27;</span>, [<span class="hljs-string">&#x27;another list&#x27;</span>]]<br></code></pre></td></tr></table></figure>

<h1 id="14、异常"><a href="#14、异常" class="headerlink" title="14、异常"></a>14、异常</h1><p><strong>Python标准异常总结</strong></p>
<table>
<thead>
<tr>
<th>AssertionError</th>
<th>断言语句（assert）失败</th>
</tr>
</thead>
<tbody><tr>
<td>AttributeError</td>
<td>尝试访问未知的对象属性</td>
</tr>
<tr>
<td>EOFError</td>
<td>用户输入文件末尾标志EOF（Ctrl+d）</td>
</tr>
<tr>
<td>FloatingPointError</td>
<td>浮点计算错误</td>
</tr>
<tr>
<td>GeneratorExit</td>
<td>generator.close()方法被调用的时候</td>
</tr>
<tr>
<td>ImportError</td>
<td>导入模块失败的时候</td>
</tr>
<tr>
<td>IndexError</td>
<td>索引超出序列的范围</td>
</tr>
<tr>
<td>KeyError</td>
<td>字典中查找一个不存在的关键字</td>
</tr>
<tr>
<td>KeyboardInterrupt</td>
<td>用户输入中断键（Ctrl+c）</td>
</tr>
<tr>
<td>MemoryError</td>
<td>内存溢出（可通过删除对象释放内存）</td>
</tr>
<tr>
<td>NameError</td>
<td>尝试访问一个不存在的变量</td>
</tr>
<tr>
<td>NotImplementedError</td>
<td>尚未实现的方法</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统产生的异常（例如打开一个不存在的文件）</td>
</tr>
<tr>
<td>OverflowError</td>
<td>数值运算超出最大限制</td>
</tr>
<tr>
<td>ReferenceError</td>
<td>弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象</td>
</tr>
<tr>
<td>RuntimeError</td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td>StopIteration</td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>Python的语法错误</td>
</tr>
<tr>
<td>IndentationError</td>
<td>缩进错误</td>
</tr>
<tr>
<td>TabError</td>
<td>Tab和空格混合使用</td>
</tr>
<tr>
<td>SystemError</td>
<td>Python编译器系统错误</td>
</tr>
<tr>
<td>SystemExit</td>
<td>Python编译器进程被关闭</td>
</tr>
<tr>
<td>TypeError</td>
<td>不同类型间的无效操作</td>
</tr>
<tr>
<td>UnboundLocalError</td>
<td>访问一个未初始化的本地变量（NameError的子类）</td>
</tr>
<tr>
<td>UnicodeError</td>
<td>Unicode相关的错误（ValueError的子类）</td>
</tr>
<tr>
<td>UnicodeEncodeError</td>
<td>Unicode编码时的错误（UnicodeError的子类）</td>
</tr>
<tr>
<td>UnicodeDecodeError</td>
<td>Unicode解码时的错误（UnicodeError的子类）</td>
</tr>
<tr>
<td>UnicodeTranslateError</td>
<td>Unicode转换时的错误（UnicodeError的子类）</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入无效的参数</td>
</tr>
<tr>
<td>ZeroDivisionError</td>
<td>除数为零</td>
</tr>
</tbody></table>
<h2 id="异常捕捉"><a href="#异常捕捉" class="headerlink" title="异常捕捉"></a>异常捕捉</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    检测范围<br><span class="hljs-keyword">except</span> Exception[<span class="hljs-keyword">as</span> reason]:<br>    出现异常（Exception）后的处理代码<br></code></pre></td></tr></table></figure>

<p>Testdemo📝:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># sum = 1 + &#x27;1&#x27; # 这里十类型错误</span><br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;一个文件.txt&#x27;</span>)  <span class="hljs-comment"># 系统文件错误</span><br>    <span class="hljs-built_in">print</span>(f.read()) <br>    f.close()<br><span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> reason:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;文件出错了,错误的原因是：&#x27;</span>,<span class="hljs-built_in">str</span>(reason))<br><span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> reason:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;类型出错了，错误的原因是：&#x27;</span>,<span class="hljs-built_in">str</span>(reason))<br></code></pre></td></tr></table></figure>

<p>finanlly关键字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">1</span> + <span class="hljs-string">&#x27;1&#x27;</span><br>    f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;一个文件.txt&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(f.read())<br>    f.close()<br><span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> reason:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;文件出错了,错误的原因是：&#x27;</span>,<span class="hljs-built_in">str</span>(reason))<br><span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> reason:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;类型出错了，错误的原因是：&#x27;</span>,<span class="hljs-built_in">str</span>(reason))<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;执行备用方案&#x27;</span>) <span class="hljs-comment"># 最终会执行到finally</span><br></code></pre></td></tr></table></figure>

<p>额外补充📚:</p>
<p><code>raise #该关键字可以将系统错误自定义设置</code></p>
<h1 id="15、对象"><a href="#15、对象" class="headerlink" title="15、对象"></a>15、对象</h1><h2 id="定义一个简单的类"><a href="#定义一个简单的类" class="headerlink" title="定义一个简单的类"></a>定义一个简单的类</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简单定义一个类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>:</span>  <span class="hljs-comment"># Python中的类名约定以答谢字母开头</span><br>    <span class="hljs-comment"># 属性</span><br>    name = <span class="hljs-string">&#x27;空白&#x27;</span><br>    age = <span class="hljs-number">10</span><br>    <span class="hljs-comment"># 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setName</span>(<span class="hljs-params">self,name</span>):</span><br>        self.name = name<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getName</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是&#x27;</span>+self.name)<br>p = People()<br>p.getName() <span class="hljs-comment"># ‘我是空白’</span><br>p.setName(<span class="hljs-string">&#x27;小明&#x27;</span>) <span class="hljs-comment"># name = 小明</span><br>p.getName() <span class="hljs-comment"># ‘我是小明’</span><br></code></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>:</span><br>    <span class="hljs-comment"># 可以用来初始化属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_init_</span>(<span class="hljs-params">self,name</span>):</span><br>        self.name = name<br>p1 = People(<span class="hljs-string">&quot;HR&quot;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="公有与私有"><a href="#公有与私有" class="headerlink" title="公有与私有"></a>公有与私有</h2><p>Python中使用<code>name mangling</code>实现访问机制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>:</span><br>    __name = <span class="hljs-string">&quot;Programmer&quot;</span> <span class="hljs-comment"># 在属性前双下划线</span><br>    <span class="hljs-comment"># 定义内部访问机制</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getName</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__name<br>p = People()<br>p.__name <span class="hljs-comment"># 调用报错，因为__name是私有变量</span><br>p.getName() <span class="hljs-comment"># 通过方法返回属性值</span><br></code></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.number = rd.randint(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在调用父类构造方法&quot;</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>(<span class="hljs-params">Parent</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 也可以在代码执行段使用Parent.__init__(Child)</span><br>        Parent.__init__() <span class="hljs-comment"># 调用了父类的构造函数，同时继承了对象</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在调用子类构造方法&quot;</span>)<br>    <span class="hljs-keyword">pass</span><br><br>p = Parent()<br>p.__init__()<br>c = Child()<br></code></pre></td></tr></table></figure>

<p>super()函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">就是在子类的构造函数中，使用<br><span class="hljs-built_in">super</span>().__init__()<br></code></pre></td></tr></table></figure>

<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name</span>):</span><br>        self.name = name<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name</span>):</span>     <br>        self.name = name<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">A,B</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,nameA,nameB</span>):</span><br>        a = self.A(nameA)<br>        b = self.b(nameB)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是&quot;</span>+a.name+<span class="hljs-string">&quot;和&quot;</span>+b.name+<span class="hljs-string">&quot;的儿子&quot;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name</span>):</span><br>        self.name = name<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name</span>):</span><br>        self.name = name<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">A,B</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,nameA,nameB</span>):</span><br>        self.a = A(nameA)<br>        self.b = B(nameB)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是&quot;</span>+self.a.name+<span class="hljs-string">&quot;和&quot;</span>+self.b.name+<span class="hljs-string">&quot;的儿子&quot;</span>)<br>c = C(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>)<br></code></pre></td></tr></table></figure>













































]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>windows右键菜单添加</title>
    <url>/posts/8fe8a499.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="注册表添加桌面右键二级菜单"><a href="#注册表添加桌面右键二级菜单" class="headerlink" title="注册表添加桌面右键二级菜单"></a>注册表添加桌面右键二级菜单</h1><p>效果图：<br><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gmbyfpatquj30dr0dbn2y.jpg" alt="效果图"><br>想要通过注册表实现这种效果，只需要创建一个爸爸、一个儿子。</p>
<center><img src="../../images/鼠标右键添加二级菜单/15.png" alt="image-20201201093934430" style="zoom:50%;text-align:center"></center>

<h2 id="注册表修改详细步骤讲解"><a href="#注册表修改详细步骤讲解" class="headerlink" title="注册表修改详细步骤讲解"></a>注册表修改详细步骤讲解</h2><p>1、<code>win+r</code>输入<code>regedit</code>快捷打开注册表。（当然也可以去C路径下的Windows目录下寻找）</p>
<p><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gmbyvyuttij306900nt8h.jpg" alt="image-20210104210752102"></p>
<p>注册表这东西长这个样子。</p>
<p>2、第二步就要先创建一个儿子，也就是二级菜单里面的每一个子文件。</p>
<p>划重点：<code>按照这个路径去寻找shell：</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell<br></code></pre></td></tr></table></figure>

<p>找到shell之后右键单击找到新建，然后在新建的子菜单中选择项，创建一个项（没懂看图）</p>
<p><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gmbyfpzjmzj30cc06mmx4.jpg" alt="小步骤"><br>然后，你会看见有一个新建的<code>新项 #1</code>，这个就是你创建儿子（二级菜单子文件），现在右键单击重命名，对你创建的儿子起个好记的名字（这个名字不会出现在桌面二级菜单，内部使用），<code>自定义、尽量字母或英文</code>，避免出现不必要的麻烦。（no懂得看图）<br><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gmbyfpzjmzj30cc06mmx4.jpg" alt="小步骤">这里我改为了<code>CSDN</code>，新建项的右方会有一个默认的字符串值，双击打开编辑，这里创建自定义名称，就是桌面你想显示的软件名称（no懂看图）<br><img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gmbyfnw1fbj30rd074wer.jpg" alt="小步骤"><br>在这个新建的文件内右键点击新建一个字符串值（重命名为<code>Icon</code>），来存放二级菜单内要显示的软件的图标。（no懂得看图）<img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gmbyfqk30dj30qf07kjrm.jpg" alt="小步骤"><br>双击打开创建的<code>Icon</code>字符串进行编辑，放入软件路径默认显示软件图标，可以自己制作icon图标进行自定义。（no懂得看图）<br><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gmbyfnj5hlj30sc07x75h.jpg" alt="小步骤"></p>
<p>接着按相同的步骤在自己刚创建儿子（二级菜单子文件）里面创建一个<code>项</code>，no<code>字符串值</code>，是<code>项</code>！是<code>项</code>！是<code>项</code>！项的名字重命名为<code>command</code>，这个里面存放二级菜单子文件软件路径。（no懂看图）<img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gmbyfqa7ajj30po07jaaa.jpg" alt="小步骤"><br>重命名为<code>command</code>（no懂得看图）<br><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gmbyluj7whj30t702igma.jpg" alt="小步骤"><br>双击command右边框中的字符串值，在弹出的编辑框中，数值数据输入你所要在二级菜单目录下显示的软件的路径，这里我放的Xshell的路径。（no懂看图）</p>
<p><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gmbyfqfz8qj30sh074jse.jpg" alt="小步骤"><br>到这里儿子就创建好了，我们来创建爸爸。</p>
<p>3、找爸爸：</p>
<p>在注册表中找到这个地方：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">HKEY_CLASSES_ROOT\Directory\Background\shell<br></code></pre></td></tr></table></figure>

<p>然后新建一个爸爸（项），名字自定义<br><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gmbyfo1el7j30gc07c0sq.jpg" alt="小步骤"><br>在这个项里面创建两个字符串值文件，一个重命名<code>Icon</code>，放图标路径，自定义，这个就参照上面详细介绍。<br>另一个是把儿子链接过来的，重命名<code>SubCommands</code>，注意大小写，把刚才创建的儿子名字输入到这个里面，如果要放多个的话，英文分号隔开。（no懂看图）</p>
<h2 id="单个："><a href="#单个：" class="headerlink" title="单个："></a>单个：</h2><p><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gmbyfo72gvj30r508h0t3.jpg" alt="小步骤"></p>
<h2 id="多个："><a href="#多个：" class="headerlink" title="多个："></a>多个：</h2><p><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gmbyfpqi8nj30ay04kjr8.jpg" alt="小步骤"><br>慢慢一步一步来，看不懂去个厕所，回来再看一遍</p>
]]></content>
  </entry>
  <entry>
    <title>为什么要使用HTTPS？</title>
    <url>/posts/58cf9bb0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>转载声明：<a href="https://blog.csdn.net/qianyu6200430">SHERlocked93</a></p>
</blockquote>
<p>分享一个HTTP的抓包工具：</p>
<blockquote>
<p> <b><a href="https://dl.pconline.com.cn/download/363657.html">fiddler（fiddler中文版）</a></b>是一个http协议Web调试代理工具。fiddler能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点查看所有的“进出”Fiddler的数据（指html,cookie,css，js等文件，这些都可以让你胡乱修改的意思）。Fiddler（fiddler中文版）要比其他的网络调试器要更加简单，因为它不仅仅可以帮助用户提供暴露http通讯，还提供了一个友好的用户格式。Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用.net语言进行扩展，适用于：开发环境的host配置；前后端接口调试；线上bugfix；性能分析和优化等等。本站提供fiddler下载。</p>
</blockquote>
<h2 id="一、什么是HTTPS"><a href="#一、什么是HTTPS" class="headerlink" title="一、什么是HTTPS"></a>一、什么是HTTPS</h2><div><img src="../../../images/HTTPS/https.png" alt="https 的图像结果" style="float:right;inline"></div>

<p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p>
<p>HTTPS主要作用是：</p>
<p>（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;</p>
<p>（2）对网站服务器进行真实身份认证。</p>
<p>我们经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用 <code>http://</code>，而是改用 <code>https://</code>。另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标记。对HTTPS的显示方式会因浏览器的不同而有所改变。</p>
<h2 id="二、为什么需要HTTPS"><a href="#二、为什么需要HTTPS" class="headerlink" title="二、为什么需要HTTPS"></a>二、为什么需要HTTPS</h2><p>在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题，接下来，我们先来了解下 HTTP协议存在的哪些问题：</p>
<ul>
<li>通信使用明文（不加密），内容可能被窃听</li>
</ul>
<p>由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，<strong>HTTP报文使用明文（指未经过加密的报文）方式发送</strong>。</p>
<p>HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。</p>
<ul>
<li>无法证明报文的完整性，所以可能遭篡改</li>
</ul>
<p>所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，<strong>没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的</strong>。</p>
<ul>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
</ul>
<p><strong>HTTP协议中的请求和响应不会对通信方进行确认</strong>。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）</p>
<p>HTTP协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉。</p>
<p>反观HTTPS协议，它比HTTP协议相比多了以下优势（下文会详细介绍）:</p>
<ul>
<li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li>
<li>数据完整性：内容传输经过完整性校验</li>
<li>身份认证：第三方无法伪造服务端（客户端）身份</li>
</ul>
<h2 id="三、HTTPS如何解决HTTP上述问题"><a href="#三、HTTPS如何解决HTTP上述问题" class="headerlink" title="三、HTTPS如何解决HTTP上述问题?"></a>三、HTTPS如何解决HTTP上述问题?</h2><p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。</p>
<p>通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，<strong>所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP</strong>。</p>
]]></content>
      <tags>
        <tag>网络协议</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt“CV”大法——Linux下的TCP通信</title>
    <url>/posts/9dc0717d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux-下的-TCP-通信"><a href="#Linux-下的-TCP-通信" class="headerlink" title="Linux 下的 TCP 通信"></a>Linux 下的 TCP 通信</h1><p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p>四次挥手过程理解 </p>
<span id="more"></span>

<h2 id="TCP三次和四次握手"><a href="#TCP三次和四次握手" class="headerlink" title="TCP三次和四次握手"></a>TCP三次和四次握手</h2><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gjvtx77tabj30jo0cb3zf.jpg" alt="TCP三次握手" width="708" data-width="708" data-height="443">



<img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gjvtya1e9bj30i40bd750.jpg" alt="TCP三次握手2" width="652" data-width="652" data-height="409">



<img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gjvtyfjtojj30ik0cvab9.jpg" alt="TCP三次握手3" width="668" data-width="668" data-height="463">



<p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。<br>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<h2 id="Qt下的tcp"><a href="#Qt下的tcp" class="headerlink" title="Qt下的tcp"></a>Qt下的tcp</h2><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjvtzswvq8j319c0ig7hn.jpg" alt="TCP图解1" width="1632" data-width="1632" data-height="664">

<img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gjvu0bmutej31430htgqp.jpg" alt="TCP图解2" width="1443" data-width="1443" data-height="641">

<h2 id="1-服务器端"><a href="#1-服务器端" class="headerlink" title="1. 服务器端"></a>1. 服务器端</h2><p><img src="../../../images/TCPIP/image-20200811204053089.png"></p>
<p><img src="../../../images/TCPIP/image-20200811204123538.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//断开链接</span><br>tcpSocket-&gt;<span class="hljs-built_in">disconnectFromHost</span>();<br>tcpSocket-&gt;<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure>



<h2 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//客户端链接服务器端</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clientWidget::on_buttonConnect_clicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//获取服务器ip和端口</span><br>    <br>    QString ip = ui-&gt;lineEditIP-&gt;<span class="hljs-built_in">text</span>();<br>    qint16 port = ui-&gt;lineEditPort-&gt;<span class="hljs-built_in">text</span>().<span class="hljs-built_in">toInt</span>();<br>    tcpSocket-&gt;<span class="hljs-built_in">connectToHost</span>(<span class="hljs-built_in">QHostAdderss</span>(ip),port);<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="../../../images/TCPIP/image-20200812105738859.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//发送数据</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//获取编辑框内容</span><br>    QString str = ui-&gt;textEditWrite-&gt;<span class="hljs-built_in">toPlainText</span>();<br>    <span class="hljs-comment">//发送数据</span><br>    tcpSocket-&gt;<span class="hljs-built_in">write</span>( str.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>() );<br>    <br>&#125;<br><br><br><span class="hljs-comment">//构造函数读取内容</span><br><br><span class="hljs-built_in">connect</span>(tcpSocket,&amp;QTcpSocket::readyRead,<br>       [=]()<br>        &#123;<br>            <span class="hljs-comment">//获取对方发送的内容</span><br>            QByteArray array = tcpSocket-&gt;<span class="hljs-built_in">readAll</span>();<br>            <span class="hljs-comment">//追加到编辑框</span><br>            ui.TextEditRead-&gt;<span class="hljs-built_in">append</span>(array);<br>        &#125;<br>       )<br></code></pre></td></tr></table></figure>

<div class="note orange icon flat"><i class="note-icon fa fa-battery-quarter"></i><p>这篇文章还在编辑中······</p>
</div>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows平台下的内存泄露检测</title>
    <url>/posts/32ba7a76.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>转载声明： 原文链接<a href="https://blog.csdn.net/qq_41786318/article/details/81838359">@千么漾漾</a></p>
</blockquote>
<h1 id="Windows平台下的内存泄漏检测"><a href="#Windows平台下的内存泄漏检测" class="headerlink" title="Windows平台下的内存泄漏检测"></a>Windows平台下的内存泄漏检测</h1><h2 id="检测是否存在内存泄漏问题"><a href="#检测是否存在内存泄漏问题" class="headerlink" title="检测是否存在内存泄漏问题"></a>检测是否存在内存泄漏问题</h2><p>Windows平台下面Visual Studio 调试器和 C 运行时 (CRT) 库为我们提供了检测和识别内存泄漏的有效方法，原理大致如下：内存分配要通过CRT在运行时实现，只要在分配内存和释放内存时分别做好记录，程序结束时对比分配内存和释放内存的记录就可以确定是不是有内存泄漏。在vs中启用内存检测的方法如下：</p>
<ul>
<li>STEP1，在程序中包括以下语句： （#include 语句必须采用上文所示顺序。 如果更改了顺序，所使用的函数可能无法正常工作。）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRTDBG_MAP_ALLOC</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;crtdbg.h&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>通过包括 crtdbg.h，将 <a href="http://msdn.microsoft.com/zh-cn/library/6ewkz86d.aspx">malloc</a> 和 <a href="http://msdn.microsoft.com/zh-cn/library/we1whae7.aspx">free</a> 函数映射到它们的调试版本，即 <a href="http://msdn.microsoft.com/zh-cn/library/faz3a37z.aspx">_malloc_dbg</a> 和 <a href="http://msdn.microsoft.com/zh-cn/library/16swbsbc.aspx">_free_dbg</a>，这两个函数将跟踪内存分配和释放。 此映射只在调试版本（在其中定义了**_DEBUG**）中发生。 发布版本使用普通的 <strong>malloc</strong> 和 <strong>free</strong> 函数。</p>
<p>#define 语句将 CRT 堆函数的基版本映射到对应的“Debug”版本。 并非绝对需要该语句；但如果没有该语句，内存泄漏转储包含的有用信息将较少。</p>
<ul>
<li>STEP2， 在添加了上述语句之后，可以通过在程序中包括以下语句（通常应恰好放在程序退出位置之前）来转储内存泄漏信息：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">_CrtDumpMemoryLeaks();<br></code></pre></td></tr></table></figure>

<p>此时，完整的代码如下：</p>
<table>
<thead>
<tr>
<th>1234567891011121314151617181920</th>
<th><code>#define _CRTDBG_MAP_ALLOC``#include &lt;stdlib.h&gt;``#include &lt;crtdbg.h&gt;</code> <code>#include &lt;iostream&gt;``using</code> <code>namespace</code> <code>std;</code> <code>void</code> <code>GetMemory(``char</code> <code>*p, ``int</code> <code>num)``&#123;``  ``p = (``char``*)``malloc``(``sizeof``(``char``) * num);``&#125;</code> <code>int</code> <code>main(``int</code> <code>argc,``char``** argv)``&#123;``  ``char</code> <code>*str = NULL;``  ``GetMemory(str, 100);``  ``cout&lt;&lt;``&quot;Memory leak test!&quot;``&lt;&lt;endl;``  ``_CrtDumpMemoryLeaks();``  ``return</code> <code>0;</code></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>当在调试器下运行程序时，<a href="http://msdn.microsoft.com/zh-cn/library/d41t22sb.aspx">_CrtDumpMemoryLeaks</a> 将在<a href="http://msdn.microsoft.com/zh-cn/library/3hk6fby3.aspx">“输出”窗口</a>中显示内存泄漏信息。 内存泄漏信息如下所示：</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/skynet/201102/20110220175032138.png"><img src="../../../images/Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/20110220175032977.png" alt="image"></a></p>
<p>如果没有使用 #define _CRTDBG_MAP_ALLOC 语句，内存泄漏转储将如下所示：</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/skynet/201102/201102201750331467.png"><img src="../../../images/Windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B/201102201750332863.png" alt="image"></a></p>
<p>未定义 _CRTDBG_MAP_ALLOC 时，所显示的会是：</p>
<ul>
<li>内存分配编号（在大括号内）。</li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/htdyz80k.aspx">块类型</a>（普通、客户端或 CRT）。</li>
</ul>
<blockquote>
<ul>
<li>“普通块”是由程序分配的普通内存。</li>
<li>“客户端块”是由 MFC 程序用于需要析构函数的对象的特殊类型内存块。 MFC new 操作根据正在创建的对象的需要创建普通块或客户端块。</li>
<li>“CRT 块”是由 CRT 库为自己使用而分配的内存块。 CRT 库处理这些块的释放，因此您不大可能在内存泄漏报告中看到这些块，除非出现严重错误（例如 CRT 库损坏）。</li>
</ul>
<p>从不会在内存泄漏信息中看到下面两种块类型：</p>
<ul>
<li>“可用块”是已释放的内存块。</li>
<li>“忽略块”是您已特别标记的块，因而不出现在内存泄漏报告中。</li>
</ul>
</blockquote>
<ul>
<li>十六进制形式的内存位置。</li>
<li>以字节为单位的块大小。</li>
<li>前 16 字节的内容（亦为十六进制）。</li>
</ul>
<p>定义了 _CRTDBG_MAP_ALLOC 时，还会显示在其中分配泄漏的内存的文件。 文件名后括号中的数字（本示例中为 10）是该文件中的行号。</p>
<p>注意：如果程序总是在同一位置退出，调用 <a href="http://msdn.microsoft.com/zh-cn/library/d41t22sb.aspx">_CrtDumpMemoryLeaks</a> 将非常容易。 如果程序从多个位置退出，则无需在每个可能退出的位置放置对 <strong>_CrtDumpMemoryLeaks</strong> 的调用，而可以在程序开始处包含以下调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );<br></code></pre></td></tr></table></figure>

<p>该语句在程序退出时自动调用 <strong>_CrtDumpMemoryLeaks</strong>。 必须同时设置 <strong>_CRTDBG_ALLOC_MEM_DF</strong> 和**_CRTDBG_LEAK_CHECK_DF** 两个位域，如前面所示。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>B+树、B树、hash表</title>
    <url>/posts/bf9c7d2e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、B-树做索引而不用B-树"><a href="#一、B-树做索引而不用B-树" class="headerlink" title="一、B+树做索引而不用B-树"></a>一、B+树做索引而不用B-树</h2><p>那么Mysql如何衡量查询效率呢？– 磁盘IO次数。<br>一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。B-树/B+树 的特点就是每层节点数目非常多，层数很少，目的就是为了减少磁盘IO次数，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。</p>
<ul>
<li>优点一： <strong>B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。</strong></li>
<li>优点二： <strong>B+树所有的Data域在叶子节点，并且所有叶子节点之间都有一个链指针。</strong> 这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。</li>
</ul>
<h2 id="二、B-树做索引而不用红黑树"><a href="#二、B-树做索引而不用红黑树" class="headerlink" title="二、B+树做索引而不用红黑树"></a>二、B+树做索引而不用红黑树</h2><p>AVL 树（平衡二叉树）和红黑树（二叉查找树）基本都是存储在内存中才会使用的数据结构。在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
]]></content>
  </entry>
  <entry>
    <title>hash冲突的四种解决办法</title>
    <url>/posts/92bebae7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。下面以创建哈希表为例，说明解决冲突的方法。</p>
<h1 id="hash冲突的四种解决办法"><a href="#hash冲突的四种解决办法" class="headerlink" title="hash冲突的四种解决办法"></a>hash冲突的四种解决办法</h1><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><blockquote>
<p>就是根据key即经过一个函数f(key)得到的结果的作为地址去存放当前的key value键值对(这个是hashmap的存值方式)，但是却发现算出来的地址上已经有人先来了。造成当前值无法存储的情况</p>
</blockquote>
<h2 id="一、开放定址法"><a href="#一、开放定址法" class="headerlink" title="一、开放定址法"></a>一、开放定址法</h2><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">Hi = (H(key) + di) MOD m，其中i=1,2,…,k(k&lt;=m-1)<br></code></pre></td></tr></table></figure>

<p>H(key)为哈希函数，m为哈希表表长，di为增量序列，i为已发生冲突的次数。其中，开放定址法根据步长不同可以分为3种：</p>
<h3 id="1-线性探查法"><a href="#1-线性探查法" class="headerlink" title="1. 线性探查法"></a>1. 线性探查法</h3><p>简单地说，就是以当前冲突位置为起点，步长为1循环查找，直到找到一个空的位置，如果循环完了都占不到位置，就说明容器已经满了。举个栗子，就像你在饭点去街上吃饭，挨家去看是否有位置一样。</p>
<h3 id="2-平方探测法"><a href="#2-平方探测法" class="headerlink" title="2. 平方探测法"></a>2. 平方探测法</h3><p>相对于线性探查法，这就相当于的步长为di = i2来循环查找，直到找到空的位置。以上面那个例子来看，现在你不是挨家去看有没有位置了，而是拿手机算去第i2家店，然后去问这家店有没有位置。</p>
<h3 id="3-伪随机探测法：di-伪随机序列"><a href="#3-伪随机探测法：di-伪随机序列" class="headerlink" title="3. 伪随机探测法：di=伪随机序列"></a>3. 伪随机探测法：di=伪随机序列</h3><p>这个就是取随机数来作为步长。还是用上面的例子，这次就是完全按心情去选一家店问有没有位置了。</p>
<p>但开放定址法有这些缺点：</p>
<ul>
<li>这种方法建立起来的哈希表，当冲突多的时候数据容易堆集在一起，这时候对查找不友好；</li>
<li>删除结点的时候不能简单将结点的空间置空，否则将截断在它填入散列表之后的同义词结点查找路径。因此如果要删除结点，只能在被删结点上添加删除标记，而不能真正删除结点；</li>
<li>如果哈希表的空间已经满了，还需要建立一个溢出表，来存入多出来的元素。</li>
</ul>
<h2 id="二、链地址法"><a href="#二、链地址法" class="headerlink" title="二、链地址法"></a>二、链地址法</h2><p>将冲突位置的元素构造成链表。在添加数据的时候，如果哈希地址与哈希表上的元素冲突，就放在这个位置的链表上。</p>
<p>拉链法的优点：</p>
<ul>
<li>处理冲突的方式简单，且无堆集现象，非同义词绝不会发生冲突，因此平均查找长度较短；</li>
<li>由于拉链法中各链表上的结点空间是动态申请的，所以它更适合造表前无法确定表长的情况；</li>
<li>删除结点操作易于实现，只要简单地删除链表上的相应的结点即可。</li>
</ul>
<p>拉链法的缺点：需要额外的存储空间。</p>
<p>从HashMap的底层结构中我们可以看到，HashMap采用是数组+链表/红黑树的组合来作为底层结构，也就是开放地址法+链地址法的方式来实现HashMap。</p>
<p><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gl1fleu37ij30n30ba753.jpg" alt="链表法"></p>
<h2 id="三、再哈希法"><a href="#三、再哈希法" class="headerlink" title="三、再哈希法"></a>三、再哈希法</h2><figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">Hi = RHi(key), 其中i=1,2,…,k<br></code></pre></td></tr></table></figure>

<p>RHi()函数是不同于H()的哈希函数，用于同义词发生地址冲突时，计算出另一个哈希函数地址，直到不发生冲突位置。这种方法不容易产生堆集，但是会增加计算时间。</p>
<p>所以再哈希法的缺点是：增加了计算时间。</p>
<h2 id="四、建立一个公共溢出区"><a href="#四、建立一个公共溢出区" class="headerlink" title="四、建立一个公共溢出区"></a>四、建立一个公共溢出区</h2>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络协议</title>
    <url>/posts/17750952.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>一些可以帮助学习各种协议的工具推荐：</p>
<blockquote>
<p><b><a href="downza.cn/soft/30116.html">Cisco Packet Tracer中文版</a></b> 是一款功能齐全的思科交换机模拟器，简称PT。为学习CCNA课程的网络初学者提供了网络模拟环境。Cisco Packet Tracer中文版是思科最新7.0模拟器，以前的5.5和5.3的版本只能做NA的实验，现在这个可以做NP的实验，里边的IOS也升级了，思科在save里面保存有很多学习用的拓扑，值得研究。</p>
</blockquote>
<p>常见抓包工具：</p>
<blockquote>
<p> <b><a href="https://dl.pconline.com.cn/download/363657.html">fiddler（fiddler中文版）</a></b>是一个http协议Web调试代理工具。fiddler能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点查看所有的“进出”Fiddler的数据（指html,cookie,css，js等文件，这些都可以让你胡乱修改的意思）。Fiddler（fiddler中文版）要比其他的网络调试器要更加简单，因为它不仅仅可以帮助用户提供暴露http通讯，还提供了一个友好的用户格式。Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用.net语言进行扩展，适用于：开发环境的host配置；前后端接口调试；线上bugfix；性能分析和优化等等。本站提供fiddler下载。</p>
</blockquote>
<blockquote>
<p><b><a href="https://www.cr173.com/soft/5937.html">Wireshark</a></b>（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包, 并尽可能显示出最为详细的网络封包资料。网络封包分析软件的功能可想像成 “电工技师使用电表来量测电流、电压、电阻” 的工作 - 只是将场景移植到网络上，并将电线替换成网络线。</p>
<p>在过去，网络封包分析软件是非常昂贵，或是专门属于营利用的软件。Ethereal的出现改变了这一切。在GNU GPL通用许可证的保障范围底下，使用者可以以免费的代价取得软件与其程式码，并拥有针对其原始码修改及客制化的权利。Ethereal是目前全世界最广泛的网络封包分析软件之一</p>
</blockquote>
</blockquote>
<h1 id="五层网络协议、功能"><a href="#五层网络协议、功能" class="headerlink" title="五层网络协议、功能"></a>五层网络协议、功能</h1><p><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gl18e39ln5j30go0b10wv.jpg"></p>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p>
<p>三种模型结构：</p>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210114195446.png" alt="计算机网络体系结构"></p>
<hr>
<p>各层对应的协议：</p>
<style>tr:hover {background-color: #000;color:white;filter:brightness(3);}</style>
<table style="vertical-align: middle;text-align:left;">
   <tr style="border-bottom: 3px solid #ddd;background-color: #000;color:white;">
      <td width="20%">OSI七层网络模型</td>
      <td width="20%">TCP/IP四层概念模型</td>
      <td width="50%">对应网络协议</td>
   </tr>
   <tr>
      <td>应用层(Application)</td>
      <td></td>
       <td><span style="color:darkred">HTTP</span>、TFTP、<span style="color:darkred">FTP</span>、NFS、WAIS、SMTP</td>
   </tr>
   <tr>
      <td>表示层(Presentation)</td>
      <td>应用层</td>
      <td>Telnet、Rlogin、SNMP、Gopher</td>
   </tr>
   <tr style="border-bottom: 1px solid #ddd;">
      <td>会话层(Session)</td>
      <td></td>
      <td>SMTP、DNS</td>
   </tr>
   <tr style="border-bottom: 1px solid #ddd;">
      <td>运输层(Transport)</td>
      <td>传输层</td>
       <td><span style="color:darkred">TCP</span>、<span style="color:darkred">UDP</span></td>
   </tr>
   <tr style="border-bottom: 1px solid #ddd;">
      <td>网络层（Network）</td>
      <td>网络层</td>
      <td>IP、ICMP、ARP、RAPP、AKP、UUCP</td>
   </tr>
   <tr>
      <td>数据链路层（Data Link）</td>
      <td>数据链路层</td>
      <td>FDDI、Ethernet、Arpanet、PDN、SLIP、PPP</td>
   </tr>
   <tr>
      <td>物理层（Physical）</td>
      <td></td>
      <td>IEEE 802.1A、IEEE802.2到IEEE 802.11</td>
   </tr>
</table>

<h2 id="第五层——应用层（application-layer）"><a href="#第五层——应用层（application-layer）" class="headerlink" title="第五层——应用层（application layer）"></a>第五层——应用层（application layer）</h2><ul>
<li>应用层是体系结构中的最高层。直接为用户的应用进程（例如电子邮件、文档传输和终端仿真）提供服务。</li>
<li>在因特网中的应用层协议很多，如支持万维网应用的HTTP协议，支持电子邮件的SMPT协议、支持文件传送的FTP协议、DNS协议、POP3、SNMP、TeInet等等。</li>
</ul>
<h2 id="第四层——运输层（transport-layer）"><a href="#第四层——运输层（transport-layer）" class="headerlink" title="第四层——运输层（transport layer）"></a>第四层——运输层（transport layer）</h2><ul>
<li>运输层负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能</li>
<li>复用，就是多个应用进程可同时使用下面运输层的服务</li>
<li>分用，就是把收到的信息分别交付给上面应用层中相应的进程。</li>
<li>运输层主要使用以下两种协议：<ol>
<li><mark style="font-family:黑体;background:lightblue;font-weight:900;background-size:110% 110%;padding:8px 5px;border-radius:50px">传输控制协议TCP(Tranmisson Contronl Protocol)：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。</mark></li>
<li><mark style="font-family:黑体;background:lightblue;font-weight:900;background-size:110% 110%;padding:8px 5px;border-radius:50px">用户数据包协议UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</mark></li>
</ol>
</li>
</ul>
<h2 id="第三层——网络层（networl-layer）"><a href="#第三层——网络层（networl-layer）" class="headerlink" title="第三层——网络层（networl layer）"></a>第三层——网络层（networl layer）</h2><p><mark style="font-family:黑体;background:lightblue;font-weight:900;background-size:110% 110%;padding:8px 5px;border-radius:50px">网络层主要包含以下两个任务：</mark></p>
<ol>
<li><mark style="font-family:黑体;background:lightblue;font-weight:900;background-size:110% 110%;padding:8px 5px;border-radius:50px">负责为分组交换网上的不同主机提供通信服务。在发送数据是，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫作IP数据报，或简称为数据报。</mark></li>
<li><mark style="font-family:黑体;background:lightblue;font-weight:900;background-size:110% 110%;padding:8px 5px;border-radius:50px">选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</mark></li>
<li>协议：IP、ICMP、IGMP、ARP、RAPP</li>
</ol>
<h2 id="第二层——数据链路层（Data-link-layer"><a href="#第二层——数据链路层（Data-link-layer" class="headerlink" title="第二层——数据链路层（Data link layer)"></a>第二层——数据链路层（Data link layer)</h2><ul>
<li><p>在两个相邻结点之间传送数据时，<mark style="font-family:黑体;background:lightblue;font-weight:900;background-size:110% 110%;padding:8px 5px;border-radius:50px">数据链路层将网络层交下来的IP数据报组装成帧</mark>，在两个相邻结点之间的链路上“透明”的传送帧中的数据。</p>
</li>
<li><p><mark style="font-family:黑体;background:lightblue;font-weight:900;background-size:110% 110%;padding:8px 5px;border-radius:50px">每一帧包含数据和必要的控制信息（如同步地址、地址信息、差错控制等）。典型的帧长是几百字节到一千多字节。</mark></p>
</li>
<li><div style="background:lightgray;border-radius:25px;padding:10px 10px">注：”透明”是一个很重要的术语。它表示，某一个实际存在的事物看起来却好像不存在一样。”在数据链路层透明传送数据”表示无力什么样的比特组合的数据都能够通过这个数据链路层。因此，对所传送的数据来说，这些数据就“看不见”数据链路层。或者说，数据链路层对这些数据来说是透明的。 
(1)在接收数据时，控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。 
(2)控制信息还使接收端能检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如需改正错误，就由运输层的TCP协议来完成。
</div></li>
</ul>
<h2 id="第一层——物理层（physical-layer"><a href="#第一层——物理层（physical-layer" class="headerlink" title="第一层——物理层（physical layer)"></a>第一层——物理层（physical layer)</h2><p>在物理层上所传数据的单位是比特。物理层的任务就是透明的传送比特流。</p>
<h1 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h1><p><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gl185r7cpsj30oe0cl0td.jpg" alt="传输过程"></p>
<h1 id="常见端口及对应服务"><a href="#常见端口及对应服务" class="headerlink" title="常见端口及对应服务"></a>常见端口及对应服务</h1><table>
<thead>
<tr>
<th align="left">端口</th>
<th align="left">服务</th>
</tr>
</thead>
<tbody><tr>
<td align="left">21</td>
<td align="left">主要用于FTP（File Transfer Protocol,文件传输协议）服务</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">ssh传统的网络服务程序，如ftp、pop和teInet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">Telnet服务</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">SMTP服务</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">80</td>
<td align="left">HTTP服务器</td>
</tr>
<tr>
<td align="left">110</td>
<td align="left">POP3</td>
</tr>
<tr>
<td align="left">1158</td>
<td align="left">Oracle EmCTL</td>
</tr>
<tr>
<td align="left">1521</td>
<td align="left">Oracle数据库</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">3036</td>
<td align="left">MySQL</td>
</tr>
<tr>
<td align="left">3389</td>
<td align="left">WIN2003远程登录</td>
</tr>
<tr>
<td align="left">8080</td>
<td align="left">JBOSS</td>
</tr>
<tr>
<td align="left">8080</td>
<td align="left">TOMCAT</td>
</tr>
<tr>
<td align="left">9080</td>
<td align="left">Webshpere应用程序</td>
</tr>
<tr>
<td align="left">9090</td>
<td align="left">webshpere</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>1、按端口号分布划分</strong></p>
<p>（1）知名端口（Well-Known Ports）</p>
<p>知名端口即众所周知的端口号，范围从0到1023，这些端口号一般固定分配给一些服务。比如21端口分配给FTP服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务，135端口分配给RPC（远程过程调用）服务等等。</p>
<p>（2）动态端口（Dynamic Ports）</p>
<p>　　动态端口的范围从1024到65535，这些端口号一般不固定分配给某个服务，也就是说许多服务都可以使用这些端口。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。比如1024端口就是分配给第一个向系统发出申请的程序。在关闭程序进程后，就会释放所占用的端口号。</p>
<p>　不过，动态端口也常常被病毒木马程序所利用，如冰河默认连接端口是7626、WAY 2.4是8011、Netspy 3.0是7306、YAI病毒是1024等等。</p>
<p><strong>2、按协议类型划分</strong></p>
<p>按协议类型划分，可以分为TCP、UDP、IP和ICMP（Internet控制消息协议）等端口。下面主要介绍TCP和UDP端口：</p>
<p>（1）TCP端口</p>
<p>TCP端口，即传输控制协议端口，需要在客户端和服务器之间建立连接，这样可以提供可靠的数据传输。常见的包括FTP服务的21端口，Telnet服务的23端口，SMTP服务的25端口，以及HTTP服务的80端口等等。</p>
<p>（2）UDP端口</p>
<p>UDP端口，即用户数据包协议端口，无需在客户端和服务器之间建立连接，安全性得不到保障。常见的有DNS服务的53端口，SNMP（简单网络管理协议）服务的161端口，QQ使用的8000和4000端口等等。</p>
]]></content>
      <tags>
        <tag>网络协议</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法小记</title>
    <url>/posts/8b24ddfa.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p><strong>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</strong></p>
<p><strong>基本思想：</strong>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p>
<p><strong>复杂度分析：</strong> 查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;<br>当查找不成功时，需要n次比较，时间复杂度为O(n);<br>所以，<strong>顺序查找的时间复杂度为O(n)。</strong></p>
<p><strong>C++实现源码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//顺序查找</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SequenceSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">if</span>(a[i] == value)<br>            <span class="hljs-keyword">return</span> i;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><strong>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</strong></p>
<p><strong>基本思想：</strong>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p>
<p><strong>复杂度分析：</strong>最坏情况下，关键词比较次数为 <img src="https://www.zhihu.com/equation?tex=log_2(n)+1" alt="[公式]"> （ <img src="https://www.zhihu.com/equation?tex=log_2(n)" alt="[公式]"> 取下整），且<strong>期望时间复杂度为</strong> <img src="https://www.zhihu.com/equation?tex=O(log_2n)" alt="[公式]"> ；</p>
<p>折半查找是一棵二叉排序树，每个根结点的值都大于左子树的所有结点的值，小于右子树所有结点的值。</p>
<p>例如：长度为10的有序表的<strong>平均查找长度</strong>为：ASL=(1<em>1+2</em>2+3<em>4+4</em>3)/10=29/10=2.9;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BinarySearch2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//二分查找（折半查找），循环实现</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinarySearch1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> low, high, mid;<br>    low = <span class="hljs-number">0</span>;<br>    high = n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(low&lt;=high)<br>    &#123;<br>        mid = (low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]==value)<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&gt;value)<br>            high = mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&lt;value)<br>            low = mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//二分查找，递归实现</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinarySearch2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt;= high)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = low+(high-low)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]==value)<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&gt;value)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">BinarySearch2</span>(a, value, low, mid<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&lt;value)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">BinarySearch2</span>(a, value, mid+<span class="hljs-number">1</span>, high);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>二分查找的升级版本；添加了一个比例参数用以调整每次查找区间的大小。</p>
<p><code>int mid = low+（value-a[low])/(a[high]-a[low])*(high-low);</code></p>
<p><strong>基本思想：</strong>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 关键代码</span><br><span class="hljs-keyword">int</span> value ; <span class="hljs-comment">//比例参数</span><br><span class="hljs-keyword">int</span> mid = low+（value-a[low])/(a[high]-a[low])*(high-low);<br><br><span class="hljs-comment">//插值查找</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsertionSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt;= high)<br>    &#123;<br>        <span class="hljs-keyword">int</span> mid = low+(value-a[low])/(a[high]-a[low])*(high-low);<br>        <span class="hljs-keyword">if</span>(a[mid]==value)<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;value)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">InsertionSearch</span>(a, value, low, mid<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(a[mid]&lt;value)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">InsertionSearch</span>(a, value, mid+<span class="hljs-number">1</span>, high);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>数据库常见面试问题</title>
    <url>/posts/42c6ad67.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库面试"><a href="#数据库面试" class="headerlink" title="数据库面试"></a>数据库面试</h1><p><a href="https://www.notion.so/WHERE-HAVING-ON-dc9d97ff06d1444bae158910e466f14a">WHERE与HAVING与ON</a></p>
<p><a href="https://www.notion.so/4e6164801333404090bcff027719eb12">事务</a></p>
<p><a href="https://www.notion.so/b7fe920caa62425f9326aacefb5ce228">数据库面试</a></p>
<p><a href="https://www.notion.so/3ecdab90ed174dbd90575cddb9defd18">🪡索引</a></p>
<h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>索引是对数据表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。索引有助于更快的获取信息。</p>
<p>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</p>
<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>数据库事务（Database Transaction），是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部操作成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务时数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p>
<h2 id="数据库事务隔离"><a href="#数据库事务隔离" class="headerlink" title="数据库事务隔离"></a>数据库事务隔离</h2><p>同一时间，只允许一个事务请求统一数据，u痛的事务之间彼此美欧任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转钱。</p>
<h2 id="inner-join-和-left-join"><a href="#inner-join-和-left-join" class="headerlink" title="inner join  和 left join"></a><code>inner join</code>  和 <code>left join</code></h2><p>left join（左连接）返回包括左表中的所有记录和右边中联结字段相等的记录</p>
<p>right join（右连接）返回包含右表中所有记录和左表中联结字段相等的记录</p>
<p>inner join（等值连接）只返回两个表中联结字段相等的行</p>
<p>example:</p>
<p>某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p>
<p>Customers 表：</p>
<p>+—-+——-+<br>| Id | Name  |<br>+—-+——-+<br>| 1  | Joe   |<br>| 2  | Henry |<br>| 3  | Sam   |<br>| 4  | Max   |<br>+—-+——-+<br>Orders 表：</p>
<p>+—-+————+<br>| Id | CustomerId |<br>+—-+————+<br>| 1  | 3          |<br>| 2  | 1          |<br>+—-+————+<br>例如给定上述表格，你的查询应返回：</p>
<p>+———–+<br>| Customers |<br>+———–+<br>| Henry     |<br>| Max       |<br>+———–+</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> c.Name <span class="hljs-keyword">as</span> Customers<br><span class="hljs-keyword">from</span> Customers c<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Orders d <br><span class="hljs-keyword">on</span> c.Id <span class="hljs-operator">=</span> d.CustomerId<br><span class="hljs-keyword">where</span> d.CustomerId <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure>



<h2 id="数据库事务的一致性"><a href="#数据库事务的一致性" class="headerlink" title="数据库事务的一致性"></a>数据库事务的一致性</h2><p>事务是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务时DBMA中最基础的单位，事务不可分割。</p>
<p>事务具有四个特征：分别是原子性、一致性、隔离性、持续性。简称ACID。</p>
<h2 id="mysql的四种隔离状态"><a href="#mysql的四种隔离状态" class="headerlink" title="mysql的四种隔离状态"></a>mysql的四种隔离状态</h2><p>Mysql主要包含四种隔离状态：读未提交、不可重复读、可重复读、串行化</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="请你介绍一下mysql的MVCC机制"><a href="#请你介绍一下mysql的MVCC机制" class="headerlink" title="请你介绍一下mysql的MVCC机制"></a>请你介绍一下mysql的MVCC机制</h2><p>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过<mark>保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号</mark>，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p>
<h2 id="数据库默认端口"><a href="#数据库默认端口" class="headerlink" title="数据库默认端口"></a>数据库默认端口</h2><p>1、mysql的默认端口是3306，可以编辑用户目录下的 .my.cnf 文件进行修改；</p>
<p>2、sqlserver默认端口号为：1433；</p>
<p>3、oracle默认端口号为：1521；</p>
<p>4、DB2默认端口号为：50000；</p>
<p>5、PostgreSQL默认端口号为：5432。</p>
<h2 id="主键索引和普通索引的区别"><a href="#主键索引和普通索引的区别" class="headerlink" title="主键索引和普通索引的区别"></a>主键索引和普通索引的区别</h2><blockquote>
<p>1.主键索引索引着数据，然而普通索引索引着主键ID值(这是在innodb中，但是如果是myisam中，主键索引和普通索引是没有区别的都是直接索引着数据)<br>2.当你查询用的是where id=x 时，那只需要扫描一遍主键索引，然后拿到相应数据，但是如果是查询的普通索引的话，那么会先扫描一次普通索引，拿到主键值，然后再去扫主键索引，拿到所需要的数据，这个过程叫做回表</p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>WHERR与HAVING与ON</title>
    <url>/posts/e5f67d8e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="WHERE与HAVING与ON"><a href="#WHERE与HAVING与ON" class="headerlink" title="WHERE与HAVING与ON"></a>WHERE与HAVING与ON</h1><h1 id="1-where与having的区别"><a href="#1-where与having的区别" class="headerlink" title="1. where与having的区别"></a>1. where与having的区别</h1><p><code>WHERE</code> 与 <code>HAVING</code> 的根本区别在于： <code>WHERE</code>子句在 <code>GROUP BY</code> 分组与聚合函数之前对数据行进行过滤； <code>HAVING</code> 子句对 <code>GROUP BY</code> 分组和聚合函数之后的数据进行过滤。</p>
<ol>
<li><p>where</p>
<ul>
<li><code>where</code>是一个约束声明，使用<code>where</code>来约束来数据库的数据；</li>
<li><code>where</code>是在结果返回之前起作用的；</li>
<li><code>where</code>子句中不能使用聚合函数。</li>
</ul>
</li>
<li><p>having</p>
<ul>
<li><code>having</code> 是一个过滤声明</li>
<li>在查询结果返回结果集以后，对结果进行的过滤操作；</li>
<li>在 <code>having</code> 中可以使用聚合函数。</li>
<li>所以可以看出， <code>having</code> 通常和聚合函数以及 <code>group by</code> 连用。（面试知识点）</li>
<li>having子句中不能输用除了分组字段和聚合函数之外的其他字段。</li>
</ul>
 <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#例如:查找每个部门月薪<br>#大于等于<span class="hljs-number">30000</span>的员工人数<br><span class="hljs-keyword">select</span> dept_id,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> employee<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id<br><span class="hljs-keyword">having</span> salary <span class="hljs-operator">&gt;=</span> <span class="hljs-number">30000</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>因为经过group by分组和聚合函数之后，不再存在salary字段，having 子句中只能使用分组字段或者聚合函数。</p>
<p>当然， <code>WHERE</code> 和 <code>having</code> 可以组合在一起使用。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> dept_id, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> employee<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">10000</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">该语句返回了月薪大于10000的员工人数</span><br><span class="hljs-comment">大于1的部门；WHERE用于过滤月薪大于</span><br><span class="hljs-comment">10000的员工；HAVING用于过滤员工数量</span><br><span class="hljs-comment">大于1的部门。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>WHERE与ON</li>
</ol>
<p>当涉及多个表的关联时，我们那既可以使用 <code>WHERE</code> 子句也可以使用 <code>ON</code> 子句指定链接条件和过滤条件。这两者的主要区别在于：</p>
<ul>
<li>对于内链接（inner join）查询， <code>WHERE</code> 和 <code>ON</code> 中的过滤条件等效；</li>
<li>对于外链接（outer join）查询， <code>ON</code> 中的过滤条件在连接操作之前执行， <code>WHERE</code> 中的过滤条件（逻辑上）在连接操作之后执行。</li>
</ul>
<h1 id="2-聚合函数和group-by"><a href="#2-聚合函数和group-by" class="headerlink" title="2. 聚合函数和group by"></a>2. 聚合函数和group by</h1><p>聚合函数就是例如：</p>
<p>SUM、COUNT、MAX、AVG等</p>
<p>对一组（多条）数据操作的函数，需要配合group by来使用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#如：<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">SUM</span>(popultion),region <br><span class="hljs-keyword">FROM</span> T01_beijing <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> region;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>计算北京每个分区的人数<br></code></pre></td></tr></table></figure>

<h1 id="3-where和having的执行顺序"><a href="#3-where和having的执行顺序" class="headerlink" title="3. where和having的执行顺序"></a>3. where和having的执行顺序</h1><ul>
<li><code>where</code> 早于 <code>group by</code> 早于 <code>having</code></li>
<li><code>where</code>子句在聚合前筛选记录，也就是说作用在<code>group by</code>子句和<code>having</code>子句前，而<code>having</code>子句在聚合后对组记录进行筛选</li>
</ul>
<h1 id="4-where不能使用聚合函数、having中可以使用聚合函数"><a href="#4-where不能使用聚合函数、having中可以使用聚合函数" class="headerlink" title="4. where不能使用聚合函数、having中可以使用聚合函数"></a>4. where不能使用聚合函数、having中可以使用聚合函数</h1><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#筛选出ABC及各区学校数量<br><span class="hljs-keyword">SELECT</span> region，<span class="hljs-built_in">count</span>(school)<br><span class="hljs-keyword">FROM</span> T02_beijing_school<br><span class="hljs-keyword">WHERE</span> region <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;Ａ&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> region <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(school) <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#筛选出ABC三地中学校数量超过<span class="hljs-number">10</span>的区及各区学校<br><span class="hljs-keyword">SELECT</span> region ,<span class="hljs-built_in">count</span>(school)<br><span class="hljs-keyword">FROM</span> T02_beijing_school<br><span class="hljs-keyword">WHERE</span> region <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>)<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> region <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">count</span>(shool) <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>C++文件操作</title>
    <url>/posts/a83ff634.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一个最简单的打开文件写的demo"><a href="#一个最简单的打开文件写的demo" class="headerlink" title="一个最简单的打开文件写的demo"></a>一个最简单的打开文件写的demo</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @fn           ReadJson</span><br><span class="hljs-comment">* @brief        从制定路径的文件中读取Json字符串保存到sJson中</span><br><span class="hljs-comment">* @param[in]    wsFilePath: 读取Json文件的路径</span><br><span class="hljs-comment">				sJson: 保存读取文件内容的字符串</span><br><span class="hljs-comment">* @param[out]   </span><br><span class="hljs-comment">* @return       </span><br><span class="hljs-comment">*               </span><br><span class="hljs-comment">* @detail      </span><br><span class="hljs-comment">* @author      mingming.shi</span><br><span class="hljs-comment">* @date        2021-09-16</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">BOOL <span class="hljs-title">ReadJson</span><span class="hljs-params">(__in tstring wsFilePath, __out std::string&amp; sJson, <span class="hljs-keyword">int</span> *pErr)</span></span><br><span class="hljs-function"></span>&#123;<br>	FILE* fp_read = <span class="hljs-literal">NULL</span>;<br>	fp_read = _wfopen(wsFilePath.<span class="hljs-built_in">c_str</span>(), _T(<span class="hljs-string">&quot;w+&quot;</span>));<br>	<span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">if</span>( fp_read == <span class="hljs-literal">NULL</span>)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (pErr)<br>		&#123;<br>			_get_errno(pErr);<br>		&#125;<br><br>		<span class="hljs-keyword">return</span> FALSE;<br>	&#125;<br>	size = <span class="hljs-built_in">ftell</span>(fp_read)<br><br>	<span class="hljs-comment">/* 查找文件的开头 */</span><br>	<span class="hljs-built_in">fseek</span>(fp_read, <span class="hljs-number">0</span>, SEEK_SET);<br><br>	<span class="hljs-built_in">fread</span>(sJson.<span class="hljs-built_in">c_str</span>(), size, <span class="hljs-number">1</span>, fp_read);<br>	<span class="hljs-built_in">fclose</span>(fp_read);<br><br>	<span class="hljs-keyword">return</span> TRUE;<br><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>unorder_map容器必知必会攻略🐘</title>
    <url>/posts/5ec68291.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p> 挂上map的学习笔记 <a href="#">Post not found: 学习笔记/STL/STL之map</a></p>
</blockquote>
<div class="note purple icon flat"><i class="note-icon fas fa-comment"></i><p>unordered_map 容器，直译过来就是”无序 map 容器”的意思。所谓“无序”，指的是 unordered_map 容器不会像 map 容器那样对存储的数据进行排序。换句话说，<mark style="background:darkgreen;color:white;border-radius:5px;">unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的</mark>。</p>
<blockquote>
<p>对于已经学过 map 容器的读者，可以将 unordered_map 容器等价为无序的 map 容器。</p>
</blockquote>
<p>具体来讲，unordered_map 容器和 map 容器一样，以键值对（pair类型）的形式存储数据，存储的各个键值对的键互不相同且不允许被修改。但由于 unordered_map 容器底层采用的是哈希表存储结构，该结构本身不具有对数据的排序功能，所以此容器内部不会自行对存储的键值对进行排序。</p>
<p>值得一提的是，unordered_map 容器在<code>&lt;unordered_map&gt;</code>头文件中，并位于 std 命名空间中。因此，如果想使用该容器，代码中应包含如下语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>

<p>如果使用的是<code>map</code>则需要添加map的头文件以及命名空间；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>

<p>如果需要使用到容器中的函数，还需要添加头文件<code>#include &lt;algorithm&gt;</code>。</p>
<p>unordered_map 容器模板的定义如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Key</span>,      //键值对中键的类型</span><br><span class="hljs-class">		<span class="hljs-keyword">class</span> <span class="hljs-title">T</span>,      //键值对中值的类型</span><br><span class="hljs-class">        <span class="hljs-keyword">class</span> <span class="hljs-title">Hash</span> =</span> hash&lt;Key&gt;,      <span class="hljs-comment">//容器内部存储键值对所用的哈希函数</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pred</span> =</span> equal_to&lt;Key&gt;,     <span class="hljs-comment">//判断各个键值对键相同的规则</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Alloc</span> =</span> allocator&lt; pair&lt;<span class="hljs-keyword">const</span> Key,T&gt; &gt;  <span class="hljs-comment">// 指定分配器对象的类型</span><br>        &gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unordered_map</span>;</span><br></code></pre></td></tr></table></figure>

<p>以上 5 个参数中，必须显式给前 2 个参数传值，并且除特殊情况外，最多只需要使用前 4 个参数，各自的含义和功能如表 1 所示。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;key,T&gt;</td>
<td>前 2 个参数分别用于确定键值对中键和值的类型，也就是存储键值对的类型。</td>
</tr>
<tr>
<td>Hash = hash<Key></Key></td>
<td>用于指明容器在存储各个键值对时要使用的哈希函数，默认使用 STL 标准库提供的 hash<key> 哈希函数。注意，默认哈希函数只适用于基本数据类型（包括 string 类型），而不适用于自定义的结构体或者类。</key></td>
</tr>
<tr>
<td>Pred = equal_to<Key></Key></td>
<td>要知道，unordered_map 容器中存储的各个键值对的键是不能相等的，而判断是否相等的规则，就由此参数指定。默认情况下，使用 STL 标准库中提供的 equal_to<key> 规则，该规则仅支持可直接用 == 运算符做比较的数据类型。</key></td>
</tr>
</tbody></table>
<blockquote>
<p>总的来说，当无序容器中存储键值对的键为自定义类型时，默认的哈希函数 hash 以及比较函数 equal_to 将不再适用，只能自己设计适用该类型的哈希函数和比较函数，并显式传递给 Hash 参数和 Pred 参数。至于如何实现自定义，后续章节会做详细讲解。</p>
</blockquote>
<p>demo:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> A, <span class="hljs-keyword">typename</span> B&gt;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insertToMap</span><span class="hljs-params">(unordered_map&lt;A, B&gt; *tempUmap, string a, vector&lt;<span class="hljs-keyword">int</span>&gt; b)</span></span><br><span class="hljs-function"></span>&#123;<br>	unordered_map&lt;A, B&gt; temp;<br>	temp[a] = b;<br>	<br>	tempUmap-&gt;<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(a,b));<br>	cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; is here&quot;</span> &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	insert() 会返回一个迭代器，如下两种形式：</span><br><span class="hljs-comment">		//1、引用传递一个键值对</span><br><span class="hljs-comment">			pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="hljs-comment">		//2、以右值引用的方式传递键值对</span><br><span class="hljs-comment">			template &lt;class P&gt;</span><br><span class="hljs-comment">			pair&lt;iterator,bool&gt; insert (P&amp;&amp; val);</span><br><span class="hljs-comment">	如果插入成功，返回的bool值为true(1)，否则为false(0),</span><br><span class="hljs-comment">	而返回的iterator则指向插入的键值对，如果插入失败，则会指向有冲突的键值对</span><br><span class="hljs-comment">	*/</span><br><br>	cout &lt;&lt; <span class="hljs-string">&quot;this is \&quot;unordered_map\&quot;:&quot;</span> &lt;&lt; endl;<br>	unordered_map&lt;string, vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; personalInfoUMap;<br>	<span class="hljs-built_in">insertToMap</span>(&amp;personalInfoUMap, <span class="hljs-string">&quot;bbb&quot;</span>, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;);<br>	cout &lt;&lt; personalInfoUMap[<span class="hljs-string">&quot;aaa&quot;</span>].<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>	personalInfoUMap[<span class="hljs-string">&quot;aaa&quot;</span>] = &#123;<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iit : personalInfoUMap) &#123;<br>		cout &lt;&lt; iit.first &lt;&lt; <span class="hljs-string">&quot;:&quot;</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : iit.second) &#123;<br>			cout &lt;&lt; it;<br>		&#125;<br>		cout &lt;&lt; endl;<br>	&#125;<br>	cout &lt;&lt; <span class="hljs-string">&quot;------------------------------------&quot;</span> &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;this is \&quot;map\&quot; demo:&quot;</span> &lt;&lt; endl;<br><br>	map&lt;string, vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; personalInfoMap;<br>	personalInfoMap[<span class="hljs-string">&quot;bbb&quot;</span>] = &#123; <span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span> &#125;;<br>	personalInfoMap[<span class="hljs-string">&quot;aaa&quot;</span>] = &#123; <span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span> &#125;;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iit : personalInfoMap) &#123;<br>		cout &lt;&lt; iit.first &lt;&lt; <span class="hljs-string">&quot;:&quot;</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : iit.second) &#123;<br>			cout &lt;&lt; it;<br>		&#125;<br>		cout &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>


</div>]]></content>
      <categories>
        <category>C++笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库主键外键</title>
    <url>/posts/2a1f41d8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、什么是主键、外键："><a href="#一、什么是主键、外键：" class="headerlink" title="一、什么是主键、外键："></a>一、什么是主键、外键：</h1><p>关系型<a href="http://lib.csdn.net/base/mysql">数据库</a>中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键<br>比如 </p>
<blockquote>
<p>学生表(<mark>学号</mark>，姓名，性别，班级)  </p>
</blockquote>
<p>其中每个学生的学号是唯一的，学号就是一个主键 </p>
<blockquote>
<p>课程表(<mark>课程编号</mark>,课程名,学分) </p>
</blockquote>
<p>其中课程编号是唯一的,课程编号就是一个主键 </p>
<blockquote>
<p>成绩表(<mark>学号,课程号</mark>,成绩) </p>
</blockquote>
<p>成绩表中单一一个属性无法唯一标识一条记录，学号和课程号的组合才可以唯一标识一条记录，所以 学号和课程号的属性组是一个主键 。</p>
<p><strong>成绩表中的学号不是成绩表的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的外键</strong> </p>
<p>同理 成绩表中的课程号是课程表的外键 </p>
<p>定义主键和外键主要是为了维护关系数据库的完整性，总结一下：</p>
<ol>
<li><strong>主键是能确定一条记录的唯一标识</strong>，比如，一条记录包括身份正号，姓名，年龄。</li>
</ol>
<p>身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。 </p>
<ol start="2">
<li><strong>外键用于与另一张表的关联。</strong>是能确定另一张表记录的字段，用于保持数据的一致性。</li>
</ol>
<p>比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</p>
<h1 id="二、-主键、外键和索引的区别"><a href="#二、-主键、外键和索引的区别" class="headerlink" title="二、 主键、外键和索引的区别"></a>二、 主键、外键和索引的区别</h1><p>主键、外键和索引的区别？</p>
<table>
<thead>
<tr>
<th></th>
<th>主键</th>
<th>外键</th>
<th>索引</th>
</tr>
</thead>
<tbody><tr>
<td>定义：</td>
<td>唯一标识一条记录，不能有重复的，不允许为空</td>
<td>表的外键是另一表的主键, 外键可以有重复的, 可以是空值</td>
<td>该字段没有重复值，但可以有一个空值</td>
</tr>
<tr>
<td>作用：</td>
<td>用来保证数据完整性</td>
<td>用来和其他表建立联系用的</td>
<td>是提高查询排序的速度</td>
</tr>
<tr>
<td>个数：</td>
<td>主键只能有一个</td>
<td>一个表可以有多个外键</td>
<td>一个表可以有多个惟一索引</td>
</tr>
</tbody></table>
<h2 id="聚集索引和非聚集索引的区别？"><a href="#聚集索引和非聚集索引的区别？" class="headerlink" title="聚集索引和非聚集索引的区别？"></a>聚集索引和非聚集索引的区别？</h2><p>聚集索引一定是唯一索引。但唯一索引不一定是聚集索引。 </p>
<p>聚集索引，在索引页里直接存放数据，而非聚集索引在索引页里存放的是索引，这些索引指向专门的数据页的数据。</p>
<h1 id="三、数据库中主键和外键的设计原则"><a href="#三、数据库中主键和外键的设计原则" class="headerlink" title="三、数据库中主键和外键的设计原则"></a>三、数据库中主键和外键的设计原则</h1><p>主键和外键是把多个表组织为一个有效的关系数据库的粘合剂。主键和外键的设计对物理数据库的性能和可用性都有着决定性的影响。</p>
<p>必须将数据库模式从理论上的逻辑设计转换为实际的物理设计。而主键和外键的结构是这个设计过程的症结所在。一旦将所设计的数据库用于了生产环境，就很难对这些键进行修改，所以在开发阶段就设计好主键和外键就是非常必要和值得的。</p>
<p>主键：</p>
<p> 关系数据库依赖于主键—它是数据库物理模式的基石。</p>
<p> 主键在物理层面上只有两个用途：</p>
<ol>
<li><p>唯一地标识一行。</p>
</li>
<li><p>作为一个可以被外键有效引用的对象。</p>
</li>
</ol>
<p> 基于以上这两个用途，下面给出了我在设计物理层面的主键时所遵循的一些原则：</p>
<ol>
<li><p>主键应当是对用户没有意义的。如果用户看到了一个表示多对多关系的连接表中的数据，并抱怨它没有什么用处，那就证明它的主键设计地很好。</p>
</li>
<li><p>主键应该是单列的，以便提高连接和筛选操作的效率。</p>
</li>
</ol>
<p>​    注：使用复合键的人通常有两个理由为自己开脱，而这两个理由都是错误的。其一是主键应当具有实际意义，然而，让主键具有意义只不过是给人为地破坏数据库提供了方便。其二是利用这种方法可以在描述多对多关系的连接表中使用两个外部键来作为主键，我也反对这种做法，理由是：复合主键常常导致不良的外键，即当连接表成为另一个从表的主表，而依据上面的第二种方法成为这个表主键的一部分，然，这个表又有可能再成为其它从表的主表，其主键又有可能成了其它从表主键的一部分，如此传递下去，越靠后的从表，其主键将会包含越多的列了。</p>
<ol start="3">
<li>永远也不要更新主键。实际上，因为主键除了惟一地标识一行之外，再没有其他的用途了，所以也就没有理由去对它更新。如果主键需要更新，则说明主键应对用户无意义的原则被违反了。</li>
</ol>
<p>​    注：这项原则对于那些经常需要在数据转换或多数据库合并时进行数据整理的数据并不适用。</p>
<ol start="4">
<li><p>主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等。</p>
</li>
<li><p>主键应当有计算机自动生成。如果由人来对主键的创建进行干预，就会使它带有除了惟一标识一行以外的意义。一旦越过这个界限，就可能产生认为修改主键的动机，这样，这种系统用来链接记录行、管理记录行的关键手段就会落入不了解数据库设计的人的手中。</p>
</li>
</ol>
<h1 id="四、数据库主键-选取策略"><a href="#四、数据库主键-选取策略" class="headerlink" title="四、数据库主键 选取策略"></a>四、数据库主键 选取策略</h1><p>我们在建立数据库的时候，需要为每张表指定一个主键，所谓主键就是能够唯一标识表中某一行的属性或属性组，一个表只能有一个主键，但可以有多个候选索引。因为主键可以唯一标识某一行记录，所以可以确保执行数据更新、删除的时候不会出现张冠李戴的错误。当然，其它字段可以辅助我们在执行这些操作时消除共享冲突，不过就不在这里讨论了。主键除了上述作用外，常常与外键构成参照完整性约束，防止出现数据不一致。所以数据库在设计时，主键起到了很重要的作用。</p>
<p>常见的数据库主键选取方式有：</p>
<p>· 自动增长字段</p>
<p>· 手动增长字段</p>
<p>· UniqueIdentifier</p>
<p>· “COMB（Combine）”类型</p>
<p>1自动增长型字段</p>
<p>很多数据库设计者喜欢使用自动增长型字段，因为它使用简单。自动增长型字段允许我们在向数据库添加数据时，不考虑主键的取值，记录插入后，数据库系统会自动为其分配一个值，确保绝对不会出现重复。如果使用SQL Server数据库的话，我们还可以在记录插入后使用@@IDENTITY全局变量获取系统分配的主键键值。</p>
<p>尽管自动增长型字段会省掉我们很多繁琐的工作，但使用它也存在潜在的问题，那就是在数据缓冲模式下，很难预先填写主键与外键的值。假设有两张表：</p>
<p>Order(OrderID, OrderDate)<br>OrderDetial(OrderID, LineNum, ProductID, Price)</p>
<p>Order表中的OrderID是自动增长型的字段。现在需要我们录入一张订单，包括在Order表中插入一条记录以及在OrderDetail表中插入若干条记录。因为Order表中的OrderID是自动增长型的字段，那么我们在记录正式插入到数据库之前无法事先得知它的取值，只有在更新后才能知道数据库为它分配的是什么值。这会造成以下矛盾发生：</p>
<p>首先，为了能在OrderDetail的OrderID字段中添入正确的值，必须先更新Order表以获取到系统为其分配的OrderID值，然后再用这个OrderID填充OrderDetail表。最后更新OderDetail表。但是，为了确保数据的一致性，Order与OrderDetail在更新时必须在事务保护下同时进行，即确保两表同时更行成功。显然它们是相互矛盾的。</p>
<p>除此之外，当我们需要在多个数据库间进行数据的复制时（SQL Server的数据分发、订阅机制允许我们进行库间的数据复制操作），自动增长型字段可能造成数据合并时的主键冲突。设想一个数据库中的Order表向另一个库中的Order表复制数据库时，OrderID到底该不该自动增长呢？</p>
<p>ADO<a href="http://lib.csdn.net/base/dotnet">.NET</a>允许我们在DataSet中将某一个字段设置为自动增长型字段，但千万记住，这个自动增长字段仅仅是个占位符而已，当数据库进行更新时，数据库生成的值会自动取代ADO<a href="http://lib.csdn.net/base/dotnet">.Net</a>分配的值。所以为了防止用户产生误解，建议大家将ADO.NET中的自动增长初始值以及增量都设置成-1。此外，在ADO.NET中，我们可以为两张表建立DataRelation，这样存在级联关系的两张表更新时，一张表更新后另外一张表对应键的值也会自动发生变化，这会大大减少了我们对存在级联关系的两表间更新时自动增长型字段带来的麻烦。</p>
<p>2手动增长型字段</p>
<p>既然自动增长型字段会带来如此的麻烦，我们不妨考虑使用手动增长型的字段，也就是说主键的值需要自己维护，通常情况下需要建立一张单独的表存储当前主键键值。还用上面的例子来说，这次我们新建一张表叫IntKey，包含两个字段，KeyName以及KeyValue。就像一个HashTable，给一个KeyName，就可以知道目前的KeyValue是什么，然后手工实现键值数据递增。在SQL Server中可以编写这样一个存储过程，让取键值的过程自动进行。代码如下：</p>
<p>CREATE PROCEDURE [GetKey]</p>
<p>@KeyName char(10),<br>@KeyValue int OUTPUT </p>
<p>AS<br>UPDATE IntKey SET @KeyValue = KeyValue = KeyValue + 1 WHERE KeyName = @KeyName<br><a href="http://lib.csdn.net/base/go">Go</a></p>
<p>这样，通过调用存储过程，我们可以获得最新键值，确保不会出现重复。若将OrderID字段设置为手动增长型字段，我们的程序可以由以下几步来实现：首先调用存储过程，获得一个OrderID，然后使用这个OrderID填充Order表与OrderDetail表，最后在事务保护下对两表进行更新。</p>
<p>使用手动增长型字段作为主键在进行数据库间数据复制时，可以确保数据合并过程中不会出现键值冲突，只要我们为不同的数据库分配不同的主键取值段就行了。但是，使用手动增长型字段会增加网络的RoundTrip，我们必须通过增加一次数据库访问来获取当前主键键值，这会增加网络和数据库的负载，当处于一个低速或断开的网络环境中时，这种做法会有很大的弊端。同时，手工维护主键还要考虑并发冲突等种种因素，这更会增加系统的复杂程度。</p>
<p>3使用UniqueIdentifier</p>
<p>SQL Server为我们提供了UniqueIdentifier数据类型，并提供了一个生成函数NEWID( )，使用NEWID( )可以生成一个唯一的UniqueIdentifier。UniqueIdentifier在数据库中占用16个字节，出现重复的概率非常小，以至于可以认为是0。我们经常从注册表中看到类似</p>
<p>{45F0EB02-0727-4F2E-AAB5-E8AEDEE0CEC5}</p>
<p>的东西实际上就是一个UniqueIdentifier，Windows用它来做COM组件以及接口的标识，防止出现重复。在.NET里管UniqueIdentifier称之为GUID（Global Unique Identifier）。在C#中可以使用如下命令生成一个GUID：</p>
<p>Guid u = System.Guid.NewGuid();</p>
<p>对于上面提到的Order与OrderDetail的程序，如果选用UniqueIdentifier作为主键的话，我们完全可以避免上面提到的增加网络RoundTrip的问题。通过程序直接生成GUID填充主键，不用考虑是否会出现重复。</p>
<p>UniqueIdentifier字段也存在严重的缺陷：首先，它的长度是16字节，是整数的4倍长，会占用大量存储空间。更为严重的是，UniqueIdentifier的生成毫无规律可言，要想在上面建立索引（绝大多数数据库在主键上都有索引）是一个非常耗时的操作。有人做过实验，插入同样的数据量，使用UniqueIdentifier型数据做主键要比使用Integer型数据慢，所以，出于效率考虑，尽可能避免使用UniqueIdentifier型数据库作为主键键值。</p>
<p>4使用“COMB（Combine）”类型</p>
<p>既然上面三种主键类型选取策略都存在各自的缺点，那么到底有没有好的办法加以解决呢？答案是肯定的。通过使用COMB类型（数据库中没有COMB类型，它是Jimmy Nilsson在他的“The Cost of GUIDs as Primary Keys”一文中设计出来的），可以在三者之间找到一个很好的平衡点。</p>
<p>COMB数据类型的基本设计思路是这样的：既然UniqueIdentifier数据因毫无规律可言造成索引效率低下，影响了系统的性能，那么我们能不能通过组合的方式，保留UniqueIdentifier的前10个字节，用后6个字节表示GUID生成的时间（DateTime），这样我们将时间信息与UniqueIdentifier组合起来，在保留UniqueIdentifier的唯一性的同时增加了有序性，以此来提高索引效率。也许有人会担心UniqueIdentifier减少到10字节会造成数据出现重复，其实不用担心，后6字节的时间精度可以达到1/300秒，两个COMB类型数据完全相同的可能性是在这1/300秒内生成的两个GUID前10个字节完全相同，这几乎是不可能的！在SQL Server中用SQL命令将这一思路实现出来便是：</p>
<p>DECLARE @aGuid UNIQUEIDENTIFIER</p>
<p>SET @aGuid = CAST(CAST(NEWID() AS BINARY(10))<br>+ CAST(GETDATE() AS BINARY(6)) AS UNIQUEIDENTIFIER)</p>
<p>经过<a href="http://lib.csdn.net/base/softwaretest">测试</a>，使用COMB做主键比使用INT做主键，在检索、插入、更新、删除等操作上仍然显慢，但比Unidentifier类型要快上一些</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法小记</title>
    <url>/posts/b170dee.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h2><p><img src="https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp"></p>
<ol>
<li>两两比较确定最大数，依次确定第二大，第三大数</li>
<li>稳定 时间复杂度O(n^2^)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums == null || nusm.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>()-i<span class="hljs-number">-1</span>;++j) &#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &gt; nums[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">int</span> temp = nums[j+<span class="hljs-number">1</span>];<br>                nums[j+<span class="hljs-number">1</span>] = nums[j];<br>                nums[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h2><ol>
<li>从后向前扫描，如果发现前边的比当前的大，则将前边元素后移，直到找到已排序元素中小于当前位置元素的数</li>
<li>稳定 时间复杂度O(n^2^)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums == null || nums.length &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">for</span> (iny i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>		iny curr = nums[i+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> preIndex = i;<br>        <span class="hljs-keyword">while</span> ( preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; curr &lt; nums[preIdnex]) &#123;<br>            nums[preIndex + <span class="hljs-number">1</span>] = nums[preIndex];<br>            preIndex--;<br>        &#125;<br>        nums[preIndex + <span class="hljs-number">1</span>] = curr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h2><ol>
<li>从最小元素开始，依次找第二小，第三小元素（与冒泡排序对称相反）</li>
<li>不稳定 时间复杂度O(n^2^)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>		<span class="hljs-keyword">int</span> minIndex = i;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>			<span class="hljs-keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;<br>				minIndex = j;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (minIndex != i) &#123;<br>			<span class="hljs-keyword">int</span> temp = nums[i];<br>			nums[minIndex] = temp;<br>			nums[i] = nums[minIndex];<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h2><p><strong>分治思想</strong></p>
<p>思路：</p>
<ol>
<li>从数组中选一个数做为基准值，一般选第一个数，或者最后一个数。</li>
<li>采用双指针(头尾两端)遍历，从左往右找到比基准值大的第一个数，从右往左找到比基准值小的第一个数，交换两数位置，直到头尾指针相等或头指针大于尾指针，把基准值与头指针的数交换。这样一轮之后，左边的数就比基准值小，右边的数就比基准值大。</li>
<li>对左边的数列，重复上面1，2步骤。对右边重复1，2步骤。</li>
<li>左右两边数列递归结束后，排序完成。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums == null || nums.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> star, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (star &gt; end) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = star;<br>        <span class="hljs-keyword">int</span> j = end;<br>        <span class="hljs-keyword">int</span> key = nums[star];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt; key) &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= key) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                <span class="hljs-keyword">int</span> temp = nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = temp;<br>            &#125;<br>        &#125;<br>        nums[star] = nums[i];<br>        nums[i] = key;<br>        <span class="hljs-built_in">quickSort</span>(nums, star, i - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(nums, i + <span class="hljs-number">1</span>, end);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//10万个数的数组，耗时：50毫秒</span><br></code></pre></td></tr></table></figure>



<p>快排，面试最喜欢问的排序算法。这是运用分治法的一种排序算法。</p>
<p><img src="../../../../images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.webp" alt="快速排序"></p>
<ol>
<li>从数组中选一个数做为基准值，一般选第一个数，或者最后一个数。</li>
<li>采用双指针(头尾两端)遍历，从左往右找到比基准值大的第一个数，从右往左找到比基准值小的第一个数，交换两数位置，直到头尾指针相等或头指针大于尾指针，把基准值与头指针的数交换。这样一轮之后，左边的数就比基准值小，右边的数就比基准值大。</li>
<li>对左边的数列，重复上面1，2步骤。对右边重复1，2步骤。</li>
<li>左右两边数列递归结束后，排序完成。</li>
<li>不稳定 O(nlogn)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> star, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (star &gt; end) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = star;<br>        <span class="hljs-keyword">int</span> j = end;<br>        <span class="hljs-keyword">int</span> key = nums[star];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt; key) &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= key) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                <span class="hljs-keyword">int</span> temp = nums[i];<br>                nums[i] = nums[j];<br>                nums[j] = temp;<br>            &#125;<br>        &#125;<br>        nums[star] = nums[i];<br>        nums[i] = key;<br>        <span class="hljs-built_in">quickSort</span>(nums, star, i - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(nums, i + <span class="hljs-number">1</span>, end);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//10万个数的数组，耗时：50毫秒</span><br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Oracle Undo</title>
    <url>/posts/7e1f6773.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Oracle回滚-撤销"><a href="#Oracle回滚-撤销" class="headerlink" title="Oracle回滚/撤销"></a>Oracle回滚/撤销</h1><blockquote>
<p>撤销数据是反转DML语句结果所需的信息。撤销数据通常被称为“回滚数据”，在过去的Oracle版本中，“回滚数据”和“撤销数据”可以交替使用，但从9i版本开始，这两个术语有所不同：功能相同，但管理方式不同。只要某个事务修改了数据，那么更新前的原有数据就会被写入一个回滚段或撤销段。回滚段在11g版本中依然存在，但从9i版本开始，Oracle数据库引入了可供选择的撤销段。<strong>Oracle强烈建议所有数据库都应当使用撤销段，回滚段只被保留用于向后兼容</strong>。</p>
</blockquote>
<h2 id="撤销管理"><a href="#撤销管理" class="headerlink" title="撤销管理"></a>撤销管理</h2><p>Oracle数据库中，也设置了一个专门的存储空间，用来保存操作过程及被操作的数据，即撤销记录，以便提供撤销功能，即允许用户撤销对数据库所执行的最后操作。<br>撤销表空间中创建撤销段，自动保存当前对数据库的操作，以便实现自动撤销管理，撤销该操作。</p>
<blockquote>
<p>撤销表空间，也叫还原空间，Undo tablespace</p>
</blockquote>
<img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gkpnlhc8ipj30m60bjgmj.jpg" alt="撤销" style="zoom:50%;">

<h2 id="自动撤销管理"><a href="#自动撤销管理" class="headerlink" title="自动撤销管理"></a>自动撤销管理</h2><ul>
<li><code>undo_tablespace</code><br>指定默认的撤销表空间</li>
<li><code>undo_retention</code><br>指定撤销记录在撤销段中保留的时间</li>
<li><code>undo_management</code><br>设置为auto，即使用的是自动撤销管理功能<br>由系统来决定在undo表空间内开多少undo段<br>Oracle服务器在UNDO表空间中，自动维护撤销数据</li>
<li>在system表空间中保留一个system回退段，以便存放和处理由Oracle系统事务产生的撤销数据。<br>创建数据库时，运行sql.bsq脚本会自动创建system回退段，DBA不需要对它进行任何维护和管理，也不能删除它</li>
</ul>
<h2 id="撤销的目的与作用"><a href="#撤销的目的与作用" class="headerlink" title="撤销的目的与作用"></a>撤销的目的与作用</h2><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gkpnlhttygj30mq0d9mxu.jpg" alt="目的" style="zoom:50%;">

<h3 id="①事物的回退"><a href="#①事物的回退" class="headerlink" title="①事物的回退"></a>①事物的回退</h3><p>在Oracle数据库中，对数据库的操作被划分成事务，一个事务由一条或多条SQL语句组成。一个事务中的SQL语句要么都执行要么都不执行，即可以回退<br>当用户回退一个事务时，Oracle使用撤销段中的撤销数据来撤销自从这个事务开始以来所发生的全部更改，并释放这个事务所涉及的表行上的任何锁，然后结束这个事务</p>
<h3 id="②读一致性"><a href="#②读一致性" class="headerlink" title="②读一致性"></a>②读一致性</h3><ul>
<li>数据库的读操作不会妨碍写操作，而数据库的写操作也不会妨碍读操作<ul>
<li>举例：如果在查询所有员工工资数据的同时有人修改了几个员工的工资数据，那么查询出来的所有员工的工资数据应该是修改前的、上一次提交后的数据，而不是修改后的数据。</li>
</ul>
</li>
<li>有了读一致性，就能保证修改前的数据和修改后的数据不会混杂在一起。读一致性是由Oracle自动提供的，并由撤销段中的撤销记录来实现</li>
</ul>
<h3 id="③闪回查询"><a href="#③闪回查询" class="headerlink" title="③闪回查询"></a>③闪回查询</h3><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gkpnlho32aj30k80cwq3m.jpg" alt="读一致性" style="zoom:50%;">

<ul>
<li>利用撤销段和闪回查询功能实现</li>
<li>闪回查询允许用户回到过去，查询刚刚过去的某个时间点上已经存在的一个表中的内容（这个时间点必然受到撤销空间、撤销信息保留时间的限制）</li>
<li>看起来像一条SELECT语句，不同的是它另外包含一个AS OF TIMESTAMP子句</li>
</ul>
<h3 id="④事物的恢复"><a href="#④事物的恢复" class="headerlink" title="④事物的恢复"></a>④事物的恢复</h3><p>事务恢复是例程恢复的一部分，是由Oracle自动完成的。在数据库运行过程中，正在做大量的事务，其中一些事务还没有提交，但出现了例程失败（如断电、内存故障、后台进程故障等），此时就可以使用撤销恢复数据。</p>
<h2 id="创建和配置撤销段"><a href="#创建和配置撤销段" class="headerlink" title="创建和配置撤销段"></a>创建和配置撤销段</h2><h3 id="①类型"><a href="#①类型" class="headerlink" title="①类型"></a>①类型</h3><ul>
<li><p>SYSTEM：用于在SYSTEM表空间中的对象</p>
</li>
<li><p>Non-SYSTEM：用于其它表空间中的对象</p>
<ul>
<li><p>自动模式：需要一个撤销表空间</p>
</li>
<li><p>手动模式：8i之前才使用的</p>
<ul>
<li><p>私有的：仅用于一个单独实例、</p>
</li>
<li><p>公用的：用于任意实例</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>延迟的撤销段：用于表空间立即、临时离线时，或恢复时</p>
</li>
</ul>
<h3 id="②配置"><a href="#②配置" class="headerlink" title="②配置"></a>②配置</h3><ul>
<li>在初始化文件中配置两个参数：<br><code>UNDO_MANAGEMENT（auto或manual）</code>指定系统是使用自动的还是手动的模式<br><code>UNDO_TABLESPACE</code>指定使用一个特定的撤销表空间</li>
<li>建立至少一个撤销表空间。</li>
</ul>
<p><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gkpnlhjoruj30g406g0ss.jpg" alt="撤销表空间"></p>
<h3 id="③创建撤销表空间"><a href="#③创建撤销表空间" class="headerlink" title="③创建撤销表空间"></a>③创建撤销表空间</h3><blockquote>
<p><code>undo_management=auto</code>使用自动管理方式</p>
</blockquote>
<ol>
<li><p>必须在数据库中创建一个撤销表空间，以便Oracle在其中分配撤销段来保存撤销数据。</p>
<blockquote>
<ol>
<li>在创建数据库的同时创建一个默认的撤销表空间</li>
<li>在数据库创建之后创建一个撤销表空间</li>
</ol>
</blockquote>
</li>
<li><p>如果没有指定一个撤销表空间，则在例程启动时，Oracle会自动搜索是否存在一个可用的（或联机的）撤销表空间，并自动选择第一个可用的撤销表空间来保存撤销数据。</p>
</li>
<li><p>如果没有找到一个可用的撤销表空间，Oracle就使用SYSTEM表空间的system回退段来保存撤销数据，并会在预警文件中记录如下警告信息：</p>
<p><code>Warning – Executing transaction without active Undo Tablespace</code></p>
</li>
</ol>
<h3 id="④创建UNDO表空间"><a href="#④创建UNDO表空间" class="headerlink" title="④创建UNDO表空间"></a>④创建UNDO表空间</h3><p>通过在CREATE DATABASE命令中增加一个子句，可以为数据库建立UNDO表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE db01<br>. . .<br>UNDO TABLESPACE undo1 DATAFILE <span class="hljs-string">&#x27;undo1db01.dbf&#x27;</span><br>SIZE <span class="hljs-number">20</span>M AUTOEXTEND <span class="hljs-keyword">ON</span><br></code></pre></td></tr></table></figure>
<p>或者通过使用CREATE UNDO TABLESPACE命令，在之后建立</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> UNDO TABLESPACE undo1<br>DATAFILE <span class="hljs-string">&#x27;undo1db01.dbf&#x27;</span> SIZE <span class="hljs-number">20</span>M;<br></code></pre></td></tr></table></figure>

<h3 id="⑤改变UNDO表空间"><a href="#⑤改变UNDO表空间" class="headerlink" title="⑤改变UNDO表空间"></a>⑤改变UNDO表空间</h3><p>ALTER TABLESPACE命令能改变UNDO表空间<br>例：把另一个数据文件加入到UNDO表空间中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span>SPACE undotbs<br><span class="hljs-keyword">ADD</span> DATAFILE <span class="hljs-string">&#x27;undotbs2.dbf&#x27;</span> SIZE <span class="hljs-number">30</span>M<br>AUTOEXTEND <span class="hljs-keyword">ON</span>;<br></code></pre></td></tr></table></figure>

<h3 id="⑥切换UNDO表空间"><a href="#⑥切换UNDO表空间" class="headerlink" title="⑥切换UNDO表空间"></a>⑥切换UNDO表空间</h3><p>可以在不同的UNDO表空间之间进行切换</p>
<ul>
<li>由于不能实际缩小撤销表空间的大小，如果启用了自动扩展功能，则为了响应一个产生大量撤销数据的大事务时，撤销表空间会自动增大。因为需要备份撤销表空间的数据文件，所以这会影响未来所有备份的大小</li>
<li>解决这个问题的方法是及时更换撤销表空间</li>
</ul>
<p>注：</p>
<ul>
<li>在任何时候，一个实例只能指定一个UNDO表空间</li>
<li>一个实例可以有多于一个的UNDO表空间，但是只能有一个是活跃的(被激活)</li>
<li>使用ALTER SYSTEM命令动态地在UNDO表空间之间切换</li>
</ul>
<blockquote>
<p>创建一个新的撤销表空间</p>
<p><code>CREATE DATABASE db01 . . . UNDO TABLESPACE undo1 DATAFILE &#39;undo1db01.dbf&#39; SIZE 20M AUTOEXTEND ON</code></p>
<p>或者</p>
<p><code>CREATE UNDO TABLESPACE undo1 DATAFILE &#39;undo1db01.dbf&#39; SIZE 20M;</code></p>
<p>更改使用该新的撤销表空间：<br><code>ALTER SYSTEM SET undo_tablespace=undotbs_new</code><br>删除旧的撤销表空间：</p>
<p><code>DROP TABLESPACE undotbs_old</code></p>
</blockquote>
<h3 id="⑦删除一个UNDO表空间"><a href="#⑦删除一个UNDO表空间" class="headerlink" title="⑦删除一个UNDO表空间"></a>⑦删除一个UNDO表空间</h3><p>DROP TABLESPACE命令删除一个UNDO表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> TABLESPACE UNDOTBS2;<br></code></pre></td></tr></table></figure>
<p>一个UNDO表空间只能在当前实例没有用它时才被删除。为了删除一个活跃的UNDO表空间：</p>
<ul>
<li>切换到一个新的UNDO表空间</li>
<li>等待在原表空间工作的当前事务都完成之后，删除表空间</li>
</ul>
<h3 id="⑧其他参数"><a href="#⑧其他参数" class="headerlink" title="⑧其他参数"></a>⑧其他参数</h3><p><code>UNDO_SUPPRESS_ERRORS</code>：设置为真，这个参数在AUTO模式中确定是否报错<br><code>UNDO_RETENTION</code>：单位是秒。控制回滚数据的数量，保持读一致性的时间(在回滚段中保持一段时间，保持读一致性)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> undo_retention<span class="hljs-operator">=</span><span class="hljs-number">600</span> <span class="hljs-keyword">SCOPE</span><span class="hljs-operator">=</span>memory;<br>#如果将UNDO_RETENTION设置成较大的值，就应该保证撤销表空间具有足够的空间，否则UNDO_RETENTION参数的值就会失去意义。<br></code></pre></td></tr></table></figure>

<h3 id="⑨设置UNDO表空间的大小"><a href="#⑨设置UNDO表空间的大小" class="headerlink" title="⑨设置UNDO表空间的大小"></a>⑨设置UNDO表空间的大小</h3><p>$UndoSize = UR × UPS × BS ×( 1 + overhead)$</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>UndoSize</strong></td>
<td>所需的撤销表空间的大小。</td>
</tr>
<tr>
<td><strong>UR</strong></td>
<td>表示UNDO_RETENTION参数的值（以秒为单位）。</td>
</tr>
<tr>
<td><strong>UPS</strong></td>
<td>表示每秒钟产生的撤销数据的Oracle块数。</td>
</tr>
<tr>
<td><strong>BS</strong></td>
<td>表示由DB_BLOCK_SIZE参数决定的Oracle块的大小。</td>
</tr>
<tr>
<td><strong>Overhead</strong></td>
<td>表示在撤销表空间中保留系统信息所需要的额外开销（一般为UR × UPS × BS 的5%~10%）。</td>
</tr>
</tbody></table>
<h3 id="⑩撤销数据统计量"><a href="#⑩撤销数据统计量" class="headerlink" title="⑩撤销数据统计量"></a>⑩撤销数据统计量</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> end_time,begin_time,undoblks<br><span class="hljs-keyword">FROM</span>   v$undostat;<br></code></pre></td></tr></table></figure>

<div style="text-align:center">------------------------------V$UNDOSTAT中的常用列--------------------------------</div>

<table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Endtime</td>
<td align="center">以10分钟为间隔的结束时间</td>
</tr>
<tr>
<td align="center">UndoBlocksUsed</td>
<td align="center">使用的undo块总数</td>
</tr>
<tr>
<td align="center">TxnConcurrency</td>
<td align="center">事务并发执行的最大数</td>
</tr>
<tr>
<td align="center">TxnTotal</td>
<td align="center">在时间段内事务执行总数</td>
</tr>
<tr>
<td align="center">QueryLength</td>
<td align="center">查询长度的最大值</td>
</tr>
<tr>
<td align="center">ExtentsStolen</td>
<td align="center">在时间段内undo区必须从一个undo段转到另一个的次数</td>
</tr>
<tr>
<td align="center">SSTooOldError</td>
<td align="center">在时间段内’Snapshot Too Old’错误发生的次数</td>
</tr>
<tr>
<td align="center">UNDOTSN</td>
<td align="center">这段时间内最后活动的undo表空间ID</td>
</tr>
</tbody></table>
<h2 id="获得撤销段信息"><a href="#获得撤销段信息" class="headerlink" title="获得撤销段信息"></a>获得撤销段信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#数据字典视图<br>DBA_ROLLBACK_SEGS<br>#动态性能视图<br>V$ROLLNAME<br>V$ROLLSTAT<br>V$UNDOSTAT<br>V$SESSION<br>V$TRANSACTION<br><br>用法:<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> V$ROLLNAME;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Oracle数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle存储结构</title>
    <url>/posts/ac7c815e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Oracle存储结构"><a href="#Oracle存储结构" class="headerlink" title="Oracle存储结构"></a>Oracle存储结构</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>数据库的主要功能是保存数据，所以可以将数据库看成是保存数据的容器。数据库的存储结构也就是数据库存储数据的结构或方式、方法、方案等。</p>
<blockquote>
<p>oracle 数据库的存储结构分为<strong>物理存储结构</strong>和<strong>逻辑存储结构</strong>两种。</p>
<ul>
<li>物理存储结构主要用于描述在 oracle  数据库外部数据的存储，即在操作系统层面中如何组织和管理数据，与具体的操作系统有关。</li>
<li>逻辑存储结构主要描述oracle 数据库内部数据的组织和管理方式，即在数据库管理系统的层面中如何组织和管理数据，与操作系统没有关系。</li>
</ul>
</blockquote>
<h2 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h2><p> oracle 数据库的物理存储结构与逻辑存储结构既相互独立又相互联系，如下图：</p>
<img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gkp0ewy59pj30g10eh74t.jpg" alt="关系图" style="zoom:50%;">

<p>从上面图中可以看出数据库物理存储结构和逻辑存储结构的基本关系：</p>
<ol>
<li>一个数据库在物理上包含多个数据文件，在逻辑上包含多个表空间</li>
<li>一个表空间包含一个或多个数据文件，一个数据文件只能从属于某个表空间</li>
<li>数据库的逻辑块由一个或多个操作系统块组成</li>
<li>一个逻辑区只能从属于一个数据文件，而一个数据文件可包括一个或多个逻辑区</li>
</ol>
<h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><div style="float:right"><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gkp0ex5uahj30ei0a0t98.jpg" alt="逻辑结构" style="zoom:70%;filter:drop-shadow(-6px 6px 6px black) ;"></div>

<p>是从逻辑的角度定义数据库的构成，比物理存储结构更高一层，许多初始化参数都是针对逻辑存储结构来定义的。</p>
<blockquote>
<p>主要描述Oracle数据库的内部存储结构，即从技术概念上描述在Oracle数据库中如何组织、管理数据。</p>
</blockquote>
<p>数据字典描述</p>
<blockquote>
<p>在操作系统中无法找到逻辑存储结构，但通过查询Oracle数据库的数据字典，可以找到逻辑存储结构的描述。</p>
</blockquote>
<p>包括表空间、段、区、块</p>
<ul>
<li>一个区只能在一个数据文件中</li>
<li>一个段中的各个区可以分别在多个数据文件中</li>
<li>组成区的块是连续的。</li>
</ul>
<blockquote>
<p>由于逻辑块对应磁盘空间中某个固定大小的尺寸（一般为操作系统数据块的整数倍），所以逻辑存储结构也是有大小的。</p>
</blockquote>
<p>逻辑结构类型按照尺寸从小到大分可分为：块(block)–&gt;区(extent)–&gt;段(segment)–&gt;表空间(tablespace)，下边依次阐述：</p>
<h4 id="表空间-tablespace"><a href="#表空间-tablespace" class="headerlink" title="表空间(tablespace)"></a>表空间(tablespace)</h4><blockquote>
<p>表空间组织数据和分配空间的逻辑结构，是最大的逻辑单位。<span style="background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900">数据库的大小从逻辑上看就是由表空间决定的，所有表空间大小的和就是数据库的大小</span>。表空间与数据库文件直接关联，在 oracle 数据库中，<span style="background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900">存储结构管理主要就是通过对表空间的管理来实现的</span>。</p>
</blockquote>
<div style="float:right"><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gkp0f0e0tnj30ab08dq37.jpg" alt="表空间" style="zoom:70%;filter:drop-shadow(-6px 6px 6px black) ;z-index:2;"></div>

<ol style="background:;border-radius:10px;padding:1px 5px;color:;font-weight:900;z-index:1;">
    <li>一个数据库可以有多个表空间</li>
    <li>一个表空间只属于一个数据库。</li>
    <li>一个表空间必须有一个数据文件。</li>
    <li>一个表空间的大小等于其中所有数据文件的大小之和。数据库的大小等于其中所有表空间的大小之和。</li>
    <li>表空间可以被联机和脱机。</li>
    <li>SYSTEM表空间不能被脱机。</li>
    <li>表空间可以在读写、只读状态之间切换。</li>
    <li>每个表空间由一个或多个物理存在的操作系统的数据文件组成。这种数据文件可以具有固定的大小，或允许其自动变大。可以在表空间中添加、删除数据文件。</li>
    <li>方案、对象、表、索引的数据都被存储在表空间的数据文件中。一个数据文件存储不下，就存储在另一个数据文件中，只要该数据文件是本表空间中的就行。</li>
<li>一个用户默认使用一个表空间，但他的不同方案对象的数据可以被存储在不同表空间中。</li>
<li>一个用户使用的表空间的数量是有一定配额的，不能超出这个配额。</li>
<li>可以根据使用目的，创建不同类型的表空间，如永久表空间、临时表空间、撤销表空间、大表空间等。不同类型的表空间的格式、使用方式及目的是不同的。</li></ol>


<p>表空间又根据存储数据类型的不同，分为<strong>系统表空间</strong>和<strong>非系统表空间</strong>两类。</p>
<blockquote>
<ul>
<li>系统表空间主要存放数据库的系统信息，如数据字典、数据库对象定义信息，数据库组件信息等。</li>
<li>非系统表空间又分为<strong>撤销表空间、临时表空间和用户表空间</strong>等。其中撤销表空间用于自动管理数据库的回退信息，临时表空间用于管理数据库的临时信息，用户表空间用于存储业务数据。</li>
</ul>
</blockquote>
<h4 id="段-segment"><a href="#段-segment" class="headerlink" title="段(segment)"></a>段(segment)</h4><p>段用于存储表空间中表一种特定的、具有独立存储结构的数据库对象的数据，它由一个或多个连续分区组成。当创建表、索引、簇等对象时，Oracle就会为这些对象分配存储空间（即段），以便存储它们的数据。按照段中所存储的数据的特征、用途不同，可以将段分成以下几种类型：</p>
<div style="display:table;">
<div style="float:left;display:flex;max-width:450px" width="25%"><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gkp0ezdqbfj303f04lmwy.jpg" alt="Table"><p style="text-align:left;display:inline-block">表段存储表的所有数据。当用户创建表时，就会在该用户的默认表空间中为该表分配一个与表名相同的表段，以便将来存储该表的所有数据。显然，在一个表空间中创建了几个表，在该表空间中就有几个表段。
</p></div>
<div style="float:left;display:flex;max-width:450px" width="25%"><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gkp0ezwpu2j303o052t8j.jpg" alt="Table partition"><p style="text-align:left;display:inline-block">表分区段用于存储分区表的所有数据。当用户创建分区表时，就会在该用户的默认表空间中为该表的每个分区分配一个表分区段。通过将一个大表的数据分散到不同的表分区段中，能降低I/O次数，提高性能。
</p></div>
<div style="float:left;display:flex;max-width:450px" width="25%"><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gkp0f0jaxej303q04fjr7.jpg" alt="Cluster"><p style="text-align:left;display:inline-block">簇段把几张表组织在一起，放在一个物理段中。
</p></div>
<div style="float:left;display:flex;max-width:450px" width="25%"><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gkp0exqa31j305q057mx2.jpg" alt="Index"><p style="text-align:left;display:inline-block">索引段存储索引的所有数据。当用户创建索引或定义约束而自动创建索引时，就会在该用户的默认表空间中为该索引分配一个与索引名相同的索引段，以便将来存储该索引的所有数据。
</p></div>
<div style="float:left;display:flex;max-width:450px" width="25%"><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gkp0exwhazj302u049a9x.jpg" alt="Index"><p style="text-align:left;display:inline-block">Index-organized table按照索引的顺序来存储的表。数据是有序存放的。按照索引的键值升序或降序排序。
</p></div>
<div style="float:left;display:flex;max-width:450px" width="25%"><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gkp0ez3fy0j304r02zjr9.jpg" alt="Index"><p style="text-align:left;display:inline-block">Index partition用于大的索引，物理上放置在不同的段中。如果为分区表创建分区索引，则会为每个分区索引分配一个索引分区段，其功能与表分区段相同。</p></div>
<div style="float:left;display:flex;max-width:450px" width="25%"><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gkp0ez9hxqj304q04qmx5.jpg" alt="Index"><p style="text-align:left;display:inline-block">Undo segment是有序的、循环的使用。用来存放oracle运行过程中发生数据改变时，存放数据的old value。帮助完成加滚和恢复。撤销段存储数据修改之前的位置和值。利用这些信息，可以回退未提交的事务，维护数据库的读一致性，并能从例程的崩溃中进行恢复。</p></div>
<div style="float:left;display:flex;max-width:450px" width="25%"><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gkp0ez67amj304a04sjr9.jpg" alt="Index"><p style="text-align:left;display:inline-block">临时段支持排序。临时段存储排序操作所产生的临时数据。临时数据首先会被暂存到排序区（属于PGA区）中，当排序区（其大小由SORT_AREA_SIZE初始化参数决定）不足以暂存这些临时数据时，则会在该用户的临时表空间中自动创建一个临时段，用于暂存这些临时数据，排序结束时，临时段自动消除。</p></div>
<div style="float:left;display:flex;max-width:500px" width="25%"><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gkp0eyw12wj306k04mweg.jpg" alt="Index"><p style="text-align:left;display:inline-block">二进制大对象段用于存储LOB数据类型列中的数据，如文档、图像、音频、视频数据。创建表时，可以定义LOB数据类型（包括CLOB，BLOB，NCLOB，BFILE）的列，Oracle会为此自动分配对应的二进制大对象段。对于LOB列来说，如果数据长度少于4000字节，则与其他列的数据会一起存放在表段中；否则数据就会被存储到二进制大对象段中。</p></div>
<div style="float:left;display:flex;max-width:450px" width="25%"><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gkp0exscr2j304a04sdfq.jpg" alt="Index"><p style="text-align:left;display:inline-block">Bootstrap segment：初始化实例的。创建数据库时自动创建，用过后自动释放。</p></div>
<div style="float:left;display:flex;max-width:450px" width="25%"><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gkp0eyzgr8j304m04vglh.jpg" alt="Index"></div>
</div>







<h4 id="区-extent"><a href="#区-extent" class="headerlink" title="区(extent)"></a>区(extent)</h4><p>区由物理上连续存放的块构成，是Oracle存储分配的最小单位，由一个或多个块组成区，由一个或多个分区组成段.<br>一个分区只能属于一个数据文件<br>当在数据库中创建带有实际存储结构的方案对象（如表、索引、簇）时，Oracle将为该方案对象分配若干个分区（视该方案对象的初始大小而定），以便组成一个对应的段，来为该方案对象提供初始的存储空间。当段中已分配的区都写满后，Oracle就要在该方案对象所在的表空间中为该段分配下一个新的空白区，以便容纳更多的数据。</p>
<img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gkp0ewtjv6j30ml08vq32.jpg" alt="分区" style="zoom:50%;">

<h4 id="块-block"><a href="#块-block" class="headerlink" title="块(block)"></a>块(block)</h4><div style="float:right"><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gkp0ex1x6oj30gb0ci3z0.jpg" alt="数据块内容" style="zoom:30%;"></div>

<p>是最小的数据管理单位，即数据管理中I/O的最小单位<br>其大小是OS块大小的整数倍<br>块大小是表空间的一个属性</p>
<h3 id="物理存储结构"><a href="#物理存储结构" class="headerlink" title="物理存储结构"></a>物理存储结构</h3><p> oracle 数据库的物理存储结构是由一系列操作系统文件组成的，存放于物理磁盘上，是数据库的实际存储单元。这些文件主要包括数据文件、控制文件、重做日志文件、归档文件、初始化参数文件、跟踪文件、告警文件等。每种文件都存储特定内容的信息，其数量也因文件类型不同而不同。</p>
<blockquote>
<p>数据文件：是数据库所有数据的实际存储空间，所有数据文件的大小和构成了数据库的大小。<br>控制文件：记录数据库结构信息的重要的二进制文件，由oracle 系统进行读 / 写操作。<br>重做日志文件：是以重做记录的形式记录、保存用户对数据库所进行的变更操作，<strong>是数据库中最重要的物理文件。</strong><br>归档日志文件：是历史联机重做日志文件的集合，是联机重做日志文件被覆盖之前备份的副本。<br>初始化参数文件：是数据库启动过程所必需的文件，记录了数据库显式参数的设置。数据库启动的第一步是根据初始化参数文件中的设置，</p>
</blockquote>
<p>创建并启动实例，即分配内存空间、启动后台进程。</p>
<blockquote>
<p>跟踪文件：是数据库中重要的诊断文件，是获取数据库信息的重要工具，对管理数据库的实例起着至关重要的作用。跟踪文件中包含数据库系统运行过程中所发生的重大事件的有关信息，可以为数据库运行故障的解决提供重要信息。<br>告警文件：是数据库中重要的诊断文件，记录数据库在启动、关闭和运行期间后台进程的活动情况。</p>
</blockquote>
<h3 id="获得存储信息"><a href="#获得存储信息" class="headerlink" title="获得存储信息"></a>获得存储信息</h3><p>使用数据字典</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">DBA_TABLESPACES<br>DBA_DATA_FILES<br>DBA_SEGMENTS<br>DBA_EXTENTS<br>DBA_FREE_SPACE<br></code></pre></td></tr></table></figure>



<h2 id="数据库的三级模式、二级映像结构"><a href="#数据库的三级模式、二级映像结构" class="headerlink" title="数据库的三级模式、二级映像结构"></a>数据库的三级模式、二级映像结构</h2><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gkp0exm0g4j30lc0giq3k.jpg" alt="三级模式" style="zoom:50%;">

<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><blockquote>
<p>也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有应用程序的公共的数据结构。<br>在信息世界中描述了现实世界中的实现及其联系。</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>一个数据库只有一个模式，它统一地、综合地考虑了所有用户的需求，并将这些需求有机地结合成一个逻辑整体。不同的应用程序可能只使用模式中的一部分；</li>
<li>模式是逻辑的，即它与具体珠应用程序无关或不属于某个应用程序。它描述的是一个数据库的总体结构，是装配数据的一个框架；</li>
<li>模式是<span style="background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900">以某种数据模型为基础</span>的。定义模式时不仅要定义数据的逻辑结构（如表有哪些数据项，每个数据项的名字、类型、取值范围等），而且还要定义这些数据项之间的联系（如外键），定义与数据项有关的安全性、完整性（如约束、主键）要求等；</li>
<li>模式用模式描述语言（如DDL）来定义。模式设计是数据库设计的重要任务。</li>
</ul>
<h3 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h3><blockquote>
<p>也称用户模式，是数据库用户（应用程序、终端用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是用户所用的数据库结构。</p>
</blockquote>
<p> 特点：</p>
<ul>
<li>一个数据库可以有多个外模式，分别对应于每个用户。由于各个用户在应用需求、看待数据的方式、对数据的保密程度等方面存在差异，所以其外模式可能不一样。如，即使对模式中同一个数据，在外模式中的结构、类型、长度、保密程度等都有可能不一样</li>
<li>外模式是保证数据库安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据，而看不见其他数据</li>
<li>可以通过授权等方式，使一个用户可以使用另一个用户的外模式</li>
<li>外模式是外模式描述语言（一般也归类到DDL）来定义。</li>
</ul>
<h3 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h3><blockquote>
<p>也称为存储模式，是对数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式，是整个数据库底层结构的表示，是数据库在物理存储方面的描述。</p>
</blockquote>
<p>特点：</p>
<ul>
<li>一个数据库只有一个内模式</li>
<li>一个数据库由多个文件组成</li>
<li>内模式对用户是透明的，即在用DML操纵数据库时不涉及内模式</li>
<li>内模式不同于物理层（或独立于物理设备）。它只是一个描述（如，数据是否压缩、加密；存储方式是按顺序、B树结构，还是Hash方法；按照什么方式组织索引；记录的结构有何规定等）</li>
<li>内模式由内模式描述语言（一般也归类到DDL）来定义。因为内模式的设计直接影响到数据库的性能，所以必须要对其有充分的了解，才能合理、有效地优化数据库的性能</li>
</ul>
<h3 id="二级映像"><a href="#二级映像" class="headerlink" title="二级映像"></a>二级映像</h3><blockquote>
<p>数据独立性（逻辑独立性、物理独立性）是由二级映像功能来保证的。</p>
<ul>
<li>逻辑独立性是指<span style="background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900">应用程序与数据的逻辑结构之间是相互独立的。</span>即，当模式（即逻辑结构）发生改变（如，增加新的关系或表、增加新的数据项或字段、更改数据项的名称或数据类型）时，只要数据库管理员对相应的外模式/模式映像做相应的修改，就可以使外模式保持不变，从而应用程序不需要改变。</li>
<li>物理独立性是指<span style="background: PaleVioletRed;border-radius:10px;padding:1px 5px;color:white;font-weight:900">应用程序与存储在磁盘上的数据库中的数据是相互独立的。</span>即，数据在磁盘上的数据库中如何存储完全由DBMS来管理，应用程序不需要了解，它只需要了解数据的逻辑结构就可以了。这样，当数据的存储格式和组织方式改变时，应用程序不需要改变。</li>
</ul>
</blockquote>
<p>外模式/模式映像</p>
<ul>
<li><p>由模式生成外模式的规则,定义了各个外模式和模式之间的对应关系</p>
</li>
<li><p>一个数据库可以有多个外模式/模式映像。对应于一个模式可以有多个外模式，所以对于每一个外模式都有一个外模式/模式映像</p>
</li>
<li><p>给数据库提供了逻辑独立性。</p>
</li>
</ul>
<p>指模式在物理设备中的存储结构，定义了模式和内模式之间的对应关系</p>
<ul>
<li>一个数据库只有一个模式/内模式映像。因为数据库只有一个模式和一个内模式，所以只有一个模式/内模式映像</li>
<li>给数据库提供了物理独立性。</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gkp0exefbgj30ll0dlgmf.jpg" alt="各级模式与各类用户、关系数据库管理系统之间的关系" style="zoom:50%;">]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Oracle数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle重做日志文件</title>
    <url>/posts/30a326fd.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h1><p>重做日志文件时为了数据库恢复的物理文件，其中保存了数据库的变更操作信息。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>重做日志文件(Redo Logfile)又被称为事务日志文件(Transaction Logfile)。</p>
<p>它对ORACLE数据库来说至关重要。ORACLE中每执行一条更新操作时，都会引起数据库的变化，因此都会生成一定数量的重做日志，他们将被记录到重做日志文件中。以便在数据库出现例程失败或介质故障时，可以利用重做日志文件来恢复数据库</p>
<p>重做日志文件是ORACLE三类文件中最为复杂的一类。在ORACLE 10G安装完毕后，会自动创建3个重做日志文件。</p>
<blockquote>
<ol>
<li>重做日志文件主要以<mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">重做记录的形式记录、保存对数据库所作的修改(或事务)</mark>。</li>
<li>如果在一段时间内只对数据库进行了查询操作，则不产生重做日志记录信息。</li>
<li>如果对一个表的数据进行了修改，并完成了事务的提交，这时数据文件只存储修改后的数据，但重做日志文件中要记录两类数据:<ol>
<li>一类是修改前的数据；</li>
<li>一类是修改后的数据。</li>
</ol>
所以<mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">重做日志文件的管理方式与数据文件的管理方式有所不同</mark>。</li>
</ol>
</blockquote>
<h2 id="二、作用与目的"><a href="#二、作用与目的" class="headerlink" title="二、作用与目的"></a>二、作用与目的</h2><blockquote>
<p>重做日志文件在<mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">数据库的恢复</mark>过程中起着非常重要的作用，可以用来进行例程和介质恢复（其中介质恢复需要借助于归档日志文件），以及事务的撤销。</p>
<blockquote>
<ul>
<li>重做日志文件是为了数据库恢复的物理文件，其中保存了数据库的变更操作信息。</li>
<li>通过重做日志文件通常是通过重做（REDO）或者是回退（UNDO）实现的。</li>
<li>重做（REDO）就是有些原因到导致事务对数据库的操作的修改在写入数据文件之前丢失了，此时就可以利用重做日志文件做该事务对数据库的变更。</li>
<li>回退（UNDO）如果用户在事务提交之前想回滚事务，那么可以利用重做日志文件撤销事务对数据库所做的变更。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h2><p><mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">重做日志文件记录所有对数据的改变，并提供由系统或媒体失败带来的恢复机制。</mark></p>
<p>每个数据库至少有两个重做日志文件，采用循环写的方式进行工作。这样就能保证当一个重做日志文件在进行归档时，还有另一个重做日志文件可用。当一个重做日志文件被写满后，后台进行就开始写下一个重做日志文件。当所有的重做日志文件都写满后，LGWR进程再重新开始写入第一个重做日志文件，开始新的循环。</p>
<p>通常LGWR进程再开始下一个重做日志之前要确定： 该重做日志文件中的所有重做记录所对应的变更操作结果必须全部写入数据文件中。如果数据库处于“归档模式”，要确定对该重做日志文件进行了归档。</p>
<hr>
<p>重做日志写进程（LGWR）在任意时刻只能写一组重做日志组，LGWR后台进程正在写的重做日志组叫做当前重做日志组。</p>
<ul>
<li>LGWR将完全相同的信息从重做日志缓冲区复制到改组的每个重做日志文件中。</li>
<li>LGWR是以循环的方式写重做日志组的，当写满一个重做日志组时，就会开始写下一组重做日志，这称为<strong>日志切换</strong>，当写满最后一组时，LGWR又开始写第一组重做日志。<ul>
<li>这被称为日志切换</li>
<li>检查点操作也产生</li>
<li>信息被写入控制文件</li>
</ul>
</li>
<li>如果数据库运行在归档模式下（oracle默认为非归档模式）,当LGWR的写操作从一个重做日志组切换到下一个重做日志组后，归档写进程（ARCH/ARCH0）就会将原来的重做日志文件中的信息复制到归档日志文件中。</li>
<li>oracle服务器保证在归档写进程没有将重做日志文件中的信息复制到归档日志文件中之前，LGWR进程不能再写这组重做日志。</li>
</ul>
<h3 id="1-重做日志文件的写入"><a href="#1-重做日志文件的写入" class="headerlink" title="1. 重做日志文件的写入"></a>1. 重做日志文件的写入</h3><ul>
<li>为保证数据库是可以恢复的，写入重做日志文件时必须遵守如下两个原则：</li>
</ul>
<ol>
<li>写入的次序要严格按并发事务的执行次序；</li>
<li>必须先写入重做日志文件再写入数据文件。</li>
</ol>
<ul>
<li>循环写入</li>
<li>日志切换或日志序列号</li>
<li>检查点</li>
</ul>
<h3 id="2-强迫日志切换和启动检查点"><a href="#2-强迫日志切换和启动检查点" class="headerlink" title="2. 强迫日志切换和启动检查点"></a>2. 强迫日志切换和启动检查点</h3><ol>
<li><p>日志切换</p>
<p>可以使用<code>ALTERSYSTEM SWITCH LOGFILE</code>命令来启动</p>
</li>
<li><p>启动检查点</p>
<ul>
<li><p>设置fast_start_mttr_target参数</p>
</li>
<li><p>ALTER SYSTEM CHECKPOINT命令</p>
</li>
<li><pre><code class="sql">ALTER SYSTEM CHECKPOINT；
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="3-启动检查点进程的时机"><a href="#3-启动检查点进程的时机" class="headerlink" title="3. 启动检查点进程的时机"></a>3. 启动检查点进程的时机</h3><ol>
<li><p>重做日志切换</p>
<p>即当一组重做日志写满时切换到下一组重做日志时。</p>
</li>
<li><p>关闭数据库</p>
<p>使用<code>NORMAL，TRANSACTIONAL,IMMEDIATTE</code>选项关闭数据库时，启动检查点。</p>
</li>
<li><p>表空间脱机或被设置成BACKUP模式</p>
</li>
<li><p>手动检查点</p>
<p>可以使用<code>ALTER SYSTEM CHRCKPOINT</code>手动设置一个检查点</p>
</li>
<li><p>时间检查点</p>
<blockquote>
<p>每隔多长时间执行一次检查点。可以通过调整<code>LOG_CHECKPOINT_TOMEOUT</code>和<code>LOG_CHECKPOINT_INTERVAL</code>参数来改变检查点执行的间隔。调整时小心，不要让间隔时间太长，也不要添加不必要的检查点。</p>
</blockquote>
</li>
<li><p>初始化参数LOG_CHECKPOINT_TO_ALTER</p>
<blockquote>
<p>如果将设置成TRUE，则关于每个检查点的信息都将被记录到预警日志文件中。该参数默认值是FALSE，表示不记录检查点的信息。如果在预警日志文件中看到关于检查点没有完成的信息，就应该给数据库添加新的重做日志文件，这样会给检查点的完成提供更多的时间，也保证了检查点产生的不是很频繁。</p>
</blockquote>
</li>
</ol>
<h2 id="四、概述重做日志文件的结构"><a href="#四、概述重做日志文件的结构" class="headerlink" title="四、概述重做日志文件的结构"></a>四、概述重做日志文件的结构</h2><p>当写满一个重做日志组时，就会开始写下一组重做日志。当写满最后一组时，LGWR又开始写第一组重做日志。</p>
<img src="../../../images/重做日志文件/重做日志文件的结构.png" alt="重做日志文件的结构" style="zoom:50%;">

<h3 id="重做记录"><a href="#重做记录" class="headerlink" title="重做记录"></a>重做记录</h3><img src="../../../images/重做日志文件/重做记录.png" alt="重做记录" style="zoom: 33%;">

<p>重做日志文件是由一条一条重做记录组成的，重做记录(REDO RECORD)是有一个个修改向量(CHANGE VECTOR)组成的。每个修改向量记录了对数据库中的某个数据块所作的修改。<br>重做记录记录了可以用来对数据可进行恢复的所有修改的数据，包括回退段。因此，重做日志文件同样也会保护回退数据。<mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">当使用重做日志文件来进行数据库恢复时，ORACLE将读取其中的重做记录(包括其中的修改向量)，并且将这些修改用于相关的块中。</mark><br>在ORACLE中，对数据库所作的修改实际上都是先在内存中进行的。当满足一定条件时先将修改操作产生的在SGA区的重做日志高速缓存中的修改结果，以重做记录的形式成批的写入重做日志文件中<span style="border-bottom:red 2px dashed">（此时就认为该事务已成功提交，因为此时可以进行事务的回退了，这种机制被称为“快速提交”</span>，然后才将内存中的在SGA区的数据告诉缓存中的修改结构成批的写入数据文件进行永久保存。因此，只要某项修改操作的重做记录没有丢失，就可以通过重做记录来恢复该项的修改操作。<br>在相应的数据提交之前，重做记录也可以被写入到重做日志文件中。如当SGA区的<strong>重做日志</strong>告诉<strong>缓存已经填满</strong>，或者提交了另一个事务，那么即使某些重做记录还没有提交，LGWR也会将重做日志缓存区中的所有重做记录全部写入到某个重做日志文件中，以便获得更多的空闲空间。这样，如果需要，ORACLE就可以回退这些修改了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Oracle数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>deque容器必知必会攻略🐋</title>
    <url>/posts/ed78b4bb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🐋deque容器"><a href="#🐋deque容器" class="headerlink" title="🐋deque容器"></a>🐋deque容器</h1><p>和其他STL容器一样，<code>deque</code>容器也是以模板类<code>deque&lt;T&gt;</code>的<code>&lt;deque&gt;</code>头文件中，并位于std命名空间中。因此，在使用该容器之前，代码中需要包含如下代码(<small><strong>注意</strong>：std 命名空间也可以在使用 deque 容器时额外注明，两种方式都可以。</small>)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>

<p>deque 是 double-ended queue 的缩写，又称双端队列容器。如果你已经了解<code>vector</code>，在学完<code>deque</code>之后，你就能发现这两者有很多相似之处，比如：</p>
<ul>
<li>deque 容器也擅长在序列尾部添加或删除元素（时间复杂度为O(1)），而不擅长在序列中间添加或删除元素。</li>
<li>deque 容器也可以根据需要修改自身的容量和大小。</li>
</ul>
<p>和<code>vector</code>不同的是，deque还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常熟阶<code>O(1)</code>。并且更重要的一点是，<mark style="color:white;background:green;border-bottom:dashed 2px;border-radius:20px;border-top:dashed 2px;background-size:50% 10%;padding:2px 10px;">deque容器中存储元素并不能保证所有元素都存储到连续的内存空间中</mark>。</p>
<blockquote>
<p>当需要想序列两端频繁的添加元素师，应首选deque容器。</p>
</blockquote>
<h1 id="🐋-创建deque容器"><a href="#🐋-创建deque容器" class="headerlink" title="🐋 创建deque容器"></a>🐋 创建deque容器</h1><p>创建 deque 容器，根据不同的实际场景，可选择使用如下几种方式。</p>
<ol>
<li>创建一个没有任何元素的空 deque 容器：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">deque&lt;<span class="hljs-keyword">int</span>&gt; d;	<span class="hljs-comment">//创建一个存放int的deque容器</span><br>deque&lt;<span class="hljs-keyword">float</span>&gt; dflt;	<span class="hljs-comment">//创建一个存放float的deque容器</span><br>deque&lt;string&gt; dstr;	<span class="hljs-comment">// 创建一个存放string的deque容器</span><br><span class="hljs-comment">//在头插入使用push_front()</span><br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//d = &#123;1&#125;</span><br><span class="hljs-comment">//在尾插入则使用push_back()</span><br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// d = &#123;1,2&#125;</span><br></code></pre></td></tr></table></figure>

<p>和空 array 容器不同，空的 deque 容器在创建之后可以做添加或删除元素的操作，因此这种简单创建 deque 容器的方式比较常见。</p>
<ol start="2">
<li>创建一个具有 n 个元素的 deque 容器，其中每个元素都采用对应类型的默认值：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//创建一个大小为10的deque容器，默认元素为0</span><br><span class="hljs-function">deque&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>此行代码创建一个具有 10 个元素（默认都为 0）的 deque 容器。</p>
<ol start="3">
<li>创建一个具有 n 个元素的 deque 容器，并为每个元素都指定初始值，例如：</li>
</ol>
<ul>
<li><code>deque(n,elem);</code> //构造函数将n个elem拷贝给本身。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//创建具有10个元素为5的deque 容器</span><br><span class="hljs-function">deque&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span><br></code></pre></td></tr></table></figure>

<p>如此就创建了一个包含 10 个元素（值都为 5）的 deque 容器。</p>
<ol start="4">
<li>在已有 deque 容器的情况下，可以通过拷贝该容器创建一个新的 deque 容器，例如：</li>
</ol>
<ul>
<li><code>deque(const deque  &amp;deq);</code>  拷贝构造函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">deque&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; 	<span class="hljs-comment">// 创建大小为5的deque容器d1</span><br><span class="hljs-function">deque&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d2</span><span class="hljs-params">(d1)</span></span>;		<span class="hljs-comment">//通过拷贝构造函数创建d2</span><br></code></pre></td></tr></table></figure>

<p>注意，采用此方式，必须保证新旧容器存储的元素类型一致。</p>
<ol start="5">
<li>通过拷贝其他类型容器中指定区域内的元素（也可以是普通数组），可以创建一个新容器，例如：</li>
</ol>
<ul>
<li><code>deque(beg,end);</code>   构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//拷贝普通数组，创建deque容器</span><br><span class="hljs-keyword">int</span> a[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>deque&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">d</span>(a, a + <span class="hljs-number">5</span>);<br><span class="hljs-comment">//适用于所有类型的容器</span><br>array&lt;<span class="hljs-keyword">int</span>, 5&gt; arr&#123; <span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span> &#125;;<br>deque&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">d</span>(arr.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>, arr.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//拷贝arr容器中的&#123;13,14,15&#125;</span><br></code></pre></td></tr></table></figure>

<h1 id="🐋deque容器的操作"><a href="#🐋deque容器的操作" class="headerlink" title="🐋deque容器的操作"></a>🐋deque容器的操作</h1><h2 id="🐋deque末尾的添加移除操作"><a href="#🐋deque末尾的添加移除操作" class="headerlink" title="🐋deque末尾的添加移除操作"></a>🐋deque末尾的添加移除操作</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">deque.<span class="hljs-built_in">push_back</span>(elem);	<span class="hljs-comment">//在容器尾部添加一个数据</span><br>deque.<span class="hljs-built_in">push_front</span>(elem);	<span class="hljs-comment">//在容器头部插入一个数据</span><br>deque.<span class="hljs-built_in">pop_back</span>();   	<span class="hljs-comment">//删除容器最后一个数据</span><br>deque.<span class="hljs-built_in">pop_front</span>();		<span class="hljs-comment">//删除容器第一个数据</span><br></code></pre></td></tr></table></figure>



<h2 id="deque的赋值"><a href="#deque的赋值" class="headerlink" title="deque的赋值"></a>deque的赋值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">deque.<span class="hljs-built_in">assign</span>(beg,end);   <span class="hljs-comment">//将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</span><br>deque.<span class="hljs-built_in">assign</span>(n,elem);  <span class="hljs-comment">//将n个elem拷贝赋值给本身。</span><br>deque&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> deque &amp;deq);	<span class="hljs-comment">//重载等号操作符 </span><br>deque.<span class="hljs-built_in">swap</span>(deq);  <span class="hljs-comment">// 将vec与本身的元素互换</span><br></code></pre></td></tr></table></figure>

<h2 id="deque的大小"><a href="#deque的大小" class="headerlink" title="deque的大小"></a>deque的大小</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">deque.<span class="hljs-built_in">size</span>();	  <span class="hljs-comment">//返回容器中元素的个数</span><br>deque.<span class="hljs-built_in">empty</span>();	  <span class="hljs-comment">//判断容器是否为空</span><br>deque.<span class="hljs-built_in">resize</span>(num);  <span class="hljs-comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br>deque.<span class="hljs-built_in">resize</span>(num, elem);  <span class="hljs-comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</span><br></code></pre></td></tr></table></figure>

<h2 id="deque的插入"><a href="#deque的插入" class="headerlink" title="deque的插入"></a>deque的插入</h2><p><mark style="color:white;background:green;border-bottom:dashed 2px;border-radius:20px;border-top:dashed 2px;background-size:50% 10%;padding:2px 10px;">第一个参数为迭代器</mark></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">deque.<span class="hljs-built_in">insert</span>(pos,elem);  <span class="hljs-comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。</span><br>deque.<span class="hljs-built_in">insert</span>(pos,n,elem);  <span class="hljs-comment">//在pos位置插入n个elem数据，无返回值。</span><br>deque.<span class="hljs-built_in">insert</span>(pos,beg,end);  <span class="hljs-comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span><br></code></pre></td></tr></table></figure>

<h2 id="deque的删除"><a href="#deque的删除" class="headerlink" title="deque的删除"></a>deque的删除</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">deque.<span class="hljs-built_in">clear</span>();	<span class="hljs-comment">//移除容器的所有数据 执行此操作之后deque.size() = 0</span><br>deque.<span class="hljs-built_in">erase</span>(beg,end);  <span class="hljs-comment">//删除[beg,end)区间的数据，返回下一个数据的位置。</span><br>deque.<span class="hljs-built_in">erase</span>(pos);   <span class="hljs-comment">//删除pos位置的数据，返回下一个数据的位置。</span><br></code></pre></td></tr></table></figure>

<h1 id="🐋deque容器成员方法"><a href="#🐋deque容器成员方法" class="headerlink" title="🐋deque容器成员方法"></a>🐋deque容器成员方法</h1><p>基于<code>deque</code>双端队列的特点，该容器包含一些 array、vector 容器都没有的成员函数。</p>
<p>下表中罗列了<code>deque</code>容器提供的所有成员函数。</p>
<table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>begin()</strong></td>
<td>返回指向容器中第一个元素的迭代器。</td>
</tr>
<tr>
<td><strong>end()</strong></td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 232-1，我们很少会用到这个函数。</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检查的索引访问元素。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
</tr>
<tr>
<td><strong>push_back()</strong></td>
<td>在序列的尾部添加一个元素。</td>
</tr>
<tr>
<td><strong>push_front()</strong></td>
<td>在序列的头部添加一个元素。</td>
</tr>
<tr>
<td><strong>pop_back()</strong></td>
<td>移除容器尾部的元素。</td>
</tr>
<tr>
<td><strong>pop_front()</strong></td>
<td>移除容器头部的元素。</td>
</tr>
<tr>
<td><strong>insert()</strong></td>
<td>在指定的位置插入一个或多个元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>移除一个元素或一段元素。</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</td>
</tr>
</tbody></table>
<blockquote>
<p>和 vector 相比，额外增加了实现在容器头部添加和删除元素的成员函数，同时删除了 capacity()、reserve() 和 data() 成员函数。</p>
</blockquote>
<h1 id="💻程序演示"><a href="#💻程序演示" class="headerlink" title="💻程序演示"></a>💻程序演示</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">deque&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dq</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>	dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br>	dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>	cout &lt;&lt; <span class="hljs-string">&quot;dq当前的大小为：&quot;</span> &lt;&lt; dq.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;dq中的元素为：&quot;</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : dq)<br>		cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	cout &lt;&lt; endl;<br>	<span class="hljs-function">deque&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dq2</span><span class="hljs-params">(dq.begin(),dq.end())</span></span>; <span class="hljs-comment">//拷贝构造赋值</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;dq2的大小为：&quot;</span> &lt;&lt; dq2.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">//dq2.size() = 3</span><br>	dq2.<span class="hljs-built_in">insert</span>(dq2.<span class="hljs-built_in">end</span>(),<span class="hljs-number">4</span>,<span class="hljs-number">4</span>);  <span class="hljs-comment">//第一个参数是迭代器 dq2 = &#123;1,2,3,4,4,4,4&#125; </span><br>	dq2.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 移除容器的所有数据 dq2.size() = 0</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;执行\&quot;dq2.clear()\&quot;移除容器后dq2.size() = &quot;</span> &lt;&lt; dq2.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>	dq2.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">//重新定义 dq2 = &#123;5,5,5,5,5&#125;</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;执行\&quot;dq2.resize(5, 5)\&quot;移除容器后dq2.size() = &quot;</span> &lt;&lt; dq2.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<div style="background:black;color:white;font-family:consolas">
dq当前的大小为：3<br>
dq中的元素为：1 2 3<br>
dq2的大小为：3<br>
执行"dq2.clear()"移除容器后dq2.size() = 0<br>
执行"dq2.resize(5, 5)"移除容器后dq2.size() = 5</div>]]></content>
      <categories>
        <category>C++笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>deque</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题☀️</title>
    <url>/posts/4e0bd4b0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目</p>
<p><a href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84%E7%9A%84K%E4%B8%AA%E7%82%B9">最接近原点的的K个点</a></p>
<h2 id="最接近原点的的K个点"><a href="#最接近原点的的K个点" class="headerlink" title="最接近原点的的K个点"></a>最接近原点的的K个点</h2><div align="left"><img src="https://img.shields.io/badge/难度-中等-yellow" style="zoom:100%;"></div>

<h4 id="973-最接近原点的-K-个点"><a href="#973-最接近原点的-K-个点" class="headerlink" title="973. 最接近原点的 K 个点"></a><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">973. 最接近原点的 K 个点</a></h4><p>我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。</p>
<p>（这里，平面上两点之间的距离是欧几里德距离。）</p>
<p>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：points &#x3D; [[1,3],[-2,2]], K &#x3D; 1<br>输出：[[-2,2]]<br>解释： <br>(1, 3) 和原点之间的距离为 sqrt(10)，<br>(-2, 2) 和原点之间的距离为 sqrt(8)，<br>由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。<br>我们只需要距离原点最近的 K &#x3D; 1 个点，所以答案就是 [[-2,2]]。<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：points &#x3D; [[3,3],[5,-1],[-2,4]], K &#x3D; 2<br>输出：[[3,3],[-2,4]]<br>（答案 [[-2,4],[3,3]] 也会被接受。）<br></code></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">kClosest</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points, <span class="hljs-keyword">int</span> K) &#123;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(),points.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; u, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; v)&#123;<br>            <span class="hljs-keyword">return</span> u[<span class="hljs-number">0</span>] * u[<span class="hljs-number">0</span>] + u[<span class="hljs-number">1</span>] * u[<span class="hljs-number">1</span>] &lt; v[<span class="hljs-number">0</span>] * v[<span class="hljs-number">0</span>] + v[<span class="hljs-number">1</span>] * v[<span class="hljs-number">1</span>];<br>    &#125;);<br>        <span class="hljs-keyword">return</span> &#123;points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">begin</span>() + K&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：</p>
<p>我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。</p>
<p>同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。</p>
<p>以排列 [4,5,2,6,3,1][4,5,2,6,3,1] 为例：</p>
<p>我们能找到的符合条件的一对「较小数」与「较大数」的组合为 22 与 33，满足「较小数」尽量靠右，而「较大数」尽可能小。</p>
<p>当我们完成交换后排列变为 [4,5,3,6,2,1][4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6][4,5,3,1,2,6]。</p>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="hljs-number">1</span>])<br>            i--;<br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums [j])<br>                j--;<br>            <span class="hljs-built_in">swap</span>(nums[i],nums[j]);<br>        &#125;        <br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle数据类型</title>
    <url>/posts/2b739d38.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="../../../../images/Oracle%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="数据类型"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Oracle数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle数据库的启动过程和关闭模式</title>
    <url>/posts/69b24920.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Oracle数据库的启动过程和关闭模式。"><a href="#Oracle数据库的启动过程和关闭模式。" class="headerlink" title="Oracle数据库的启动过程和关闭模式。"></a>Oracle数据库的启动过程和关闭模式。</h1><h2 id="一-启动数据库"><a href="#一-启动数据库" class="headerlink" title="一 启动数据库"></a>一 启动数据库</h2><p>Oracle启动过程涉及几种模式，这些模式涉及不同的文件，每个状态下数据库做不同的事情，同时这些模式适用于不同的维护需求，主要的模式有三种：<span style="background: pink;border-radius:10px;padding:1px 5px">NOMOUNT、MOUNT、OPEN</span>。</p>
<p><img src="../../../images/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%85%B3%E9%97%AD%E6%A8%A1%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%AF%E5%8A%A8.png" alt="数据库启动模式"></p>
<ol>
<li>NOMOUNT：启动数据库实例， 此时读取参数文件，但是不加载数据库;</li>
<li>MOUNT：启动数据库实例，加载数据库，但是数据库处于关闭状态；</li>
<li>OPEN: 启动数据库实例，加载并打开数据库；</li>
<li>FORCE: 终止实例并重启数据库，这种模式在数据库关闭或者启动遇到问题时使用，这种方式不到万不得已时不要使用，会有数据丢失；</li>
</ol>
<h3 id="1-NOMOUNT-启动例程"><a href="#1-NOMOUNT-启动例程" class="headerlink" title="1 NOMOUNT 启动例程"></a>1 NOMOUNT 启动例程</h3><ul>
<li>在启动例程时，这些内存结构和服务进程得到分配、初始化和启动，以便Oracle能够管理数据库</li>
<li>此时的例程还没有与一个确定的数据库相联系，或者说数据库是否存在对例程的启动并没有影响，即还没有装载数据库</li>
<li>若初始化参数文件设置有误，则无法启动例程</li>
</ul>
<p>这种模式只会创建实例（创建Oracle实例的各种内存结构与服务进程，其中有5个进程必须启动， DBWR、LGWR、SMON、PMON、CKPT），并不加载数据库，也不会打开任何数据文件。其任务为：</p>
<ul>
<li>读取参数文件</li>
<li>根据该参数文件中有关SGA区、PGA区的参数设置的值，在内存中分配相应的空间</li>
<li>根据该参数文件中有关后台进程的参数设置的值，启动相应后台进程</li>
<li>打开跟踪文件和报警文件</li>
</ul>
<p>① <code>先关闭数据库</code></p>
<p><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gkmjys31aqj30jm03a3ye.jpg" alt="Oracle启动 (1)">② 使用<code>STARTUP NOMOUNT</code>命令启动例程。通常使用数据库的这种状态来创建一个新的数据库，或创建一个新的控制文件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">startup nomount<br></code></pre></td></tr></table></figure>

<p><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gkmjytrwp5j30p60hkjsm.jpg" alt="Oracle启动 (2)">数据库的启动过程记录在警告追踪文件中，该警告追踪文件中包括数据库启动信息，它存放在参数<code>BACKGOUND_DUMP_DEST</code>定义的目录下，警告日志的名字为alert_orcl.log</p>
<p><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gkmjyu048aj30de03sjr8.jpg" alt="Oracle启动 (3)"></p>
<p>③ 进入到目录查看警告日志关于<mark style="background: pink;border-radius:10px;padding:1px 5px">startup nomount</mark>过程记录</p>
<p><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gkmjyu575sj30lj075wek.jpg" alt="Oracle启动 (4)"></p>
<p>④ 测试在nomount状态时数据字典是否打的开，下图说明数据库字典在nomount状态下是无法访问的，因为数据字典需要从控制文件获取文件的信息，而此时控制文件没有打开所以无法查看。</p>
<p><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gkmjyua3zlj30hk02v743.jpg" alt="Oracle启动 (5)"></p>
<p>但是在nomount下可以通过参数文件获得控制文件的位置，因为此时参数文件已经打开</p>
<p><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gkmjyueeibj30gq06yt8t.jpg" alt="Oracle启动 (6)"></p>
<h3 id="2-MOUNT-装载数据库"><a href="#2-MOUNT-装载数据库" class="headerlink" title="2 MOUNT 装载数据库"></a>2 MOUNT 装载数据库</h3><p>这种模式将启动实例，加载数据库并保持数据库关闭状态。数据库启动到MOUNT状态有两种方式：</p>
<ul>
<li>一是可以直接启动数据库到MOUNT</li>
<li>二是如果数据库已经启动到NOMOUNT状态，使用<code>alter database mount</code>把数据库切换到MOUNT状态；</li>
</ul>
<p>① <code>alert database mount</code></p>
<p><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gkmjyrbdrsj30fi0bxt8w.jpg" alt="Oracle启动 (7)"></p>
<p>② <code>startup mount</code></p>
<p><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gkmjyreg90j30hh040wed.jpg" alt="Oracle启动 (8)"></p>
<p>此时我们可以查看数据字典，因为控制文件已经打开</p>
<p><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gkmjyrgzh0j30fk08gdfz.jpg" alt="Oracle启动 (9)"></p>
<p><strong>注意：</strong>但是此时我们不能访问数据库的数据文件（表，视图），文件此时数据文件没有打开。</p>
<p><img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gkmjyrn3oej30d904rgli.jpg" alt="Oracle启动 (10)"></p>
<h4 id="MOUNT下改变状态："><a href="#MOUNT下改变状态：" class="headerlink" title="MOUNT下改变状态："></a>MOUNT下改变状态：</h4><p><strong>改变归档模式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">ARCHIVE LOG LIST<br><span class="hljs-keyword">ALTER</span> DATABASE ARCHIVELOG；<br><span class="hljs-keyword">ALTER</span> DATABASE NOARCHIVELOG；<br></code></pre></td></tr></table></figure>

<p><strong>暂停和重新开始数据库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> SUSPEND;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> RESUME;<br></code></pre></td></tr></table></figure>

<p>执行数据库备份时，为了避免控制文件和数据文件之间的I/O冲突，可以使用ALTER SYSTEM语句来暂停和重新开始数据库。暂停之后，禁止在控制文件和数据文件上进行任何I/O操作.</p>
<h3 id="3-OPEN-打开数据库"><a href="#3-OPEN-打开数据库" class="headerlink" title="3 OPEN 打开数据库"></a>3 OPEN 打开数据库</h3><blockquote>
<p>使用STARTUP OPEN（或STARTUP）命令启动例程、装在数据库并打开数据库</p>
</blockquote>
<p>这种模式将启动实例，加载并打开数据库，这是常规的启动模式，用户想要对数据库进行多种操作就必须使用OPEN模式启动数据库，启动到OPEN状态，有两种方式：</p>
<ul>
<li>一是直接启动到OPEN状态（使用startup或者startup open）</li>
<li>二是如果数据库处于NOMOUNT或者MOUNT状态，可以通过<code>alter database open</code>切换到OPEN状态。</li>
</ul>
<p><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gkmjyrpk6tj30bs09ndg1.jpg" alt="Oracle启动 (11)"></p>
<p>　　此时可以访问数据文件了。</p>
<p><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gkmjyrsomxj30a702mt8j.jpg" alt="Oracle启动 (12)"></p>
<p>　　</p>
<h3 id="4-FORCE-强制执行"><a href="#4-FORCE-强制执行" class="headerlink" title="4 FORCE 强制执行"></a>4 FORCE 强制执行</h3><p>这种模式将终止实例并重启数据库，这是一种强制性启动模式，只有在启动或者关闭出现问题时才使用，并且有一定的风险，会丢失数据，造成意外的问题。</p>
<p><img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gkmjyrvxskj30he040q2w.jpg" alt="Oracle启动 (13)"></p>
<p>　　</p>
<h2 id="二-关闭数据库"><a href="#二-关闭数据库" class="headerlink" title="二 关闭数据库"></a>二 关闭数据库</h2><p>　　与启动数据库顺序相反，也分三个步骤：关闭数据库(CLOSE 关闭数据文件)，卸载数据库(关闭控制文件 DISMOUNT)，关闭Oracle实例(SHUTDOWN)。同时关闭模式也有多种常见的有：</p>
<h3 id="1-NORMAL"><a href="#1-NORMAL" class="headerlink" title="1 NORMAL"></a>1 NORMAL</h3><p>正常的关闭方式，如果对于关闭数据库的时间没有限制，通常采用这种方式，以NORMAL方式关闭数据库，Oracle将执行如下操作：</p>
<blockquote>
<p>A 阻止任何用户建立新的连接；</p>
<p>B 等待当前所有正在连接的用户主动断开连接；</p>
<p>C 当前所有用户的都断开连接后，将立即关闭数据库；</p>
</blockquote>
<h3 id="2-TRANSACTION"><a href="#2-TRANSACTION" class="headerlink" title="2 TRANSACTION"></a>2 TRANSACTION</h3><p>事务关闭方式，它的首要任务是保证当前所有活动的事务都可以被提交，并在尽可能短的时间内关闭数据库。以事务方式关闭，Oracle将执行如下操作：</p>
<blockquote>
<p>A 阻止用户建立新连接和开始新事务；<br>B 等待所有活动事务提交后，再断开用户连接；<br>C 当所有活动事务提交完毕，用户断开连接后，关闭数据库；</p>
</blockquote>
<h3 id="3-IMMEDIATE"><a href="#3-IMMEDIATE" class="headerlink" title="3 IMMEDIATE"></a>3 IMMEDIATE</h3><p>立即关闭方式，可以较快且安全的关闭数据库，是DBA经常采用的关闭数据库的方式，立即关闭方式，Oracle执行如下操作：</p>
<blockquote>
<p>A 阻止用户建立新的连接和开始新的事务；</p>
<p>B 中断当前事务，回滚未提交事务；</p>
<p>C 强制断开所有用户连接和执行检查点把脏数据写到数据文件中；</p>
<p>D 关闭数据库</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Oracle数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>C++连接Oracle</title>
    <url>/posts/ddbf2ebc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-连接Oracle"><a href="#C-连接Oracle" class="headerlink" title="C++连接Oracle"></a>C++连接Oracle</h1><h2 id="常见的几种连接Oracle的方式"><a href="#常见的几种连接Oracle的方式" class="headerlink" title="常见的几种连接Oracle的方式"></a>常见的几种连接Oracle的方式</h2><ol>
<li>ODAC，通过 COM 的形式调用 Oracle，缺点是需要装 ODAC 客户端，而且体积不小</li>
<li>OCCI，通过动态库调用 Oracle, 不需要安装客户端，只需要几个 DLL 即可，问题是 Oracle 12.2 开始支持 VS2015，但不支持 XP</li>
<li>OCI，C语言的 API，调用起来稍显复杂</li>
<li>ODPI-C，也是C语言的 API，在 OCI 基础上做了一层封装，对比前两者，仍然不够简洁</li>
<li>cx_Oracle，Python 的第三方库，各方面都满足要求，但是甲方禁止使用 Python </li>
<li>ODBC，效率估计最低了吧</li>
<li>Pro*C，个人比较反感这种方案，不多说了</li>
<li>OTL，基于模板和流的 C++ 库，依赖 OCI</li>
</ol>
<p>而使用C/C++操作Oracle数据库的方法有以下几种种：</p>
<ul>
<li><p>pro*C：易入门，但程序代码繁琐；</p>
</li>
<li><p>OCI：Oracle Call Interface，功能强大，性能卓越，但难以驾驭；</p>
<blockquote>
<p>​    OCI是Oracle提供的C语言函数库，如果不对OCI进行封装，C程序员对Oracle的开发比较困难。</p>
<p>​    freecplus框架吧OCI封装成connection和sqlstatement两个类，C程序员对Oracle数据的操作成为了体力活。</p>
</blockquote>
</li>
<li><p>ODBC：效率较低</p>
</li>
</ul>
<p>1、无结果集SQL的程序流程图</p>
<img src="../../../../images/C++连接Oracle/1.png" alt="无结果集SQL的程序流程图" style="zoom:67%;">]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Oracle数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试宝典——操作系统1</title>
    <url>/posts/fe44a3e7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><p>进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发；</p>
<p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p>
<h2 id="死锁的原因"><a href="#死锁的原因" class="headerlink" title="死锁的原因"></a>死锁的原因</h2><ol>
<li>系统资源不足</li>
<li>进程运行推进的顺序不合适</li>
<li>资源分配不当</li>
</ol>
<p>四个必要条件：</p>
<ol>
<li>互斥条件：一个资源每次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h2 id="遇到死锁怎么处理"><a href="#遇到死锁怎么处理" class="headerlink" title="遇到死锁怎么处理"></a>遇到死锁怎么处理</h2><p>找到进程号，关闭进程</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML和Markdown设置下换线</title>
    <url>/posts/19f15521.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTML以及编辑的Markdown如何设置下划线样式"><a href="#HTML以及编辑的Markdown如何设置下划线样式" class="headerlink" title="HTML以及编辑的Markdown如何设置下划线样式"></a>HTML以及编辑的Markdown如何设置下划线样式</h1><p>本篇文章就给大家介绍css添加文字下划线样式的方法。有一定的参考价值，有需要的朋友可以参考一下，希望对大家有所帮助。</p>
<h2 id="常规办法"><a href="#常规办法" class="headerlink" title="常规办法"></a>常规办法</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span></span>这里是常规办法添加下划线<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p><mark style="background:green;border-radius:10px;color:white">效果如下：</mark></p>
<p><u>这里是常规办法添加下划线</u></p>
<h2 id="text-decoration属性"><a href="#text-decoration属性" class="headerlink" title="text-decoration属性"></a>text-decoration属性</h2><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-decoration:underline&quot;</span>&gt;</span>这是text-decoration属性设置的下划线。<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><mark style="background:green;border-radius:10px;color:white">效果如下：</mark></p>
<p><span style="text-decoration:underline">这是text-decoration属性设置的下划线。</span></p>
<h2 id="border-bottom属性"><a href="#border-bottom属性" class="headerlink" title="border-bottom属性"></a>border-bottom属性</h2><p>border-bottom属性使用起来比较灵活，并且可以设置线的格式，因此能满足你一篇文章的不同需求~~~</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是第实线样式，<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-bottom: 1px solid #000000;&quot;</span>&gt;</span>Mming‘s Blog<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>! <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是变粗的实线，<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-bottom: 5px solid #0081EF;&quot;</span>&gt;</span>Mming‘s Blog<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>! <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是虚线样式，<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-bottom: 2px dashed #000000;&quot;</span>&gt;</span>Mming‘s Blog<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>! <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是虚点下划线，<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-bottom: 2px dotted #000000;&quot;</span>&gt;</span>Mming‘s Blog<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>! <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是双下划綫，<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-bottom: 5px double #000000;&quot;</span>&gt;</span>Mming‘s Blog<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>! <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><mark style="background:green;border-radius:10px;color:white">效果如下：</mark></p>
<p>这是第实线样式，<span style="border-bottom: 1px solid #000000;">Mming‘s Blog</span>! </p> 
<p>这是变粗的实线，<span style="border-bottom: 5px solid #0081EF;">Mming‘s Blog</span>! </p>
<p>这是虚线样式，<span style="border-bottom: 2px dashed #000000;">Mming‘s Blog</span>! </p>
<p>这是虚点下划线，<span style="border-bottom: 2px dotted #000000;">Mming‘s Blog</span>! </p>
<p>这是双下划线，<span style="border-bottom: 5px double #000000;">Mming‘s Blog</span>! </p>

<p>border-bottom属性可以通过控制线的粗细、颜色、样式来实现不同的文字下划线样式。此外还有如下边框样式供参考⬇️ ：</p>
<ul>
<li>groove: 定义3D沟槽边框。效果取决于边框的颜色值</li>
<li>ridge: 定义3D脊边框。效果取决于边框的颜色值</li>
<li>inset:定义一个3D的嵌入边框。效果取决于边框的颜色值</li>
<li>outset: 定义一个3D突出边框。 效果取决于边框的颜色值</li>
</ul>
<blockquote>
<p>以上就是在HTML或者支持HTML的markdown文件中给文字添加下划线的方式，简单处理可以直接使用<code>u</code>标签，对下划线格式有要求时可以使用<code>border-bottom</code>属性对下划线进行设置。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试宝典——编译与底层</title>
    <url>/posts/9dd3ece6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="编译与底层"><a href="#编译与底层" class="headerlink" title="编译与底层"></a><font size="10px" style="font-weight:700;font-family:'华文彩云';color:rgb(100,190,100)"><span class="fa-stack fa-lg"><i class="fa fa-square fa-stack-2x"></i><i class="fa fa-code fa-stack-1x fa-inverse"></i></span>编译与底层</font></h1><h2 id="1-一个C-源文件从文本到可执行文件经历的过程？"><a href="#1-一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="1 一个C++源文件从文本到可执行文件经历的过程？"></a>1 一个C++源文件从文本到可执行文件经历的过程？</h2><p>对于C++源文件，从文本到可执行文件一般需要四个过程：</p>
<p><mark style="background:pink;border-radius:10px">预处理阶段</mark>：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件🔻。</p>
<p><mark style="background:pink;border-radius:10px">编译阶段</mark>：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件🔻。</p>
<p><mark style="background:pink;border-radius:10px">汇编阶段</mark>：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件🔻。</p>
<p><mark style="background:pink;border-radius:10px">链接阶段</mark>：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
<h2 id="2-include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#2-include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="2 include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>2 include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h2><p>Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。</p>
<p><strong>双引号和尖括号的区别：</strong>编译器预处理阶段查找头文件的路径不一样。</p>
<ul>
<li><p>对于使用双引号包含的头文件，查找头文件路径的顺序为：</p>
<blockquote>
<p>当前头文件目录</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量<code>CPLUS_INCLUDE_PATH/C_INCLUDE_PATH</code>指定的头文件路径</p>
</blockquote>
</li>
<li><p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p>
<blockquote>
<p> 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量<code>CPLUS_INCLUDE_PATH/C_INCLUDE_PATH</code>指定的头文件路径</p>
</blockquote>
</li>
</ul>
<h2 id="3-malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#3-malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="3 malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>3 malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h2><p>Malloc函数用于<strong>动态分配内存</strong>。为了减少内存碎片和系统调用的开销，malloc其采用<strong>内存池</strong>的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用<strong>显式链表结构</strong>来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</p>
<hr>
<p>当进行内存分配时，Malloc会通过<mark style="background:pink;border-radius:10px">隐式链表</mark>遍历所有的空闲块，选择满足要求的块进行分配；</p>
<p>当进行内存合并时，malloc采用<mark style="background:pink;border-radius:10px">边界标记法</mark>，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<hr>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。</p>
<ul>
<li>其中当申请内存<mark style="background:pink;border-radius:10px">小于128K</mark>时，会使用<mark style="background:pink;border-radius:10px">系统函数brk</mark>在<mark style="background:pink;border-radius:10px">堆区中</mark>分配；</li>
<li>而当申请内存<mark style="background:pink;border-radius:10px">大于128K</mark>时，会使用<mark style="background:pink;border-radius:10px">系统函数mmap</mark>在<mark style="background:pink;border-radius:10px">映射区</mark>分配。</li>
</ul>
<h2 id="4-C-的内存管理是怎样的？"><a href="#4-C-的内存管理是怎样的？" class="headerlink" title="4 C++的内存管理是怎样的？"></a>4 C++的内存管理是怎样的？</h2><p>在C++中，虚拟内存分为<span style="border-bottom: 2px dashed #000000">代码段、数据段、BSS段、堆区、文件映射区以及栈区</span>六部分。</p>
<p><mark style="background:pink;border-radius:10px">代码段</mark>：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p><mark style="background:pink;border-radius:10px">数据段</mark>：存储程序中已初始化的全局变量和静态变量</p>
<p><mark style="background:pink;border-radius:10px">bss 段</mark>(Block Started by Symbol)：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
<p><mark style="background:pink;border-radius:10px">堆区</mark>：调用<code>new/malloc</code>函数时在堆区动态分配内存，同时需要调用<code>delete/free</code>来手动释放申请的内存。</p>
<p><mark style="background:pink;border-radius:10px">映射区</mark>：存储动态链接库以及调用mmap函数进行的文件映射</p>
<p><mark style="background:pink;border-radius:10px">栈</mark>：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<h2 id="5-C-C的内存分配"><a href="#5-C-C的内存分配" class="headerlink" title="5 C++/C的内存分配"></a>5 C++/C的内存分配</h2><p><img src="../../../images/%E7%BC%96%E8%AF%91%E5%BA%95%E5%B1%82/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpg" alt="img"></p>
<p>32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中<mark style="background:pink;border-radius:10px">0~3G是用户态空间，3~4G是内核空间</mark>，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：</p>
<p>各个段说明如下：</p>
<div align="center" style="font-size:30px;">3G用户空间和1G内核空间</div>

<p><strong>静态区域：</strong></p>
<p><mark style="background:pink;border-radius:10px">text segment(代码段)</mark>:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p><mark style="background:pink;border-radius:10px">data segment(数据段)</mark>：存储程序中已初始化的<strong>全局变量</strong>和静态变量</p>
<p><mark style="background:pink;border-radius:10px">bss segment</mark>：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0</p>
<p><strong>动态区域：</strong></p>
<p><mark style="background:pink;border-radius:10px">heap（堆）</mark>： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。</p>
<p><mark style="background:pink;border-radius:10px">memory mapping segment(映射区)</mark>:存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</p>
<p><mark style="background:pink;border-radius:10px">stack（栈）</mark>：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</p>
<h2 id="6-如何判断内存泄漏？"><a href="#6-如何判断内存泄漏？" class="headerlink" title="6 如何判断内存泄漏？"></a>6 如何判断内存泄漏？</h2><p>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<h2 id="7-什么时候会发生段错误"><a href="#7-什么时候会发生段错误" class="headerlink" title="7 什么时候会发生段错误"></a>7 什么时候会发生段错误</h2><p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：</p>
<ul>
<li>使用野指针</li>
<li>试图修改字符串常量的内容</li>
</ul>
<h2 id="8-什么是memory-leak，也就是内存泄漏"><a href="#8-什么是memory-leak，也就是内存泄漏" class="headerlink" title="8 什么是memory leak，也就是内存泄漏"></a>8 什么是memory leak，也就是内存泄漏</h2><p><mark style="background:pink;border-radius:10px">内存泄漏(memory leak)</mark>是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
<p>内存泄漏的分类：</p>
<ol>
<li><p>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</p>
</li>
<li><p>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p>
</li>
<li><p>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</p>
</li>
</ol>
<h2 id="9-new和malloc的区别"><a href="#9-new和malloc的区别" class="headerlink" title="9 new和malloc的区别"></a>9 new和malloc的区别</h2><ol>
<li>new分配内存按照数据<strong>类型</strong>进行分配，malloc分配内存按照指定的大小分配；</li>
<li>new返回的是指定<strong>对象的指针</strong>，而malloc返回的是<strong>void</strong>*，因此malloc的返回值一般都需要进行类型转化。</li>
<li>new不仅分配一段内存，而且会调用构造函数，malloc不会。</li>
<li>new分配的内存要用<strong>delete销毁</strong>，malloc要用<strong>free来销毁</strong>；delete销毁的时候<strong>会调用</strong>对象的析构函数，而free则不会。</li>
<li>new是一个<strong>操作符</strong>可以重载，malloc是一个库函数。</li>
<li>malloc分配的内存不够的时候，可以用<strong>realloc扩容</strong>。扩容的原理？new没用这样操作。</li>
<li>new如果分配失败了会抛出<strong>bad_malloc</strong>的异常，而malloc失败了会返回NULL。</li>
<li>申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能<code>sizeof(int) * n</code>。</li>
</ol>
<h2 id="10-如何采用单线程的方式处理高并发"><a href="#10-如何采用单线程的方式处理高并发" class="headerlink" title="10 如何采用单线程的方式处理高并发"></a>10 如何采用单线程的方式处理高并发</h2><p>在单线程模型中，可以采用I/O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle体系结构与组件</title>
    <url>/posts/18cff4c7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Oracle体系结构和组件"><a href="#Oracle体系结构和组件" class="headerlink" title="Oracle体系结构和组件"></a>Oracle体系结构和组件</h1><blockquote>
<p>系统的体系结构决定了数据库如何使用内存、硬件和网络，以及哪个进程或程序运行在哪台机器上。<br>Oracle数据库服务器有两个主要的组成部分：数据库和实例(instance)。Oracle数据库用于存储和检索信息，是数据的集合。Oracle实例是指数据库服务器的内存及相关处理程序。</p>
</blockquote>
<p><img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gkfoikxodgj30hw091aan.jpg" alt="Oracle体系结构组件概览"></p>
<h1 id="图示并解释Oracle体系结构和组件"><a href="#图示并解释Oracle体系结构和组件" class="headerlink" title="图示并解释Oracle体系结构和组件"></a>图示并解释Oracle体系结构和组件</h1><p>Oracle体系结构如下图所示：</p>
<p><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gkfoilf6odj30fd09ywh0.jpg" alt="Oracle体系结构"></p>
<h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>一个Oracle数据库的物理结构，是由为数据库信息提供真实屋物理存储的操作系统文件决定的。</p>
<ul>
<li>控制文件</li>
<li>数据文件</li>
<li>重做日志文件</li>
</ul>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>Oracle内存结构由两个存储区域组成：</p>
<ul>
<li><p>系统全局区（System Global Area，SGA）：在实例启动时被分配，是Oracle实例的一个基本组件</p>
</li>
<li><p>程序全局区（Program Global Area，PGA）：在服务器进程启动时分配</p>
</li>
</ul>
<h1 id="系统全局区"><a href="#系统全局区" class="headerlink" title="系统全局区"></a>系统全局区</h1><blockquote>
<p> SGA(系统全局区)包括共享池、数据库缓冲区高速缓存、重做日志缓冲区、Java池、大型共享池等（锁管理、统计数据）。</p>
<p>SGA能配置两个可选存储结构：<code>大池</code>和<code>Java池</code></p>
</blockquote>
<ul>
<li>SGA是可变大小的,使用<code>SGA_MAX_SIZE</code>来设置大小</li>
<li>SGA组件分配SGA内存空间,并分割成更小的颗粒<ul>
<li>分配连续的虚拟内存</li>
<li>基于<code>SGA_ MAX_ SIZE</code>来分配大小</li>
</ul>
</li>
</ul>
<h2 id="1-共享池-SHARE-POOL"><a href="#1-共享池-SHARE-POOL" class="headerlink" title="1. 共享池(SHARE POOL)"></a>1. 共享池(SHARE POOL)</h2><div style="float:right"><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gkhduw53bzj306z09j3ye.jpg" alt="共享池" width="251" data-width="251" data-height="343"></div>

<pre><code> 共享池包括`库高速缓存`和`数据字典高速缓存`，共享池的主要作用和功能如下：
</code></pre>
<ol>
<li><p>共享池是对SQL、PL/SQL程序进行语法分析、编译、执行的内存区域。</p>
</li>
<li><p>共享池由库缓存和数据字典缓存组成。</p>
</li>
<li><p>库缓存含有最近执行的SQL、PL/SQL语句的分析码和执行计划；</p>
</li>
<li><p>数据字典缓存含有从数据字典中得到的表、索引、列定义和权限等信息。共享池的大小直接影响数据库的性能。</p>
</li>
<li><p>共享池的大小由初始化参数<code>shared_pool_size</code>决定，该参数以KB或MB为单位。默认的大小为8MB。</p>
</li>
<li><p>查询语句：<code>SQL &gt; show parameter shared_pool_size</code></p>
</li>
<li><p>用如下命令可以调整，参数为<code>SHARED_POOL_SIZE</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span><br>SHARED_POOL_SIZE <span class="hljs-operator">=</span> <span class="hljs-number">64</span>M;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-数据高速缓冲区-DATABASE-BUFFER-CACHE"><a href="#2-数据高速缓冲区-DATABASE-BUFFER-CACHE" class="headerlink" title="2. 数据高速缓冲区(DATABASE BUFFER CACHE)"></a>2. 数据高速缓冲区(DATABASE BUFFER CACHE)</h2><ol>
<li>由<mark style="background:pink;border-radius:10px;font-weight:600">最近最少使用（LRU）算法</mark>来管理</li>
<li>用于存储从磁盘数据文件中读入的数据，服务器进程将读入的数据保存在数据缓冲区中，当后续的请求需要这些数据时可以在内存中找到，不再从磁盘读取，提高了读取速度。</li>
<li>数据高速缓冲区中存放着Oracle系统最近使用过的数据库数据块。</li>
<li>数据缓冲区的大小对数据库的读取速度有直接的影响。</li>
<li>数据缓冲区直接由初始化参数文件中的<code>DB_CACHE_SIZE</code>参数决定，<code>DB_ CACHE_ ADVICE</code>能被设置为收集统计量,以预测不同高速缓存的大小调整</li>
<li><code>DB_BLOCK_SIZE</code>用于定义标准块的大小</li>
<li>查询语句：<code>SQL &gt; show parameter db</code></li>
<li>可以使用<code>ALTER_SYSTEM</code>动态调节大小，包括增加或减小</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> DB_CACHE_SIZE <span class="hljs-number">96</span>M;<br></code></pre></td></tr></table></figure>

<h2 id="3-重做日志缓冲区-REDO-LOG-BUFFER"><a href="#3-重做日志缓冲区-REDO-LOG-BUFFER" class="headerlink" title="3. 重做日志缓冲区(REDO LOG BUFFER)"></a><strong>3.</strong> 重做日志缓冲区(REDO LOG BUFFER)</h2><ol>
<li>日志记录数据库的所有修改信息，日志信息首先产生于日志缓冲区。 </li>
<li>当日志缓冲区的日志数据达到一定数量时，由后台进程将日志数据写入日志文件中。</li>
<li>在初始化参数文件中查询参数<code>log_buffer</code>。 </li>
<li>查询语句：<code>SQL &gt; show parameter log_buffer</code></li>
</ol>
<h2 id="4-库高速缓存"><a href="#4-库高速缓存" class="headerlink" title="4. 库高速缓存"></a>4. 库高速缓存</h2><p>库高速缓存存储的是最，近使用过的SQL和PL /SQL语句相关的信息。库高速缓存:</p>
<ul>
<li>使得共同使用的语句可以共享</li>
<li>可由最近最少使用(LRU)算法来管理</li>
<li>由两种结构组成:<ul>
<li>共享SQL区域</li>
<li>共享PL /SQL区域</li>
</ul>
</li>
<li>它的大小由 共享池大小的设置来决定</li>
</ul>
<h2 id="5-数据字典高速缓存"><a href="#5-数据字典高速缓存" class="headerlink" title="5. 数据字典高速缓存"></a>5. 数据字典高速缓存</h2><p>数据字典高速缓存是数据库中最近最多使用的定义的集合</p>
<ul>
<li>它包 括数据库文件、表、索引、列、用户、特权和其它数据库对象的有关信息</li>
<li>在解析阶段，服务器进程查看数据字典,核对信息，以解析对象名，并验证存取</li>
<li>把数据字典信息高速缓存到内存,提高查询响应时间</li>
<li>大小由共享池大小的设置来决定</li>
</ul>
<h2 id="6-Java池-JAVA-POOL"><a href="#6-Java池-JAVA-POOL" class="headerlink" title="6. Java池(JAVA POOL)"></a>6. Java池(JAVA POOL)</h2><ol>
<li><p>存储JAVA命令服务分析要求</p>
</li>
<li><p>安装和使用JAVA时必须的</p>
</li>
<li><p>大小有<code>JAVA_POOL_SIZE</code>确定</p>
</li>
</ol>
<h2 id="6-大型共享池-LARGE-POOL"><a href="#6-大型共享池-LARGE-POOL" class="headerlink" title="6. 大型共享池(LARGE POOL)"></a>6. 大型共享池(LARGE POOL)</h2><ol>
<li>SGA可选的内存区</li>
<li>分担了共享池的一部分工作</li>
<li>用于共享服务器的UGA</li>
<li>用于I/O服务器进程</li>
<li>备份和恢复操作或RMAN</li>
<li>并行执行消息缓冲区（前提<code>PARALLEL_POOL_SIZE=TRUE</code>）</li>
<li>不使用LRU列表</li>
<li>大小由<code>LARGE_POOL_SIZE</code>确定</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-keyword">SET</span> LARGE_POOL_SIZE <span class="hljs-operator">=</span> <span class="hljs-number">64</span>M;<br></code></pre></td></tr></table></figure>



<h1 id="程序全局区"><a href="#程序全局区" class="headerlink" title="程序全局区"></a>程序全局区</h1><blockquote>
<p>除此之外，还有程序全局区(PGA)，是为每一个连接到Oracle数据库的用户进程预留的内存</p>
</blockquote>
<p><img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gkfoilc1sjj30kt0abaam.jpg" alt="PGA"></p>
<h2 id="1-用户进程"><a href="#1-用户进程" class="headerlink" title="1. 用户进程"></a>1. 用户进程</h2><p>用户进程是一个程序，它请求与Oracle服务器的连接</p>
<ul>
<li> 它必须首先建立一个连接</li>
<li>它不直接与Oracle服务器进行交互</li>
</ul>
<h2 id="2-服务器进程"><a href="#2-服务器进程" class="headerlink" title="2. 服务器进程"></a>2. 服务器进程</h2><p>服务器进程是一个程序，它与Oracle服务器直接作用</p>
<ul>
<li>它回应用户进程产生的调用。并返回结果</li>
<li>可能是独占的或共享的服务器</li>
</ul>
<h2 id="3-后台进程"><a href="#3-后台进程" class="headerlink" title="3. 后台进程"></a>3. 后台进程</h2><p>硬盘和内存之间的关系被保持，并由Oracle的后台进程驱动：</p>
<ul>
<li>必须的后台进程</li>
</ul>
<table>
<thead>
<tr>
<th>DBWn</th>
<th>PMON</th>
<th>CKPT</th>
</tr>
</thead>
<tbody><tr>
<td>LGWR</td>
<td>SMON</td>
<td>RECO</td>
</tr>
</tbody></table>
<ul>
<li>可选的后台进程</li>
</ul>
<table>
<thead>
<tr>
<th>ARCn</th>
<th>LMON</th>
<th>Snnn</th>
</tr>
</thead>
<tbody><tr>
<td>QMNn</td>
<td>LMDn</td>
<td></td>
</tr>
<tr>
<td>CJQ0</td>
<td>Pnnn</td>
<td></td>
</tr>
<tr>
<td>LCKn</td>
<td>Dnnn</td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-数据库写进程（DBWn）"><a href="#1-数据库写进程（DBWn）" class="headerlink" title="1. 数据库写进程（DBWn）"></a>1. 数据库写进程（DBWn）</h3><p>DBWn延迟写入数据文件,直到发生下列事件之一：</p>
<ol>
<li>增量或正常检查点</li>
<li>灰数据缓冲区的数量达到阈值</li>
<li>进程扫描指定数量的块而无法找到任何空闲缓冲区时</li>
<li>出现超时</li>
<li>实时应用集群(Real Application Clusters, RAC)环境中出现ping请求</li>
<li>使一般表空间或临时表空间处于脱机状态</li>
<li>使表空间处于只读模式</li>
<li>删除或截断表</li>
<li>执行ALTER TABLESPACE表空间名BEGIN BACKUP操作</li>
</ol>
<h3 id="2-日志写进程（LGWR）"><a href="#2-日志写进程（LGWR）" class="headerlink" title="2.  日志写进程（LGWR）"></a>2.  日志写进程（LGWR）</h3><p>LGWR在下列情况下执行从重做日志缓冲区到重做日志文件的连续写入：</p>
<ol>
<li>当提交事务时</li>
<li>当重做日志缓冲区的<code>三分之一</code>填满时</li>
<li>当重做日志缓冲区中记录了超过<code>1 MB\2MB</code>的更改时</li>
<li>在<code>DBWn</code>将数据库缓冲区高速缓存中修改的块<code>写入数据文件以前</code></li>
<li>每隔<code>三秒</code></li>
</ol>
<h3 id="3-系统监控（SMON）"><a href="#3-系统监控（SMON）" class="headerlink" title="3. 系统监控（SMON）"></a>3. 系统监控（SMON）</h3><ul>
<li>实例恢复<ul>
<li>前滚重做日志中的更改</li>
<li>打开数据库供用户访问</li>
<li>回滚未提交的事务处理</li>
</ul>
</li>
<li>每三秒对自由空间的整理</li>
<li>对临时段的清空</li>
</ul>
<h3 id="4-进程监控（PMON）"><a href="#4-进程监控（PMON）" class="headerlink" title="4. 进程监控（PMON）"></a>4. 进程监控（PMON）</h3><p>进程失败后，后台进程PMON通过下面的方法进行清理：</p>
<ul>
<li>回滚用户的当前事务处理</li>
<li>释放当前保留的所有表锁或行锁</li>
<li>释放用户当前保留的其它资源</li>
<li>重新启动已失效（死锁）的调度程序</li>
</ul>
<h3 id="5-检查点Checkpoint（CKPT）"><a href="#5-检查点Checkpoint（CKPT）" class="headerlink" title="5. 检查点Checkpoint（CKPT）"></a>5. 检查点Checkpoint（CKPT）</h3><ul>
<li>在检查点发信号给DBWn</li>
<li>使用检查点信息更新数据文件的标头</li>
<li>使用检查点信息更新控制</li>
</ul>
<p>启动检查点的原因如下：</p>
<ul>
<li>确保定期向磁盘写入内存中发生修改的数据块，以便在系统或数据库失败时不会丢失数据</li>
<li>缩短例程恢复所需的时间。只需处理最后一个检查点后面的重做日志条目以启动恢复操作</li>
<li>确保提交的所有数据在关闭期间均已写入数据文件</li>
</ul>
<p>由CKPT写入的检查点信息包括检查点位置、系统更改号、重做日志中恢复操作的起始位置以及有关日志的信息等等。</p>
<p><mark style="background:lightblue">注：CKPT并不将数据块写入磁盘，或将重做块写入联机重做日志。</mark></p>
<h3 id="6-归档日志（ARCn）"><a href="#6-归档日志（ARCn）" class="headerlink" title="6. 归档日志（ARCn）"></a>6. 归档日志（ARCn）</h3><ul>
<li>可选的后台进程</li>
<li>设置<code>ARCHIVELOG模式</code>时自动归档联机重做日志</li>
<li>保留数据库的全部更改记录</li>
</ul>
<h2 id="4-QMNn会话内存-SESSION-MEMORY"><a href="#4-QMNn会话内存-SESSION-MEMORY" class="headerlink" title="4. QMNn会话内存(SESSION MEMORY)"></a>4. QMNn会话内存(SESSION MEMORY)</h2><p>为保留会话变量以及与该会话相关的其它信息而分配的内存。对于共享服务器环境，该会话是共享的而不是专用的。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Oracle数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>词根</title>
    <url>/posts/1744453e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="词根、词缀表"><a href="#词根、词缀表" class="headerlink" title="词根、词缀表"></a>词根、词缀表</h1><h2 id="Word-List-1"><a href="#Word-List-1" class="headerlink" title="Word List 1"></a>Word List 1</h2><table>
<thead>
<tr>
<th align="center">词根词缀</th>
<th align="center">含义</th>
<th align="right">Exapmle</th>
<th align="left">Translation</th>
</tr>
</thead>
<tbody><tr>
<td align="center">abs-</td>
<td align="center">离去</td>
<td align="right">abstract</td>
<td align="left">n.摘要 adj.抽象的</td>
</tr>
<tr>
<td align="center">con-</td>
<td align="center">共同</td>
<td align="right">consensus</td>
<td align="left">n.意见等一致</td>
</tr>
<tr>
<td align="center">inter-</td>
<td align="center">在……之前，相互</td>
<td align="right">internal</td>
<td align="left">adj.国内的；内心的</td>
</tr>
<tr>
<td align="center">pro-</td>
<td align="center">向前</td>
<td align="right">propel</td>
<td align="left">vt.推进，激励</td>
</tr>
<tr>
<td align="center">re-</td>
<td align="center">又，再；重新</td>
<td align="right">repression</td>
<td align="left">n.压抑；镇压</td>
</tr>
<tr>
<td align="center">bio</td>
<td align="center">生命</td>
<td align="right">biography</td>
<td align="left">n.传记</td>
</tr>
<tr>
<td align="center">ceed</td>
<td align="center">行走，前进</td>
<td align="right">proceedings</td>
<td align="left">n.进程；议程</td>
</tr>
<tr>
<td align="center">cogn</td>
<td align="center">知道</td>
<td align="right">congnitive</td>
<td align="left">adj.认知的，认知能力的</td>
</tr>
<tr>
<td align="center">fin</td>
<td align="center">范围</td>
<td align="right">define</td>
<td align="left">vt.给……下定义，限定</td>
</tr>
<tr>
<td align="center">ign</td>
<td align="center">燃</td>
<td align="right">ignite</td>
<td align="left">vt.点燃；引发 vi.着火</td>
</tr>
<tr>
<td align="center">luxur</td>
<td align="center">富，精美</td>
<td align="right">luxury</td>
<td align="left">n. 奢侈，奢侈品</td>
</tr>
<tr>
<td align="center">pel</td>
<td align="center">推</td>
<td align="right">propel</td>
<td align="left">vt.推进，激励</td>
</tr>
<tr>
<td align="center">pli</td>
<td align="center">倍，重</td>
<td align="right">compliment</td>
<td align="left">n.赞美的话 vt. 赞美，恭维</td>
</tr>
<tr>
<td align="center">pond</td>
<td align="center">重量</td>
<td align="right">ponder</td>
<td align="left">v. 思索，考虑，沉思</td>
</tr>
<tr>
<td align="center">press</td>
<td align="center">压</td>
<td align="right">repression</td>
<td align="left">n. 压抑；镇压</td>
</tr>
<tr>
<td align="center">rog</td>
<td align="center">要求</td>
<td align="right">arrangant</td>
<td align="left">adj. 傲慢的，自大的</td>
</tr>
<tr>
<td align="center">-ine</td>
<td align="center">……的</td>
<td align="right">genuine</td>
<td align="left">adj. 真的；真诚的</td>
</tr>
<tr>
<td align="center">-ion</td>
<td align="center">表性质</td>
<td align="right">repression</td>
<td align="left">n. 压抑；镇压</td>
</tr>
<tr>
<td align="center">-y</td>
<td align="center">……的</td>
<td align="right">hasty</td>
<td align="left">adj. 草率的；急速的；匆忙的</td>
</tr>
</tbody></table>
<h2 id="Word-List-2"><a href="#Word-List-2" class="headerlink" title="Word List 2"></a>Word List 2</h2><table>
<thead>
<tr>
<th align="center">词根词缀</th>
<th align="center">含义</th>
<th align="center">Exapmle</th>
<th align="left">Translation</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ac-,ap-,as-</td>
<td align="center">加强</td>
<td align="center">appendix</td>
<td align="left">n. 阑尾；附录</td>
</tr>
<tr>
<td align="center">con-，cor-</td>
<td align="center">共同，加强</td>
<td align="center">contest</td>
<td align="left">n. 竞赛，争夺</td>
</tr>
<tr>
<td align="center">em-，en-</td>
<td align="center">使…</td>
<td align="center">embody</td>
<td align="left">vt. 使具体化；包括</td>
</tr>
<tr>
<td align="center">in-</td>
<td align="center">不</td>
<td align="center">innumerable</td>
<td align="left">adj. 无数的，数不清的</td>
</tr>
<tr>
<td align="center">intel-</td>
<td align="center">中间</td>
<td align="center">intellectual</td>
<td align="left">n. 知识分子 adj. 智力的</td>
</tr>
<tr>
<td align="center">pre-</td>
<td align="center">预先</td>
<td align="center">presume</td>
<td align="left">vt. 推测，假定</td>
</tr>
<tr>
<td align="center">circ</td>
<td align="center">环绕</td>
<td align="center">circus</td>
<td align="left">n. 马戏团；环形广场</td>
</tr>
<tr>
<td align="center">cumul</td>
<td align="center">堆积</td>
<td align="center">accumulate</td>
<td align="left">v. 积累，堆积</td>
</tr>
<tr>
<td align="center">fic</td>
<td align="center">做</td>
<td align="center">proficiency</td>
<td align="left">n. 熟练，精通</td>
</tr>
<tr>
<td align="center">fract</td>
<td align="center">打破</td>
<td align="center">fracture</td>
<td align="left">n. 裂缝 v. 使断裂</td>
</tr>
<tr>
<td align="center">guis</td>
<td align="center">伪装</td>
<td align="center">disguise</td>
<td align="left">vt. 假扮，伪装；掩盖</td>
</tr>
<tr>
<td align="center">lect</td>
<td align="center">选择</td>
<td align="center">intellectual</td>
<td align="left">n. 知识分子 adj. 智力的</td>
</tr>
<tr>
<td align="center">liter</td>
<td align="center">文字</td>
<td align="center">literacy</td>
<td align="left">n. 识字，有文化，读写能力</td>
</tr>
<tr>
<td align="center">nutri</td>
<td align="center">营养</td>
<td align="center">nutrition</td>
<td align="left">n. 营养，营养学</td>
</tr>
<tr>
<td align="center">pos</td>
<td align="center">放</td>
<td align="center">compose</td>
<td align="left">vt. 组成，是镇静</td>
</tr>
<tr>
<td align="center">sent</td>
<td align="center">感觉</td>
<td align="center">sentiment</td>
<td align="left">n. 意见，感情</td>
</tr>
<tr>
<td align="center">vi</td>
<td align="center">道路</td>
<td align="center">deviate</td>
<td align="left">vi. 背离，偏离</td>
</tr>
<tr>
<td align="center">-ee</td>
<td align="center">表人</td>
<td align="center">referee</td>
<td align="left">n. 裁判员；证明人</td>
</tr>
<tr>
<td align="center">-ic</td>
<td align="center">…的</td>
<td align="center">gigantic</td>
<td align="left">adj. 巨大的，庞大的</td>
</tr>
<tr>
<td align="center">-ish</td>
<td align="center">使</td>
<td align="center">nourish</td>
<td align="left">vt. 养育，喂养</td>
</tr>
<tr>
<td align="center">-ive</td>
<td align="center">…性质的</td>
<td align="center">progressive</td>
<td align="left">adj. 前进的；渐进的</td>
</tr>
<tr>
<td align="center">-ure</td>
<td align="center">行为，行为的加过</td>
<td align="center">fracture</td>
<td align="left">n. 裂缝 v. 使断裂</td>
</tr>
</tbody></table>
<h2 id="Word-List-3"><a href="#Word-List-3" class="headerlink" title="Word List 3"></a>Word List 3</h2><table>
<thead>
<tr>
<th align="center">词根词缀</th>
<th align="center">含义</th>
<th align="center">Exapmle</th>
<th align="left">Translation</th>
</tr>
</thead>
<tbody><tr>
<td align="center">con-</td>
<td align="center">共同；加强</td>
<td align="center">conversion</td>
<td align="left">n. 转变；皈依</td>
</tr>
<tr>
<td align="center">en-</td>
<td align="center">使……</td>
<td align="center">endurance</td>
<td align="left">n. 忍耐力，持久（力）</td>
</tr>
<tr>
<td align="center">ex</td>
<td align="center">出</td>
<td align="center">expose</td>
<td align="left">vt. 使暴露，揭露</td>
</tr>
<tr>
<td align="center">cens</td>
<td align="center">评估</td>
<td align="center">census</td>
<td align="left">n. 人口普查，统计</td>
</tr>
<tr>
<td align="center">clud，clus</td>
<td align="center">关闭</td>
<td align="center">inclusive</td>
<td align="left">adj. 包括一切的</td>
</tr>
<tr>
<td align="center">crim</td>
<td align="center">罪行</td>
<td align="center">criminal</td>
<td align="left">n. 犯人 adj. 犯罪的</td>
</tr>
<tr>
<td align="center">dict</td>
<td align="center">说</td>
<td align="center">predict</td>
<td align="left">vt.预言，预告， 预测</td>
</tr>
<tr>
<td align="center">init</td>
<td align="center">开始</td>
<td align="center">initial</td>
<td align="left">adj. 最初的，开始的</td>
</tr>
<tr>
<td align="center">loqu</td>
<td align="center">说</td>
<td align="center">eloquent</td>
<td align="left">adj. 雄辩的，口才流利的</td>
</tr>
<tr>
<td align="center">miss</td>
<td align="center">送，放出</td>
<td align="center">dismiss</td>
<td align="left">vt. 不再考虑，解雇</td>
</tr>
<tr>
<td align="center">norm</td>
<td align="center">规则</td>
<td align="center">abnormal</td>
<td align="left">adj. 反常的，异常的</td>
</tr>
<tr>
<td align="center">radi</td>
<td align="center">光线</td>
<td align="center">radical</td>
<td align="left">adj. 基本的，激进的</td>
</tr>
<tr>
<td align="center">serv</td>
<td align="center">保持</td>
<td align="center">conserve</td>
<td align="left">vt. 保护，保藏</td>
</tr>
<tr>
<td align="center">-ence</td>
<td align="center"></td>
<td align="center">essence</td>
<td align="left">n. 本质；精髓，精华</td>
</tr>
<tr>
<td align="center">-ial</td>
<td align="center">……的</td>
<td align="center">initial</td>
<td align="left">adj. 最初的，开始的</td>
</tr>
<tr>
<td align="center">-ous</td>
<td align="center">……的</td>
<td align="center">previous</td>
<td align="left">adj. 先的，以前的</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>CET6</tag>
      </tags>
  </entry>
  <entry>
    <title>unorder_map容器必知必会攻略🐘</title>
    <url>/posts/5ec68291.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p> 点击加速到<strong>unorder_map</strong><a href="#">Post not found: 学习笔记/STL/STL之unorder_map</a></p>
</blockquote>
<h1 id="🐘map"><a href="#🐘map" class="headerlink" title="🐘map"></a>🐘map</h1><p>map 由红黑树实现，其元素都是 “键值/实值” 所形成的一个对组（key/value pairs)。每个元素有一个键，是排序准则的基础。每一个键只能出现一次，不允许重复。</p>
<p>map 主要用于资料一对一映射的情况，map 内部自建一颗红黑树，这颗树具有对数据自动排序的功能，所以在 map 内部所有的数据都是有序的。比如一个班级中，每个学生的学号跟他的姓名就存在着一对一映射的关系。</p>
<p><strong>特点</strong></p>
<ul>
<li>自动建立 Key - value 的对应。key 和 value 可以是任意你需要的类型。</li>
<li>根据 key 值快速查找记录，查找的复杂度基本是 O(logN)，如果有 1000 个记录，二分查找最多查找 10次(1024)。</li>
<li>增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。</li>
<li>对于迭代器来说，可以修改实值，而不能修改 key。</li>
</ul>
<p><strong>优缺点和适用场景</strong></p>
<ul>
<li><strong>优点：使用平衡二叉树实现，便于元素查找，且能把一个值映射成另一个值，可以创建字典。</strong></li>
<li>缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响。</li>
<li>适用场景：适用于需要存储一个数据字典，并要求方便地根据key找value的场景.</li>
</ul>
<p>1、如果需要高效的随机存取，不在乎插入和删除的效率，使用 vector。<br>2、如果需要大量的插入和删除元素，不关心随机存取的效率，使用 list。<br>3、如果需要随机存取，并且关心两端数据的插入和删除效率，使用 deque。<br>4、<strong>如果打算存储数据字典，并且要求方便地根据 key 找到 value，一对一的情况使用 map，</strong>一对多的情况使用 multimap。<br>5、如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用 set，不唯一存在的情况使用 multiset。</p>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ在线编程常见输入输出练习</title>
    <url>/posts/2ead30ec.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OJ在线编程常见输入输出练习"><a href="#OJ在线编程常见输入输出练习" class="headerlink" title="OJ在线编程常见输入输出练习"></a>OJ在线编程常见输入输出练习</h1><p><img src="../../../images/cover/niukebg.jpg" alt="img"></p>
<p>ACM的时候才知道自己连基本的输入都难以搞定！！！耻辱柱定死了~~~😭😭😭</p>
<p>如果大家有更好的方法一定给我分享一下，我太菜了👤</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="#A+B(1)">A+B(1)</a><font style="font-size:30px;color:lightblue;font-weight:900">||</font><a href="#A+B(2)">A+B(2)</a><font style="font-size:30px;color:lightblue;font-weight:900">||</font><a href="#A+B(3)">A+B(3)</a><font style="font-size:30px;color:lightblue;font-weight:900">||</font><a href="#A+B(4)">A+B(4)</a><font style="font-size:30px;color:lightblue;font-weight:900">||</font><a href="#A+B(5)">A+B(5)</a><font style="font-size:30px;color:lightblue;font-weight:900">||</font><a href="#A+B(6)">A+B(6)</a><font style="font-size:30px;color:lightblue;font-weight:900">||</font><a href="#A+B(7)">A+B(7)</a><font style="font-size:30px;color:lightblue;font-weight:900">||</font><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F(1)">字符串排序(1)</a><font style="font-size:30px;color:lightblue;font-weight:900">||</font><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F(2)">字符串排序(2)</a><font style="font-size:30px;color:lightblue;font-weight:900">||</font><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F(3)">字符串排序(3)</a></p>
<h1 id="A-B-1"><a href="#A-B-1" class="headerlink" title="A+B(1)"></a>A+B(1)</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/5650/A">https://ac.nowcoder.com/acm/contest/5650/A</a><br>来源：牛客网</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>  计算a+b </p>
<p>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据包括多组。<br></code></pre></td></tr></table></figure>

<p>输出描述:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输出a+b的结果<br></code></pre></td></tr></table></figure>

<p>示例1</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1 5<br>10 20<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">6<br>30<br></code></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; a;<br>	<span class="hljs-keyword">int</span> ta;<br>	cin &gt;&gt; ta;<br>	<span class="hljs-keyword">while</span> (cin) &#123;<br>		a.<span class="hljs-built_in">push_back</span>(ta);<br>		cin &gt;&gt; ta;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i+=<span class="hljs-number">2</span>)<br>		cout &lt;&lt; a[i] + a[i+<span class="hljs-number">1</span>] &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="A-B-2"><a href="#A-B-2" class="headerlink" title="A+B(2)"></a>A+B(2)</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/5650/B">https://ac.nowcoder.com/acm/contest/5650/B</a><br>来源：牛客网</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>  计算a+b </p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入第一行包括一个数据组数t(1 &lt;&#x3D; t &lt;&#x3D; 100)<br>接下来每行包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9)<br></code></pre></td></tr></table></figure>

<p><strong>输出描述</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输出a+b的结果<br></code></pre></td></tr></table></figure>

<p><strong>示例1</strong></p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2<br>1 5<br>10 20<br></code></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">6<br>30<br></code></pre></td></tr></table></figure>

<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> t;<br>	cin &gt;&gt; t;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>	<span class="hljs-keyword">while</span> (t-- &amp;&amp; cin) &#123;<br>		<span class="hljs-keyword">int</span> a,b;<br>		cin &gt;&gt; a &gt;&gt; b;<br>		nums.<span class="hljs-built_in">push_back</span>(a+b);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : nums)<br>		cout &lt;&lt; it &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="A-B-3"><a href="#A-B-3" class="headerlink" title="A+B(3)"></a>A+B(3)</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/5650/C">https://ac.nowcoder.com/acm/contest/5650/C</a><br>来源：牛客网</p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>  计算a+b </p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入<br></code></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输出a+b的结果<br></code></pre></td></tr></table></figure>

<p>示例1</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1 5<br>10 20<br>0 0<br></code></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">6<br>30<br></code></pre></td></tr></table></figure>

<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> a, b;<br>	cin &gt;&gt; a &gt;&gt; b;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>	<span class="hljs-keyword">while</span> (cin &amp;&amp; a != <span class="hljs-number">0</span> &amp;&amp; b != <span class="hljs-number">0</span>) &#123;<br>		nums.<span class="hljs-built_in">push_back</span>(a + b);<br>		cin &gt;&gt; a &gt;&gt; b;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : nums)<br>		cout &lt;&lt; it &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="A-B-4"><a href="#A-B-4" class="headerlink" title="A+B(4)"></a>A+B(4)</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/5650/D">https://ac.nowcoder.com/acm/contest/5650/D</a><br>来源：牛客网</p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>  计算一系列数的和 </p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入数据包括多组。<br>每组数据一行,每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100), n为0的时候结束输入。<br>接下来n个正整数,即需要求和的每个正整数。<br></code></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></td></tr></table></figure>

<p>示例1</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">4 1 2 3 4<br>5 1 2 3 4 5<br>0<br></code></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">10<br>15<br></code></pre></td></tr></table></figure>

<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;		<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>	<span class="hljs-keyword">int</span> length;<br>	cin &gt;&gt; length;<br>	<span class="hljs-keyword">while</span> (length != <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>				<span class="hljs-keyword">int</span> temp;<br>				cin &gt;&gt; temp;<br>				ans += temp;<br>		&#125;<br>		nums.<span class="hljs-built_in">push_back</span>(ans);<br>		cin &gt;&gt; length;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : nums)<br>			cout &lt;&lt; it &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="A-b-5"><a href="#A-b-5" class="headerlink" title="A+b(5)"></a>A+b(5)</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/5650/E">https://ac.nowcoder.com/acm/contest/5650/E</a><br>来源：牛客网</p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>  计算一系列数的和 </p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入的第一行包括一个正整数t(1 &lt;&#x3D; t &lt;&#x3D; 100), 表示数据组数。<br>接下来t行, 每行一组数据。<br>每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。<br>接下来n个正整数, 即需要求和的每个正整数。<br></code></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></td></tr></table></figure>

<p>示例1</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2<br>4 1 2 3 4<br>5 1 2 3 4 5<br></code></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">10<br>15<br></code></pre></td></tr></table></figure>

<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> row;<br>	cin &gt;&gt; row;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>	<span class="hljs-keyword">while</span> (row--) &#123;<br>		<span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>		cin &gt;&gt; length;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>			<span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>			cin &gt;&gt; temp;<br>			ans += temp;<br>		&#125;<br>		res.<span class="hljs-built_in">push_back</span>(ans);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : res)<br>		cout &lt;&lt; i &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="A-B-6"><a href="#A-B-6" class="headerlink" title="A+B(6)"></a>A+B(6)</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/5650/F">https://ac.nowcoder.com/acm/contest/5650/F</a><br>来源：牛客网</p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>  计算一系列数的和 </p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入数据有多组, 每行表示一组输入数据。<br>每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。<br>接下来n个正整数, 即需要求和的每个正整数。<br></code></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></td></tr></table></figure>

<p>示例1</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">4 1 2 3 4<br>5 1 2 3 4 5<br></code></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">10<br>15<br></code></pre></td></tr></table></figure>

<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>	<span class="hljs-keyword">int</span> length;<br>	cin &gt;&gt; length;<br>	<span class="hljs-keyword">while</span> (cin) &#123;<br>		<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>			<span class="hljs-keyword">int</span> temp;<br>			cin &gt;&gt; temp;<br>			ans += temp;<br>		&#125;<br>		nums.<span class="hljs-built_in">push_back</span>(ans);<br>		cin &gt;&gt; length;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : nums)<br>		cout &lt;&lt; it &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="A-B-7"><a href="#A-B-7" class="headerlink" title="A+B(7)"></a>A+B(7)</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/5650/G">https://ac.nowcoder.com/acm/contest/5650/G</a><br>来源：牛客网</p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>计算一系列数的和</p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入数据有多组, 每行表示一组输入数据。<br><br>每行不定有n个整数，空格隔开。(1 &lt;&#x3D; n &lt;&#x3D; 100)。<br></code></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">每组数据输出求和的结果<br></code></pre></td></tr></table></figure>

<p>示例1</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1 2 3<br>4 5<br>0 0 0 0 0<br></code></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">6<br>9<br>0<br></code></pre></td></tr></table></figure>

<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; sum;<br>	vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>	<span class="hljs-keyword">while</span> (!cin.<span class="hljs-built_in">eof</span>()) &#123;<br>		vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>		<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span>(cin)&#123;<br>			cin &gt;&gt; temp;<br>			ans += temp;		<br>			<span class="hljs-comment">//	nums.push_back(temp); //把结果保存在nums中</span><br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">getchar</span>() == <span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-keyword">break</span>;<br>		&#125;<br>	<span class="hljs-comment">//	res.push_back(nums); //把nums保存在res中</span><br>		sum.<span class="hljs-built_in">push_back</span>(ans);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sum.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ++i)<br>		cout &lt;&lt; sum[i] &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="字符串排序-1"><a href="#字符串排序-1" class="headerlink" title="字符串排序(1)"></a>字符串排序(1)</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/5650/H">https://ac.nowcoder.com/acm/contest/5650/H</a><br>来源：牛客网</p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>对输入的字符串进行排序后输出</p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入有两行，第一行n<br><br>第二行是n个空格隔开的字符串<br></code></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输出一行排序后的字符串，空格隔开，无结尾空格<br></code></pre></td></tr></table></figure>

<p>示例1</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">5<br>c d a bb e<br></code></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">a bb c d e<br></code></pre></td></tr></table></figure>

<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;string&gt; vstr;<br>	<span class="hljs-keyword">int</span> length;<br>	cin &gt;&gt; length;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>		string str;<br>		cin &gt;&gt; str;<br>		vstr.<span class="hljs-built_in">push_back</span>(str);<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(vstr.<span class="hljs-built_in">begin</span>(), vstr.<span class="hljs-built_in">end</span>());<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : vstr)<br>		cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="字符串排序-2"><a href="#字符串排序-2" class="headerlink" title="字符串排序(2)"></a>字符串排序(2)</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/5650/I">https://ac.nowcoder.com/acm/contest/5650/I</a><br>来源：牛客网</p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>对输入的字符串进行排序后输出</p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">多个测试用例，每个测试用例一行。<br><br>每行通过空格隔开，有n个字符，n＜100<br></code></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开<br></code></pre></td></tr></table></figure>

<p>示例1</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">a c bb<br>f dddd<br>nowcoder<br></code></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">a bb c<br>dddd f<br>nowcode<br></code></pre></td></tr></table></figure>

<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;vector&lt;string&gt; &gt; res;<br>	<span class="hljs-keyword">while</span> (!cin.<span class="hljs-built_in">eof</span>()) &#123;<br>		vector&lt;string&gt; vstr;<br>		<span class="hljs-keyword">while</span> (cin) &#123;<br>			string str;<br>			cin &gt;&gt; str;<br>			vstr.<span class="hljs-built_in">push_back</span>(str);<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">getchar</span>() == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>				<span class="hljs-built_in">sort</span>(vstr.<span class="hljs-built_in">begin</span>(), vstr.<span class="hljs-built_in">end</span>());<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>		&#125;<br>		res.<span class="hljs-built_in">push_back</span>(vstr);<br>	&#125;<br>	<span class="hljs-comment">//输出</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>		cout &lt;&lt; res[i][<span class="hljs-number">0</span>];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j = <span class="hljs-number">1</span>;j &lt; res[i].<span class="hljs-built_in">size</span>(); ++j)<br>			cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; res[i][j];<br>		cout &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="字符串排序-3"><a href="#字符串排序-3" class="headerlink" title="字符串排序(3)"></a>字符串排序(3)</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/5650/J">https://ac.nowcoder.com/acm/contest/5650/J</a><br>来源：牛客网</p>
<h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>对输入的字符串进行排序后输出</p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">多个测试用例，每个测试用例一行。<br>每行通过,隔开，有n个字符，n＜100<br></code></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">对于每组用例输出一行排序后的字符串，用&#39;,&#39;隔开，无结尾空格<br></code></pre></td></tr></table></figure>

<p>示例1</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">a,c,bb<br>f,dddd<br>nowcoder<br></code></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">a,bb,c<br>dddd,f<br>nowcoder<br></code></pre></td></tr></table></figure>

<h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    vector&lt;string&gt; vec;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>        <span class="hljs-function">istringstream <span class="hljs-title">input</span><span class="hljs-params">(s)</span></span>;<br>        string t;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(input, t, <span class="hljs-string">&#x27;,&#x27;</span>))<br>            vec.<span class="hljs-built_in">push_back</span>(t);<br>        <span class="hljs-keyword">if</span> (cin.<span class="hljs-built_in">get</span>() == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                <span class="hljs-keyword">if</span> (i) cout &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; vec[i];<br>                <span class="hljs-keyword">else</span> cout &lt;&lt; vec[i];<br>            &#125;<br>            cout &lt;&lt; endl;<br>            vec.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str;<br>    vector&lt;string&gt;array;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(cin,str))<br>    &#123;<br>        <span class="hljs-function">istringstream <span class="hljs-title">strs</span><span class="hljs-params">(str)</span></span>;<br>         string strt;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(strs,strt,<span class="hljs-string">&#x27;,&#x27;</span>))<br>        array.<span class="hljs-built_in">push_back</span>(strt);<br>       <span class="hljs-built_in">sort</span>(array.<span class="hljs-built_in">begin</span>(),array.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter=array.<span class="hljs-built_in">begin</span>();iter!=array.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>;iter++)<br>            cout&lt;&lt;*iter&lt;&lt;<span class="hljs-string">&#x27;,&#x27;</span>;<br>        cout&lt;&lt;array.<span class="hljs-built_in">back</span>()&lt;&lt;endl;<br>        array.<span class="hljs-built_in">clear</span>();      <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>牛客</tag>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS和DFS算法(基础)</title>
    <url>/posts/9ced94a0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><blockquote>
<p> 在《数据结构》这本书中，第七章第三小节讲了图的遍历，需要的同学可以自行去查看。同时，在牛客或者力扣刷题，遍历二叉树经常会用到DFS和BFS。</p>
</blockquote>
<p>和树的遍历类似。图的遍历也是从某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。这一过程就叫做图的遍历。图的遍历算法是求解<mark style="background:pink;color:white;font-weight: 700">图的连通性问题、拓扑排序和求关键路径等算法</mark>的基础。在图的遍历中，为了避免同一顶点被访问多次，必须记下每个已访问过的顶点。可以设置一个辅助数组用以判断当前结点是否已被访问。</p>
<p>在图的遍历中，有：深度优先搜索和广度优先搜索，他们对无向图和有向图都适用。</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>假设有这样一棵树如下所示：</p>
<img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gk6gp45p9yj30ax0a1aad.jpg" alt="二叉树" width="393" data-width="393" data-height="361" align="center">

<p>**深度优先搜索算法(Breadth-First-Search，缩写为 BFS)**：上图的遍历顺序为<mark>A-B-D-C-E-F</mark>。是一种利用<b>队列</b>实现的搜索算法，类似于树的先序遍历，是树的先序遍历的推广。</p>
<p>**广度优先搜索算法(Breadth-First-Search，缩写为 BFS)**：上图的遍历顺序为<mark>A-B-C-D-E-F</mark>。是一种利用<b>递归</b>搜索算法。遍历类似于树的按层次遍历的过程。</p>
<p><strong>BFS的重点在于队列，而DFS的重点在于递归。这是它们的本质区别</strong></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>求树的深度</p>
<div class="note green icon flat"><i class="note-icon fas fa-tree"></i><p>输入一棵<strong>二叉树</strong>，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
</div>

<h2 id="DFS方法"><a href="#DFS方法" class="headerlink" title="DFS方法"></a>DFS方法</h2><p><font color="green" style="font-family:思源宋体;font-weight:900">“不撞南墙不回头”</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;left);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">return</span> (left &gt; right) ? (left + <span class="hljs-number">1</span>) : (right + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="BFS方法"><a href="#BFS方法" class="headerlink" title="BFS方法"></a>BFS方法</h2><p><font color="green" style="font-family:思源宋体;font-weight:900">“剥洋葱，一层一层剥开”</font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">C++<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct TreeNode *left;</span><br><span class="hljs-comment">	struct TreeNode *right;</span><br><span class="hljs-comment">	TreeNode(int x) :</span><br><span class="hljs-comment">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot == <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>        que.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left)&#123;<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node-&gt;right)&#123;<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序员内功</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>树🌳</title>
    <url>/posts/undefined.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="刷题目录"><a href="#刷题目录" class="headerlink" title="刷题目录"></a>刷题目录</h1><p><a href="#%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C">求根到叶子节点数字之和</a></p>
<p><a href="#%E6%A3%80%E6%9F%A5%E5%B9%B3%E8%A1%A1%E6%80%A7">检查平衡性</a></p>
<span id="more"></span>





<h1 id="求根到叶子节点数字之和"><a href="#求根到叶子节点数字之和" class="headerlink" title="求根到叶子节点数字之和"></a>求根到叶子节点数字之和</h1><h4 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129. 求根到叶子节点数字之和"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根到叶子节点数字之和</a></h4><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [1,2,3]<br>    1<br>   &#x2F; \<br>  2   3<br>输出: 25<br>解释:<br>从根到叶子节点路径 1-&gt;2 代表数字 12.<br>从根到叶子节点路径 1-&gt;3 代表数字 13.<br>因此，数字总和 &#x3D; 12 + 13 &#x3D; 25.<br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [4,9,0,5,1]<br>    4<br>   &#x2F; \<br>  9   0<br> &#x2F; \<br>5   1<br>输出: 1026<br>解释:<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.<br>从根到叶子节点路径 4-&gt;0 代表数字 40.<br>因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026.<br></code></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root,<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> sum = data * <span class="hljs-number">10</span> + root-&gt;val;<br><br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, sum) + <span class="hljs-built_in">dfs</span>(root-&gt;right, sum);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root,<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="检查平衡性"><a href="#检查平衡性" class="headerlink" title="检查平衡性"></a>检查平衡性</h1><h4 id="面试题-04-04-检查平衡性"><a href="#面试题-04-04-检查平衡性" class="headerlink" title="面试题 04.04. 检查平衡性"></a><a href="https://leetcode-cn.com/problems/check-balance-lcci/">面试题 04.04. 检查平衡性</a></h4><p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> lh = <span class="hljs-built_in">height</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> rh = <span class="hljs-built_in">height</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(lh-rh) &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> lh = <span class="hljs-built_in">height</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> rh = <span class="hljs-built_in">height</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> lh&gt;rh?lh+<span class="hljs-number">1</span>:rh+<span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>set容器必知必会攻略🐢</title>
    <url>/posts/99373a3e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note purple icon flat"><i class="note-icon fas fa-comment"></i><p>set 容器定义于<code>&lt;set&gt;</code>头文件，并位于 <strong>std 命名空间</strong>中。如果想在程序中使用 set 容器，该程序代码应先包含如下语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>

<p><strong>set 容器的类模板定义如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">template &lt; <br>	class T,                        &#x2F;&#x2F; 键 key 和值 value 的类型           <br>	class Compare &#x3D; less&lt;T&gt;,        &#x2F;&#x2F; 指定 set 容器内部的排序规则           <br>	class Alloc &#x3D; allocator&lt;T&gt;      &#x2F;&#x2F; 指定分配器对象的类型           <br>	&gt; class set;<br></code></pre></td></tr></table></figure>

<p>注意，由于 set 容器存储的各个键值对，其键和值完全相同，也就意味着它们的类型相同，因此 set 容器类模板的定义中，仅有第 1 个参数用于设定存储数据的类型。</p>
<blockquote>
<p>对于 set 类模板中的 3 个参数，后 2 个参数自带默认值，且几乎所有场景中只需使用前 2 个参数，第 3 个参数不会用到。</p>
</blockquote>
</div>

<h1 id="🐢set容器"><a href="#🐢set容器" class="headerlink" title="🐢set容器"></a>🐢set容器</h1><blockquote>
<p>和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。</p>
<p>举个例子，如下有 2 组键值对数据：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">&#123;&lt;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>&gt;, &lt;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>&gt;, &lt;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>&gt;&#125;<br>&#123;&lt;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&gt;, &lt;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>&gt;, &lt;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&gt;&#125;<br></code></pre></td></tr></table></figure>

<p>显然，第一组数据中各键值对的键和值不相等，而第二组中各键值对的键和值对应相等。对于 set 容器来说，只能存储第 2 组键值对，而无法存储第一组键值对。</p>
<p>基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。仍以存储上面第 2 组键值对为例，只需要为 set 容器提供 {‘a’,’b’,’c’} ，该容器即可成功将它们存储起来。</p>
</blockquote>
<h1 id="🐢set的简介"><a href="#🐢set的简介" class="headerlink" title="🐢set的简介"></a>🐢set的简介</h1><ul>
<li><p>set是一个<strong>集合</strong>容器，其中所包含的元素是<strong>唯一</strong>的，<strong>集合中的元素按一定的顺序排列</strong>。元素插入过程是按排序规则插入，所以不能指定插入位置。</p>
</li>
<li><p>set采用<a href="#">Post not found: 程序员内功/算法与数据结构/数据结构/红黑树</a>变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。</p>
</li>
<li><p>set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</p>
</li>
<li><p style="color:SkyBlue;">multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。</p></li>
<li><p></p><font style="color:LightSkyBlue">不可以直接修改set或multiset容器中的元素值</font>，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。</li>
</ul>
<h1 id="🐢创建set容器"><a href="#🐢创建set容器" class="headerlink" title="🐢创建set容器"></a>🐢创建set容器</h1><p>常见的创建set容器的方法，大致有以下5种：</p>
<h3 id="1）默认构造函数"><a href="#1）默认构造函数" class="headerlink" title="1）默认构造函数"></a>1）默认构造函数</h3><p>调用默认构造函数，创建空的set容器。set对象的默认构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">set&lt;<span class="hljs-keyword">int</span>&gt; setInt;       <span class="hljs-comment">//一个存放int的set容器。</span><br>set&lt;<span class="hljs-keyword">float</span>&gt; setFloat;   <span class="hljs-comment">//一个存放float的set容器。</span><br>set&lt;string&gt; setString;   <span class="hljs-comment">//一个存放string的set容器。</span><br></code></pre></td></tr></table></figure>

<p>由此就创建好了一个 set 容器，该容器采用默认的<code>std::less&lt;T&gt;</code>规则，会对存储的 string 类型元素做升序排序。注意，由于 set 容器支持随时向内部添加新的元素，因此创建空 set 容器的方法是经常使用的。</p>
<h3 id="2）创建并初始化"><a href="#2）创建并初始化" class="headerlink" title="2）创建并初始化"></a>2）创建并初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">set&lt;string&gt; myBlogSet&#123;<br>    	<span class="hljs-string">&quot;http://fole-del.github.io&quot;</span>,<br>        <span class="hljs-string">&quot;http://fole-del.gitee.io&quot;</span>,<br>        <span class="hljs-string">&quot;http://www.mingsrc.work&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>由此即创建好了包含 3 个 string 元素的 <code>myBlogSet</code>容器。由于其采用默认的 std::less<T> 规则，因此其内部存储 string 元素的顺序如下所示：</T></p>
<div style="background:black;color:white;font-family:consolas;">
    http://fole-del.gitee.io<br>
    http://fole-del.github.io<br>
    http://www.mingsrc.work<br>
</div>

<h3 id="3）拷贝构造函数"><a href="#3）拷贝构造函数" class="headerlink" title="3）拷贝构造函数"></a>3）拷贝构造函数</h3><p>使用set类模板提供的拷贝构造函数，在第2种myBlog的基础上，执行如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::set&lt;std::string&gt; <span class="hljs-title">copyBlogSet</span><span class="hljs-params">(myBlogSet)</span></span>;<br><span class="hljs-comment">//等同于</span><br><span class="hljs-comment">//std::set&lt;std::string&gt; copyBlogSet = myBlogSet</span><br></code></pre></td></tr></table></figure>

<p>该行代码在创建 copyBlogSet 容器的基础上，还会将myBlogSet容器中存储的所有元素，全部复制给copyBlogSet容器一份。</p>
<p>除此之外，C++11标准还为set类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">set&lt;string&gt; <span class="hljs-title">retBlogSet</span><span class="hljs-params">()</span> </span>&#123;<br>    std::set&lt;std::string&gt; myBlogSet&#123; <span class="hljs-string">&quot;http://fole-del.github.io&quot;</span>,<br>                   <span class="hljs-string">&quot;http://fole-del.gitee.io&quot;</span>,<br>                   <span class="hljs-string">&quot;http://www.mingsrc.work&quot;</span>&#125;;<br>    <span class="hljs-keyword">return</span> myBlogSet;<br>&#125;<br><span class="hljs-function">std::set&lt;std::string&gt; <span class="hljs-title">copyBlogSet</span><span class="hljs-params">(retBlogSet())</span></span>;<br><span class="hljs-comment">//或者</span><br><span class="hljs-comment">//std::set&lt;std::string&gt; copyBlogSet = retBlogSet();</span><br></code></pre></td></tr></table></figure>

<h3 id="4-使用已有set的部分初始化set"><a href="#4-使用已有set的部分初始化set" class="headerlink" title="4) 使用已有set的部分初始化set"></a>4) 使用已有set的部分初始化set</h3><p>在第 3 种方式的基础上，set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">set&lt;string&gt; myBlogSet&#123;<span class="hljs-string">&quot;http://fole-del.github.io&quot;</span>,<br>                   <span class="hljs-string">&quot;http://fole-del.gitee.io&quot;</span>,<br>                   <span class="hljs-string">&quot;http://www.mingsrc.work&quot;</span>&#125;;<br><span class="hljs-function">std::set&lt;std::string&gt; <span class="hljs-title">copyBlogSet</span><span class="hljs-params">(++myBlogSet.begin(), myBlogSet.end())</span></span>;<br></code></pre></td></tr></table></figure>

<p>由此初始化的copyset容器，其内部有如下2两个字符串：</p>
<div style="background:black;color:white;font-family:consolas;">
    http://fole-del.github.io<br>
    http://www.mingsrc.work<br>
</div>

<h3 id="5）修改set的排序规则"><a href="#5）修改set的排序规则" class="headerlink" title="5）修改set的排序规则"></a>5）修改set的排序规则</h3><p>以上几种方式创建的 set 容器，都采用了默认的<code>std::less&lt;T&gt;</code>规则。其实，借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">set&lt;string,greater&lt;string&gt; &gt; myBlogSet&#123;<span class="hljs-string">&quot;http://fole-del.github.io&quot;</span>,<br>                   	<span class="hljs-string">&quot;http://fole-del.gitee.io&quot;</span>,<br>                   <span class="hljs-string">&quot;http://www.mingsrc.work&quot;</span>&#125;;<br></code></pre></td></tr></table></figure>

<div style="background:black;color:white;font-family:consolas;">
    http://www.mingsrc.work<br>
    http://fole-del.github.io<br>
    http://fole-del.gitee.io<br>
</div>
# 🐢set容器成员方法

<div align="center">下表C++ set 容器常用成员方法</div>

<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 set 容器中存有元素的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 set 容器中插入元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 set 容器中存储的元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(val)</td>
<td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody></table>
<h1 id="🐢set的操作"><a href="#🐢set的操作" class="headerlink" title="🐢set的操作"></a>🐢set的操作</h1><h2 id="set的插入"><a href="#set的插入" class="headerlink" title="set的插入"></a>set的插入</h2><p>set.insert(elem);   //在容器中插入元素。</p>
<h2 id="Set集合的元素排序"><a href="#Set集合的元素排序" class="headerlink" title="Set集合的元素排序"></a>Set集合的元素排序</h2><p>set&lt;int,less<int> &gt;  setIntA;  //该容器是按升序方式排列元素。</int></p>
<p>set&lt;int,greater<int>&gt; setIntB;  //该容器是按降序方式排列元素。</int></p>
<p>set<int> 相当于 set&lt;int,less<int>&gt;。</int></int></p>
<p>less<int>与greater<int>中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。</int></int></p>
<p>注意点1： less&lt;&gt;与greate&lt; &gt;是什么？</p>
<p>注意点2：如果set&lt;&gt;不包含int类型，而是包含自定义类型，set容器如何排序？</p>
<p>要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。</p>
<p>下面将讲解什么是functor以及用法。</p>
<p>使用stl提供的函数对象</p>
<p>set&lt;int,greater<int>&gt; setIntB;  </int></p>
<p>setIntB.insert(3);</p>
<p>setIntB.insert(1);</p>
<p>setIntB.insert(5);</p>
<p>setIntB.insert(2);</p>
<p>此时容器setIntB就包含了按顺序的5,3,2,1元素</p>
<h2 id="函数对象functor的用法"><a href="#函数对象functor的用法" class="headerlink" title="函数对象functor的用法"></a>函数对象functor的用法</h2><p>尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。</p>
<p>functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。</p>
<p>greater&lt;&gt;与less&lt;&gt;就是函数对象。</p>
<p>下面举出greater<int>的简易实现原理。 </int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">greater</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; iLeft, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; iRight)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> iLeft &gt; iRight;  <span class="hljs-comment">//如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);</span><br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>容器就是调用函数对象的operator()方法去比较两个值的大小。</p>
<h2 id="仿函数练习"><a href="#仿函数练习" class="headerlink" title="仿函数练习"></a>仿函数练习</h2><p>学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//学生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CStudent</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">CStudent</span>(<span class="hljs-keyword">int</span> iID, string strName)<br>	&#123;<br>		m_iID = iID;<br>		m_strName = strName;<br>	&#125;<br>	<span class="hljs-comment">//private:</span><br>	<span class="hljs-keyword">int</span> m_iID;		<span class="hljs-comment">//学号</span><br>	string m_strName; 	<span class="hljs-comment">//姓名</span><br><br><br>&#125;;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, CStudent&amp; stu) &#123;<br>	os &lt;&lt; stu.m_iID &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : stu.m_strName)<br>		os &lt;&lt; it;<br>	<span class="hljs-keyword">return</span> os;<br>&#125;<br><span class="hljs-comment">//为保持主题鲜明，本类不写拷贝构造函数，本类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。</span><br><span class="hljs-comment">//函数对象</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StuFunctor</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CStudent&amp; stu1, <span class="hljs-keyword">const</span> CStudent&amp; stu2)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> (stu1.m_iID &lt; stu2.m_iID);<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	set&lt;CStudent, StuFunctor&gt; setStu;<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;小张&quot;</span>));<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小李&quot;</span>));<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;小王&quot;</span>));<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;小刘&quot;</span>));<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : setStu)<br>	&#123;<br>		cout &lt;&lt; i &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<div style="background:black;color:white;font-family:consolas">
1 小李<br>
2 小刘<br>
3 小张<br>
5 小王
<div>


<h2 id="set对象的拷贝构造与赋值"><a href="#set对象的拷贝构造与赋值" class="headerlink" title="set对象的拷贝构造与赋值"></a>set对象的拷贝构造与赋值</h2><p>set(const set &amp;st);           //拷贝构造函数</p>
<p>set&amp; operator=(const set &amp;st);    //重载等号操作符</p>
<p>set.swap(st);                //交换两个集合容器</p>
<h2 id="set的大小"><a href="#set的大小" class="headerlink" title="set的大小"></a>set的大小</h2><p>set.size();    //返回容器中元素的数目</p>
<p>set.empty();//判断容器是否为空</p>
<h2 id="set的删除"><a href="#set的删除" class="headerlink" title="set的删除"></a>set的删除</h2><p>set.clear();        //清除所有元素</p>
<p>set.erase(pos);    //删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
<p>set.erase(beg,end);      //删除区间[beg,end)的所有元素    ，返回下一个元素的迭代器。</p>
<p>set.erase(elem);   //删除容器中值为elem的元素。</p>
<h2 id="set的查找"><a href="#set的查找" class="headerlink" title="set的查找"></a>set的查找</h2><p>set.find(elem);  //查找elem元素，返回指向elem元素的迭代器。</p>
<p>set.count(elem);  //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</p>
<p>set.lower_bound(elem);      //返回第一个&gt;=elem元素的迭代器。</p>
<p>set.upper_bound(elem);      //  返回第一个&gt;elem元素的迭代器。</p>
<p>set.equal_range(elem);        //返回一对迭代器，这两个迭代器分别用于发现set中其键大于指定键的第一个元素，以及集中其键等于或大于指定键的第一个元素。</p>
<p>以上函数返回两个迭代器，而这两个迭代器被封装在pair中。</p>
<h1 id="💻程序演示："><a href="#💻程序演示：" class="headerlink" title="💻程序演示："></a>💻程序演示：</h1><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <br>    <span class="hljs-comment">//创建空set容器    </span><br>    std::set&lt;std::string&gt; myBlogSet;    <br>    <span class="hljs-comment">//空set容器不存储任何元素    </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;1、myBlogSet size = &quot;</span> &lt;&lt; myset.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    <br>    <span class="hljs-comment">//向myBlogSet容器中插入新元素    </span><br>    myset.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;http://www.mingsrc.work&quot;</span>);<br>    myset.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;http://fole-del.github.io&quot;</span>);<br>    myset.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;http://fole-del.gitee.io&quot;</span>);    <br>    cout &lt;&lt; <span class="hljs-string">&quot;2、myBlogSet size = &quot;</span> &lt;&lt; myBlogSet.<span class="hljs-built_in">size</span>() &lt;&lt; endl;    <br>    <span class="hljs-comment">//利用双向迭代器，遍历myBlogSet    </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = myBlogSet.<span class="hljs-built_in">begin</span>(); iter != myBlogSet.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>        cout &lt;&lt; *iter &lt;&lt; endl;    <br>    &#125;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序的执行结果为：</p>
<div style="background:black;color:white;font-family:consolas;">
    1、myBlogSet size = 0<br>
    2、myBlogSet size = 3<br>
    http://fole-del.gitee.io<br>
    http://fole-del.github.io<br>
    http://www.mingsrc.work<br>
</div>


</div></div>]]></content>
      <categories>
        <category>C++笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>C++连接oracle</title>
    <url>/posts/da132b8a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Oracle数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举（enum）</title>
    <url>/posts/9e0a28a8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>C++的枚举工具提供了另一种创建符号常量的方式，这种方式可以代替<code>const</code>。还允许定义新类型，但必须按严格的限制执行。使用<code>enum</code>的句法与<code>struct</code>类似。</p>
<p><code>enum color &#123; red, orange, blue, green, red, black&#125;</code></p>
<p>这条语句定义了一个名为<code>color</code>的新类型，它的取值范围为<code>red, orange, blue, green, red, black</code>，称为符号常量，同时将<code>0~5</code>分别对应于<code>red~black</code>。在默认情况下，<code>0</code>对应的是<code>red</code>,<code>5</code>对应的是<code>black</code>,其他以此类推。</p>
<h2 id="声明与使用"><a href="#声明与使用" class="headerlink" title="声明与使用"></a>声明与使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">color cor1; <span class="hljs-comment">//定义了一个类型为color的变量cor1</span><br><span class="hljs-comment">//枚举变量的赋值</span><br>cor1 = red; <span class="hljs-comment">//正常赋值</span><br>cor1 = <span class="hljs-number">20</span>; <span class="hljs-comment">//非法，20不是枚举变量</span><br></code></pre></td></tr></table></figure>

<p>由此可以看出，枚举变量的赋值受到限制，与程序员的定义有关。</p>
<ul>
<li><p>对枚举而言，它的操作符只有赋值运算符<code>=</code>，这就意味着枚举变量不能执行<code>++、--、+、—</code>等<code>等号</code>以外的操作。</p>
</li>
<li><p>枚举量是整形，可被提升为int类型，但int类型不能自动转换为枚举类型</p>
</li>
<li><p>枚举可以进行强制类型转换，但不确定其结果，如<code>cor1 = spectrum(100);</code></p>
</li>
<li><p>如果只打算使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称 <code>enum &#123;red,orange&#125;</code>；</p>
</li>
</ul>
<h2 id="设置枚举的值"><a href="#设置枚举的值" class="headerlink" title="设置枚举的值"></a>设置枚举的值</h2><p>可以使用赋值运算符显式地来设置枚举量的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">bits</span> &#123;</span>one = <span class="hljs-number">1</span>, two = <span class="hljs-number">2</span>, three = <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>但是，指定的值必须是整数。也可以只显式的设置其中一部分的值，默认情况下，枚举的 第一个常量始终是从<code>0</code>开始的，这一点需要注意。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">digits</span> &#123;</span>zero, one = <span class="hljs-number">0</span>, two, three = <span class="hljs-number">1</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里，<code>zero</code>和<code>one</code>的枚举量都为<code>0</code>,<code>two</code>和<code>three</code>都是<code>1</code>。</p>
<p>除了可以将<code>int</code>类型的值赋值给枚举量，还可以使用<code>long</code>和<code>long long</code>类型的值。</p>
<h2 id="枚举的取值范围"><a href="#枚举的取值范围" class="headerlink" title="枚举的取值范围"></a>枚举的取值范围</h2><p>现在有指定了枚举量的枚举如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">enum</span> <span class="hljs-title">bits</span><span class="hljs-params">(one = <span class="hljs-number">1</span>, two = <span class="hljs-number">2</span>,four = <span class="hljs-number">4</span>,eight = <span class="hljs-number">8</span>&#125;;</span></span><br><span class="hljs-function"><span class="hljs-params">bits myflag;</span></span><br><span class="hljs-function"><span class="hljs-params">myflag = bits(<span class="hljs-number">6</span>);</span></span><br></code></pre></td></tr></table></figure>

<p>问：</p>
<div align="center">
    上述赋值是否合法
    <div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>答案</span></div>
    <div class="hide-content"><p>合法，虽然<code>6</code>不是枚举量，但它位于枚举定义的取值范围内。
    </p>
</div></div></div>




<p>关于取值范围的定义（参考C++ primer 第六版）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">enum</span> <span class="hljs-title">bigstep</span><span class="hljs-params">(firat,second = <span class="hljs-number">100</span>, third&#125;;</span></span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的2的幂，将它减去1，得到的便是取值范围的上限。例如，定义的bigstep的最大值枚举值是101。在2的幂中，比这个数大的最小值为128，因此取值范围的上限为127。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围的下限为0∶否则，采用与寻找上限方式相同的方式，但加上负号。</p>
<hr>
<p>例如，如果最小的枚举量为-6，而比它小的、最大的2的幂是-8（加上负号），因此下限为-7。选择用多少空间来存储枚举由编译器决定。对于取值范围较小的枚举，使用一个字节或更少的空间∶而对于包含 long类型值的枚举，则使用4个字节。</p>
</blockquote>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">myFlag</span> &#123;</span><br>	one,<br>	two = <span class="hljs-number">0</span>,<br>	three,<br>	four = <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; three &lt;&lt; endl;<br>	myFlag flag = <span class="hljs-built_in">myFlag</span>(<span class="hljs-number">0</span>);<br>	cout &lt;&lt; flag &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<div style="background:black;color:white">1<br>0<br></div>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">color</span> &#123;</span> red=<span class="hljs-number">1</span>, green, blue &#125;;<br> <br>    <span class="hljs-class"><span class="hljs-keyword">enum</span>  <span class="hljs-title">color</span> <span class="hljs-title">favorite_color</span>;</span><br> <br>    <span class="hljs-comment">/* 用户输入数字来选择颜色 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%u&quot;</span>, &amp;favorite_color);<br> <br>    <span class="hljs-comment">/* 输出结果 */</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (favorite_color)<br>    &#123;<br>    <span class="hljs-keyword">case</span> red:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是红色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> green:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是绿色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> blue:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你喜欢的颜色是蓝色&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;你没有选择你喜欢的颜色&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<div style="background:black;color:white">请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1
<br>你喜欢的颜色是红色</div>]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
        <category>第四章、数据类型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>enum</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/posts/undefined.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的前序遍历</a></p>
<p><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">平衡二叉树</a></p>
<span id="more"></span>





<h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">44. 二叉树的前序遍历</a></p>
<p>给定一个二叉树，返回它的 前序 遍历。</p>
<p> 示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>输入: [1,null,2,3]  <br>   1<br>    \<br>     2<br>    &#x2F;<br>   3 <br><br>输出: [1,2,3]<br></code></pre></td></tr></table></figure>
<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preoreder</span><span class="hljs-params">(TreeNode *root,vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;res)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">preoreder</span>(root-&gt;left,res);<br>        <span class="hljs-built_in">preoreder</span>(root-&gt;right,res);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-built_in">preoreder</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(root-&gt;left),<span class="hljs-built_in">height</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">height</span>(root-&gt;left)-<span class="hljs-built_in">height</span>(root-&gt;right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right);  <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯</title>
    <url>/posts/undefined.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="副本文件"><a href="#副本文件" class="headerlink" title="副本文件"></a>副本文件</h1><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p><a href="#1">17. 电话号码的字母组合</a></p>
<p><a href="#2">22. 括号生成</a></p>
<span id="more"></span>



<h1 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合<i id="1"></i></h1><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：&quot;23&quot;<br>输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].<br></code></pre></td></tr></table></figure>
<p>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br><br>    map&lt;<span class="hljs-keyword">char</span>, string&gt; M = &#123;<br>	            &#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,<br>	&#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,<br>	&#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;<br>    &#125;;   <br>    vector&lt;string&gt; ans;<br>    string current;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index ,string digits)</span> </span><br><span class="hljs-function">    </span>&#123;<br>	    <span class="hljs-keyword">if</span> (index == digits.<span class="hljs-built_in">size</span>())<br>	    &#123;<br>		    ans.<span class="hljs-built_in">push_back</span>(current);<br>		    <span class="hljs-keyword">return</span>;<br>	    &#125;<br>	    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; M[digits[index]].<span class="hljs-built_in">size</span>();i++)<br>	    &#123;<br>		    current.<span class="hljs-built_in">push_back</span>(M[digits[index]][i]);<br>		    <span class="hljs-built_in">DFS</span>(index + <span class="hljs-number">1</span>, digits);<br>		    current.<span class="hljs-built_in">pop_back</span>();<br>	    &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span></span><br><span class="hljs-function">    </span>&#123;<br>	    <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>		    <span class="hljs-keyword">return</span> ans;<br>	    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">0</span>, digits);<br>	    <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="括号生产"><a href="#括号生产" class="headerlink" title="括号生产"></a>括号生产<i id="2"></i></h2><h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h4><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：n = 1<br>输出：[“()”]</p>
</blockquote>
<p>提示：1 &lt;= n &lt;= 8</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// dfs生成</span><br><span class="hljs-comment">/*理解为二叉树的每个节点括号交替*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">void dfs(int n, string str, vector&lt;string&gt;&amp; res) &#123;</span><br><span class="hljs-comment">	if (str.length() == 2 * n)</span><br><span class="hljs-comment">	&#123;</span><br><span class="hljs-comment">		res.push_back(str);</span><br><span class="hljs-comment">		return;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">	dfs(n, str + &#x27;(&#x27;, res);</span><br><span class="hljs-comment">	dfs(n, str + &#x27;)&#x27;, res);</span><br><span class="hljs-comment">&#125;*/</span><br><br><span class="hljs-comment">// 括号生成、剪枝策略</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, string str, vector&lt;string&gt;&amp; res, <span class="hljs-keyword">int</span> open, <span class="hljs-keyword">int</span> close)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (open &gt; n || close &gt; open) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">length</span>() == <span class="hljs-number">2</span> * n)<br>	&#123;<br>		res.<span class="hljs-built_in">push_back</span>(str);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(n, str + <span class="hljs-string">&#x27;(&#x27;</span>, res,open + <span class="hljs-number">1</span>, close);<br>	<span class="hljs-built_in">dfs</span>(n, str + <span class="hljs-string">&#x27;)&#x27;</span>, res,open,close + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 括号生成</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;string&gt; res;<br>	<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>	<span class="hljs-built_in">dfs</span>(n, <span class="hljs-string">&quot;&quot;</span>, res,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;string&gt; ans = <span class="hljs-built_in">generateParenthesis</span>(<span class="hljs-number">2</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : ans)<br>	&#123;<br>		cout &lt;&lt; i &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>C++“内联函数”</title>
    <url>/posts/fb55278d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考文章：<a href="https://www.cnblogs.com/P3nguin/p/7977860.html">[c++] 用宏定义一个函数 - 推杯问盏 - 博客园</a></p>
</blockquote>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>对于一个频繁使用的短小函数，在C语言中应该用<code>宏定义</code>实现，在C++中用<code>inline</code>实现。宏定义与内联函数的不同用法000。</p>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>在c语言中，写一手漂亮的宏定义是非常有必要的，方式出错；提高代码的移植性和可读性等。尤其是一些常用或通用的功能函数或者代码段，这些功能既可以写成函数，也可以封装为宏定义。就功能性上来讲，用宏定义自然有函数无法比拟的优势所在。</p>
<p>*<em>要点：变量都用括号括起来，防止出错，结尾不需要;。在实际编程中，不推荐把复杂的函数使用宏，不容易调试。多行用\*</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max(a,b) ((a)&gt;(b)？(a):(b)) <span class="hljs-comment">//一个简单的大小比较的宏定义函数</span></span><br></code></pre></td></tr></table></figure>

<p>但是如果用函数实现的话，你可能得先声明，并且定义，尤其是对变量类型的局限性上：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> b)</span></span>; <span class="hljs-comment">//声明</span><br><span class="hljs-comment">//定义</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b?a:b;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>比较明显，宏定义简单又方便；同时，<mark>函数地调用会带来额外的开销，他需要开辟一片栈空间，记录返回地址，函数返回还要释放</mark>。这种开销很明显地会降低代码效率，而且代码量也会大大增加，而使用宏定义则在代码规模和速度方面都有优势。其次就是变量类型上，在C++中因为有模板还可以实现多类型变量的比较，但是在上述代码中仅仅支持int类型的变量进行比较。但宏定义就有所不同，可以用于整形、长整型、单浮点型、双浮点型以及其他一些可以用<code>&gt;</code>操作符进行比较的变量类型，就是说，宏定义是不需要考虑类型的。</p>
<p>在具体使用中，较多场合会因为使用宏定义重命名函数名以及定义一些变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MALLOC(n, type) \</span><br>((type *) <span class="hljs-built_in">malloc</span>((n)* <span class="hljs-keyword">sizeof</span>(type))<br></code></pre></td></tr></table></figure>

<p>利用这个宏，我们就可以简单的为任何类型分配一段我们指定的空间大小，并返回指向这段空间的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">int</span> *ptr;<br>ptr = MALLOC( <span class="hljs-number">5</span>, <span class="hljs-keyword">int</span> );<span class="hljs-comment">//申请5int大小的空间</span><br></code></pre></td></tr></table></figure>

<p>关于宏定义还会有一些小问题，可能也会导致你使用上的错误，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SQUARE_SUM(x,y) x*x+y*y</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>,j = <span class="hljs-number">2</span>,k ;<br>    k = SQUARE_SUM(i+<span class="hljs-number">1</span>,j);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,k);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码真实的调用是<code>1+1*1+1+2*2=7</code>，这一点需要注意，所以如果有需要的话，建议给变量小括号带上。</p>
<h2 id="宏定义小结"><a href="#宏定义小结" class="headerlink" title="宏定义小结"></a>宏定义小结</h2><table>
<thead>
<tr>
<th>属性</th>
<th>#define宏</th>
<th>函数</th>
</tr>
</thead>
<tbody><tr>
<td>代码长度</td>
<td>每次使用时，宏代码都被插入到程序中。除了非常小的宏之外，程序的长度将大幅度增长。</td>
<td>函数代码只出现于一个地方：每次使用这个函数时，都调用那个地方的同一份代码</td>
</tr>
<tr>
<td>执行速度</td>
<td>更快</td>
<td>存在函数调用、返回的额外开销</td>
</tr>
<tr>
<td>操作符优先级</td>
<td>宏参数的求值是在所有周围表达式的上下文环境里，除非它们加上括号，否则邻近操作符的优先级可能产生不可预料的结果。</td>
<td>函数参数只在函数调用时求值一次，它的结果值传递给函数。表达式的求值结果更容易预测。</td>
</tr>
<tr>
<td>参数求值</td>
<td>参数用于宏定义时，每次都将重新求值，由于多次求值，具有副作用的参数可能会产生不可预测的结果。</td>
<td>参数在函数调用前只求值一次，在函数中多次使用参数并不会导致多次求值过程，参数的副作用并不会造成任何特殊问题。</td>
</tr>
<tr>
<td>参数类型</td>
<td>宏与类型无关，只要参数的操作是合法的，它可以用于任何参数类型。</td>
<td>函数的参数是与类型有关系的，如果参数的类型不同，就需要使用不同的函数，即使它们执行的任务是相同的。</td>
</tr>
</tbody></table>
<hr>
<h1 id="inline函数"><a href="#inline函数" class="headerlink" title="inline函数"></a><code>inline</code>函数</h1><p>在系统下，栈空间是有限的，加入频繁大量的使用就会造成因栈空间不足所造成的程序出错的问题，内联函数的引入也是为了解决一些频繁调用的小函数大量消耗栈空间的问题。</p>
<p>看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-comment">//函数定义为inline即:内联函数  </span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">dbtest</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;奇&quot;</span> : <span class="hljs-string">&quot;偶&quot;</span>;  <br>&#125;   <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>   <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  <br>   <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;  <br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i:%d    奇偶性:%s /n&quot;</span>, i, <span class="hljs-built_in">dbtest</span>(i));      <br>   &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>

<p>在这种情况时当在下表调用函数时，会变成<code>(i%2&gt;0)?&quot;奇&quot;:&quot;偶&quot;</code>；避免了函数的重复调用对栈内存重复开辟所带来的消耗；当然，inline函数不是在任何条件下都可以使用的，只有函数本身没有调用本身并且函数不是复杂函数（<strong>当函数中存在while循环或swich语句时为复杂函数</strong>，但是不是复杂函数还要看编译器对它的判断）时，才可以使用；</p>
<hr>
<p><strong>注意点：</strong><div class="note purple no-icon simple"><p>inline函数仅仅是一个建议,对编译器的建议,所以最后能否真正内联,看编译器的意思,它如果认为函数不复杂,能在调用点展开,就会真正内联,并不是说声明了内联就会内联,声明内联只是一个建议而已。</p>
<p>其次,因为内联函数要在调用点展开,所以编译器必须随处可见内联函数的定义,要不然,就成了非内联函数的调用了.所以,这要求每个调用了内联函数的文件都出现了该内联函数的定义。因此,<strong>将内联函数放在头文件里实现是合适的</strong>,省却你为每个文件实现一次的麻烦.而所以声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为,即是说,如果不是每个文件里的定义都一样,那么,编译器展开的是哪一个,那要看具体的编译器而定.所以,最好将内联函数定义放在头文件中.<br>而类中的成员函数缺省都是内联的,如果在类定义时就在类内给出函数,那当然最好;如果在类中未给出成员函数定义,而又想内联该函数的话,那在类外要加上inline,否则就认为不是内联的.<br>为了方便,将内联函数直接声明时就定义,放在头文件中.这样其它文件包含了该头文件,就在每个文件都出现了内联函数的定义.就可以内联了.</p>
</div></p>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内联函数</tag>
      </tags>
  </entry>
  <entry>
    <title>共用体（union）</title>
    <url>/posts/c63335c7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也</p>
<p>就是说，结构可以同时存储int、long 和double，共用体只能存储 int、long或double。共用体的句法与结</p>
<p>构相似，但含义不同。例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">one4all</span> &#123;</span><br>	<span class="hljs-keyword">int</span> int_val;<br>	<span class="hljs-keyword">long</span> long_val;<br>	<span class="hljs-keyword">double</span> double_val;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//创建一个共用体</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">one4all</span> &#123;</span><br>	<span class="hljs-keyword">int</span> int_val;<br>	<span class="hljs-keyword">long</span> long_val;<br>	<span class="hljs-keyword">double</span> double_val;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//在同一时间只能之勇union中变量的一种</span><br>	one4all temp;<br>	temp.int_val = <span class="hljs-number">10</span>;<br>	cout &lt;&lt; temp.int_val &lt;&lt; endl;<br>	temp.double_val = <span class="hljs-number">3.1415926</span>;<br>	cout &lt;&lt; temp.double_val &lt;&lt; endl;<br>	cout &lt;&lt; &amp;temp.double_val &lt;&lt; endl;<br>	cout &lt;&lt; &amp;temp.long_val &lt;&lt; endl;<br>	cout &lt;&lt; &amp;temp.int_val &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img@3f4a1f1680269224b3728e4869cbc54b33109707/2020/10/24/662aa3b91116d089c4d3e669dd8ab6f4.png"></p>
<p>为什么每次只能使用一个，直接打印地址可以发现，<code>union</code>中变量共同使用一个地址，所以每次也只能存储一种类型的值。那么，共用体在什么时候才会用到呢？</p>
<hr>
<p>《C++ primer 第六版》中给的定义是：</p>
<div class="note red no-icon flat"><p>共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。</p>
</div>

<h1 id="匿名共用体-anonymous-union"><a href="#匿名共用体-anonymous-union" class="headerlink" title="匿名共用体 (anonymous union)"></a>匿名共用体 (anonymous union)</h1><p>没有名称的共同体，启程苑将成为位于相同地址处的变量。每次只有一个成员是当前的成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> &#123;</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">bool</span> gender;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-keyword">long</span> id_num;<br>        <span class="hljs-keyword">char</span> id_char[<span class="hljs-number">20</span>];<br>    &#125;;<br>&#125;;<br><br>worker programmer;<br><span class="hljs-keyword">if</span>(programmer.gender == <span class="hljs-number">1</span>)<br>    cout &lt;&lt; programmer.id_num;<br><span class="hljs-keyword">else</span><br>    cout &lt;&lt; programmer.id_char;<br></code></pre></td></tr></table></figure>

<p><code>id_num</code>和<code>id_char[20]</code>使用的还是同一个地址。使用中只需确定当前是哪个成员活动就行。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>共用体常用语节省内存。尤其是嵌入式系统编程，对内存要求较为严格。另外，共用体常用于操作系统数据结构或硬件数据结构。</p>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
        <category>第四章、数据类型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>union</tag>
      </tags>
  </entry>
  <entry>
    <title>C++“多态”</title>
    <url>/posts/fc3d8b80.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本篇是自己阅读加上自己对“多态”的理解，若有不足之处，感谢指出~</p>
</blockquote>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态最常见的用法就是<mark style="background:pink">声明基类类型的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法</mark>。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是固定的，因此将始终调用到同一个函数，这就无法实现“一个接口，多种方法”的目的了。</p>
<div class="note pink icon simple"><i class="note-icon fa fa-3x fa-wheelchair-alt faa-horizontal animated"></i><p>在C++ Primer有关于OOP编程的描述是这样的。</p>
<p>OOP不仅仅是将数据和方法合并为类定义；还有助于创建可重用的代码，这将减少大量的工作（继承、类的复用）。</p>
<ul>
<li><strong>封装</strong>（信息隐藏）可以保护数据，使其免遭不适当的访问（使得代码模块化）；</li>
<li><strong>多态</strong>让您能够为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义；<ul>
<li>编译时多态：通过重载函数实现</li>
<li>运行时多态性：通过虚函数实现</li>
</ul>
</li>
<li><strong>继承</strong>让您能够使用旧类派生出新类(扩展已存在的代码)。</li>
</ul>
<p>这些都是面向对象（OOP)所指的特性。还包括：</p>
<ul>
<li><strong>抽象</strong></li>
<li><strong>代码的可重用性</strong></li>
</ul>
</div>

<p>在C++面试中很有可能会问你C++的三个特性：<strong>封装、继承、多态</strong>。</p>
<p>有关于这三点特性，从设计模式中会受益许多，一个好的建议就是去学习设计模式。推荐《Easy搞定设计模式》这本PDF，网上可以搜到。</p>
<hr>
<p>关于多态，<mark style="background:pink;border:2px solid">C++ primer</mark>给的定义包括多个方面：</p>
<ol>
<li>函数重载</li>
</ol>
<p>函数多态是C++在C语言的基础上新增的功能，默认参数让您能够使用不同数目的参数调用同一个函数，而函数多态（函数重载）让您能够使用多个同名的函数。术语“多态”指的是拥有多种形式，因此函数多态允许函数可以有多种形式。类似地，术语“函数重载”指的是可以有多个同名的含糊，因此对名称进行了重载。</p>
<ol start="2">
<li>类继承：有些继承关系是多态的，这意味着相同的方法名称可能导致依赖于对象类型的行为。（如下代码所示）</li>
<li>运算符重载</li>
</ol>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;一种水果&quot;</span> &lt;&lt; endl;;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;水果的颜色&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	还可以声明其他的类和添加您所需要的方法以满足业务需求</span><br><span class="hljs-comment">	您可以尝试创建一个Pear类来更加了解多态行为，更多的可以去了解纯虚函数、抽象等</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> :</span> <span class="hljs-keyword">public</span> Fruit &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;我是苹果&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;红色苹果&quot;</span> &lt;&lt; endl;;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//声明父类和子类的对象</span><br>	Fruit fruit;<br>	Apple apple;<br>	<span class="hljs-comment">//声明一个指向父类的父类指针</span><br>	Fruit *anotherFruit = &amp;fruit;<br>	anotherFruit-&gt;<span class="hljs-built_in">getName</span>();<br>	anotherFruit-&gt;<span class="hljs-built_in">getColor</span>();<br>	<span class="hljs-comment">//令父类指针指向子类对象</span><br>	anotherFruit = &amp;apple;<br>	anotherFruit-&gt;<span class="hljs-built_in">getName</span>(); <span class="hljs-comment">//由于fetName()是虚函数，因此调用时指向虚函数表中该函数所在的位置</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	有virtual才能发生多态现象，没有virtual就按类型调用。</span><br><span class="hljs-comment">    	而getColor()不是虚函数，因此调用基类的getColor()</span><br><span class="hljs-comment">    */</span><br>	anotherFruit-&gt;<span class="hljs-built_in">getColor</span>(); <br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img@efbea9b01d4d12b1df5b28ef74f1572047f4e5b2/2020/10/24/2c3d166689bbe5bffacd45bd9c5854e6.png"></p>
<h1 id="再谈“接口”"><a href="#再谈“接口”" class="headerlink" title="再谈“接口”"></a>再谈“接口”</h1><p>不同对象调用使用相同方法实现不同操作，也即，方法完成的行为取决于调用该方法的对象。说着有点拗口，我自己理解就是类层面的“重载”。怎么去理解？代码！还是刚才的两个类，额外添加一个Pear类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//先修改基类，使其变为抽象类</span><br><span class="hljs-comment">// 1. 抽象类不用定义，只需声明即可</span><br><span class="hljs-comment">// 2. 抽象类方法前必须有virtual声明</span><br><span class="hljs-comment">// 3. 抽象类不能实例化对象，但是可以创建对象指针</span><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">	定义一个水果类抽象基类。用于定操作和规定函数，提供方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>但凡是纯虚函数，子类继承必须全部重定义！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 定义苹果类和犁类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> :</span> <span class="hljs-keyword">public</span> Fruit &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;我是苹果&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;红色苹果&quot;</span> &lt;&lt; endl;;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pear</span> :</span> <span class="hljs-keyword">public</span> Fruit &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;我是犁&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;黄犁&quot;</span> &lt;&lt; endl;;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>创建指针对象指向不同的子类，实现不同的操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 通过创建基类的指针对象可以实现多台，就不用访问具体的类，只需要根据基类知道其中的操作即可</span><br>    Fruit *apple = <span class="hljs-keyword">new</span> Apple;<br>	Fruit *pear = <span class="hljs-keyword">new</span> Pear;<br>	apple-&gt;<span class="hljs-built_in">getName</span>();<br>	apple-&gt;<span class="hljs-built_in">getColor</span>();<br>	pear-&gt;<span class="hljs-built_in">getName</span>();<br>	pear-&gt;<span class="hljs-built_in">getColor</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img@f3cb5d2dc32212f0cc788c6f2ba6b1a1057c762a/2020/10/24/ad7856d16df0440bb96974c1e1954d0e.png"></p>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试经典题目</title>
    <url>/posts/19326953.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>直接上一些问题，做一下就知道自己可不可以了！</p>
<h1 id="1-如何判断一段程序是C还是C-编译程序编译"><a href="#1-如何判断一段程序是C还是C-编译程序编译" class="headerlink" title="1 如何判断一段程序是C还是C++编译程序编译"></a>1 如何判断一段程序是C还是C++编译程序编译</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus <span class="hljs-comment">//双下划线</span></span><br>	cout &lt;&lt; <span class="hljs-string">&quot;C++&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> </span><br>	cout &lt;&lt; <span class="hljs-string">&quot;C&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
</div></div>

<h1 id="2-C-值传递方式有哪几种？"><a href="#2-C-值传递方式有哪几种？" class="headerlink" title="2 C++值传递方式有哪几种？"></a>2 C++值传递方式有哪几种？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><ul>
<li>指针传递</li>
<li>引用专递</li>
<li>值传递</li>
</ul>
<p>在C语言中都可以认为是值传递。在C++中多了引用传递（1.在函数内部可以修改值；2.节省内存）。</p>
<p>为了提高效率，可以在函数传参时选择使用<code>const refrence</code>的方式节省对象拷贝创造副本造成的内存浪费</p>
</div></div>

<h1 id="3-静态全局变量的作用域"><a href="#3-静态全局变量的作用域" class="headerlink" title="3 静态全局变量的作用域"></a>3 静态全局变量的作用域</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>本文件中全局使用</p>
</div></div>

<h1 id="4-虚函数"><a href="#4-虚函数" class="headerlink" title="4 虚函数"></a>4 虚函数</h1><p>问<code>A中fun1()</code>是否为虚函数、<code>B中fun2()</code>是否为虚函数？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">b</span> :</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;fun1()&quot;</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>&#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;fun2()&quot;</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>A中fun1()和B中fun2()均为虚函数；其中如果父类函数为<code>virtual</code>，子类重写时，可省略virtual关键字。无论子类函数是否是<code>virtual</code>，子类与父类同名函数指的是不同函数。</p>
<ul>
<li>父类有virtual时，其子类必定是虚函数</li>
<li>父类无virtual时，就要看其子类函数是否有<code>virtual</code>关键字，有就是虚函数。可以用高中生物遗传想这个问题。</li>
</ul>
</div></div>

<h1 id="5-C和C-中struct有什么区别？"><a href="#5-C和C-中struct有什么区别？" class="headerlink" title="5 C和C++中struct有什么区别？"></a>5 C和C++中struct有什么区别？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><table>
<thead>
<tr>
<th></th>
<th>protection行为</th>
<th>能否定义函数</th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>无</td>
<td>否，但可以有函数指针</td>
</tr>
<tr>
<td>C++</td>
<td>有，默认是public</td>
<td>可以，包括构造函数，析构函数等</td>
</tr>
</tbody></table>
</div></div>

<h1 id="6-int-id-sizeof-unsigned-long-这种写法是否正确-为什么？"><a href="#6-int-id-sizeof-unsigned-long-这种写法是否正确-为什么？" class="headerlink" title="6 int id[sizeof(unsigned long)];这种写法是否正确?为什么？"></a>6 <code>int id[sizeof(unsigned long)];</code>这种写法是否正确?为什么？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>正确。sizeof()是编译时运算符，编译时就确定了，可以认为其实和机器有关的常量。所以<code>sizeof(long)=4;</code>，这句话相当于定义了一个大小为4的数组id；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">&quot;sizeof(long):&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">long</span>) &lt;&lt; endl;<br><span class="hljs-keyword">int</span> id[<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">long</span>)];<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(id)&quot;</span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(id) &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210114201055.png" alt="面试经典1"></p>
</div></div>

<h1 id="7-变量的指针的含义是指变量的"><a href="#7-变量的指针的含义是指变量的" class="headerlink" title="7 变量的指针的含义是指变量的?"></a>7 变量的指针的含义是指变量的<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: pink;color: white">参考答案点击查看
  </button><span class="hide-content">B.地址</span></span>?</h1><div align="center" style="font-size:30px;">A. 值&nbsp;&nbsp;&nbsp;&nbsp;B.地址&nbsp;&nbsp;&nbsp;&nbsp;    C.存储    &nbsp;&nbsp;&nbsp;&nbsp;D.名字</div>

<h1 id="8-重载（overload）、重定义（redefintion）、重写（override）的区别？"><a href="#8-重载（overload）、重定义（redefintion）、重写（override）的区别？" class="headerlink" title="8 重载（overload）、重定义（redefintion）、重写（override）的区别？"></a>8 重载（overload）、重定义（redefintion）、重写（override）的区别？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><table>
<thead>
<tr>
<th>名称</th>
<th>名字空间</th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td>重载</td>
<td>同一名字空间</td>
<td>是指允许存在多个同名函数，而这些函数的参数表不同。</td>
</tr>
<tr>
<td>重定义/隐藏</td>
<td>不同名字空间</td>
<td>用于继承，派生类与基类的函数同名，屏蔽基类的函数</td>
</tr>
<tr>
<td>重写/覆盖</td>
<td>不同名字空间</td>
<td>用于继承，子类重新定义父类<mark style="border-top:solid 2px black;border-right:solid 3px black;margin:1px;background:RGB(156,212,124);border-radius:10px;padding:2px 4px;color:white">虚函数</mark>的方法</td>
</tr>
</tbody></table>
</div></div>

<h1 id="9-多态的作用"><a href="#9-多态的作用" class="headerlink" title="9 多态的作用"></a>9 多态的作用</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><ol>
<li>隐藏实现细节，是的代码能够模块化；扩展代码模块，实现代码复用</li>
<li>接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。</li>
</ol>
</div></div>

<h1 id="10-多态中虚函数表什么时候建立"><a href="#10-多态中虚函数表什么时候建立" class="headerlink" title="10 多态中虚函数表什么时候建立"></a>10 多态中虚函数表什么时候建立</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>虚函数表是在<strong>编译期</strong>就建立了。各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组，而对象的隐藏成员——虚拟函数表指针是在运行期——也就是构造函数被调用时进行初始化的，这是实现多态的关键。</p>
</div></div>

<h1 id="11-面向对象的三个基本特征，并简单叙述"><a href="#11-面向对象的三个基本特征，并简单叙述" class="headerlink" title="11 面向对象的三个基本特征，并简单叙述"></a>11 面向对象的三个基本特征，并简单叙述</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><ol>
<li>封装：将客观事物抽象成类，每个类对自身的数据和方法事项protection（private，protected，public）</li>
<li>继承：广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后带子类实现）。前两种（累继承）和后一种（对象组合=&gt;接口继承以及纯虚函数）构成了功能复用的两种方式。</li>
<li>多态：是将父对象设置成为和一个或更多的与他的子对象相等的技术。赋值之后，父对象的就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单讲就是：允许将子类类型的指针赋值给父类类型的指针。</li>
</ol>
</div></div>

<h1 id="12-内联函数是否做类型检查"><a href="#12-内联函数是否做类型检查" class="headerlink" title="12 内联函数是否做类型检查"></a>12 内联函数是否做类型检查</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>内联函数要做参数类型检查，这是内联函数跟宏相比的优势。</p>
</div></div>

<h1 id="13-内存分配的方式有几种"><a href="#13-内存分配的方式有几种" class="headerlink" title="13 内存分配的方式有几种"></a>13 内存分配的方式有几种</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><ol>
<li>静态存储区域。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。</li>
<li>在栈上创建。在执行函数是，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>从堆上分配，亦称动态内存分配。程序在运行的时候用<code>malloc</code>或<code>new</code>申请任意大小的内存，程序员自己负责何时使用<code>free</code>和<code>delete</code>释放内存。动态内存的生存期由我们决定，使用比较灵活，但问题也最多。很容易造成内存泄露、越界等问题</li>
</ol>
</div></div>

<h1 id="14-频繁使用的短小函数，在C语言中应用什么实现，在c-中应用什么实现？"><a href="#14-频繁使用的短小函数，在C语言中应用什么实现，在c-中应用什么实现？" class="headerlink" title="14 频繁使用的短小函数，在C语言中应用什么实现，在c++中应用什么实现？"></a>14 频繁使用的短小函数，在C语言中应用什么实现，在c++中应用什么实现？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>C用宏定义，C++用inline</p>
</div></div>

<h1 id="15-全局变量和局部变量的区别"><a href="#15-全局变量和局部变量的区别" class="headerlink" title="15 全局变量和局部变量的区别"></a>15 全局变量和局部变量的区别</h1><p>全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？</p>
<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>生命周期不同：全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；内存中分配在全局数据区。</p>
<p>使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。操作系统和编译器通过内存分配的位置来知道的，全局变量变量分配在全局数据段并且在程序开始运行的时候被夹在。局部变量则分配在堆栈里边。</p>
</div></div>

<h1 id="16-如何判断一个操作系统是16为还是32位？"><a href="#16-如何判断一个操作系统是16为还是32位？" class="headerlink" title="16 如何判断一个操作系统是16为还是32位？"></a>16 如何判断一个操作系统是16为还是32位？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>定义一个指针p。打印出sizeof(p)，如果节后是4，则表示该操作系统是32位；打印结果是2，则表示是16位。</p>
</div></div>

<h1 id="17-上题在不能使用sizeof-情况下如何判断？"><a href="#17-上题在不能使用sizeof-情况下如何判断？" class="headerlink" title="17 上题在不能使用sizeof()情况下如何判断？"></a>17 上题在不能使用sizeof()情况下如何判断？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>超过32位时，这种方法不管用，最好的办法还是使用<code>sizeof()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a = ~<span class="hljs-number">0</span>; <span class="hljs-comment">// 最好是 unsigned int</span><br><span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">65536</span>)<br>    cout &lt;&lt; <span class="hljs-string">&quot;32 bit&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <br>    cout &lt;&lt; <span class="hljs-string">&quot;16 bit&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
</div></div>

<h1 id="18-如何处理内存耗尽"><a href="#18-如何处理内存耗尽" class="headerlink" title="18 如何处理内存耗尽"></a>18 如何处理内存耗尽</h1><p>如果再申请动态内存时找不到足够大的内存块，<code>malloc</code>和<code>new</code>⬇️ 将返回NULL指针，宣告内存申请失败。如何处理内存耗尽？</p>
<div align="center" style="background:black;color:white">new如果分配失败了会抛出bad_malloc的异常<br>malloc则会返回NULL</div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>如果返回的NULL，则马上使用人return语句终止本函数。</p>
</div></div>

<h1 id="19-为什么要使用堆空间，使用堆空间的原因？"><a href="#19-为什么要使用堆空间，使用堆空间的原因？" class="headerlink" title="19 为什么要使用堆空间，使用堆空间的原因？"></a>19 为什么要使用堆空间，使用堆空间的原因？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>直到运行时才知道一个对象需要多少内存；不知道对象的生存期到底有多长。</p>
</div></div>

<h1 id="20-析构函数和虚函数的用法和作用"><a href="#20-析构函数和虚函数的用法和作用" class="headerlink" title="20 析构函数和虚函数的用法和作用"></a>20 析构函数和虚函数的用法和作用</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>析构函数是特殊的类成员函数，它没有返回类型，没有参数，不能随意调用，也没有重载，只有在类对象的生命期结束的时候，由系统自动调用。有适放内存空间的作用。虚函数是C++多态的一种表现，使用虚函数，我们可以灵活的进行动态绑定，当然是以一定的开销为代价。</p>
</div></div>

<h1 id="21-错误的转移字符是？"><a href="#21-错误的转移字符是？" class="headerlink" title="21 错误的转移字符是？"></a>21 错误的转移字符是<span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: green;color: white">参考答案<font size="0.5px">点击查看</font>
  </button><span class="hide-content">A.091</span></span>？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><div align="center" style="font-size:30px;">A. ‘\091'&nbsp;&nbsp;&nbsp;&nbsp;B.'\\'&nbsp;&nbsp;&nbsp;&nbsp;    C.'\0'    &nbsp;&nbsp;&nbsp;&nbsp;D.'\''</div>
</div></div>

<h1 id="22-引用和指针有什么区别"><a href="#22-引用和指针有什么区别" class="headerlink" title="22 引用和指针有什么区别"></a>22 引用和指针有什么区别</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><ol>
<li>引用不会开辟新的内存，是对引用变量地址的调用</li>
<li>引用必须被初始化，指针不必</li>
<li>引用初始化以后不能被改变，指针可以改变所指的对象</li>
<li>不存在指向空值的引用，但是存在指向空值的指针</li>
</ol>
</div></div>

<h1 id="23-直接在程序中填写数字或字符串，将会有什么麻烦？"><a href="#23-直接在程序中填写数字或字符串，将会有什么麻烦？" class="headerlink" title="23 直接在程序中填写数字或字符串，将会有什么麻烦？"></a>23 直接在程序中填写数字或字符串，将会有什么麻烦？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><ol>
<li>程序的可读性（可理解性）变差。程序员自己会忘记那些数字或字符串是什么意思，用户则更加不知它们从何处来、表示什么。</li>
<li>在程序的很多地方输入同样的数字或字符串，难保不发生书写错误。</li>
<li>如果要修改数字或字符串，则会在很多地方改动，既麻烦又容易出错。</li>
</ol>
</div></div>

<h1 id="24-重复多次fclose一个打开过一次的FLIE-fp指针会有什么结果，并解释"><a href="#24-重复多次fclose一个打开过一次的FLIE-fp指针会有什么结果，并解释" class="headerlink" title="24 重复多次fclose一个打开过一次的FLIE *fp指针会有什么结果，并解释"></a>24 重复多次fclose一个打开过一次的FLIE *fp指针会有什么结果，并解释</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>导致文件描述符结构中指针指向的内存被<mark style="border-top:solid 2px black;border-right:solid 3px black;margin:1px;background:RGB(156,212,124);border-radius:10px;padding:2px 4px;color:white">重复释放</mark>，进而导致一些不可预期的异常。</p>
</div></div>

<h1 id="25-C-是不是类型安全"><a href="#25-C-是不是类型安全" class="headerlink" title="25 C++是不是类型安全"></a>25 C++是不是类型安全</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>不是，两个不同类型的指针之间可以强制转换（用reinterpret cast）</p>
</div></div>

<h1 id="26-C-中是不是所有的动作都是main-引起的？"><a href="#26-C-中是不是所有的动作都是main-引起的？" class="headerlink" title="26 C++中是不是所有的动作都是main()引起的？"></a>26 C++中是不是所有的动作都是main()引起的？</h1><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"><p>不是。比如全局变量的初始化，就不是由main()函数引起的。举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span>&#125;；<br>    A a;<span class="hljs-comment">// a的构造函数先执行</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure>


</div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>



<div class="note orange icon modern"><i class="note-icon fa fa-battery-quarters"></i><p>当前文章还在编辑当中······</p>
</div>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>参考答案</span></div>
    <div class="hide-content"></div></div>





]]></content>
      <categories>
        <category>面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——栈和队列</title>
    <url>/posts/9b2a43f2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈的定义与运算"><a href="#栈的定义与运算" class="headerlink" title="栈的定义与运算"></a>栈的定义与运算</h2><div class="note green no-icon flat"><ol>
<li><p>栈是只允许在线性表的一段进行插入和删除的线性表。表中值允许插入和删除的一段称为栈顶命令一段称为栈底。</p>
<ol>
<li>由于只能在栈顶进行插入和删除操作，使得后进栈的元素先出栈，先进栈的元素后出栈，所以栈是一种<mark>后进先出</mark>（Last  In First Out，简称LIFO）的数据结构。有关栈的应用都是基于这一特性。</li>
</ol>
</li>
<li><p>栈的操作通常称为入栈或进栈，其删除操作称为出栈或退栈。当栈中五元素是，称为空栈。</p>
</li>
</ol>
<p>有关栈的基本操作主要有以下几种：</p>
<pre><code>1. 栈的初始化操作，即建立一个空栈S
 2. 判空栈操作，弱S为空栈，返回一个真值
 3. 进栈操作，在S栈顶插入一个元素X
 4. 出栈操作，若栈S不空，则取栈顶元素（栈顶元素不删除）。 
</code></pre>
</div>

<p>栈的顺序存储结构（又称为顺序栈）类似于线性表的顺序存储结构。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>双队列实现栈的操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;</span><br>    queue&lt;<span class="hljs-keyword">int</span>&gt; queue1;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; queue2;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        queue2.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">while</span> (!queue1.<span class="hljs-built_in">empty</span>()) &#123;<br>            queue2.<span class="hljs-built_in">push</span>(queue1.<span class="hljs-built_in">front</span>());<br>            queue1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">swap</span> (queue1,queue2);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> r = queue1.<span class="hljs-built_in">front</span>();<br>        queue1.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> r = queue1.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack* obj = new MyStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>









<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p>环形队列（头就是尾，尾就是头）</p>
]]></content>
      <categories>
        <category>程序员内功</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>《Effective C++》中的一些命名习惯</title>
    <url>/posts/ef83a37.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="命名习惯"><a href="#命名习惯" class="headerlink" title="命名习惯"></a>命名习惯</h1><p>在阅读这本开始之际，作者就一些命名习惯（不是命名空间哦）做了详细阐述，以方便我们平时阅读过程以及开发过程中如何命名变量名，甚觉对个人编程上一些基础的东西有极大的帮助，整理如下：</p>
<table>
<thead>
<tr>
<th>用途</th>
<th>含义</th>
<th>变量名</th>
</tr>
</thead>
<tbody><tr>
<td>二元操作符</td>
<td>左手端（left-hand side）</td>
<td>lhs</td>
</tr>
<tr>
<td>二元操作符</td>
<td>右手短（right-hand side）</td>
<td>rhs</td>
</tr>
<tr>
<td>指向一个T型对象</td>
<td>pointer to T</td>
<td>pt</td>
</tr>
<tr>
<td>指向一个Widget的指针</td>
<td>ptr to Wodget</td>
<td>pw</td>
</tr>
<tr>
<td>指向一个airplane的指针</td>
<td>ptr to Airplane</td>
<td>pa</td>
</tr>
<tr>
<td>指向一个GameCharacter的指针</td>
<td>ptr to GameCharacter</td>
<td>pgc</td>
</tr>
</tbody></table>
<p>对于引用（reference），则习惯以<code>r*</code>的形式命名。例如reference to widget，变量名为<code>rw</code>,<code>ra</code>则是reference to Airplane。</p>
<p>而对于成员函数，则可以以<code>mf</code>为名。</p>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象和泛型编程</title>
    <url>/posts/2d1049a4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h1><p><a href="https://zhuanlan.zhihu.com/p/85668787">https://zhuanlan.zhihu.com/p/85668787</a></p>
<ul>
<li>左值：占用了一定内存，且拥有可辨认的地址的对象</li>
<li>右值：左值以外的所有对象</li>
</ul>
<blockquote>
<p> 右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：</p>
<ol>
<li><p>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</p>
</li>
<li><p>能够更简洁明确地定义泛型函数。</p>
</li>
</ol>
</blockquote>
<h2 id="引用（注意左值引用）"><a href="#引用（注意左值引用）" class="headerlink" title="引用（注意左值引用）"></a>引用（注意左值引用）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">int</span> &amp;r = i;<br><span class="hljs-keyword">int</span> &amp;r = <span class="hljs-number">5</span>; <span class="hljs-comment">// 错误，不能左值引用绑定右值</span><br><br><span class="hljs-comment">// const 引用是例外</span><br><span class="hljs-comment">// 可以认为指向一个临时左值的引用，其值为5</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h3><ul>
<li>移动语义</li>
<li>完美转发</li>
</ul>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>移动语意(std::move)，可以将左值转化为右值引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 左值</span><br><span class="hljs-keyword">int</span> &amp;b = a; <span class="hljs-comment">// 左值引用</span><br><br><span class="hljs-comment">// 移动语意: 转换左值为右值引用</span><br><span class="hljs-keyword">int</span> &amp;&amp;c = std::<span class="hljs-built_in">move</span>(a); <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; i)</span> </span>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;lval ref: &quot;</span> &lt;&lt; i &lt;&lt; endl; <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp;&amp; i)</span> </span>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;rval ref: &quot;</span> &lt;&lt; i &lt;&lt; endl; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-comment">// 调用 printInt(int&amp;), i是左值</span><br>  <span class="hljs-built_in">printInt</span>(i);<br>  <br>  <span class="hljs-comment">// 调用 printInt(int&amp;&amp;), 6是右值</span><br>  <span class="hljs-built_in">printInt</span>(<span class="hljs-number">6</span>);<br>  <br>  <span class="hljs-comment">// 调用 printInt(int&amp;&amp;)，移动语意</span><br>  <span class="hljs-built_in">printInt</span>(std::<span class="hljs-built_in">move</span>(i));   <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>完美转发是指</p>
<ul>
<li>只有在需要的时候，才调用复制构造函数</li>
<li>左值被转发为左值，右值被转发为右值</li>
</ul>
<h2 id="右值引用和左值引用的区别"><a href="#右值引用和左值引用的区别" class="headerlink" title="右值引用和左值引用的区别"></a>右值引用和左值引用的区别</h2><ol>
<li><p>左值可以寻址，而右值不可以。</p>
</li>
<li><p>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</p>
</li>
<li><p>左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows壁纸软件推荐</title>
    <url>/posts/db382da4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="爱壁纸UWP"><a href="#爱壁纸UWP" class="headerlink" title="爱壁纸UWP"></a>爱壁纸UWP</h1><p><a href="http://www.microsoftuwp.com/pc/apps/978.html">爱壁纸UWP下载链接</a></p>
<blockquote>
<p> 有影视明星、风光风景、性感美女、花卉植物、体育运动、动物宠物、游戏CG、卡通动漫、机车世界、炫彩美图、品牌欣赏、美食天下、影视剧集、艺术设计、节庆假日、美图杂烩等的壁纸分类内容。</p>
</blockquote>
<h2 id="★WIN10商店娱乐分类第一"><a href="#★WIN10商店娱乐分类第一" class="headerlink" title="★WIN10商店娱乐分类第一"></a>★WIN10商店娱乐分类第一</h2><p> ★ 最高人气必备应用<br> ★ 壁纸类下载排名第一应用<br> ★诺基亚“春 Phone 计划”优秀应用<br> ★ 微软“Live SDK应用大赛”优秀应用<br> 全球首款跨平台服务专业级壁纸应用，提供海量优质壁纸，超乎想象的精彩！</p>
<h2 id="特-点"><a href="#特-点" class="headerlink" title="[特 点]"></a>[特 点]</h2><p> 1.方便便捷，锁屏预览、一键设置锁屏；<br> 2.天气锁屏，精彩锁屏壁纸上天气早知道；<br> 3.自动换景，定时自动更换个性锁屏壁纸；<br> 4.批量下载，收藏后批量下载到本地壁纸；<br> 5.高清壁纸，榜单、精选、专题、每日更新；<br> 6.贴心服务，分类、标签、搜索、预览、收藏；<br> 7.特色功能，颜色筛选、猜你喜欢、壁纸拼图；<br> 8.节省流量，自动缓存图片,更有缓存清理功能，解除存储烦忧。 我们有影视明星、风光风景、性感美女、花卉植物、体育运动、动物宠物、游戏CG、卡通动漫、机车世界、炫彩美图、品牌欣赏、美食天下、影视剧集、艺术设计、节庆假日、美图杂烩等的壁纸分类内容。</p>
<h1 id="附上一些比较好看壁纸"><a href="#附上一些比较好看壁纸" class="headerlink" title="附上一些比较好看壁纸"></a>附上一些比较好看壁纸</h1><div class="justified-gallery"><p><img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gjvw1yzkafj343c2awnph.jpg"><br><img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gjvw1zx0z7j31z4140kjm.jpg"><br><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjvw209hknj34802tcqv5.jpg"><br><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gjvw20n7otj31hc0zdgxz.jpg"><br><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjvw20udytj33kw2oo7ma.jpg"><br><img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gjvw2181omj32gu1dznpd.jpg"></p>
          </div>]]></content>
      <categories>
        <category>Windows系列</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>桌面美化</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown用法</title>
    <url>/posts/2c291b4d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Markdown介绍"><a href="#Markdown介绍" class="headerlink" title="Markdown介绍"></a>Markdown介绍</h1><p><i class="fa fa-quote-left fa-3x fa-pull-left fa-border" aria-hidden="true"></i><code>Markdown</code>是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br> <code>Markdown</code>语法的目标是：成为一种适用于网络的书写语言「易读易写」。并且<code>Markdown</code>兼容HTML。你可以使用HTML语言编写Markdown，如果你要部署你的个人博客，那这更是你必不可少的技能之一！！！</p>
<p><strong>强烈推荐typora这款markdown软件，谁用谁说好！</strong></p>
<p><font color="green" face="华文彩云" size="5px">一款优质的Markdown编辑器,不仅仅是Markdown</font></p>
<p>除此之外，如果你愿意花一点点时间来了解{ post_link }</p>
<hr>
<h1 id="简述Markdown常见用法"><a href="#简述Markdown常见用法" class="headerlink" title="简述Markdown常见用法"></a>简述Markdown常见用法</h1><p>在下面，我将简单介绍几个常用的<code>markdown</code>写法。希望大家写出更好的观看效果的文章。本文一些内容是属于Hexo下buttrerfly主题的内置标签。</p>
<hr>
<p>大家可以自己下载<a href="https://typora.io/">Typora</a>尝试一下<code>markdown</code>。</p>
<iframe src="https://typora.io/" cols="50%,50%" heigth="500px" width="100%" style="width:100%;height:500px;scroll-x:auto;"></iframe>

<div class="note green no-icon flat"><p>为什么推荐<mark>Typora</mark>,我归纳了以下几点：</p>
<p><font style="font-size:20px;font-weight:900;color:green;font-family:'华文彩云'">一</font> “所见即所得”（即时渲染）</p>
<p><font style="font-size:20px;font-weight:900;color:green;font-family:'华文彩云'">二</font> 支持图床功能，配合PicGO可以实现图片的随用随传</p>
<p><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gk9x8gmzdlj30v904ddg1.jpg" alt="Markdown"></p>
<p>如下所示，右击图片就可以上传到PicGo指定的图床。真的很好用！！！<img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gk9x9cn79xj30v705jq3r.jpg" alt="Markdown" width="1123" data-width="1123" data-height="199"></p>
<p><font style="font-size:20px;font-weight:900;color:green;font-family:'华文彩云'">三</font> Typora还支持将<code>md文件</code>导出为多种格式的文件，目前支持以下文件:</p>
<img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gk9x4ku3rqj304u09iq2u.jpg" alt="Markdown" width="174" data-width="174" data-height="342">

<p><font style="font-size:20px;font-weight:900;color:green;font-family:'华文彩云'">四</font> 如果你还会一点CSS,那你甚至可以自定义界面样式</p>
<p><img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gk9xloodttj306i0d1gls.jpg" alt="Markdown"></p>
</div>

<p><big>下面我将从以下这几个方面介绍一下Typora的一些使用方法：</big></p>
<ul>
<li><a href="#%E5%AD%97%E4%BD%93">字体</a>             <code> （&lt;small&gt;小&lt;/small&gt;     &lt;big&gt;大&lt;/big&gt;）</code></li>
<li><a href="#%E6%96%9C%E4%BD%93">斜体</a>                    <code> *斜体*</code></li>
<li><a href="#%E5%8A%A0%E7%B2%97">粗体</a>                   <code> **粗体**</code></li>
<li><a href="#%E6%96%9C%E4%BD%93%E5%8A%A0%E7%B2%97">斜体 + 粗体</a>          <code> ***斜体+粗体\***</code></li>
<li><a href="#%E5%88%A0%E9%99%A4">删除</a>                  <code>~~原价：99.9元~~</code></li>
<li><a href="#%E9%93%BE%E6%8E%A5">链接</a>               <code>[http://www.jianshu.com](https://www.jianshu.com)</code></li>
<li><a href="#%E5%88%86%E5%89%B2%E7%BA%BF">分割线</a></li>
<li><a href="#%E4%B8%8B%E5%88%92%E7%BA%BF">下划线</a></li>
<li><a href="#%E6%A0%87%E9%A2%98">标题</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8">任务列表</a></li>
<li><a href="#%E5%9B%BE%E7%89%87">图片</a></li>
<li><a href="#%E5%8C%BA%E5%9D%97%E5%BC%95%E7%94%A8">区块引用</a></li>
<li><a href="#%E8%A1%8C%E5%86%85%E4%BB%A3%E7%A0%81">行内代码</a>    `markdown`</li>
<li><a href="#%E5%88%97%E8%A1%A8">列表</a></li>
<li><a href="#%E8%A1%A8%E6%A0%BC">表格</a></li>
<li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li>
<li><a href="#%E9%AB%98%E4%BA%AE">高亮</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
</ul>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><div class="tabs" id="字体大小"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#字体大小-1">格式</button></li><li class="tab active"><button type="button" data-href="#字体大小-2">演示</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="字体大小-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span></span>小号字体<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">big</span>&gt;</span></span>大号字体<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">big</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align:center;&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">rgb(25,26,35)</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;华文彩云&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">100px</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align:center&quot;</span>&gt;</span></span>其他快捷方式<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>rgb();<br>#XXXXXX<br>colorname</td>
<td>规定文本的颜色，可以使用<code>style</code>代替</td>
</tr>
<tr>
<td>face</td>
<td>font_family</td>
<td>规定文本的字体</td>
</tr>
<tr>
<td>size</td>
<td>number</td>
<td>规定文本的大小</td>
</tr>
</tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="字体大小-2"><p><small>小号字体</small></p>
<p><big>大号字体</big></p>
<div style="text-align:center;"><font color="rgb(25,26,35)" face="华文彩云" size="100px" style="text-align:center">其他快捷方式</font></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p>西方斜体这一习惯看个人喜好吧。在文字前后各加一个<code>*</code>就👌了</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*斜体*</span><br></code></pre></td></tr></table></figure>

<p> 效果如下：<br><em>斜体</em></p>
<h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p>在文字前后各加两个<code>**</code>就👌了</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**加粗**</span><br></code></pre></td></tr></table></figure>

<p>效果如下：<br> <strong>加粗</strong></p>
<h2 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h2><p>斜体文字前后各加<code>*</code>，加粗文字前后各加<code>**</code>，斜体加粗在文字前后加<code>***</code>。没毛病…</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**<span class="hljs-emphasis">*斜体加粗<span class="hljs-strong">**<span class="hljs-emphasis">*</span></span></span></span><br></code></pre></td></tr></table></figure>

<p>效果如下:<br> <em><strong>斜体加粗</strong></em></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">~~content~~<br></code></pre></td></tr></table></figure>

<p> 效果如下：<br><del>content</del></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接应该是使用最多的场景了。他人有好的文字或者自己摘自哪里、都可以传送门直接过去。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">网站名</span>](<span class="hljs-link">地址</span>)<br>地址<br></code></pre></td></tr></table></figure>

<p> 效果如下：<br><a href="mailto:example@163.com">example@163.com</a><br><a href="http://www.baidu.com/">http://www.baidu.com</a></p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><div class="tabs" id="分割线"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#分割线-1">格式</button></li><li class="tab"><button type="button" data-href="#分割线-2">演示</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="分割线-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">1 <span class="hljs-strong">****</span><br>2 <span class="hljs-strong">****</span><span class="hljs-emphasis">*</span><br><span class="hljs-emphasis">3 ---</span><br><span class="hljs-emphasis">以上三种写法都可以，效果一样，看个人心情使用。</span><br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分割线-2"><hr>
<hr>
<hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span></span>内容<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p><u>内容</u></p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><div class="tabs" id="标题"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#标题-1">格式</button></li><li class="tab"><button type="button" data-href="#标题-2">演示</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="标题-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题</span><br>···<br><span class="hljs-section">###### 六级标题 //最多支持六级标题</span><br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="标题-2"><p><font size="10px" style="font-weight:700">一级标题</font></p>
<p><font size="3px" style="font-weight:600">六级标题</font></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>格式：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet"> -</span> [] 待完成<br><span class="hljs-bullet">-</span> [X] 已完成<br></code></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li><input disabled type="checkbox"> 待完成</li>
<li><input checked disabled type="checkbox"> 已完成</li>
</ul>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>格式为<code>![]()</code></p>
<p>其中图片名称可以为空。直接输入[]就可以。下面我的<code>url</code>输入的直接就文字url。所以肯定是空图片啦。Typora也可以直接把电脑本地的图片拖进来，自动生成图片链接。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">图片名</span>](<span class="hljs-link">URL</span>)<br></code></pre></td></tr></table></figure>

<h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>代码块，使用’`‘和<code>~</code>都可以</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">```</span><br><span class="hljs-code">代码</span><br><span class="hljs-code">```</span><br></code></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs undefined">代码<br></code></pre></td></tr></table></figure>

<h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><p>程序猿引用代码，或者是文章中有一些关键性的名词啊，或者为了突出醒目。效果不错。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">`printf(&quot;test&quot;)`</span><br></code></pre></td></tr></table></figure>

<p>效果如下：<br> <code>printf(&quot;test”);</code></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><div class="tabs" id="列表"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#列表-1">格式</button></li><li class="tab"><button type="button" data-href="#列表-2">演示</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="列表-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 无序项目1<br><span class="hljs-bullet">*</span> 无序项目2<br><span class="hljs-bullet">+</span> 无序项目3<br><span class="hljs-bullet">	-</span> 无序二级1<br><span class="hljs-bullet">	-</span> 无序二级2<br><span class="hljs-bullet">1.</span> 有序标题<br><span class="hljs-bullet">	1.</span> 无序二级标题<br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="列表-2"><ul>
<li>无序项目1</li>
</ul>
<ul>
<li>无序项目2</li>
</ul>
<ul>
<li>无序项目3<ul>
<li>无序二级1</li>
<li>无序二级2</li>
</ul>
</li>
</ul>
<ol>
<li>有序标题<ol>
<li>无序二级标题</li>
</ol>
</li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><kbd>ctrl+t</kbd>更方便</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">| 第一格表头                       | 第二格表头             |<br>| -------------------------------- | ---------------------- |<br>| 内容单元格 第一列第一格          | 内容单元格第二列第一格 |<br>| 内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 |<br></code></pre></td></tr></table></figure>

<p>效果如下:</p>
<table>
<thead>
<tr>
<th>第一格表头</th>
<th>第二格表头</th>
</tr>
</thead>
<tbody><tr>
<td>内容单元格 第一列第一格</td>
<td>内容单元格第二列第一格</td>
</tr>
<tr>
<td>内容单元格 第一列第二格 多加文字</td>
<td>内容单元格第二列第二格</td>
</tr>
</tbody></table>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p><code>H~2~o</code>效果预览–&gt;H<del>2</del>o</p>
<h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mark</span>&gt;</span></span>content<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p><code>&lt;mark&gt;</code>标签支持全局属性，因此可以通过自定义<code>style</code>修改mark的样式。</p>
<div class="tabs" id="高亮"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#高亮-1">全局属性</button></li><li class="tab active"><button type="button" data-href="#高亮-2">代码</button></li><li class="tab"><button type="button" data-href="#高亮-3">演示</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="高亮-1"><p>参考这个↓：</p>
<p><a href="http://codingdict.com/article/1679">HTML参考手册|编程字典</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="高亮-2"><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mark</span>&gt;</span></span>原始样式<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">mark</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font:&#x27;微软雅黑&#x27;;color:red;font-weight:900&quot;</span>&gt;</span></span>CSS样式<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mark</span>&gt;</span></span><br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="高亮-3"><p><mark>原始样式</mark><br><mark style="font:'微软雅黑';color:green;font-weight:900;background:lightgray">CSS样式</mark></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>代码</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">[toc]<br></code></pre></td></tr></table></figure>

<p>在typora输入<code>[toc]</code>即可生成内容目录</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>STL和C++11</title>
    <url>/posts/136ce074.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="STL和C-11"><a href="#STL和C-11" class="headerlink" title="STL和C++11"></a>STL和C++11</h1><blockquote>
<p>参考《C++ primer Plus 第六版》</p>
</blockquote>
<h2 id="1-array容器"><a href="#1-array容器" class="headerlink" title="1 array容器"></a>1 array容器</h2><div class="note red no-icon disable simple"><p>array容易一旦声明，其长度就是固定的，他使用静态（栈）内存，而不是动态分配的内存。提供它旨在替代数组；array受到的显示比vector多，<mark style="color:white;background:red;font-weight:600;border_radius:100px">但效率更高</mark>。</p>
</div>

]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
        <category>附录G 标准模板库方法和函数</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>《Effective C++》</title>
    <url>/posts/b7419768.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="《Effective-C-》"><a href="#《Effective-C-》" class="headerlink" title="《Effective C++》"></a>《Effective C++》</h1><p>我不知道我是否能快速把这本书读完，但我一定尽快，并整理自己的感悟！</p>
<blockquote><p><i class="fa fa-quote-left fa-3x fa-pull-left fa-border" aria-hidden="true"></i>有人说C+ +程序员可以分成两类,读过Effective C+ +的和没读过的。世界顶级C+ +大师Scott Meyers成名之作的第三版的确当得起这样的评价。当您读过这本书之后，就获得了迅速提升自己C++功力的一个契机。</p>
<p>在国际上.本书所引起的反响,波及整个计算技术出版领域,余音至今未绝。几乎在所有C++书籍的推荐名单上,本书都会位于前三名。作者高超的技术把握力、独特的视角、诙谐轻松的写作风格、独具匠心的内容组织，都受到极大的推崇和仿效。这种奇特的现象,只能解释为人们对这本书衷心的赞美和推崇。<br>这本书不是读完一遍就可以束之 高阁的快餐读物，也不是用以解决手边问题的参考手册，而是需要您去反复阅读体会的，C++是真正程序员的语言，背后有着精深的思想与无与伦比的表达能力，这使得它具有类似宗教般的魅力。希望这本书能够帮助您跨越C++的重重险阻，领略高处才有的壮美风光，做-一个成功而快乐的C++程序员。</p>
<footer><strong>——引言</strong></footer></blockquote>

<img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gjvo1t6ln1j30in0p9wln.jpg" alt="译序" width="671" data-width="671" data-height="909">]]></content>
      <categories>
        <category>C++笔记</category>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>控制文件与重做日志文件</title>
    <url>/posts/d6644a62.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="控制文件和重做日志文件"><a href="#控制文件和重做日志文件" class="headerlink" title="控制文件和重做日志文件"></a><strong>控制文件和重做日志文件</strong></h1><p>主要是数字字典 控制文件 和重做日志文件的内容</p>
<h1 id="1-启动SQL-Plus工具："><a href="#1-启动SQL-Plus工具：" class="headerlink" title="1.启动SQL*Plus工具："></a>1.启动SQL*Plus工具：</h1><p>确保iSQL*Plus应用服务器已经启动（一般默认安装都是自动启动），isqlplustcl start<br>为启动iSQLPlus应用服务器的命令；</p>
<h1 id="2-使用SQL-Plus的步骤"><a href="#2-使用SQL-Plus的步骤" class="headerlink" title="2.使用SQL*Plus的步骤"></a>2.使用SQL*Plus的步骤</h1><p> a.在浏览器中输入：http:localhost:5560/isqlplus<br> b.输入用户名密码<br> c.在iSQL<em>Plus的工作区输入SQL语句，就像在SQL</em>Plus中一样</p>
<h1 id="3-Oracle实例的管理"><a href="#3-Oracle实例的管理" class="headerlink" title="3.Oracle实例的管理"></a>3.Oracle实例的管理</h1><p> 3.1 初始化参数文件（Oracle数据库的最重要文件之一）<br>   文件在本机的路径<br>   <code>G:\oracle\product\10.1.0\admin\orcl\pfile</code></p>
<h1 id="4-格式化某字段的长度命令-："><a href="#4-格式化某字段的长度命令-：" class="headerlink" title="4.格式化某字段的长度命令 ："></a>4.格式化某字段的长度命令 ：</h1><p><code>col name for a15;</code></p>
<h1 id="5-数据字典"><a href="#5-数据字典" class="headerlink" title="5.数据字典"></a>5.数据字典</h1><p>  查看表空间信息 <code>dba_tablespaces</code><br>  查看表空间存储位置及文件的名字等信息 <code>dba_data_files</code><br>  查看数据库系统上有多少用户和什么时候创建数据库的 <code>dba_users</code></p>
<h1 id="6-控制文件，重做日志，表空间文件的存储路径："><a href="#6-控制文件，重做日志，表空间文件的存储路径：" class="headerlink" title="6.控制文件，重做日志，表空间文件的存储路径："></a>6.控制文件，重做日志，表空间文件的存储路径：</h1><p>本机<code>G:\oracle\product\10.1.0\oradata\orcl</code></p>
<h1 id="7-控制文件及其引入目的："><a href="#7-控制文件及其引入目的：" class="headerlink" title="7.控制文件及其引入目的："></a>7.控制文件及其引入目的：</h1><p>控制文件是数据库极其重要的文件，是一个比较小的二进制文件，它记载了物理数据库的当前状态<br> 每一个控制文件只属于一个数据库，但为了防止控制文件的丢失，一个数据库不止一个控制文件。这些控制文件的内容完全<br> 一样，我当前的数据库就有三个控制文件。实际的商用数据库至少两个一般三个控制文件，为了防止磁盘的物理故障，这些<br> 文件最后放在不同的物理磁盘控制器上<br> 在数据库装载或打开之前，Oracle服务器必须能够访问控制文件，当数据库在打开的状态下Oracle服务器会随时地修改控制<br> 文件中的内容。任何用户，包括数据库管理员都不能修改控制文件中的数据</p>
<h1 id="8-怎么查看控制文件的配置"><a href="#8-怎么查看控制文件的配置" class="headerlink" title="8.怎么查看控制文件的配置"></a>8.怎么查看控制文件的配置</h1><p>  <code>SELECT type,record_size,records_total,records_used FROM v$controlfile_record_section; </code><br><code> SELECT type,record_size,records_total,records_used FROM v$controlfile_record_section where type IN(&#39;DATAFILE&#39;,&#39;TABLESPACE&#39;,&#39;REDO LOG&#39;);</code></p>
<h1 id="9-通过使用数据字典获取属性"><a href="#9-通过使用数据字典获取属性" class="headerlink" title="9.通过使用数据字典获取属性"></a>9.通过使用数据字典获取属性</h1><p>使用<code>v\$parameter</code>来获取控制文件的名字<br><code> SELECT value FROM v\$parameter WHERE name=&#39;control_files&#39;;</code><br> 然后格式化显示 </p>
<p><code>col name for a45;</code></p>
<p><code>SELECT * FROM v$controlfile;</code></p>
<h1 id="10-控制文件的备份"><a href="#10-控制文件的备份" class="headerlink" title="10.控制文件的备份"></a>10.控制文件的备份</h1><p><code> alter database backup controlfile to &#39;D:\backup\control.bak&#39;;</code><br> 也可将控制文件备份到一个追踪文件中，改追踪文件已含重建控制文件的SQL语句<br> <code>alter database backup controlfile to trace;</code></p>
<h1 id="11-移动控制文件的实例"><a href="#11-移动控制文件的实例" class="headerlink" title="11.移动控制文件的实例"></a>11.移动控制文件的实例</h1><p>  以下操作假定数据库没有使用服务器参数化文件（SPFLILE）<br>  参看控制文件现有的配置<br> <code> col name for a50 ;</code> </p>
<p><code>SELECT * FROM v$controlfile;</code><br>  正常关闭数据库<br> <code> shutdown immediate</code><br>  拷贝文件<br><code>  host copy G:\oracle\product\10.1.0\oradata\orcl D:\Disk3\CONTROL01.CTL   host copy G:\oracle\product\10.1.0\oradata\orcl D:\Disk6\CONTROL02.CTL   host copy G:\oracle\product\10.1.0\oradata\orcl D:\Disk9\CONTROL03.CTL</code><br>  启动数据库<br><code>  startup</code></p>
<h1 id="12-获取重做日志的信息"><a href="#12-获取重做日志的信息" class="headerlink" title="12.获取重做日志的信息"></a>12.获取重做日志的信息</h1><p> 2个获取重做日志的信息的数据字典<code> v\$log</code>和<code>v\$logfile</code><br><code> SELECT group#,sequence#,members,bytes,status,archived FROM v$log;  col member for a50;  SELECT * FROM v$logfile;</code></p>
<h1 id="13-强制性产生重做日志切换的命令"><a href="#13-强制性产生重做日志切换的命令" class="headerlink" title="13.强制性产生重做日志切换的命令"></a>13.强制性产生重做日志切换的命令</h1><p><code> ALTER SYSTEM SWITCH LOGFILE</code></p>
<h1 id="14-强制性产生检查点的命令"><a href="#14-强制性产生检查点的命令" class="headerlink" title="14.强制性产生检查点的命令"></a>14.强制性产生检查点的命令</h1><p><code>ALTER SYSTEM CHECKPIONT</code></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试基本知识点（1）</title>
    <url>/posts/64d12821.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><font size="10px" style="font-weight:700;font-family:'华文彩云';color:rgb(100,190,100)"><span class="fa-stack fa-lg"><i class="fa fa-square fa-stack-2x"></i><i class="fa fa-code fa-stack-1x fa-inverse"></i></span>基本语言(一)</font></p>
<h2 id="1-说一下static关键字的作用"><a href="#1-说一下static关键字的作用" class="headerlink" title="1 说一下static关键字的作用"></a>1 说一下static关键字的作用</h2><blockquote>
<p>静态变量：编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。另外，如果没有显式地初始化静态变量，编译器将把它设置为0.这种变量被称为零初始化的（zero-initialized）。</p>
</blockquote>
<h3 id="（1）全局静态变量"><a href="#（1）全局静态变量" class="headerlink" title="（1）全局静态变量"></a>（1）全局静态变量</h3><p>在全局变量前加上关键字static，全局变量就定义成一个<strong>全局静态变量</strong>.</p>
<p>静态存储区，在整个程序运行期间一直存在。</p>
<p><strong>初始化</strong>：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p><strong>作用域</strong>：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
<h3 id="（2）局部静态变量"><a href="#（2）局部静态变量" class="headerlink" title="（2）局部静态变量"></a>（2）局部静态变量</h3><p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>
<p>内存中的位置：静态存储区</p>
<p><strong>初始化</strong>：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p>
<p><strong>作用域</strong>：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
<p><font style="align:center;font-weight:600;" color="green" size="5px">5种变量存储方式</font></p>
<p>这里指的是声明为static的变量对外的访问性，默认的全局变量是<code>extern</code>的。</p>
<table>
<thead>
<tr>
<th>存储描述</th>
<th>持续性</th>
<th>作用域</th>
<th>链接性</th>
<th>如何声明</th>
</tr>
</thead>
<tbody><tr>
<td>自动</td>
<td>自动</td>
<td>代码块</td>
<td>无</td>
<td>在代码块中</td>
</tr>
<tr>
<td>寄存器</td>
<td>自动</td>
<td>代码块</td>
<td>无</td>
<td>在代码块中，使用关键字register</td>
</tr>
<tr>
<td>静态，无链接性</td>
<td>静态</td>
<td>代码块</td>
<td>无</td>
<td>在代码块中，使用关键字static</td>
</tr>
<tr>
<td>静态，外部链接性</td>
<td>静态</td>
<td>文件</td>
<td>外部</td>
<td>不再任何函数内</td>
</tr>
<tr>
<td>静态，内部链接性</td>
<td>静态</td>
<td>文件</td>
<td>内部</td>
<td>不再任何函数内，使用关键字static</td>
</tr>
</tbody></table>
<p>补充关键字：<mark>静态持续性、外部链接性</mark></p>
<h3 id="（3）静态函数"><a href="#（3）静态函数" class="headerlink" title="（3）静态函数"></a>（3）静态函数</h3><p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p>
<p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>
<p><strong>warning</strong>：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
<h3 id="（4）类的静态成员"><a href="#（4）类的静态成员" class="headerlink" title="（4）类的静态成员"></a>（4）类的静态成员</h3><p><u>详细请阅读C++ Primer Plus第六版 P428相关文章</u></p>
<p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。</p>
<blockquote>
<p>一个不恰当的比喻就是：静态成员就好比公用电话，所有对象共同使用；非静态成员就好比手机，每个对象使用自己的</p>
</blockquote>
<p><mark> 注意</mark>：不能再类声明中初始化静态成员变量。这是因为声明描述了如何分配内存，但并不分配内存。对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static。</p>
<p><code>&lt;类型&gt; &lt;类名&gt;::&lt;变量名&gt; = &lt;值&gt;</code></p>
<p>如果静态类成员是私有，则不能通过类名+变量名访问，会报如下错误！</p>
<img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gjtnwvg0zkj30en017jr8.jpg" alt="JBZHD1" width="527" data-width="527" data-height="43">

<h4 id="是否可以继承"><a href="#是否可以继承" class="headerlink" title="是否可以继承"></a>是否可以继承</h4><p>子类可以访问弗雷德static变量，但受访问控制（若父类中的static是private就无法访问）</p>
<p>子类和父类的static变量是同一变量，共享同一存储空间。</p>
<p>而继承关系，子类和父类是分别有自己的存储空间。</p>
<h3 id="（5）类的静态函数"><a href="#（5）类的静态函数" class="headerlink" title="（5）类的静态函数"></a>（5）类的静态函数</h3><p>静态成员函数和静态数据成员一样，他们都属于类的静态成员，他们都不是对象成员。<mark>因此，对静态成员的引用不需要用对象名。</mark></p>
<p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（<strong>这点非常重要</strong>）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。</p>
<p>调用格式：<code>&lt;类名&gt;::&lt;静态成员函数&gt;(&lt;参数表&gt;)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">	myString.h</span><br><span class="hljs-comment">	(4)(5)说明</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myString</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">char</span> * str;<br>	<span class="hljs-keyword">int</span> len;<br>	<span class="hljs-comment">//	static int numStrings;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numStrings; <span class="hljs-comment">// 如果是私有的，则无法通过&lt;类名&gt;::&lt;变量名&gt;访问</span><br>	<span class="hljs-built_in">myString</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s);<br>	<span class="hljs-built_in">myString</span>();<br>	~<span class="hljs-built_in">myString</span>();<br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getdata</span><span class="hljs-params">(myString s)</span></span>;<br>	<span class="hljs-comment">//friend function</span><br>	<span class="hljs-keyword">friend</span> ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os,<br>						<span class="hljs-keyword">const</span> myString &amp; st);<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	myString.cpp</span><br><span class="hljs-comment">	(4)(5)说明</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myString.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> myString::numStrings = <span class="hljs-number">0</span>;<br>myString::<span class="hljs-built_in">myString</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s)<br>&#123;<br>	len = <span class="hljs-built_in">strlen</span>(s);<br>	str = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len + <span class="hljs-number">1</span>];<br>	<span class="hljs-built_in">strcpy</span>(str,s);<br>	numStrings++;<br>	cout &lt;&lt; numStrings &lt;&lt; <span class="hljs-string">&quot;: \&quot;&quot;</span> &lt;&lt; str<br>		&lt;&lt; <span class="hljs-string">&quot;\&quot; object created\n&quot;</span>;<br>&#125;<br>myString::<span class="hljs-built_in">myString</span>()<br>&#123;<br>	len = <span class="hljs-number">4</span>;<br>	str = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">4</span>];<br>	<span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;C++&quot;</span>);<br>	numStrings++;<br>	cout &lt;&lt; numStrings &lt;&lt; <span class="hljs-string">&quot;:\&quot;&quot;</span> &lt;&lt; str<br>		&lt;&lt; <span class="hljs-string">&quot;\&quot;object created\n&quot;</span>;<br>&#125;<br>myString::~<span class="hljs-built_in">myString</span>()<br>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;\&quot;&quot;</span>&lt;&lt;str&lt;&lt;<span class="hljs-string">&quot;\&quot; object deleted,&quot;</span>;<br>	--numStrings;<br>	cout &lt;&lt; numStrings &lt;&lt; <span class="hljs-string">&quot;left \n&quot;</span>;<br>	<span class="hljs-keyword">delete</span>[] str;<br>&#125;<br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os,<br>	<span class="hljs-keyword">const</span> myString &amp; st)<br>&#123;<br>	os &lt;&lt; st.str;<br>	<span class="hljs-keyword">return</span> os;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myString::getdata</span><span class="hljs-params">(myString s)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;numStrings：&quot;</span> &lt;&lt; numStrings &lt;&lt; endl; <span class="hljs-comment">//numStrings是静态成员，可以在静态成员中访问</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;当前传入字符为：&quot;</span> &lt;&lt; s.str &lt;&lt; endl;<span class="hljs-comment">//在静态成员函数中，只能通过对象访问类的非静态成员</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;当前传入字符长度为：&quot;</span> &lt;&lt; s.len &lt;&lt; endl; <br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	main.h</span><br><span class="hljs-comment">	(4)(5)说明</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;myString.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;测试开始&quot;</span> &lt;&lt; endl;<br>		<span class="hljs-function">myString <span class="hljs-title">headline1</span><span class="hljs-params">(<span class="hljs-string">&quot;足球&quot;</span>)</span></span>;<br>		<span class="hljs-function">myString <span class="hljs-title">headline2</span><span class="hljs-params">(<span class="hljs-string">&quot;羽毛球&quot;</span>)</span></span>;<br>		<span class="hljs-comment">//静态类成员函数调用直接通过类名</span><br>		cout &lt;&lt; <span class="hljs-string">&quot;执行静态类成员函数：\n&quot;</span> &lt;&lt; <span class="hljs-string">&quot;--------------\n&quot;</span>;<br>		myString::<span class="hljs-built_in">getdata</span>(headline2); <br>		<span class="hljs-comment">//headline1.getdata(headline1); 通过对象名也可以</span><br>		cout  &lt;&lt; <span class="hljs-string">&quot;--------------\n&quot;</span>;<br>		cout &lt;&lt; <span class="hljs-string">&quot;测试结束&quot;</span> &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-C-和C的区别"><a href="#2-C-和C的区别" class="headerlink" title="2 C++和C的区别"></a>2 C++和C的区别</h2><p>设计思想上：</p>
<p>C++是面向对象的语言，而C是面向过程的结构化编程语言</p>
<p>语法上：</p>
<p>C++具有<mark>封装、继承和多态</mark>三种特性</p>
<p>C++相比C，增加多许多类型安全的功能，比如强制类型转换</p>
<p>C++支持范式编程，比如<mark>模板类、函数模板</mark>等</p>
<h2 id="3-C-中的static关键字的作用"><a href="#3-C-中的static关键字的作用" class="headerlink" title="3 C++中的static关键字的作用"></a>3 C++中的static关键字的作用</h2><ul>
<li><p>对于函数定义和代码块之外的变量声明，static修改标识符的链接属性，由默认的<mark color:red>external变为internal</mark>，作用域和存储类型不改变，这些符号只能在声明它们的源文件中访问。</p>
</li>
<li><p>对于代码块内部的变量声明，static修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不变。这种变量在程序执行之前就创建，在程序执行的整个周期都存在。</p>
</li>
<li><p>对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用</p>
</li>
<li><p>对于被static修饰的类成员变量和成员函数，它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过<code>&lt;类名&gt;::&lt;静态成员&gt;</code>来使用。</p>
</li>
</ul>
<h2 id="4-C-中显式类型转换和隐式类型转换"><a href="#4-C-中显式类型转换和隐式类型转换" class="headerlink" title="4 C++中显式类型转换和隐式类型转换"></a>4 C++中显式类型转换和隐式类型转换</h2><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p>参考回答：</p>
<h4 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1.const_cast"></a>1.const_cast</h4><div class="note flat green no-icon simple"><p>用于将const变量转为非const</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> age = <span class="hljs-number">40</span>;<br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> agep = age;<br>	cout &lt;&lt; <span class="hljs-string">&quot;const of age:&quot;</span> &lt;&lt; agep &lt;&lt; endl;<br>	<span class="hljs-keyword">int</span> &amp;nConstAge = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span>&amp;&gt;(agep);<br>	<span class="hljs-comment">// 修改nConstAge的值看看是否能成功修改age的值</span><br>	nConstAge = <span class="hljs-number">18</span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;new const of age：&quot;</span> &lt;&lt; agep &lt;&lt; endl;<br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210111134448789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1ZWxfTWluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div>

<h4 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2.static_cast"></a>2.static_cast</h4><div class="note flat blue no-icon simple"><p>用于将const变量转为非const</p>
</div>

<h4 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3.dynamic_cast"></a>3.dynamic_cast</h4><div class="note flat pink no-icon simple"><p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化是，如果是非法的对于指针返回NULL,对于引用跑一场。要深入了解内部转换的原理。</p>
<ul>
<li>向上转换：指的是子类向基类的转换</li>
<li>向下转换：指的是基类想子类的转换</li>
</ul>
<p>她通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够向下转换。</p>
</div>

<h4 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4.reinterpret_cast"></a>4.reinterpret_cast</h4><div class="note flat red no-icon simple"><p>几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p>
</div>

<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><h4 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h4><div class="note flat red no-icon simple"><p>如果是不同类型的变量，计算+-*/的时候，会出现类型转换，最后会转换成只有一种类型的式子进行运算。</p>
<blockquote>
<p>   在进行运算时，以表达式中最长类型为主，将其他类型位据均转换成该类型，如：</p>
<p>(1)若运算数中有double型或float型，则其他类型数据均转换成double类型进行运算。</p>
<p>(2)若运算数中最长的类型为long型．则其他类型数均转换成long型数。</p>
<p>(3)若运算数中最长类型为int型，则char型也转换成int型进行运算。算术转换是在运算过程中自动完成的。</p>
</blockquote>
<p>大致就是如下所示，算式中的变量会转换为长度更长的更高的类型。此种情况的的还有bool类型的变量，除<code>0</code>之外，其他变量都会被bool类型转换为<code>true</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">double</span> b = <span class="hljs-number">3.1415</span>;<br>	<span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>	cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(a*b-c).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>	<span class="hljs-keyword">bool</span> flag = <span class="hljs-number">0.01</span>;<br>	cout &lt;&lt; flag &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210111131530.png" alt="image-20210111125320791"></p>
</div>

<h4 id="赋值转换"><a href="#赋值转换" class="headerlink" title="赋值转换"></a>赋值转换</h4><div class="note flat red no-icon simple"><p>进行赋值操作时，赋值运算符右边的数据类型必须转换成赋值号左边的类型，若右边的数据类型的长度大于左边，则要进行截断或舍入操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">double</span> b = <span class="hljs-number">3.1415</span>;<br>	<span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	1. a--&gt;double</span><br><span class="hljs-comment">    	2. c--&gt;int 原式就变成了 double-int</span><br><span class="hljs-comment">    	3. int--&gt;double</span><br><span class="hljs-comment">    	原始式子就是变成了 int = double</span><br><span class="hljs-comment">    	最后等号部分，double--&gt;int</span><br><span class="hljs-comment">    */</span><br>	<span class="hljs-keyword">int</span> result = a*b-a*c;  <br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210111131123.png" alt="image-20210111131113541"></p>
</div>

<h4 id="输出转换"><a href="#输出转换" class="headerlink" title="输出转换"></a>输出转换</h4><p>输出转换就是在程序中用printf()函数以指定格式输出，当要输出的数据类型与输出格式不符合时，会转化为以输出格式的输出形式。</p>
<div class="note flat red no-icon simple"><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> a = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输出a的ASCII值：%d&quot;</span>, a); <span class="hljs-comment">//输出“输出a的ASCII值：97”</span><br></code></pre></td></tr></table></figure>
</div>

<h3 id="5-为何说呢么不使用c的强制转换？"><a href="#5-为何说呢么不使用c的强制转换？" class="headerlink" title="5. 为何说呢么不使用c的强制转换？"></a>5. 为何说呢么不使用c的强制转换？</h3><div class="note flat purple no-icon simple"><p>C的强制转换表面上看起来功能很强发什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
</div>





<h2 id="5-请说一下C-C-中指针和引用的区别"><a href="#5-请说一下C-C-中指针和引用的区别" class="headerlink" title="5 请说一下C/C++中指针和引用的区别"></a>5 请说一下C/C++中指针和引用的区别</h2><ol>
<li><p>指针有自己的一块空间，而引用只是一个别名；</p>
</li>
<li><p>使用sizeof看一个<mark>指针的大小是4</mark>，而引用则是被引用对象的大小；</p>
</li>
<li><p>指针可以被初始化为<mark>NULL</mark>，而引用必须被初始化且必须是一个已有对象的引用；</p>
</li>
<li><p>作为参数传递时，指针需要被<mark>解引用</mark>才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</p>
</li>
<li><p>可以有<mark>const指针</mark>，但是没有const引用；</p>
</li>
<li><p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</p>
</li>
<li><p>指针可以有<mark>多级指针（**p）</mark>，而引用止于一级；</p>
</li>
<li><p>指针和引用使用<mark>++运算符</mark>的意义不一样；</p>
</li>
<li><p>如果<mark>返回动态内存</mark>分配的对象或者内存，<mark weight="bolder">必须使用指针</mark>，引用可能引起内存泄露。</p>
</li>
</ol>
<h2 id="6-C-中的smart-pointer-四个只能指针："><a href="#6-C-中的smart-pointer-四个只能指针：" class="headerlink" title="6 C++中的smart pointer 四个只能指针："></a>6 C++中的smart pointer 四个只能指针：</h2><p><strong>shared_ptr,unique_ptr,weak_ptr,auto_ptr</strong></p>
<p><strong>参考回答：</strong></p>
<p>C++里面的三个智能指针：auto_ptr,<strong>shared_ptr,weak_ptr,unique_ptr</strong>其中后三个是C++11支持，并且第一个已经被11弃用。</p>
<p>为什么要使用智能指针：</p>
<div class="note modern blue no-icon simple"><p>智能指针的作用是管理一个指针，因为存在一下这种情况：申请的空间在函数结束时忘记释放，造成内存泄露。使用智能指针可以很大程度上的避免这个问题，与因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是函数结束时自动释放内存空间，不需要手动释放内存空间。</p>
</div>

<h3 id="1、auto-ptrC-98的方案，C-11已经抛弃"><a href="#1、auto-ptrC-98的方案，C-11已经抛弃" class="headerlink" title="1、auto_ptrC++98的方案，C++11已经抛弃"></a>1、auto_ptr<font size="2px">C++98的方案，C++11已经抛弃</font></h3><p>采用所有权模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">auoto_ptr&lt;string&gt;  <span class="hljs-title">p1</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> string (<span class="hljs-string">&quot;I reigned lonely as a cloud.&quot;</span>))</span></span>;<br>auto_ptr&lt;string&gt; p2;<br>p2 = p1; <span class="hljs-comment">//auto_ptr不会报错</span><br></code></pre></td></tr></table></figure>

<p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时，访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</p>
<h3 id="2、unique-ptr替换auto-ptr"><a href="#2、unique-ptr替换auto-ptr" class="headerlink" title="2、unique_ptr替换auto_ptr"></a>2、unique_ptr<font size="1.5em">替换auto_ptr</font></h3><p><code>unique_ptr</code><mark>实现独占式拥有或严格拥有概念，保证同一时间内只有一个只能指针可以指向该对象</mark>。它对于避免资源泄露（例如：以new创建对象后因为发生异常而忘记调用delete，特别有用。</p>
<p>采用所有权模式，还是上面那个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> string (<span class="hljs-string">&quot;auto&quot;</span>))</span></span>;<br>unique_ptr&lt;string&gt; p4;<br>p4 = p3; <span class="hljs-comment">// 此时会报错~</span><br></code></pre></td></tr></table></figure>

<p>编译器认为<code>p4=p3</code>非法，避免了p3不再设置项有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p>
<p>另外unique_ptr还有更聪明的地方：当程序视图将一个<code>unique_ptr</code>赋值给另一个时，如果源<code>unique_ptr</code>是个临时右值，编译器允许这么做；如果源<code>unique_ptr</code>将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">pu1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string (<span class="hljs-string">&quot;hello world&quot;</span>))</span></span>;<br>unique_ptr&lt;string&gt; pu2;<br>pu2 = pu1; <span class="hljs-comment">//#1 not allowed</span><br>unique_ptr&lt;string&gt; pu3;<br>pu3 = unique_ptr&lt;string&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> (<span class="hljs-string">&quot;You&quot;</span>)); <span class="hljs-comment">//#2 allowed</span><br></code></pre></td></tr></table></figure>

<p>其中#1留下的悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用unique_ptr的构造函数，该构造函数创建的临时对象再起所有权让给pu3后就会被销毁。这种情况而已的行为表明，unique_ptr由于允许两种赋值的auto_ptr。</p>
<p><i class="fa fa-asterisk fa-spin" aria-hidden="true"></i><strong>注</strong>：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">unique_ptr&lt;string&gt; ps1, ps2;<br>ps1 = <span class="hljs-built_in">demo</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>ps2 = <span class="hljs-built_in">move</span>(ps1);<br>ps1 = <span class="hljs-built_in">demo</span>(<span class="hljs-string">&quot;alexia&quot;</span>);<br>cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h3 id="3、shared-ptr"><a href="#3、shared-ptr" class="headerlink" title="3、shared_ptr"></a>3、shared_ptr</h3><p>shared_ptr实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，他使用<mark>计数机制</mark>来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造。还可以通过传入auto_ptr、unique_ptr、weak_ptr来构造。当我们使用release()时，当前指针会释放资源苏有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr是为了解决auto_ptr在对象所有权上的局限性（auto_ptr是独占的），在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>use_count</td>
<td>返回引用计数的个数</td>
</tr>
<tr>
<td>unique</td>
<td>返回是否是独占所有权</td>
</tr>
<tr>
<td>swap</td>
<td>交换两个shared_ptr对象（即交换所拥有的对象）</td>
</tr>
<tr>
<td>reset</td>
<td>放弃内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少</td>
</tr>
<tr>
<td>get</td>
<td>返回内部对象（指针），由于已经重载了（）方法，因此和直接使用对象是一样的。<br>如<code>shared_ptr&lt;int&gt; sp(new int (1));</code> <code>sp</code>与<code>sp.get()</code>是等价的</td>
</tr>
</tbody></table>
<h3 id="4、weak-ptr"><a href="#4、weak-ptr" class="headerlink" title="4、weak_ptr"></a>4、weak_ptr</h3><p>weak_ptr是一种不控制对象生命周期的只能指针，它指向一个shared_ptr管理的对象。进行该对象的内训管理的是那个强引用的shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr设计的目的是为配合shared_ptr而引入的一种智能指针来协助shared_ptr工作，<strong>它只可以从一个shared_ptr或另一个weak_ptr对象构造</strong>,它的构造和析构不会引起引用技术的增加或见啥，weak_ptr是用来解决shatred_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数不可能下降为0，资源永远不会释放。它是对对象的一种<mark>弱引用</mark>，<strong>不会增加对象的引用计数</strong>，和share_ptr之间可以相互转化，shared_ptr可以直赋值给它，它可以通过<code>lock()函数</code>来获得shared_ptr。</p>
<div class="note orange icon flat"><i class="note-icon fa fa-battery-quarters"></i><p>这篇文章还在编辑中······</p>
</div>

]]></content>
      <categories>
        <category>面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt线程</title>
    <url>/posts/40b71726.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Qt线程"><a href="#Qt线程" class="headerlink" title="Qt线程"></a>Qt线程</h1><p><code>#include &lt; QThread&gt;</code></p>
<p><img src="../../../images/cover/Qt.jpg" alt="img"></p>
<div class="note orange icon flat"><i class="note-icon fa fa-battery-empty"></i><p>这篇文章还在编辑中······</p>
</div>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>头文件(.h)</title>
    <url>/posts/524b4b01.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="头文件-header-files"><a href="#头文件-header-files" class="headerlink" title="头文件(header files)"></a>头文件(header files)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>C++/C程序的头文件以<code>.h</code>为后缀。使用时需要在<code>.cpp</code>文件中意<code>#include&lt;fileName.h&gt;</code>的方式引入。头文件作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明，而定义文件用于保存程序的实现。</p>
<h2 id="头文件中常包含的内容"><a href="#头文件中常包含的内容" class="headerlink" title="头文件中常包含的内容"></a>头文件中常包含的内容</h2><ol>
<li><p>函数原型</p>
</li>
<li><p>使用<code>#define</code>或<code>const</code>定义的符号常量</p>
</li>
<li><p>结构声明</p>
</li>
</ol>
<p>   将结构声明放在头文件中是可以的，因为它们不创建变量，而只是在源代码文件中声明结构变量时，告诉编译器如何创建该结构变量。</p>
<ol start="4">
<li>类声明</li>
<li>内联函数(inline)</li>
</ol>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>shared_ptr详细用法</title>
    <url>/posts/e340a684.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p><code>#include&lt;memory&gt;</code></p>
<p>要确保用 new 动态分配的内存空间在程序的各条执行路径都能被释放是一件麻烦的事情。<a href="http://c.biancheng.net/cplus/">C++</a> 11 模板库的 <memory> 头文件中定义的智能<a href="http://c.biancheng.net/c/80/">指针</a>，即 shared _ptr 模板，就是用来部分解决这个问题的。</memory></p>
<p>只要将 new 运算符返回的指针 p 交给一个 shared_ptr 对象“托管”，就不必担心在哪里写<code>delete p</code>语句——实际上根本不需要编写这条语句，托管 p 的 shared_ptr 对象在消亡时会自动执行<code>delete p</code>。而且，该 shared_ptr 对象能像指针 p —样使用，即假设托管 p 的 shared_ptr 对象叫作 ptr，那么 *ptr 就是 p 指向的对象。</p>
<p>通过 shared_ptr 的构造函数，可以让 shared_ptr 对象托管一个 new 运算符返回的指针，写法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T)</span></span>; <span class="hljs-comment">// T 可以是 int、char、类等各种类型</span><br></code></pre></td></tr></table></figure>

<p>此后，ptr 就可以像 T* 类型的指针一样使用，即 *ptr 就是用 new 动态分配的那个对象。</p>
<p>多个 shared_ptr 对象可以共同托管一个指针 p，当所有曾经托管 p 的 shared_ptr 对象都解除了对其的托管时，就会执行<code>delete p</code>。</p>
<p>例如下面的程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> n):<span class="hljs-built_in">i</span>(n) &#123; &#125;;<br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot;destructed&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A(<span class="hljs-number">2</span>))</span></span>; <span class="hljs-comment">//A(2)由sp1托管，</span><br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;       <span class="hljs-comment">//A(2)同时交由sp2托管</span><br>    shared_ptr&lt;A&gt; sp3;<br>    sp3 = sp2;   <span class="hljs-comment">//A(2)同时交由sp3托管</span><br>    cout &lt;&lt; sp1-&gt;i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; sp2-&gt;i &lt;&lt;<span class="hljs-string">&quot;,&quot;</span> &lt;&lt; sp3-&gt;i &lt;&lt; endl;<br>    A * p = sp3.<span class="hljs-built_in">get</span>();      <span class="hljs-comment">// get返回托管的指针，p 指向 A(2)</span><br>    cout &lt;&lt; p-&gt;i &lt;&lt; endl;  <span class="hljs-comment">//输出 2</span><br>    sp1.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>));    <span class="hljs-comment">// reset导致托管新的指针, 此时sp1托管A(3)</span><br>    sp2.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">4</span>));    <span class="hljs-comment">// sp2托管A(4)</span><br>    cout &lt;&lt; sp1-&gt;i &lt;&lt; endl; <span class="hljs-comment">//输出 3</span><br>    sp3.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">5</span>));    <span class="hljs-comment">// sp3托管A(5),A(2)无人托管，被delete</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>程序的输出结果如下：<br>2,2,2<br>2<br>3<br>2 destructed<br>end<br>5 destructed<br>4 destructed<br>3 destructed</p>
</blockquote>
<p>可以用第 14 行及第 16 行的形式让多个 sharecLptr 对象托管同一个指针。这多个 shared_ptr 对象会共享一个对共同托管的指针的“托管计数”。有 n 个 shared_ptr 对象托管同一个指针 p，则 p 的托管计数就是 n。当一个指针的托管计数减为 0 时，该指针会被释放。shared_ptr 对象消亡或托管了新的指针，都会导致其原托管指针的托管计数减 1。</p>
<p>第 20、21 行，shared_ptr 的 reset 成员函数可以使得对象解除对原托管指针的托管（如果有的话），并托管新的指针。原指针的托管计数会减 1。</p>
<p>输出的第 4 行说明，用 new 创建的动态对象 A(2) 被释放了。程序中没有写 delete 语句，而 A(2) 被释放，是因为程序的第 23 行执行后，已经没有 shared_ptr 对象托管 A(2)，于是 A(2) 的托管计数变为 0。最后一个解除对 A(2) 托管的 shared_ptr 对象会释放 A(2)。</p>
<p>main 函数结束时，sp1、sp2、sp3 对象消亡，各自将其托管的指针的托管计数减为 0，并且释放其托管的指针，于是会有以下输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">5 destructed<br>4 destructed<br>3 destructed<br></code></pre></td></tr></table></figure>

<p>只有指向动态分配的对象的指针才能交给 shared_ptr 对象托管。将指向普通局部变量、全局变量的指针交给 shared_ptr 托管，编译时不会有问题，但程序运行时会出错，因为不能析构一个并没有指向动态分配的内存空间的指针。</p>
<p>注意，不能用下面的方式使得两个 shared_ptr 对象托管同一个指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">A* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">10</span>);<br>shared_ptr &lt;A&gt; <span class="hljs-built_in">sp1</span>(p), <span class="hljs-built_in">sp2</span>(p);<br></code></pre></td></tr></table></figure>

<p>sp1 和 sp2 并不会共享同一个对 p 的托管计数，而是各自将对 p 的托管计数都记为 1（sp2 无法知道 p 已经被 sp1 托管过）。这样，当 sp1 消亡时要析构 p，sp2 消亡时要再次析构 p，这会导致程序崩溃。</p>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux—从创建用户开始</title>
    <url>/posts/ae600674.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux—从创建用户开始"><a href="#Linux—从创建用户开始" class="headerlink" title="Linux—从创建用户开始"></a>Linux—从创建用户开始</h1><div class="note green simple icon simple"><i class="note-icon fa fa-balance-scale"></i><p>跟着实验楼做完了Linux的实验，一步一步整理下来的实验流程。</p>
</div>

<h2 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1. 创建用户"></a>1. 创建用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo adduser lilei <span class="hljs-comment">#创建用户</span><br>ls /home  <span class="hljs-comment">#默认新用户在/home目录下创建一个工作目录同时  添加用户到系统</span><br>su -l lilei <span class="hljs-comment">#登录用户</span><br>	<span class="hljs-comment">#以下命令查看用户信息</span><br>	$ who am i<br>	$ whoami<br>	$ <span class="hljs-built_in">pwd</span><br><span class="hljs-built_in">exit</span> <span class="hljs-comment">#该命令退出当前用户，相当于（Ctrl+D）</span><br></code></pre></td></tr></table></figure>

<h2 id="2-用户组"><a href="#2-用户组" class="headerlink" title="2. 用户组"></a>2. 用户组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs Linux">#查询用户组<br>$ groups shiyanlou <br>shiyanlou:shiyanlou  #冒号之前表示用户，之后表示该用户所属用户组<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194845.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs LInux">#默认情况下在sudo用户组，使用sudo命令获得root权限<br><br>#查看用户信息<br>$ cat &#x2F;etc&#x2F;group | sort  #sort讲读取文本进行一个字典排序再输出<br></code></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194850.png" style="zoom:60%">

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用grep命令过滤</span><br>cat /etc/group | grep -E<span class="hljs-string">&quot;shiyanlou&quot;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid13labid3timestamp1454035698068.png/wm"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/etc/group<br></code></pre></td></tr></table></figure>

<p>​    /etc/group 的内容包括用户组（Group）、用户组口令、GID（组ID）及该用户组所包含的用户（User），每个用户组一条记录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194903.png"></p>
<h3 id="将其他用户组加入sudo用户组"><a href="#将其他用户组加入sudo用户组" class="headerlink" title="将其他用户组加入sudo用户组"></a>将其他用户组加入sudo用户组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">su -l lilei <span class="hljs-comment">#log in</span><br>sudo ls <br></code></pre></td></tr></table></figure>

<p><img src="../../../../images/Linux03.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#更改用户密码</span><br>sudo passwd 用户名<br></code></pre></td></tr></table></figure>

<p><img src="../../../../images/Linux04.png"><img src="../../../../images/0-%E9%9B%B6%E3%80%81%E5%AE%9E%E9%AA%8C%E6%A5%BC/20210105194932.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将lilei添加到实验楼</span><br><span class="hljs-comment">#登录实验楼账户</span><br>su -l shiyanlou <br><span class="hljs-comment">#输入密码</span><br>groups lilei<br>sudo usermod -G sudo lilei<br>groups lilei<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194922.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#验证lilei用户是否有权限</span><br><span class="hljs-comment">#登录lilei用户</span><br><span class="hljs-comment">#为验证lilei用户是否添加成功，创建了mign用户作为比较</span><br>sudo ls<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194937.png"></p>
<center>用户lilei(此时，用户已经获得root权限)</center>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194943.png"></p>
<center>用户mign</center>

<h2 id="在CentOS中添加用户到su"><a href="#在CentOS中添加用户到su" class="headerlink" title="在CentOS中添加用户到su"></a>在CentOS中添加用户到su</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">su<br>vim /etc/sudoers<br><span class="hljs-meta">#</span><span class="bash"> 在以下段落后</span><br>root	ALL=(ALL)	ALL<br><span class="hljs-meta">#</span><span class="bash"> 添加</span><br><span class="hljs-meta">#</span><span class="bash"> 形如（用户名	ALL=(ALL)	ALL</span><br>ming	ALL=(ALL)	ALL<br></code></pre></td></tr></table></figure>



<h2 id="3-删除用户和用户组"><a href="#3-删除用户和用户组" class="headerlink" title="3.删除用户和用户组"></a>3.删除用户和用户组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#删除用户</span><br><span class="hljs-comment">#--remove-home参数在删除用户时会一并删除工作目录</span><br>sudo deluser lilei --remove-home<br><span class="hljs-comment">#删除用户组</span><br>sudo groupdel 用户组 --remove-home<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194948.png"></p>
<h2 id="4-用户及文件权限-ls命令"><a href="#4-用户及文件权限-ls命令" class="headerlink" title="4. 用户及文件权限 (ls命令)"></a>4. 用户及文件权限 (ls命令)</h2><p>​    <strong>1. 使用较长格式列出文件</strong> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用较长格式列出文件</span><br>ls -l<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194952.png"></p>
<h5 id="具体含义如下："><a href="#具体含义如下：" class="headerlink" title="具体含义如下："></a>具体含义如下：</h5><p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194958.jpg"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看隐藏文件</span><br>$ ls -a<br><span class="hljs-comment">#同时使用-a -l参数</span><br>$ ls -al<br><span class="hljs-comment">#查看某个目录的完整属性</span><br>$ ls -dl&lt;目录名&gt;<br><span class="hljs-comment">#显示所有文件大小，常规呈现</span><br><span class="hljs-comment"># 小写s显示文件大小 大S为按文件大小排序 </span><br>$ ls -asSh<br></code></pre></td></tr></table></figure>

<p>​    可以使用==man ls==命令查询 </p>
<h2 id="5-变更文件所有者"><a href="#5-变更文件所有者" class="headerlink" title="5. 变更文件所有者"></a>5. 变更文件所有者</h2><p>在==lilei==用户下新建文件，命名为==iPhone 11==</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">su - lile<br><span class="hljs-built_in">pwd</span> <br><span class="hljs-comment">#创建iPhone11文件</span><br>touch iphone11<br><span class="hljs-comment">#查看iphone11文件</span><br><span class="hljs-comment"># -h with -l and/or -s,print human readable sizes(e.g., 1K 234M 2G)</span><br>ls -alh iphone11<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105195002.png"></p>
<p>切换到==shiyanlou==，使用以下命令修改文件所有者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/lilei<br>ls iphone11<br>sudo chown shiyanlou iphone11<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105195007.png"></p>
<p>可见，iPhone11文件所有者为==shiyanlou==</p>
<h2 id="变更文件所有者"><a href="#变更文件所有者" class="headerlink" title="变更文件所有者"></a>变更文件所有者</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#login 查看或创建一个文件</span><br>su - username<br><span class="hljs-built_in">pwd</span> <span class="hljs-comment">#查看当前路径</span><br>touch iPhone11<span class="hljs-comment">#文件名</span><br>ls -alh ihpne11 <span class="hljs-comment">#查看iPhone11的权限</span><br></code></pre></td></tr></table></figure>

<h3 id="1-修改文件所有者操作"><a href="#1-修改文件所有者操作" class="headerlink" title="1. 修改文件所有者操作"></a>1. 修改文件所有者操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#切换到目标用户</span><br>su - shiyanlou<br><span class="hljs-built_in">cd</span> /home/lilei<br>ls iphone11<br>sudo chown shiyanlou iphone11<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105195011.png"></p>
<h3 id="2-修改文件权限"><a href="#2-修改文件权限" class="headerlink" title="2. 修改文件权限"></a>2. 修改文件权限</h3><ul>
<li><p>方法一</p>
<p>每个文件有三组固定的权限，分别对应拥有者，所属用户组，其他用户，<strong>记住这个顺序是固定的</strong>。文件的读写执行对应字母 <code>rwx</code>，以二进制表示就是 <code>111</code>，用十进制表示就是 <code>7</code>，对进制转换不熟悉的同学可以看看 <a href="https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/3117222">进制转换</a>。例如我们刚刚新建的文件 iphone11 的权限是 <code>rw-rw-rw-</code>，换成对应的十进制表示就是 666，这就表示这个文件的拥有者，所属用户组和其他用户具有读写权限，不具有执行权限。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105204056.png"></p>
<ul>
<li><p>方法二</p>
<p><code>g</code>、<code>o</code> 还有 <code>u</code> 分别表示 group（用户组）、others（其他用户） 和 user（用户），<code>+</code> 和 <code>-</code> 分别表示增加和去掉相应的权限。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105195018.png"></p>
<h3 id="3-向文件中添加内容-echo"><a href="#3-向文件中添加内容-echo" class="headerlink" title="3.向文件中添加内容(echo)"></a>3.向文件中添加内容(echo)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 重写</span><br><span class="hljs-built_in">echo</span> 添加内容 &gt; 文件名<br><span class="hljs-comment"># 追加</span><br><span class="hljs-built_in">echo</span> 添加内容 &gt;&gt; 文件名<br></code></pre></td></tr></table></figure>



<h4 id="adduser-和useradd的区别是什么？"><a href="#adduser-和useradd的区别是什么？" class="headerlink" title="adduser 和useradd的区别是什么？"></a><code>adduser </code>和<code>useradd</code>的区别是什么？</h4><blockquote>
<p><strong>答：</strong><code>useradd</code> 只创建用户，不会创建用户密码和工作目录，创建完了需要使用 <code>passwd &lt;username&gt;</code> 去设置新用户的密码。<code>adduser</code>在创建用户的同时，会创建工作目录和密码（提示你设置），做这一系列的操作。其实 <code>useradd</code>、<code>userdel</code> 这类操作更像是一种命令，执行完了就返回。而 <code>adduser</code> 更像是一种程序，需要你输入、确定等一系列操作。</p>
<p>Linux 还有一些关于隐藏权限和特殊权限的内容，想全面了解 Linux 权限管理这部分内容的用户可以通过其它方式学习 </p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>一、Linux目录结构及文件基本操作</title>
    <url>/posts/ed589a8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>支持互联网的开源技术——LAMP：Linux、Apache、Mysql、PHP</p>
</blockquote>
<h1 id="1-新建"><a href="#1-新建" class="headerlink" title="1. 新建"></a><font face="华文彩云" color="green"><strong>1. 新建</strong></font></h1><h2 id="1-新建空白文件-touch"><a href="#1-新建空白文件-touch" class="headerlink" title="1. 新建空白文件(touch)"></a>1. 新建空白文件(touch)</h2><p>使用==touch==命令创建空白文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ~ #切换到根目录<br>touch test #创建test文件<br></code></pre></td></tr></table></figure>

<h2 id="2-新建目录-mkdir"><a href="#2-新建目录-mkdir" class="headerlink" title="2. 新建目录(mkdir)"></a>2. 新建目录(mkdir)</h2><p>使用==mkdir==(make directoriese)命令可以创建一个空目录，也可以同时制定创建目录的权限属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir mydir #创建名为mydir的空目录<br></code></pre></td></tr></table></figure>

<p>使用 ==-p== 参数，同时创建父目录（如果不存在该父目录），如下我们同时创建一个多级目录（这在安装软件、配置安装路径时非常有用）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir -p father/son/grandson<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194834.png" alt="image-20200811175234205"></p>
<blockquote>
<p>当目录中已经存在同名文件时，再次使用==touch==按钮不会新建一个同名文件，但是会改变原文件的时间戳</p>
</blockquote>
<h1 id="2-复制"><a href="#2-复制" class="headerlink" title="2. 复制"></a><font face="华文彩云" color="green"><strong>2. 复制</strong></font></h1><h2 id="1-复制文件（cp）"><a href="#1-复制文件（cp）" class="headerlink" title="1. 复制文件（cp）"></a>1. 复制文件（cp）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cp test father/son/grandson  #cp 文件名 目标地址<br></code></pre></td></tr></table></figure>

<h2 id="2-复制目录（cp）"><a href="#2-复制目录（cp）" class="headerlink" title="2. 复制目录（cp）"></a>2. 复制目录（cp）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /home/shiyanlou<br>mkdir family<br>cp -r father family #cp -r 文件名 目的地文件名<br></code></pre></td></tr></table></figure>

<p>要成功复制目录需要加上 <code>-r</code> 或者 <code>-R</code> 参数，表示递归复制</p>
<h1 id="3-删除"><a href="#3-删除" class="headerlink" title="3. 删除"></a><font face="华文彩云" color="green"><strong>3. 删除</strong></font></h1><h2 id="1-删除文件（rm）"><a href="#1-删除文件（rm）" class="headerlink" title="1.删除文件（rm）"></a>1.删除文件（rm）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rm test <br><span class="hljs-meta">#</span><span class="bash">当遇到权限问题时，需要加上-f参数</span><br><span class="hljs-meta">#</span><span class="bash">删除目录时，使用 -r 或者 -R参数</span><br>rm -rf family<br></code></pre></td></tr></table></figure>

<h1 id="4-移动文件与文件重命名"><a href="#4-移动文件与文件重命名" class="headerlink" title="4. 移动文件与文件重命名"></a><font face="华文彩云" color="green"><strong>4. 移动文件与文件重命名</strong></font></h1><h2 id="1-移动文件（mv-move-or-rename-files）"><a href="#1-移动文件（mv-move-or-rename-files）" class="headerlink" title="1. 移动文件（mv-move or rename files）"></a>1. 移动文件（mv-move or rename files）</h2><p>使用mv命令移动文件（剪切）。命令格式是mv   原目录文件    目的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir Documents<br>touch file1<br>mv file1 Documents # mv 原目录文件 目的目录<br></code></pre></td></tr></table></figure>

<h2 id="2-重命名文件（mv）"><a href="#2-重命名文件（mv）" class="headerlink" title="2. 重命名文件（mv）"></a>2. 重命名文件（mv）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mv file1 myfile<br></code></pre></td></tr></table></figure>

<h2 id="3-批量重命名"><a href="#3-批量重命名" class="headerlink" title="3. 批量重命名"></a>3. 批量重命名</h2><p>首先安装==rename==命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装rename命令</span><br>sudo apt-get install rename<br></code></pre></td></tr></table></figure>

<p>使用了通配符和正则表达式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /home/shiyanlou/<br><br><span class="hljs-meta">#</span><span class="bash">使用通配符批量创建5个文件</span><br>touch file&#123;1..5&#125;.txt<br><br><span class="hljs-meta">#</span><span class="bash">批量将这5个文件重命名为.c文件</span><br>rename &#x27;s/\.txt/\.c&#x27; *.txt<br><br><span class="hljs-meta">#</span><span class="bash"> 批量将这五个文件，文件名改为大写</span><br>rename &#x27;y/a-z/A-Z/&#x27; *.c<br></code></pre></td></tr></table></figure>

<h1 id="5-查看文件"><a href="#5-查看文件" class="headerlink" title="5. 查看文件"></a><font face="华文彩云" color="green"><strong>5. 查看文件</strong></font></h1><h2 id="1-使用cat-tac和nl命令查看文件"><a href="#1-使用cat-tac和nl命令查看文件" class="headerlink" title="1. 使用cat,tac和nl命令查看文件"></a>1. 使用<mark style="background:rgb(160,205,150);border-radius:25px;padding:5px">cat,tac和nl</mark>命令查看文件</h2><p>前两个命令都是用来打印文件内容到标准输出（终端），其中<code>cat</code>为正序显示，<code>tac</code>为倒序显示</p>
<blockquote>
<p>标准输入输出：当我们执行一个 shell 命令行时通常会自动打开三个标准文件，即标准输入文件（stdin），默认对应终端的键盘、标准输出文件（stdout）和标准错误输出文件（stderr），后两个文件都对应被重定向到终端的屏幕，以便我们能直接看到输出内容。进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看/etc目录下拷贝的passwd文件</span><br>cd /home/shiyanlou<br>cp /etc/passwd passwd<br>cat passwd<br><br><span class="hljs-meta">#</span><span class="bash"> -n 参数可以显示行号</span><br>cat -n passwd<br><br><span class="hljs-meta">#</span><span class="bash">nl 命令比cat-n更专业</span><br>nl -b a passwd<br></code></pre></td></tr></table></figure>

<p>==nl==的几种用法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194814.png" alt="Linux102-相应参数"></p>
<p>使用==more==命令打开passwd文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">more passwd<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img/20210105194821.png" alt="Linux100-结果"></p>
<p>使用==head==和==tail==命令查看文件，默认只看文件前几（10）行或者后几行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">tail passwd<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/fole-del/img//20201028085735.png" alt="Linux101"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">head passwd<br></code></pre></td></tr></table></figure>

<p>甚至更直接的只看一行，加上==-n==参数就行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">tail -n 数字 /etc/passwd<br></code></pre></td></tr></table></figure>



<h1 id="6-查看文件类型"><a href="#6-查看文件类型" class="headerlink" title="6. 查看文件类型"></a><font face="华文彩云" color="green"><strong>6. 查看文件类型</strong></font></h1><h2 id="1-查看文件（file"><a href="#1-查看文件（file" class="headerlink" title="1. 查看文件（file)"></a>1. 查看文件（file)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">file shiyanlou.txt <span class="hljs-comment"># file命令查看文件</span><br></code></pre></td></tr></table></figure>

<p>文件类型有：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>普通文件</td>
</tr>
<tr>
<td>d</td>
<td>directory</td>
</tr>
<tr>
<td>l</td>
<td>软链接（快捷方式）</td>
</tr>
<tr>
<td>l</td>
<td>硬链接（相当于拷贝）</td>
</tr>
<tr>
<td>p</td>
<td>管道（管道文件主要用于进程间通信）</td>
</tr>
</tbody></table>
<h1 id="7-编辑文件"><a href="#7-编辑文件" class="headerlink" title="7. 编辑文件"></a><font face="华文彩云" color="green"><strong>7. 编辑文件</strong></font></h1><h2 id="1-编辑器（emacs，vim，nano）"><a href="#1-编辑器（emacs，vim，nano）" class="headerlink" title="1. 编辑器（emacs，vim，nano）"></a>1. 编辑器（emacs，vim，nano）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">vimtutor #打开vim编辑器<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>二、环境变量与文件查找</title>
    <url>/posts/2e2434d7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>将 <code>shiyanlou.zip</code> 解压到当前目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ unzip shiyanlou.zip<br></code></pre></td></tr></table></figure>

<p>使用安静模式，将文件解压到指定目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ unzip -q shiyanlou.zip -d ziptest<br></code></pre></td></tr></table></figure>

<p>上述指定目录不存在，将会自动创建。如果你不想解压只想查看压缩包的内容你可以使用 <code>-l</code> 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ unzip -l shiyanlou.zip<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> 使用 unzip 解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。</p>
<p>使用 <code>-O</code>（英文字母，大写 o）参数指定编码类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">unzip -O GBK 中文压缩文件.zip<br></code></pre></td></tr></table></figure>

<h1 id="环境变量与文件查找"><a href="#环境变量与文件查找" class="headerlink" title="环境变量与文件查找"></a>环境变量与文件查找</h1><h1 id="1-环境变量"><a href="#1-环境变量" class="headerlink" title="1.环境变量"></a>1.环境变量</h1><p><img src="https://doc.shiyanlou.com/linux_base/5-2.png"></p>
<blockquote>
<p>通常涉及的变量有三种：</p>
<pre><code>1. 当前Shell进程私有用户自定义变量，如上面所创建的tmp变量。只有在当前Shell中有效》
 2. Shell本身内建的变量。
 3. 自定义变量导出的环境变量。
</code></pre>
</blockquote>
<p>与上述三种环境变量相关的命令，都是用于==打印环境变量信息==，区别在于涉及的变量范围不同。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>==set==</td>
<td>显示当前Shell所有变量，包括其内建环境变量（与Shell外观等相关），用户自定义变量及导出的环境变量。</td>
</tr>
<tr>
<td>==env==</td>
<td>显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。</td>
</tr>
<tr>
<td>==export==</td>
<td>显示从Shell中导出成环境变量的变量，也能通过他将自定义变量导出为环境变量。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://doc.shiyanlou.com/linux_base/5-3.png"></p>
<p>关于哪些变量是环境变量，可以简单地理解成在当前进程的子进程有效则为环境变量，否则不是（有些人也将所有变量统称为环境变量，只是以全局环境变量和局部环境变量进行区分，我们只要理解它们的实质区别即可）。</p>
<p>按变量的生存周期来划分，Linux 变量可分为两类：</p>
<ol>
<li>永久的：需要修改配置文件，变量永久生效；</li>
<li>临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。</li>
</ol>
<p>这里介绍两个重要文件 <code>/etc/bashrc</code>（有的 Linux 没有这个文件） 和 <code>/etc/profile</code> ，它们分别存放的是 shell 变量和环境变量。还有要注意区别的是每个用户目录下的一个隐藏文件：</p>
<p>​    .profile只对当前用户永久生效。</p>
<p>==添加永久变量，只需打开<u>/etc/profile</u>,在最后加上想要添加的环境变量就行==</p>
<h2 id="1-命令的查找路径与顺序"><a href="#1-命令的查找路径与顺序" class="headerlink" title="1. 命令的查找路径与顺序"></a>1. 命令的查找路径与顺序</h2><p>你可能很早之前就有疑问，我们在 Shell 中输入一个命令，Shell 是怎么知道去哪找到这个命令然后执行的呢？这是通过环境变量 <code>PATH</code> 来进行搜索的，熟悉 Windows 的用户可能知道 Windows 中的也是有这么一个 PATH 环境变量。这个 <code>PATH</code> 里面就保存了 Shell 中执行的命令的搜索路径。</p>
<p>查看 <code>PATH</code> 环境变量的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure>

<p>默认情况下你会看到如下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/sbin:/usr/<span class="hljs-built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/<span class="hljs-built_in">local</span>/games<br></code></pre></td></tr></table></figure>

<p>如果你还记得 Linux 目录结构那一节的内容，你就应该知道上面这些目录下放的是哪一类文件了。通常这一类目录下放的都是可执行文件，当我们在 Shell 中执行一个命令时，系统就会按照 PATH 中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。</p>
<blockquote>
<p>下面我们将练习创建一个最简单的可执行 Shell 脚本和一个使用 C 语言创建的“ hello world ”程序，如果这两部分内容你之前没有学习过，那么你可以进行一个入门学习：</p>
</blockquote>
<ul>
<li><a href="https://www.lanqiao.cn/courses/57">C 语言入门教程</a></li>
<li><a href="https://www.lanqiao.cn/courses/5">高级 Bash 脚本编程指南</a></li>
<li><a href="http://bash.cyberciti.biz/guide/Main_Page">Linux Shell Scripting Tutorial (LSST) v2.0</a></li>
</ul>
<p>创建一个 Shell 脚本文件，你可以使用 gedit，vim，sublime 等工具编辑。如果你是直接复制的话，建议使用 gedit 或者 sublime，否则可能导致代码缩进混乱。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/shiyanlou<br>touch hello_shell.sh<br>gedit hello_shell.sh<br></code></pre></td></tr></table></figure>

<p>在脚本中添加如下内容，保存并退出。</p>
<p><strong>注意不要省掉第一行，这不是注释，论坛有用户反映有语法错误，就是因为没有了第一行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">for</span> ((i=0; i&lt;10; i++));<span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello shell&quot;</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>

<p>为文件添加可执行权限，否则执行会报错没有权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">chmod 755 hello_shell.sh<br></code></pre></td></tr></table></figure>

<p>执行脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/shiyanlou<br>./hello_shell.sh<br></code></pre></td></tr></table></figure>

<p>创建一个 C 语言“ hello world ”程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/shiyanlou<br>gedit hello_world.c<br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>int main(void)<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>);<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>保存后使用 gcc 生成可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gcc -o hello_world hello_world.c<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>gcc 生成二进制文件默认具有可执行权限，不需要修改</strong></p>
</blockquote>
<p>在 /home/shiyanlou 家目录创建一个 <code>mybin</code> 目录，并将上述 hello_shell.sh 和 hello_world 文件移动到其中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/shiyanlou<br>mkdir mybin<br>mv hello_shell.sh hello_world mybin/<br></code></pre></td></tr></table></figure>

<p>现在你可以在 <code>mybin</code> 目录中分别运行你刚刚创建的两个程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> mybin<br>./hello_shell.sh<br>./hello_world<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid60timestamp1532339433567.png"></p>
<p>回到上一级目录，也就是 <code>shiyanlou</code> 家目录，当再想运行那两个程序时，会发现提示命令找不到，除非加上命令的完整路径，但那样很不方便，如何做到像使用系统命令一样执行自己创建的脚本文件或者程序呢？那就要将命令所在路径添加到 <code>PATH</code> 环境变量了。</p>
<h2 id="2-添加自定义路径到“path”环境变量"><a href="#2-添加自定义路径到“path”环境变量" class="headerlink" title="2. 添加自定义路径到“path”环境变量"></a>2. 添加自定义路径到“path”环境变量</h2><p>在前面我们应该注意到 <code>PATH</code> 里面的路径是以 <code>:</code> 作为分割符的，所以我们可以这样添加自定义路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">PATH=<span class="hljs-variable">$PATH</span>:/home/shiyanlou/mybin<br></code></pre></td></tr></table></figure>

<p><strong>注意这里一定要使用绝对路径。</strong></p>
<p>现在你就可以在任意目录执行那两个命令了（注意需要去掉前面的 <code>./</code>）。你可能会意识到这样还并没有很好的解决问题，因为我给 PATH 环境变量追加了一个路径，它也只是在当前 Shell 有效，我一旦退出终端，再打开就会发现又失效了。有没有方法让添加的环境变量全局有效？或者每次启动 Shell 时自动执行上面添加自定义路径到 PATH 的命令？下面我们就来说说后一种方式——让它自动执行。</p>
<p>在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。实验楼的环境使用的 Shell 是 zsh，它的配置文件是 <code>.zshrc</code>，相应的如果使用的 Shell 是 Bash，则配置文件为 <code>.bashrc</code>。它们在 <code>etc</code> 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。Shell 的种类有很多，可以使用 <code>cat /etc/shells</code> 命令查看当前系统已安装的 Shell。</p>
<p><img src="https://doc.shiyanlou.com/courses/uid871732-20200303-1583223324878"></p>
<p>我们可以简单地使用下面命令直接添加内容到 <code>.zshrc</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;PATH=<span class="hljs-variable">$PATH</span>:/home/shiyanlou/mybin&quot;</span> &gt;&gt; .zshrc<br></code></pre></td></tr></table></figure>

<p><strong>上述命令中 <code>&gt;&gt;</code> 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 <code>&gt;</code> 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。</strong> </p>
<h2 id="3-修改和删除已有变量"><a href="#3-修改和删除已有变量" class="headerlink" title="3. 修改和删除已有变量"></a>3. 修改和删除已有变量</h2><h4 id="变量修改"><a href="#变量修改" class="headerlink" title="变量修改"></a>变量修改</h4><p>变量的修改有以下几种方式：</p>
<table>
<thead>
<tr>
<th>变量设置方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$&#123;变量名#匹配字串&#125;</code></td>
<td>从头向后开始匹配，删除符合匹配字串的最短数据</td>
</tr>
<tr>
<td><code>$&#123;变量名##匹配字串&#125;</code></td>
<td>从头向后开始匹配，删除符合匹配字串的最长数据</td>
</tr>
<tr>
<td><code>$&#123;变量名%匹配字串&#125;</code></td>
<td>从尾向前开始匹配，删除符合匹配字串的最短数据</td>
</tr>
<tr>
<td><code>$&#123;变量名%%匹配字串&#125;</code></td>
<td>从尾向前开始匹配，删除符合匹配字串的最长数据</td>
</tr>
<tr>
<td><code>$&#123;变量名/旧的字串/新的字串&#125;</code></td>
<td>将符合旧字串的第一个字串替换为新的字串</td>
</tr>
<tr>
<td><code>$&#123;变量名//旧的字串/新的字串&#125;</code></td>
<td>将符合旧字串的全部字串替换为新的字串</td>
</tr>
</tbody></table>
<p>比如我们可以修改前面添加到 PATH 的环境变量，将添加的 mybin 目录从环境变量里删除。为了避免操作失误导致命令找不到，我们先将 PATH 赋值给一个新的自定义变量 mypath：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mypath=<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$mypath</span><br>mypath=<span class="hljs-variable">$&#123;mypath%/home/shiyanlou/mybin&#125;</span><br><span class="hljs-comment"># 或使用通配符,*表示任意多个任意字符</span><br>mypath=<span class="hljs-variable">$&#123;mypath%*/mybin&#125;</span><br></code></pre></td></tr></table></figure>

<p>可以看到路径已经不存在了。</p>
<p><img src="https://doc.shiyanlou.com/courses/uid871732-20200303-1583224278229"></p>
<h4 id="变量删除"><a href="#变量删除" class="headerlink" title="变量删除"></a>变量删除</h4><p>可以使用 <code>unset</code> 命令删除一个环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> mypath<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/uid871732-20200303-1583224422523"></p>
<h2 id="4-如何让环境变量生效"><a href="#4-如何让环境变量生效" class="headerlink" title="4. 如何让环境变量生效"></a>4. 如何让环境变量生效</h2><p>前面我们在 Shell 中修改了一个配置脚本文件之后（比如 zsh 的配置文件 home 目录下的 <code>.zshrc</code>），每次都要退出终端重新打开甚至重启主机之后其才能生效，很是麻烦，我们可以使用 <code>source</code> 命令来让其立即生效，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/shiyanlou<br><span class="hljs-built_in">source</span> .zshrc<br></code></pre></td></tr></table></figure>

<p><code>source</code> 命令还有一个别名就是 <code>.</code>，上面的命令如果替换成 <code>.</code> 的方式就该是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">. ./.zshrc<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/uid871732-20200303-1583225164807"></p>
<p>在使用<code>.</code>的时候，需要注意与表示当前路径的那个点区分开。</p>
<p>注意第一个点后面有一个空格，而且后面的文件必须指定完整的绝对或相对路径名，source 则不需要。</p>
<h1 id="2-搜索文件"><a href="#2-搜索文件" class="headerlink" title="2. 搜索文件"></a>2. 搜索文件</h1><p>与搜索相关的命令常用的有 <code>whereis</code>，<code>which</code>，<code>find</code> 和 <code>locate</code>。</p>
<ul>
<li><strong><code>whereis</code>简单快速</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">whereis who<br>whereis find<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid60timestamp1532339453618.png"></p>
<p>你会看到 <code>whereis find</code> 找到了三个路径，两个可执行文件路径和一个 man 在线帮助文件所在路径，这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。</p>
<p><code>whereis</code> 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 <code>locate</code> 命令。</p>
<ul>
<li><strong><code>locate</code>快而全</strong></li>
</ul>
<p>使用 <code>locate</code> 命令查找文件也不会遍历硬盘，它通过查询 <code>/var/lib/mlocate/mlocate.db</code> 数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 <code>updatedb</code> 命令来更新数据库。所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 <code>updatedb</code> 命令（在我们的环境中必须先执行一次该命令）。注意这个命令也不是内置的命令，例如在我们的环境中就需要手动安装，然后执行更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install locate<br>sudo updatedb<br></code></pre></td></tr></table></figure>

<p>它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">locate /etc/sh<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意，它不只是在 /etc 目录下查找，还会自动递归子目录进行查找。</strong></p>
</blockquote>
<p><img src="https://doc.shiyanlou.com/courses/uid871732-20200303-1583225846911"></p>
<p>查找 /usr/share/ 下所有 jpg 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">locate /usr/share/\*.jpg<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意要添加 <code>\*</code> 号前面的反斜杠转义，否则会无法找到。</strong></p>
</blockquote>
<p><img src="https://doc.shiyanlou.com/courses/uid871732-20200303-1583226161762"></p>
<p>如果想只统计数目可以加上 <code>-c</code> 参数，<code>-i</code> 参数可以忽略大小写进行查找，whereis 的 <code>-b</code>、<code>-m</code>、<code>-s</code> 同样可以使用。</p>
<ul>
<li><strong><code>which</code>小而精</strong></li>
</ul>
<p><code>which</code> 本身是 Shell 内建的一个命令，我们通常使用 <code>which</code> 来确定是否安装了某个指定的程序，因为它只从 <code>PATH</code> 环境变量指定的路径中去搜索命令并且返回第一个搜索到的结果。也就是说，我们可以看到某个系统命令是否存在以及执行的到底是哪一个地方的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> man<br><span class="hljs-built_in">which</span> nginx<br><span class="hljs-built_in">which</span> ping<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/uid871732-20200303-1583226577160"></p>
<ul>
<li><strong><code>find</code>精而细</strong></li>
</ul>
<p><code>find</code> 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。<code>find</code> 命令强大到，要把它讲明白至少需要单独好几节课程才行，我们这里只介绍一些常用的内容。</p>
<p>这条命令表示去 /etc/ 目录下面 ，搜索名字叫做 interfaces 的文件或者目录。这是 find 命令最常见的格式，千万记住 find 的第一个参数是要搜索的地方。命令前面加上 <code>sudo</code> 是因为 shiyanlou 只是普通用户，对 /etc 目录下的很多文件都没有访问的权限，如果是 root 用户则不用使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo find /etc/ -name interfaces<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/uid871732-20200303-1583226847941"></p>
<blockquote>
<p><strong>注意 find 命令的路径是作为第一个参数的， 基本命令格式为 find [path][option] [action] 。</strong></p>
</blockquote>
<p>与时间相关的命令参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-atime</code></td>
<td>最后访问时间</td>
</tr>
<tr>
<td><code>-ctime</code></td>
<td>最后修改文件内容的时间</td>
</tr>
<tr>
<td><code>-mtime</code></td>
<td>最后修改文件属性的时间</td>
</tr>
</tbody></table>
<p>下面以 <code>-mtime</code> 参数举例：</p>
<ul>
<li><code>-mtime n</code>：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件</li>
<li><code>-mtime +n</code>：列出在 n 天之前（不包含 n 天本身）被修改过的文件</li>
<li><code>-mtime -n</code>：列出在 n 天之内（包含 n 天本身）被修改过的文件</li>
<li><code>-newer file</code>：file 为一个已存在的文件，列出比 file 还要新的文件名</li>
</ul>
<p><img src="https://doc.shiyanlou.com/linux_base/5-8.png" alt="1"></p>
<p>列出 home 目录中，当天（24 小时之内）有改动的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find ~ -mtime 0<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/uid871732-20200303-1583226953512"></p>
<p>列出用户家目录下比 /etc 目录新的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find ~ -newer /etc<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/uid871732-20200303-1583227074890"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>三、文件打包与文件查找</title>
    <url>/posts/573df444.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1、实验介绍"><a href="#1、实验介绍" class="headerlink" title="1、实验介绍"></a>1、实验介绍</h1><h2 id="1-1-实验内容"><a href="#1-1-实验内容" class="headerlink" title="1.1 实验内容"></a>1.1 实验内容</h2><p>介绍 Linux 上常用的压缩/解压工具，主要讲解 zip，tar 的使用。</p>
<h2 id="1-2-知识点"><a href="#1-2-知识点" class="headerlink" title="1.2 知识点"></a>1.2 知识点</h2><ul>
<li>zip 命令</li>
<li>tar 命令</li>
<li>压缩与解压常用组合</li>
</ul>
<h1 id="2、概念讲解"><a href="#2、概念讲解" class="headerlink" title="2、概念讲解"></a>2、概念讲解</h1><p>在讲 Linux 上的压缩工具之前，有必要先了解一下常见常用的压缩包文件格式。在 Windows 上最常见的不外乎这两种 <code>*.zip</code>，<code>*.7z</code> 后缀的压缩文件。而在 Linux 上面常见的格式除了以上两种外，还有 <code>.rar</code>，<code>*.gz</code>，<code>*.xz</code>，<code>*.bz2</code>，<code>*.tar</code>，<code>*.tar.gz</code>，<code>*.tar.xz</code>，<code>*.tar.bz2</code>，简单介绍如下：</p>
<table>
<thead>
<tr>
<th>文件后缀名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*.zip</code></td>
<td>zip 程序打包压缩的文件</td>
</tr>
<tr>
<td><code>*.rar</code></td>
<td>rar 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.7z</code></td>
<td>7zip 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar</code></td>
<td>tar 程序打包，未压缩的文件</td>
</tr>
<tr>
<td><code>*.gz</code></td>
<td>gzip 程序（GNU zip）压缩的文件</td>
</tr>
<tr>
<td><code>*.xz</code></td>
<td>xz 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.bz2</code></td>
<td>bzip2 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar.gz</code></td>
<td>tar 打包，gzip 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar.xz</code></td>
<td>tar 打包，xz 程序压缩的文件</td>
</tr>
<tr>
<td><code>*tar.bz2</code></td>
<td>tar 打包，bzip2 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar.7z</code></td>
<td>tar 打包，7z 程序压缩的文件</td>
</tr>
</tbody></table>
<p>讲了这么多种压缩文件，这么多个命令，不过我们一般只需要掌握几个命令即可，包括 <code>zip</code>，<code>tar</code>。下面会依次介绍这几个命令及对应的解压命令。</p>
<h1 id="3-实战"><a href="#3-实战" class="headerlink" title="3. 实战"></a>3. 实战</h1><h2 id="1-zip压缩打包程序-查看压缩包"><a href="#1-zip压缩打包程序-查看压缩包" class="headerlink" title="1. zip压缩打包程序|查看压缩包"></a>1. zip压缩打包程序|查看压缩包</h2><ul>
<li>使用 zip 打包文件夹：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ cd &#x2F;home&#x2F;shiyanlou<br>$ zip -r -q -o shiyanlou.zip &#x2F;home&#x2F;shiyanlou&#x2F;Desktop<br>$ du -h shiyanlou.zip<br>$ file shiyanlou.zip<br></code></pre></td></tr></table></figure>

<p>上面命令将目录 /home/shiyanlou/Desktop 打包成一个文件，并查看了打包后文件的大小和类型。第一行命令中，<code>-r</code> ：参数表示递归打包包含子目录的全部内容，<code>-q</code> ：参数表示为安静模式，即不向屏幕输出信息，<code>-o</code>：表示输出文件，需在其后紧跟打包输出文件名。后面使用 <code>du</code> 命令查看打包后文件的大小（后面会具体说明该命令）。</p>
<ul>
<li>设置压缩级别为 9 和 1（9 最大，1 最小），重新打包：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ zip -r -9 -q -o shiyanlou_9.zip &#x2F;home&#x2F;shiyanlou&#x2F;Desktop -x ~&#x2F;*.zip<br>$ zip -r -1 -q -o shiyanlou_1.zip &#x2F;home&#x2F;shiyanlou&#x2F;Desktop -x ~&#x2F;*.zip<br></code></pre></td></tr></table></figure>

<p>这里添加了一个参数用于设置压缩级别 <code>-[1-9]</code>，1 表示最快压缩但体积大，9 表示体积最小但耗时最久。最后那个 <code>-x</code> 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中，<strong>注意：这里只能使用绝对路径，否则不起作用</strong>。</p>
<p>我们再用 <code>du</code> 命令分别查看默认压缩级别、最低、最高压缩级别及未压缩的文件的大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ du -h -d 0 *.zip ~ | sort<br></code></pre></td></tr></table></figure>

<p>通过 man 手册可知：</p>
<ul>
<li>h， –human-readable（顾名思义，你可以试试不加的情况）</li>
<li>d， –max-depth（所查看文件的深度）</li>
</ul>
<p><img src="https://doc.shiyanlou.com/courses/uid600404-20190428-1556438181236" alt="图片描述"></p>
<p>这样一目了然，理论上来说默认压缩级别应该是最高的，但是由于文件不大，这里的差异不明显（几乎看不出差别），不过你在环境中操作之后看到的压缩文件大小可能跟图上的有些不同，因为系统在使用过程中，会随时生成一些缓存文件在当前用户的家目录中，这对于我们学习命令使用来说，是无关紧要的，可以忽略这些不同。</p>
<ul>
<li>创建加密 zip 包</li>
</ul>
<p>使用 <code>-e</code> 参数可以创建加密压缩包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ zip -r -e -o shiyanlou_encryption.zip &#x2F;home&#x2F;shiyanlou&#x2F;Desktop<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> 关于 <code>zip</code> 命令，因为 Windows 系统与 Linux/Unix 在文本文件格式上的一些兼容问题，比如换行符（为不可见字符），在 Windows 为 CR+LF（Carriage-Return+Line-Feed：回车加换行），而在 Linux/Unix 上为 LF（换行），所以如果在不加处理的情况下，在 Linux 上编辑的文本，==在 Windows 系统上打开可能看起来是没有换行的==。如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题，那么你还需要对命令做一些修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ zip -r -l -o shiyanlou.zip &#x2F;home&#x2F;shiyanlou&#x2F;Desktop<br></code></pre></td></tr></table></figure>

<p>需要加上 <code>-l</code> 参数将 <code>LF</code> 转换为 <code>CR+LF</code> 来达到以上目的。</p>
<h2 id="2-使用unzip命令解压缩文件"><a href="#2-使用unzip命令解压缩文件" class="headerlink" title="2. 使用unzip命令解压缩文件"></a>2. 使用unzip命令解压缩文件</h2><p>将 <code>shiyanlou.zip</code> 解压到当前目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ unzip shiyanlou.zip<br></code></pre></td></tr></table></figure>

<p>使用安静模式，将文件解压到指定目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ unzip -q shiyanlou.zip -d ziptest<br></code></pre></td></tr></table></figure>

<p>上述指定目录不存在，将会自动创建。如果你不想解压只想查看压缩包的内容你可以使用 <code>-l</code> 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ unzip -l shiyanlou.zip<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> 使用 unzip 解压文件时我们同样应该注意兼容问题，不过这里我们关心的不再是上面的问题，而是中文编码的问题，通常 Windows 系统上面创建的压缩文件，如果有有包含中文的文档或以中文作为文件名的文件时默认会采用 GBK 或其它编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题（有时候它会自动帮你处理），为了解决这个问题，我们可以在解压时指定编码类型。</p>
<p>使用 <code>-O</code>（英文字母，大写 o）参数指定编码类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">unzip -O GBK 中文压缩文件.zip<br></code></pre></td></tr></table></figure>

<h2 id="3-tar打包工具"><a href="#3-tar打包工具" class="headerlink" title="3. tar打包工具"></a>3. tar打包工具</h2><p>在 Linux 上面更常用的是 <code>tar</code> 工具，tar 原本只是一个打包工具，只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩，所以我们也无需再单独去学习其他几个工具，tar 的解压和压缩都是同一个命令，只需参数不同，使用比较方便。</p>
<p>下面先掌握 <code>tar</code> 命令一些基本的使用方式，即不进行压缩只是进行打包（创建归档文件）和解包的操作。</p>
<ul>
<li>创建一个 tar 包：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /home/shiyanlou<br>$ tar -P -cf shiyanlou.tar /home/shiyanlou/Desktop<br></code></pre></td></tr></table></figure>

<p>上面命令中，<code>-P</code> 保留绝对路径符，<code>-c</code> 表示创建一个 tar 包文件，<code>-f</code> 用于指定创建的文件名，注意文件名必须紧跟在 <code>-f</code> 参数之后，比如不能写成 <code>tar -fc shiyanlou.tar</code>，可以写成 <code>tar -f shiyanlou.tar -c ~</code>。你还可以加上 <code>-v</code> 参数以可视的的方式输出打包的文件。</p>
<ul>
<li>解包一个文件（<code>-x</code> 参数）到指定路径的<strong>已存在</strong>目录（<code>-C</code> 参数<code>目标位置目录</code>）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ mkdir tardir<br>$ tar -xf shiyanlou.tar -C tardir<br></code></pre></td></tr></table></figure>

<ul>
<li>只查看不解包文件 <code>-t</code> 参数：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ tar -tf shiyanlou.tar<br></code></pre></td></tr></table></figure>

<ul>
<li>保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（<code>-p</code> 参数）和备份链接指向的源文件而不是链接本身（<code>-h</code> 参数）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ tar -cphf etc.tar /etc<br></code></pre></td></tr></table></figure>

<p>对于创建不同的压缩格式的文件，对于 tar 来说是相当简单的，需要的只是换一个参数，这里我们就以使用 <code>gzip</code> 工具创建 <code>*.tar.gz</code> 文件为例来说明。</p>
<ul>
<li>我们只需要在创建 tar 文件的基础上添加 <code>-z</code> 参数，使用 <code>gzip</code> 来压缩文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop<br></code></pre></td></tr></table></figure>

<ul>
<li>解压 <code>*.tar.gz</code> 文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ tar -xzf shiyanlou.tar.gz<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid61timestamp1532339561961.png" alt="此处输入图片的描述"></p>
<p>现在我们要使用其它的压缩工具创建或解压相应文件只需要更改一个参数即可：</p>
<table>
<thead>
<tr>
<th>压缩文件格式</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td><code>*.tar.gz</code></td>
<td><code>-z</code></td>
</tr>
<tr>
<td><code>*.tar.xz</code></td>
<td><code>-J</code></td>
</tr>
<tr>
<td><code>*tar.bz2</code></td>
<td><code>-j</code></td>
</tr>
</tbody></table>
<blockquote>
<p>tar 命令的参数很多，不过常用的就是上述这些，需要了解更多你可以查看 man 手册获取帮助。</p>
</blockquote>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>说了这么多，其实平常使用的参数并没有那么复杂，只需要记住常用的组合就可以了。 常用命令：</p>
<ul>
<li>zip：</li>
<li>打包 ：zip something.zip something （目录请加 -r 参数）</li>
<li>解包：unzip something.zip</li>
<li>指定路径：-d 参数</li>
<li>tar：</li>
<li>打包：tar -cf something.tar something</li>
<li>解包：tar -xf something.tar</li>
<li>指定路径：-C 参数</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>四、文件系统与磁盘操作</title>
    <url>/posts/2f64ad03.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文件系统与磁盘操作"><a href="#文件系统与磁盘操作" class="headerlink" title="文件系统与磁盘操作"></a>文件系统与磁盘操作</h1><h1 id="一、实验内容"><a href="#一、实验内容" class="headerlink" title="一、实验内容"></a>一、实验内容</h1><h2 id="1-实验内容"><a href="#1-实验内容" class="headerlink" title="1. 实验内容"></a>1. 实验内容</h2><p>本节实验的文件系统操作的内容十分简单，只会包含几个命令的几个参数的讲解，但掌握这些也将对你在学习 Linux 和实验楼后续其他课程的过程中有极大帮助。</p>
<span id="more"></span>

<blockquote>
<p>因为本课程的定位为入门基础，尽快上手，故没有打算涉及太多理论内容，前面省略了关于 Linux 文件系统的一些基本知识，也因为我们是在线实验环境，所以也避开了很少一部分但又十分重要的关于硬件的内容，我们只能期待用户能够抱着提高自学能力的心态自己去补充相关的知识。</p>
</blockquote>
<h2 id="2-实验知识点"><a href="#2-实验知识点" class="headerlink" title="2. 实验知识点"></a>2. 实验知识点</h2><ul>
<li><code>df</code>，<code>du</code>，<code>mount</code>命令的使用</li>
<li>磁盘相关知识学习</li>
</ul>
<h1 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h1><h4 id="2-1-查看磁盘和目录的容量"><a href="#2-1-查看磁盘和目录的容量" class="headerlink" title="2.1 查看磁盘和目录的容量"></a>2.1 查看磁盘和目录的容量</h4><h5 id="使用-df-命令查看磁盘的容量"><a href="#使用-df-命令查看磁盘的容量" class="headerlink" title="使用 df 命令查看磁盘的容量"></a>使用 df 命令查看磁盘的容量</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">df<br></code></pre></td></tr></table></figure>

<p>在实验楼的环境中你将看到如下的输出内容： <img src="https://doc.shiyanlou.com/document-uid600404labid6122timestamp1523871472488.png"></p>
<p>但在实际的物理主机上会更像这样：</p>
<p><img src="https://doc.shiyanlou.com/linux_base/7-2.png"></p>
<p>物理主机上的 /dev/sda2 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），你如果主机上有多块硬盘则可能还会出现 /dev/sdb，/dev/sdc 这些磁盘设备都会在 /dev 目录下以文件的存在形式。</p>
<p>接着你还会看到”1k-块”这个陌生的东西，它表示以磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用和可用容量，在你了解 Linux 的文件系统之前这个就先不管吧，我们以一种你应该看得懂的方式展示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">df -h<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6122timestamp1523871955863.png"></p>
<p>现在你就可以使用命令查看你主机磁盘的使用情况了。至于挂载点如果你还记得前面第 4 节介绍 Linux 目录树结构的内容，那么你就应该能很好的理解挂载的概念，这里就不再赘述。</p>
<h5 id="使用-du-命令查看目录的容量"><a href="#使用-du-命令查看目录的容量" class="headerlink" title="使用 du 命令查看目录的容量"></a>使用 du 命令查看目录的容量</h5><p>这个命令前面其实已经用了很多次了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 默认同样以 块 的大小展示</span><br>du<br><span class="hljs-comment"># 加上`-h`参数，以更易读的方式展示</span><br>du -h<br></code></pre></td></tr></table></figure>

<p><code>-d</code>参数指定查看目录的深度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只查看1级目录的信息</span><br>du -h -d 0 ~<br><span class="hljs-comment"># 查看2级</span><br>du -h -d 1 ~<br></code></pre></td></tr></table></figure>

<p>常用参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">du -h <span class="hljs-comment">#同--human-readable 以K，M，G为单位，提高信息的可读性。</span><br>du -a <span class="hljs-comment">#同--all 显示目录中所有文件的大小。</span><br>du -s <span class="hljs-comment">#同--summarize 仅显示总计，只列出最后加总的值。</span><br>来自: http://man.linuxde.net/du<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6122timestamp1523872284604.png"></p>
<p><code>du</code>（estimate file space usage）命令与<code>df</code>（report file system disk space usage）命令只有一字之差，希望大家注意不要弄混淆了,你可以像我这样从 man 手册中获取命令的完整描述，记全称就不会搞混了。</p>
<h1 id="三、简单的磁盘管理"><a href="#三、简单的磁盘管理" class="headerlink" title="三、简单的磁盘管理"></a>三、简单的磁盘管理</h1><h2 id="1-创建虚拟磁盘"><a href="#1-创建虚拟磁盘" class="headerlink" title="1. 创建虚拟磁盘"></a>1. 创建虚拟磁盘</h2><h3 id="dd-命令简介（部分说明来自dd-Unix-wiki）"><a href="#dd-命令简介（部分说明来自dd-Unix-wiki）" class="headerlink" title="dd 命令简介（部分说明来自dd (Unix) wiki）"></a>dd 命令简介（部分说明来自<a href="http://zh.wikipedia.org/wiki/Dd_(Unix)">dd (Unix) wiki</a>）</h3><p><code>dd</code>命令用于转换和复制文件，不过它的复制不同于<code>cp</code>。之前提到过关于 Linux 的很重要的一点，<strong>一切即文件</strong>，在 Linux 上，硬件的设备驱动（如硬盘）和特殊设备文件（如<code>/dev/zero</code>和<code>/dev/random</code>）都像普通文件一样，只是在各自的驱动程序中实现了对应的功能，dd 也可以读取文件或写入这些文件。这样，<code>dd</code>也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。<code>dd</code>程序也可以在复制时处理数据，例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。</p>
<p><code>dd</code>的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为<code>选项=值</code>，而不是更标准的<code>--选项 值</code>或<code>-选项=值</code>。<code>dd</code>默认从标准输入中读取，并写入到标准输出中，但可以用选项<code>if</code>（input file，输入文件）和<code>of</code>（output file，输出文件）改变。</p>
<p>我们先来试试用<code>dd</code>命令从标准输入读入用户的输入到标准输出或者一个文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出到文件</span><br>dd of=<span class="hljs-built_in">test</span> bs=10 count=1 <span class="hljs-comment"># 或者 dd if=/dev/stdin of=test bs=10 count=1</span><br><span class="hljs-comment"># 输出到标准输出</span><br>dd <span class="hljs-keyword">if</span>=/dev/stdin of=/dev/stdout bs=10 count=1<br><span class="hljs-comment"># 注在打完了这个命令后，继续在终端打字，作为你的输入</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid62timestamp1532339776332.png" alt="此处输入图片的描述"></p>
<p>上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，<code>bs</code>（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），<code>count</code>用于指定块数量。如上图所示，我指定只读取总共 10 个字节的数据，当我输入了“hello shiyanlou”之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用<code>du</code>和<code>cat</code>命令看到的写入完成文件实际内容确实只有 10 个字节（那个黑底百分号表示这里没有换行符）,而其他的多余输入将被截取并保留在标准输入。</p>
<p>前面说到<code>dd</code>在拷贝的同时还可以实现数据转换，那下面就举一个简单的例子：将输出的英文字符转换为大写再写入文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">dd if=/dev/stdin of=test bs=10 count=1 conv=ucase<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid62timestamp1532339755321.png"></p>
<p>你可以在<code>man</code>文档中查看其他所有转换参数。</p>
<h3 id="使用-dd-命令创建虚拟镜像文件"><a href="#使用-dd-命令创建虚拟镜像文件" class="headerlink" title="使用 dd 命令创建虚拟镜像文件"></a>使用 dd 命令创建虚拟镜像文件</h3><p>通过上面一小节，你应该掌握了<code>dd</code>的基本使用，下面就来使用<code>dd</code>命令来完成创建虚拟磁盘的第一步。</p>
<p>从<code>/dev/zero</code>设备创建一个容量为 256M 的空文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ dd <span class="hljs-keyword">if</span>=/dev/zero of=virtual.img bs=1M count=256<br>$ du -h virtual.img<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid62timestamp1532339693208.png" alt="此处输入图片的描述"></p>
<p>然后我们要将这个文件格式化（写入文件系统），这里我们要学到一个（准确的说是一组）新的命令来完成这个需求。</p>
<h3 id="使用-mkfs-命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）"><a href="#使用-mkfs-命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）" class="headerlink" title="使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）"></a>使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）</h3><p>你可以在命令行输入 <code>sudo mkfs</code> 然后按下<code>Tab</code>键，你可以看到很多个以 mkfs 为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统。</p>
<p>我们可以简单的使用下面的命令来将我们的虚拟磁盘镜像格式化为<code>ext4</code>文件系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo mkfs.ext4 virtual.img<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6122timestamp1523873459128.png" alt="此处输入图片的描述"></p>
<p>可以看到实际 mkfs.ext4 是使用 mke2fs 来完成格式化工作的。mke2fs 的参数很多，不过我们也不会经常格式化磁盘来玩，所以就掌握这基本用法吧，等你有特殊需求时，再查看 man 文档解决。</p>
<p>更多关于文件系统的知识，请查看 wiki： <a href="http://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F#Linux_.E6.94.AF.E6.8F.B4.E7.9A.84.E6.AA.94.E6.A1.88.E7.B3.BB.E7.B5.B1">文件系统</a> <a href="http://zh.wikipedia.org/wiki/Ext3">ext3</a>,<a href="http://zh.wikipedia.org/wiki/Ext4">ext4</a></p>
<p>如果你想知道 Linux 支持哪些文件系统你可以输入<code>ls -l /lib/modules/$(uname -r)/kernel/fs</code>（我们的环境中无法查看）查看。</p>
<h3 id="使用-mount-命令挂载磁盘到目录树"><a href="#使用-mount-命令挂载磁盘到目录树" class="headerlink" title="使用 mount 命令挂载磁盘到目录树"></a>使用 mount 命令挂载磁盘到目录树</h3><p>用户在 Linux/UNIX 的机器上打开一个文件以前，包含该文件的文件系统必须先进行挂载的动作，此时用户要对该文件系统执行 mount 的指令以进行挂载。该指令通常是使用在 USB 或其他可移除存储设备上，而根目录则需要始终保持挂载的状态。又因为 Linux/UNIX 文件系统可以对应一个文件而不一定要是硬件设备，所以可以挂载一个包含文件系统的文件到目录树。</p>
<p>Linux/UNIX 命令行的 mount 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。</p>
<p>我们先来使用<code>mount</code>来查看下主机已经挂载的文件系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo mount<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6122timestamp1523874300781.png" alt="此处输入图片的描述"></p>
<p>输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。</p>
<p>那么我们如何挂载真正的磁盘到目录树呢，<code>mount</code>命令的一般格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mount [options] [<span class="hljs-built_in">source</span>] [directory]<br></code></pre></td></tr></table></figure>

<p>一些常用操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]<br></code></pre></td></tr></table></figure>

<p><strong>注意：由于实验楼的环境限制，mount 命令挂载及 umount 卸载都无法进行操作，可以简单了解这些步骤。</strong></p>
<p>现在直接来挂载我们创建的虚拟磁盘镜像到<code>/mnt</code>目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ mount -o loop -t ext4 virtual.img /mnt<br><span class="hljs-comment"># 也可以省略挂载类型，很多时候 mount 会自动识别</span><br><br><span class="hljs-comment"># 以只读方式挂载</span><br>$ mount -o loop --ro virtual.img /mnt<br><span class="hljs-comment"># 或者mount -o loop,ro virtual.img /mnt</span><br></code></pre></td></tr></table></figure>

<h3 id="使用-umount-命令卸载已挂载磁盘"><a href="#使用-umount-命令卸载已挂载磁盘" class="headerlink" title="使用 umount 命令卸载已挂载磁盘"></a>使用 umount 命令卸载已挂载磁盘</h3><p><strong>注意：由于实验楼的环境限制，mount 命令挂载及 umount 卸载都无法进行操作，可以简单了解这些步骤。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令格式 sudo umount 已挂载设备名或者挂载点，如：</span><br>$ sudo umount /mnt<br></code></pre></td></tr></table></figure>

<p>不过遗憾的是，由于我们环境的问题（环境中使用的 Linux 内核在编译时没有添加对 Loop device 的支持），所以你将无法挂载成功：</p>
<p><img src="https://doc.shiyanlou.com/document-uid600404labid6122timestamp1523925358180.png" alt="此处输入图片的描述"></p>
<p>另外关于 loop 设备,你可能会有诸多疑问，那么请看下面来自维基百科<a href="http://zh.wikipedia.org/wiki//dev/loop">/dev/loop</a>的说明：</p>
<blockquote>
<p>在类 UNIX 系统中，/dev/loop（或称 vnd （vnode disk）、lofi（循环文件接口））是一种伪设备，这种设备使得文件可以如同块设备一般被访问。</p>
<p>在使用之前，循环设备必须与现存文件系统上的文件相关联。这种关联将提供给用户一个应用程序接口，接口将允许文件视为块特殊文件（参见设备文件系统）使用。因此，如果文件中包含一个完整的文件系统，那么这个文件就能如同磁盘设备一般被挂载。</p>
<p>这种设备文件经常被用于光盘或是磁盘镜像。通过循环挂载来挂载包含文件系统的文件，便使处在这个文件系统中的文件得以被访问。这些文件将出现在挂载点目录。如果挂载目录中本身有文件，这些文件在挂载后将被禁止使用。</p>
</blockquote>
<h3 id="使用-fdisk-为磁盘分区（关于分区的一些概念不清楚的用户请参看主引导记录）"><a href="#使用-fdisk-为磁盘分区（关于分区的一些概念不清楚的用户请参看主引导记录）" class="headerlink" title="使用 fdisk 为磁盘分区（关于分区的一些概念不清楚的用户请参看主引导记录）"></a>使用 fdisk 为磁盘分区（关于分区的一些概念不清楚的用户请参看<a href="http://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95">主引导记录</a>）</h3><p><strong>注意：由于实验楼的环境限制，fdisk 命令无法进行操作，可以简单了解这些步骤。</strong></p>
<p>同样因为环境中没有物理磁盘，也无法创建虚拟磁盘的原因我们就无法实验练习使用该命令了，下面我将以我的物理主机为例讲解如何为磁盘分区。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看硬盘分区表信息</span><br><span class="hljs-meta">$</span><span class="bash"> sudo fdisk -l</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/linux_base/7-12.png" alt="img"></p>
<p>输出结果中开头显示了我主机上的磁盘的一些信息，包括容量扇区数，扇区大小，I/O 大小等信息。</p>
<p>我们重点看一下中间的分区信息，/dev/sda1，/dev/sda2 为主分区分别安装了 Windows 和 Linux 操作系统，/dev/sda3 为交换分区（可以理解为虚拟内存），/dev/sda4 为扩展分区其中包含 /dev/sda5，/dev/sda6，/dev/sda7，/dev/sda8 四个逻辑分区，因为主机上有几个分区之间有空隙，没有对齐边界扇区,所以分区之间不是完全连续的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 进入磁盘分区模式</span><br><span class="hljs-meta">$</span><span class="bash"> sudo fdisk virtual.img</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/linux_base/7-13.png" alt="img"></p>
<p>在进行操作前我们首先应先规划好我们的分区方案，这里我将在使用 128M（可用 127M 左右）的虚拟磁盘镜像创建一个 30M 的主分区剩余部分为扩展分区包含 2 个大约 45M 的逻辑分区。</p>
<p>操作完成后输入<code>p</code>查看结果如下:</p>
<p><img src="https://doc.shiyanlou.com/linux_base/7-14.png" alt="img"></p>
<p>最后不要忘记输入<code>w</code>写入分区表。</p>
<h3 id="使用-losetup-命令建立镜像与回环设备的关联"><a href="#使用-losetup-命令建立镜像与回环设备的关联" class="headerlink" title="使用 losetup 命令建立镜像与回环设备的关联"></a>使用 losetup 命令建立镜像与回环设备的关联</h3><p><strong>注意：由于实验楼的环境限制，losetup 命令无法进行操作，可以简单了解这些步骤。</strong></p>
<p>同样因为环境原因中没有物理磁盘，也没有 loop device 的原因我们就无法实验练习使用该命令了，下面我将以我的物理主机为例讲解。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo losetup /dev/loop0 virtual.img</span><br><span class="hljs-meta">#</span><span class="bash"> 如果提示设备忙你也可以使用其它的回环设备，<span class="hljs-string">&quot;ls /dev/loop*&quot;</span>参看所有回环设备</span><br><br><span class="hljs-meta">#</span><span class="bash"> 解除设备关联</span><br><span class="hljs-meta">$</span><span class="bash"> sudo losetup -d /dev/loop0</span><br></code></pre></td></tr></table></figure>

<p>然后再使用<code>mkfs</code>格式化各分区（前面我们是格式化整个虚拟磁盘镜像文件或磁盘），不过格式化之前，我们还要为各分区建立虚拟设备的映射，用到<code>kpartx</code>工具，需要先安装：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo apt<span class="hljs-literal">-get</span> install kpartx<br><span class="hljs-variable">$</span> sudo kpartx <span class="hljs-literal">-av</span> /dev/loop0<br><br><span class="hljs-comment"># 取消映射</span><br><span class="hljs-variable">$</span> sudo kpartx <span class="hljs-literal">-dv</span> /dev/loop0<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/linux_base/7-15.png" alt="img"></p>
<p>接着再是格式化，我们将其全部格式化为 ext4：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo mkfs.ext4 -q /dev/mapper/loop0p1</span><br><span class="hljs-meta">$</span><span class="bash"> sudo mkfs.ext4 -q /dev/mapper/loop0p5</span><br><span class="hljs-meta">$</span><span class="bash"> sudo mkfs.ext4 -q /dev/mapper/loop0p6</span><br></code></pre></td></tr></table></figure>

<p>格式化完成后在<code>/media</code>目录下新建四个空目录用于挂载虚拟磁盘：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> mkdir <span class="hljs-literal">-p</span> /media/virtualdisk_&#123;<span class="hljs-number">1</span>..<span class="hljs-number">3</span>&#125;<br><span class="hljs-comment"># 挂载磁盘分区</span><br><span class="hljs-variable">$</span> sudo <span class="hljs-built_in">mount</span> /dev/mapper/loop0p1 /media/virtualdisk_1<br><span class="hljs-variable">$</span> sudo <span class="hljs-built_in">mount</span> /dev/mapper/loop0p5 /media/virtualdisk_2<br><span class="hljs-variable">$</span> sudo <span class="hljs-built_in">mount</span> /dev/mapper/loop0p6 /media/virtualdisk_3<br><br><span class="hljs-comment"># 卸载磁盘分区</span><br><span class="hljs-variable">$</span> sudo umount /dev/mapper/loop0p1<br><span class="hljs-variable">$</span> sudo umount /dev/mapper/loop0p5<br><span class="hljs-variable">$</span> sudo umount /dev/mapper/loop0p6<br></code></pre></td></tr></table></figure>

<p>然后：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> df -h</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/linux_base/7-16.png" alt="img"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>共用体（union）</title>
    <url>/posts/c63335c7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>用体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。也</p>
<p>就是说，结构可以同时存储int、long 和double，共用体只能存储 int、long或double。共用体的句法与结</p>
<p>构相似，但含义不同。例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">one4all</span> &#123;</span><br>	<span class="hljs-keyword">int</span> int_val;<br>	<span class="hljs-keyword">long</span> long_val;<br>	<span class="hljs-keyword">double</span> double_val;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//创建一个共用体</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">one4all</span> &#123;</span><br>	<span class="hljs-keyword">int</span> int_val;<br>	<span class="hljs-keyword">long</span> long_val;<br>	<span class="hljs-keyword">double</span> double_val;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//在同一时间只能之勇union中变量的一种</span><br>	one4all temp;<br>	temp.int_val = <span class="hljs-number">10</span>;<br>	cout &lt;&lt; temp.int_val &lt;&lt; endl;<br>	temp.double_val = <span class="hljs-number">3.1415926</span>;<br>	cout &lt;&lt; temp.double_val &lt;&lt; endl;<br>	cout &lt;&lt; &amp;temp.double_val &lt;&lt; endl;<br>	cout &lt;&lt; &amp;temp.long_val &lt;&lt; endl;<br>	cout &lt;&lt; &amp;temp.int_val &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="../../../../images/5%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%EF%BC%88union%EF%BC%89/%E5%85%B1%E7%94%A8%E4%BD%931.png"></p>
<p>为什么每次只能使用一个，直接打印地址可以发现，<code>union</code>中变量共同使用一个地址，所以每次也只能存储一种类型的值。那么，共用体在什么时候才会用到呢？</p>
<hr>
<p>《C++ primer 第六版》中给的定义是：</p>
<div class="note red no-icon flat"><p>共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。</p>
</div>

<h1 id="匿名共用体-anonymous-union"><a href="#匿名共用体-anonymous-union" class="headerlink" title="匿名共用体 (anonymous union)"></a>匿名共用体 (anonymous union)</h1><p>没有名称的共同体，启程苑将成为位于相同地址处的变量。每次只有一个成员是当前的成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">worker</span> &#123;</span><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">bool</span> gender;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-keyword">long</span> id_num;<br>        <span class="hljs-keyword">char</span> id_char[<span class="hljs-number">20</span>];<br>    &#125;;<br>&#125;;<br><br>worker programmer;<br><span class="hljs-keyword">if</span>(programmer.gender == <span class="hljs-number">1</span>)<br>    cout &lt;&lt; programmer.id_num;<br><span class="hljs-keyword">else</span><br>    cout &lt;&lt; programmer.id_char;<br></code></pre></td></tr></table></figure>

<p><code>id_num</code>和<code>id_char[20]</code>使用的还是同一个地址。使用中只需确定当前是哪个成员活动就行。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>共用体常用语节省内存。尤其是嵌入式系统编程，对内存要求较为严格。另外，共用体常用于操作系统数据结构或硬件数据结构。</p>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
        <category>第四章、复合类型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>union</tag>
      </tags>
  </entry>
  <entry>
    <title>C++操作符</title>
    <url>/posts/2c746baa.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-操作符"><a href="#1-操作符" class="headerlink" title="1 操作符"></a>1 操作符</h1><h2 id="补码运算符"><a href="#补码运算符" class="headerlink" title="~(补码运算符)"></a>~(补码运算符)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> y = ~x; <span class="hljs-comment">//1.</span><br>cout &lt;&lt; y;<br><span class="hljs-comment">//输出&#x27;254&#x27;</span><br></code></pre></td></tr></table></figure>

<p>解释：</p>
<p>x = 0000 0001<br>~x = 1111  1110,<code>-x</code>为负数，负数在计算机中用补码表示，所以符号位不变，取反加1<br>y = 1 0000 0010,<code>1000 0010(BIN) = -2(DEX)</code></p>
<img src="//tvax3.sinaimg.cn/large/0072YHp3ly1gjp909adtvj30ep02b0sj.jpg" alt="操作符1" width="529" data-width="529" data-height="83">

<h2 id="操作符"><a href="#操作符" class="headerlink" title="++操作符"></a>++操作符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i1 = <span class="hljs-number">4</span>；<br><span class="hljs-keyword">int</span> y1 = i1++; <span class="hljs-comment">//如大家所知，点调用、再自增 y1 = 4 , i1 = 5; </span><br><span class="hljs-keyword">int</span> i2 = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">int</span> y2 = ++i2; <span class="hljs-comment">//先自增再调用 y2 = 5 , i2 = 5; </span><br></code></pre></td></tr></table></figure>

<p>大体上是类似的，但是<code>i++</code>在计算时会用到<strong>中间变量</strong>，会占用更多的内存和时间，所以<code>++i</code>更好</p>
<h1 id="2-C-不能重载的操作符"><a href="#2-C-不能重载的操作符" class="headerlink" title="2 C++不能重载的操作符"></a>2 C++不能重载的操作符</h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">（1） &quot;.&quot;（类成员访问运算符） <br>（2）&quot; .*&quot;（类成员指针访问运算符） <br>（3） &quot;::&quot;（域运算符） <br>（4）&quot;sizeof&quot;（长度运算符） <br>（5） &quot; ?:&quot;（条件运算符&#x2F;三目运算符）<br>（6） dynamic_cast<br>（7） static_cast<br>（8） reinterpret_cast<br> (9) const_cast<br> (10) typeid(获取类型信息)<br></code></pre></td></tr></table></figure>

<h1 id="3-运算符重载后，优先级和结合性怎么办？"><a href="#3-运算符重载后，优先级和结合性怎么办？" class="headerlink" title="3 运算符重载后，优先级和结合性怎么办？"></a>3 运算符重载后，优先级和结合性怎么办？</h1><div class="note primary simple"><p>用户重载新定义运算符，不改变元运算符的优先级和结合性。这就是说，对运算符重载不改变运算的优先级和结合性，并且运算符重载后，也不改变运算符的语法结构，即单目运算符的语法结构只能冲仔尾单目运算符，双目运算符只能重载为双目运算符。</p>
</div>

<h1 id="4-编译程序如何选用那一个运算符函数？"><a href="#4-编译程序如何选用那一个运算符函数？" class="headerlink" title="4 编译程序如何选用那一个运算符函数？"></a>4 编译程序如何选用那一个运算符函数？</h1><div class="note warning simple"><p>运算符重载实际是一个函数，所以运算符的重载实际上是函数的重载。编译程序对运算符重载的选择，遵循着函数重载的算则原则。当遇到不很明显的运算时，编译程序将去寻找参数相匹配的运算符函数。</p>
</div>

<h1 id="5-重载你算符有哪些限制？"><a href="#5-重载你算符有哪些限制？" class="headerlink" title="5 重载你算符有哪些限制？"></a>5 重载你算符有哪些限制？</h1><div class="note success simple"><ul>
<li><p>不可臆造新的运算符。必须把重载运算符限制在C++语言中已有的运算符范围内的允许重载的运算符之中。</p>
</li>
<li><p>重载运算符坚持4个“不能改变”</p>
<ul>
<li>不能改变运算符操作数的个数；</li>
<li>不能改变运算符原有的优先级；</li>
<li>不能改变运算符原有的结核性；</li>
<li>不能改变运算符原有的语法结构。</li>
</ul>
</li>
</ul>
</div>

<h1 id="6-运算符重载时必须遵循哪些原则？"><a href="#6-运算符重载时必须遵循哪些原则？" class="headerlink" title="6 运算符重载时必须遵循哪些原则？"></a>6 运算符重载时必须遵循哪些原则？</h1>  <div class="note info simple"><p>运算符重载可以是程序更加简洁，是表达式更加直观，增加可读性。但是运算符重载使用不宜过多，否则会带来一定麻烦。</p>
<p>  使用重载运算符是应遵循如下原则：</p>
<ol>
<li>重载运算符含义必须清楚</li>
<li>重载运算符不能有二义性</li>
</ol>
</div>
<p>  以下是C++编程语言中的所有运算符的优先级和结合性列表。</p>
<table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">运算符</th>
<th align="left">叙述</th>
<th align="left">示例</th>
<th align="left">重载性</th>
<th align="left">结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>1</code></td>
<td align="left"><code>::</code></td>
<td align="left">作用域解析(C++专有)</td>
<td align="left"><code>Class::age = 2;</code></td>
<td align="left">否</td>
<td align="left">由左至右</td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>++</code></td>
<td align="left">后缀递增</td>
<td align="left">i++</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>--</code></td>
<td align="left">后缀递减</td>
<td align="left">i–</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>&#123;&#125;</code></td>
<td align="left">组合</td>
<td align="left">{i++;a*=i;}</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>()</code></td>
<td align="left">函数调用或变量初始化</td>
<td align="left">c_tor(int x, int y) : _x(x), _y(y * 10) {}</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>[]</code></td>
<td align="left">数组访问</td>
<td align="left">array[4] = 2;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>.</code></td>
<td align="left">以对象方式访问成员</td>
<td align="left">obj.age = 34;</td>
<td align="left">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>-&gt;</code></td>
<td align="left">以指针方式访问成员</td>
<td align="left">ptr-&gt;age = 34;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>dynamic_cast</code></td>
<td align="left">运行时检查类型转换(C++专有)</td>
<td align="left">Y&amp; y = dynamic_cast&lt;Y&amp;&gt;(x);</td>
<td align="left">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>static_cast</code></td>
<td align="left">未经检查的类型转换(C++专有)</td>
<td align="left">Y&amp; y = static_cast&lt;Y&amp;&gt;(x);</td>
<td align="left">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>reinterpret_cast</code></td>
<td align="left">重定义类型转换(C++专有)</td>
<td align="left">int const* p = reinterpret_cast&lt;int const*&gt;(0x1234);</td>
<td align="left">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>const_cast</code></td>
<td align="left">更改非常量属性(C++专有)</td>
<td align="left">int* q = const_cast&lt;int*&gt;(p);</td>
<td align="left">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>typeid</code></td>
<td align="left">获取类型信息(C++专有)</td>
<td align="left">std::type_info const&amp; t = typeid(x);</td>
<td align="left">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>++</code></td>
<td align="left">前缀递增</td>
<td align="left">++i</td>
<td align="left"></td>
<td align="left">由右至左</td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>--</code></td>
<td align="left">前缀递减</td>
<td align="left">–i</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>+</code></td>
<td align="left">一元正号</td>
<td align="left">int i = +1;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>-</code></td>
<td align="left">一元负号</td>
<td align="left">int i = -1;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>!</code> <code>not</code></td>
<td align="left">逻辑非 <code>!</code>的备用拼写</td>
<td align="left">if (!done) …</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>~</code> <code>compl</code></td>
<td align="left">按位取反 <code>~</code>的备用拼写</td>
<td align="left">flag1 = ~flag2;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>(*type*)</code></td>
<td align="left">强制类型转换</td>
<td align="left">int i = (int)floatNum;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>*</code></td>
<td align="left">取指针指向的值</td>
<td align="left">int data = *intPtr;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>&amp;</code></td>
<td align="left">取变量的地址</td>
<td align="left">int *intPtr = &data;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>sizeof</code></td>
<td align="left">某某的大小</td>
<td align="left">size_t s = sizeof(int);</td>
<td align="left">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>new</code></td>
<td align="left">动态内存分配(C++专有)</td>
<td align="left">long* pVar = new long;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>new[]</code></td>
<td align="left">动态数组内存分配(C++专有)</td>
<td align="left">long* array = new long[20];</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>delete</code></td>
<td align="left">动态内存释放(C++专有)</td>
<td align="left">delete pVar;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>delete[]</code></td>
<td align="left">动态数组内存释放(C++专有)</td>
<td align="left">delete [] array;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>4</code></td>
<td align="left"><code>.*</code></td>
<td align="left">成员对象选择(C++专有)</td>
<td align="left">obj.*var = 24;</td>
<td align="left">否</td>
<td align="left">由左至右</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>-&gt;*</code></td>
<td align="left">成员指针选择(C++专有)</td>
<td align="left">ptr-&gt;*var = 24;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>5</code></td>
<td align="left"><code>*</code></td>
<td align="left">乘法</td>
<td align="left">int i = 2 * 4;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>/</code></td>
<td align="left">除法</td>
<td align="left">float f = 10.0 / 3.0;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>%</code></td>
<td align="left">模数(取余)</td>
<td align="left">int rem = 4 % 3;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>6</code></td>
<td align="left"><code>+</code></td>
<td align="left">加法</td>
<td align="left">int i = 2 + 3;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>-</code></td>
<td align="left">减法</td>
<td align="left">int i = 5 - 1;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>7</code></td>
<td align="left"><code>&lt;&lt;</code></td>
<td align="left">比特左移</td>
<td align="left">int flags = 33 &lt;&lt; 1;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&gt;&gt;</code></td>
<td align="left">比特右移</td>
<td align="left">int flags = 33 &gt;&gt; 1;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>8</code></td>
<td align="left"><code>&lt;</code></td>
<td align="left">小于关系</td>
<td align="left">if (i &lt; 42) …</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&lt;=</code></td>
<td align="left">小于等于关系</td>
<td align="left">if (i &lt;= 42) …</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&gt;</code></td>
<td align="left">大于关系</td>
<td align="left">if (i &gt; 42) …</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>&gt;=</code></td>
<td align="left">大于等于关系</td>
<td align="left">if (i &gt;= 42) …</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>9</code></td>
<td align="left"><code>==</code> <code>eq</code></td>
<td align="left">等于关系 <code>==</code>的备用拼写</td>
<td align="left">if (i == 42) …</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>!=</code> <code>not_eq</code></td>
<td align="left">不等于关系 <code>!=</code>的备用拼写</td>
<td align="left">if (i != 42) …</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>10</code></td>
<td align="left"><code>&amp;</code> <code>bitand</code></td>
<td align="left">比特 AND <code>&amp;</code>的备用拼写</td>
<td align="left">flag1 = flag2 &amp; 42;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>11</code></td>
<td align="left"><code>^</code> <code>xor</code></td>
<td align="left">比特 XOR(独占or) <code>^</code>的备用拼写</td>
<td align="left">flag1 = flag2 ^ 42;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>12</code></td>
<td align="left">`</td>
<td align="left"><code> </code>bitor`</td>
<td align="left">比特 OR(包含or) `</td>
<td align="left">`的备用拼写</td>
<td align="left">flag1 = flag2 | 42;</td>
</tr>
<tr>
<td align="left"><code>13</code></td>
<td align="left"><code>&amp;&amp;</code> <code>and</code></td>
<td align="left">逻辑 AND <code>&amp;&amp;</code>的备用拼写</td>
<td align="left">if (conditionA &amp;&amp; conditionB) …</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>14</code></td>
<td align="left">`</td>
<td align="left"></td>
<td align="left"><code> </code>or`</td>
<td align="left">逻辑 OR `</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>15</code></td>
<td align="left"><code>*c*?*t*:*f*</code></td>
<td align="left">三元条件运算</td>
<td align="left">int i = a &gt; b ? a : b;</td>
<td align="left">否</td>
<td align="left">由右至左</td>
</tr>
<tr>
<td align="left"><code>16</code></td>
<td align="left"><code>=</code></td>
<td align="left">直接赋值</td>
<td align="left">int a = b;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>16</code></td>
<td align="left"><code>+=</code></td>
<td align="left">以和赋值</td>
<td align="left">a += 3;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>16</code></td>
<td align="left"><code>-=</code></td>
<td align="left">以差赋值</td>
<td align="left">b -= 4;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>16</code></td>
<td align="left"><code>*=</code></td>
<td align="left">以乘赋值</td>
<td align="left">a *= 5;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>16</code></td>
<td align="left"><code>/=</code></td>
<td align="left">以除赋值</td>
<td align="left">a /= 2;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>16</code></td>
<td align="left"><code>%=</code></td>
<td align="left">以取余数赋值</td>
<td align="left">a %= 3;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>16</code></td>
<td align="left"><code>&lt;&lt;=</code></td>
<td align="left">以比特左移赋值</td>
<td align="left">flags &lt;&lt;= 2;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>16</code></td>
<td align="left"><code>&gt;&gt;=</code></td>
<td align="left">以比特右移赋值</td>
<td align="left">flags &gt;&gt;= 2;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>16</code></td>
<td align="left"><code>&amp;=</code> <code>and_eq</code></td>
<td align="left">以比特AND赋值 <code>&amp;=</code>的备用拼写</td>
<td align="left">flags &amp;= new_flags;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>16</code></td>
<td align="left"><code>^=</code> <code>xor_eq</code></td>
<td align="left">以比特XOR赋值 <code>^=</code>的备用拼写</td>
<td align="left">flags ^= new_flags;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>16</code></td>
<td align="left">`</td>
<td align="left">=<code> </code>or_eq`</td>
<td align="left">以比特OR赋值 `</td>
<td align="left">=`的备用拼写</td>
<td align="left">flags |= new_flags;</td>
</tr>
<tr>
<td align="left"><code>17</code></td>
<td align="left"><code>throw</code></td>
<td align="left">抛出异常</td>
<td align="left">throw EClass(“Message”);</td>
<td align="left">否</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>18</code></td>
<td align="left"><code>,</code></td>
<td align="left">逗号运算符</td>
<td align="left">for (i = 0, j = 0; i &lt; 10; i++, j++) …</td>
<td align="left"></td>
<td align="left">由左至右</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
      <tags>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/posts/2362a8ea.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><div class="note simple"><p>学习记录，若有不足请指出来</p>
</div>

<span id="more"></span>

<h2 id="1-结点结构"><a href="#1-结点结构" class="headerlink" title="1 结点结构"></a>1 结点结构</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Definition for singly-linked list.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SinglyListNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    SinglyListNode *next;<br>    <span class="hljs-built_in">SinglyListNode</span>(<span class="hljs-keyword">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2 操作"></a>2 操作</h2><p>与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按索引来访问元素平均要花费<code>O(N)</code>时间，其中 N 是链表的长度。</p>
<h3 id="添加操作-单链表"><a href="#添加操作-单链表" class="headerlink" title="添加操作-单链表"></a>添加操作-单链表</h3><ol>
<li>令插入结点的next为其插入位置下结点</li>
</ol>
<ol start="2">
<li>原位置下一节点为要插入的结点即可</li>
</ol>
<img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gjnxikqzxrj30eb07rjra.jpg" alt="lianbiao1" width="515" data-width="515" data-height="279">

<p>与数组不同，我们不需要将所有元素移动到插入元素之后。因此，您可以在 O(1) 时间复杂度中将新结点插入到链表中，这非常高效。</p>
<h3 id="删除操作-单链表"><a href="#删除操作-单链表" class="headerlink" title="删除操作-单链表"></a>删除操作-单链表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//删除prev的下一结点</span><br>prev-&gt;next == prev-&gt;next -&gt;next;<br></code></pre></td></tr></table></figure>

<h3 id="删除第一个结点"><a href="#删除第一个结点" class="headerlink" title="删除第一个结点"></a>删除第一个结点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">SinglyListNode *deleteTopList = singlylistNode-&gt;next; <span class="hljs-comment">//singlyListnode为需要删除头结点的链表</span><br>singlylistnode -&gt; next = deletTopList;<br></code></pre></td></tr></table></figure>

<h2 id="3-设计链表"><a href="#3-设计链表" class="headerlink" title="3 设计链表"></a>3 设计链表</h2><p>设计链表的实现。</p>
<p>​    单链表中的节点属性：<code>val</code>和<code>next</code>(如果是双向链表，还需要属性prev以指示链表中的上一个节点)</p>
<p>在链表中需要实现的功能有：</p>
<ul>
<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ul>
<p><strong>代码</strong></p>
<blockquote>
<p>虽然看着很简单，但是还是要认真写才行</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLinkedList</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkedNode</span> &#123;</span><br>        <span class="hljs-keyword">int</span> val;<br>        LinkedNode* next;<br>        <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-keyword">int</span> val):<span class="hljs-built_in">val</span>(val),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>        <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-keyword">int</span> val,LinkedNode* next1):<span class="hljs-built_in">val</span>(val),<span class="hljs-built_in">next</span>(next1)&#123;&#125;<br>    &#125;;<br>  <br>    <span class="hljs-built_in">MyLinkedList</span>()&#123;<br>        dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-number">0</span>);<br>        _size = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index &gt; (_size - <span class="hljs-number">1</span>) || index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        LinkedNode* top = dummyHead-&gt;next;<br>        <span class="hljs-keyword">while</span>(index--)<br>            top = top-&gt;next;<br>        <span class="hljs-keyword">return</span> top-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        LinkedNode *second = dummyHead-&gt;next;<br>        LinkedNode* addNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val,second);<br>        dummyHead-&gt;next = addNode;<br>        _size++;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Append a node of value val to the last element of the linked list. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        LinkedNode* newNode=<span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* tail = dummyHead;<br>        <span class="hljs-keyword">while</span>(tail-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;<br>            tail = tail-&gt;next;<br>        &#125;<br>        tail -&gt; next = newNode;<br>        _size++;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>         <span class="hljs-keyword">if</span> (index &gt; _size ) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        LinkedNode * indexNode = dummyHead;<br>        <span class="hljs-keyword">while</span>(index--)&#123;<br>            indexNode = indexNode-&gt;next;<br>        &#125;<br>        LinkedNode* tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val,indexNode-&gt;next);<br>        indexNode-&gt;next = tmp;<br>        _size++; <br>    &#125;<br>    <br>    <span class="hljs-comment">/** Delete the index-th node in the linked list, if the index is valid. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= _size || index &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        LinkedNode* indexNode = dummyHead;<br>        <span class="hljs-keyword">while</span>(index--)&#123;<br>            indexNode = indexNode-&gt;next;<br>        &#125;<br>        LinkedNode* tmp = indexNode-&gt;next;<br>        indexNode-&gt;next = indexNode-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        _size--; <br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> _size;<br>    LinkedNode* dummyHead;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyLinkedList* obj = new MyLinkedList();</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(index);</span><br><span class="hljs-comment"> * obj-&gt;addAtHead(val);</span><br><span class="hljs-comment"> * obj-&gt;addAtTail(val);</span><br><span class="hljs-comment"> * obj-&gt;addAtIndex(index,val);</span><br><span class="hljs-comment"> * obj-&gt;deleteAtIndex(index);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序员内功</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表(自刷)</title>
    <url>/posts/464e9a9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><div class="note modern"><p><a href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9">两两交换链表中的节点</a></p>
<p><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">合并两个有序链表</a></p>
</div>

<span id="more"></span>





<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><div align="left"><img src="https://img.shields.io/badge/难度-中等-yellow"></div>

<h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; []<br>输出：[]<br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1]<br>输出：[1]<br></code></pre></td></tr></table></figure>
<p>提示：<br>链表中节点的数目在范围 [0, 100] 内<br>0 &lt;= Node.val &lt;= 100</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义一个虚拟头结点<code>dummylisty</code>，如果存在可以交换的节点，则按照题目要求把相应位置的节点插入到相应位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *dummyList =<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>,head);<br>        dummyList-&gt;next = head; <br>        <span class="hljs-keyword">if</span>(dummyList-&gt;next == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(head-&gt;next == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode *top = dummyList;<br>        <span class="hljs-keyword">while</span>(top-&gt;next!= <span class="hljs-literal">nullptr</span> &amp;&amp; top-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ListNode* tmp = top-&gt;next; <span class="hljs-comment">// 记录临时节点</span><br>            ListNode* tmp1 = top-&gt;next-&gt;next-&gt;next; <span class="hljs-comment">// 记录临时节点</span><br>           <br>            top-&gt;next = top-&gt;next-&gt;next;<br>            top-&gt;next-&gt;next = tmp;<br>            top-&gt;next-&gt;next-&gt;next = tmp1;<br>            <br>            top = top-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyList-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%AE%80%E5%8D%95-green"></p>
<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* retList = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* dummy = retList;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">nullptr</span> &amp;&amp; l2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;<br>                dummy-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dummy-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;               <br>            dummy = dummy-&gt;next;<br>        &#125;<br>        dummy-&gt;next = l1 == <span class="hljs-literal">NULL</span> ? l2 : l1;<br>        <span class="hljs-keyword">return</span> retList-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<p>示例1</p>
<p><strong>输入</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#123;1,2,3&#125;<br></code></pre></td></tr></table></figure>

<p><strong>返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#123;3,2,1&#125;<br></code></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct ListNode *next;</span><br><span class="hljs-comment">	ListNode(int x) :</span><br><span class="hljs-comment">			val(x), next(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        ListNode *pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode *cur = pHead;<br>        ListNode *nex = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            nex = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = nex;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h1 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h1><img src="https://img.shields.io/badge/难度-中等-yellow" align="left">

<h3 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h3><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>示例：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt;输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>&gt;输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>         <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* evenHead = head-&gt;next;<br>        ListNode* odd = head;<br>        ListNode* even = evenHead;<br>        <span class="hljs-keyword">while</span>(even != <span class="hljs-literal">nullptr</span> &amp;&amp; even-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            odd-&gt;next = even-&gt;next;<br>            odd = odd-&gt;next;<br>            even-&gt;next = odd-&gt;next;<br>            even = even-&gt;next;<br>        &#125;<br>        odd-&gt;next = evenHead;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n)O(n)，其中 nn 是链表的节点数。需要遍历链表中的每个节点，并更新指针。</p>
<p>空间复杂度：O(1)O(1)。只需要维护有限的指针。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组(自刷)</title>
    <url>/posts/dc95c5cc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><div class="note flat red no-icon simple"><p><a href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92">杨辉三角</a></p>
<p><a href="#%E5%8A%A0%E4%B8%80">加一</a></p>
<p><a href="#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9">删除排序数组中的重复项</a></p>
<p><a href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C">四数之和</a></p>
</div>

<span id="more"></span>

<h1 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h1><p><a href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></p>
<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br>在杨辉三角中，每个数是它左上方和右上方的数的和。<br>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: 5<br>输出:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]<br></code></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-keyword">int</span> numRows) &#123;<br>     <br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++)<br>        &#123;   <br>            vector&lt;<span class="hljs-keyword">int</span>&gt; row;<br>            row.<span class="hljs-built_in">resize</span>(i+<span class="hljs-number">1</span>);<br>            row[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>            row[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i<span class="hljs-number">-1</span>; j++)<br>            &#123;<br>               row[j] = res[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+res[i<span class="hljs-number">-1</span>][j];<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>      <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h1><p><a href="https://leetcode-cn.com/problems/plus-one/">66. 加一</a></p>
<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br></code></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。<br></code></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; digits)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = digits.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            digits[i]++;<br>            <span class="hljs-keyword">if</span>(digits[i]==<span class="hljs-number">10</span>) digits[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> digits;<br>        &#125;<br>        digits.<span class="hljs-built_in">insert</span>(digits.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> digits;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><h4 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a></h4><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">给定数组 nums &#x3D; [1,1,2], <br><br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 <br><br>你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],<br><br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br><br>你不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] != nums[i]) &#123;<br>                i++;<br>                nums[i] = nums[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="四树之和"><a href="#四树之和" class="headerlink" title="四树之和"></a>四树之和</h1><p><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。<br>注意：<br>答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。<br><br>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]<br></code></pre></td></tr></table></figure>

<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target) &#123;<br>        	<span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>	vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ret;<br>	<span class="hljs-keyword">int</span> length = nums.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> first = i + <span class="hljs-number">1</span>; first &lt; length - <span class="hljs-number">2</span>; first++)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (first &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[first] == nums[first - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>			<span class="hljs-keyword">int</span> second = first + <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">int</span> third = length - <span class="hljs-number">1</span>;<br><br>			<span class="hljs-keyword">while</span> (second &lt; third)<br>			&#123;<br>				<span class="hljs-keyword">int</span> sum = nums[first] + nums[second] + nums[third] + nums[i];<br>				cout &lt;&lt; <span class="hljs-string">&quot;sum:&quot;</span> &lt;&lt; sum &lt;&lt; <span class="hljs-string">&#x27;:&#x27;</span>;<br>				cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; nums[first] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; nums[second] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; nums[third] &lt;&lt; endl;<br>				<span class="hljs-keyword">if</span> (sum == target)<br>				&#123;<br>					ret.<span class="hljs-built_in">push_back</span>(&#123; nums[i] , nums[first] , nums[second] , nums[third] &#125;);<br>					<span class="hljs-keyword">while</span> (second &lt; third &amp;&amp; nums[second] == nums[second + <span class="hljs-number">1</span>]) ++second;   <span class="hljs-comment">//注意去重</span><br>					<span class="hljs-keyword">while</span> (second &lt; third &amp;&amp; nums[third] == nums[third - <span class="hljs-number">1</span>]) --third;<br>					third--;<br>					second++;<br>				&#125;<br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target)<br>					second++;<br>				<span class="hljs-keyword">else</span><br>					third--;<br>			&#125;<br>		&#125;<br><br>	&#125;<br>	<span class="hljs-keyword">return</span> ret;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>copy(自刷)</title>
    <url>/posts/undefined.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="副本文件"><a href="#副本文件" class="headerlink" title="副本文件"></a>副本文件</h1><p><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80">题目一</a></p>
<span id="more"></span>





<h1 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h1>]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>创建表</title>
    <url>/posts/undefined.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Oracle数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>创建数据库</title>
    <url>/posts/6cc82a18.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手动创建一个数据库"><a href="#手动创建一个数据库" class="headerlink" title="手动创建一个数据库"></a>手动创建一个数据库</h1><p><img src="https://img.shields.io/badge/-Oracle-yellowgreen"><img src="https://img.shields.io/badge/-%E6%95%B0%E6%8D%AE%E5%BA%93-green"></p>
<h2 id="1-要创建一个新的数据库，必须："><a href="#1-要创建一个新的数据库，必须：" class="headerlink" title="1 要创建一个新的数据库，必须："></a>1 要创建一个新的数据库，必须：</h2><p>（1）创建一个特权用户（超越数据库），用以下两种方式之一：<br>        a. 操作系统<br>        b. 使用口令文件<br>（2）启动实例所需的充足内存<br>（3）有足够的磁盘空间</p>
<p><strong>可以使用使用口令文件：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; orapwd<br></code></pre></td></tr></table></figure>

<img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gjmutng5nkj30e903xdfo.jpg" alt="oracle50" width="513" data-width="513" data-height="141">

<h2 id="2-创建口令文件并设值SID"><a href="#2-创建口令文件并设值SID" class="headerlink" title="2 创建口令文件并设值SID"></a>2 创建口令文件并设值SID</h2><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">&gt; orawpd file=d:\oracle\ora92\database\[fileName].ora password=admin entries=10;<br>&gt; <span class="hljs-built_in">set</span> oracle_sid=[userSid]<br>example:<br>&gt; orawpd file=d:\oracle\ora92\database\pwdming.ora password=admin entries=10;<br>&gt; <span class="hljs-built_in">set</span> oracle_sid=ming<br></code></pre></td></tr></table></figure>

<img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gjmuuak30bj30fp02bmwy.jpg" alt="和代码内容不一致mm->ming，按照自己的文件名和SID设置即可" width="565" data-width="565" data-height="83">

<h2 id="3-配置相关文件"><a href="#3-配置相关文件" class="headerlink" title="3 配置相关文件"></a>3 配置相关文件</h2><ol>
<li><p>把<code> d:\oracle\ora92\admin</code> 中的<code>sample</code>文件中复制到<code> d：\oracle\admin</code>下面，改名为<code> [fileName]</code>，建议<code>filename = [userSid]</code>,示例中的文件名是<code>ming</code></p>
</li>
<li><p>编辑 <code>ming</code>文件夹下<code>pfile\initsmple.ora</code>,改名为 <code>init.ora</code>,并修改以下参数：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs init.ora">db_name&#x3D;[username] #username为上一步配置的[UserSid]<br>control_file&#x3D;(“c:\oracle\oradate\[fileName]\control01.ctl”,”c:\oracle\oradata\[fileName]\contraol02.ctl”)<br>db_block_size &#x3D; 8192<br>example:<br>db_name&#x3D;[username] #username为上一步配置的[UserSid]<br>control_file&#x3D;(“c:\oracle\oradate\ming\control01.ctl”,”c:\oracle\oradata\ming\contraol02.ctl”)<br>db_block_size &#x3D; 8192<br></code></pre></td></tr></table></figure>

<p><strong>之后再注释掉以下几个属性</strong></p>
<p>​    - text_enable</p>
<p>​    - job_queue_interval</p>
<p>​    - distributed_transactions.</p>
<p>到此属性修改完毕，<mark>保存之后<code>复制</code>当前文件~init.ora~</mark>。</p>
<ol start="3">
<li><p>在 c:\oracle\database 创建文件夹<code>[fileName]</code>^我的文件名是“ming”^</p>
</li>
<li><p>把第二步复制的<code>init.ora</code>粘贴到 <code>d:\oracle\ora92\database</code>中，改名为</p>
<p><code>initming.ora</code> 文件名自定义，下一步<i class="fa fa-arrow-down" aria-hidden="true"></i>会用到。</p>
</li>
</ol>
<h2 id="4-创建实例"><a href="#4-创建实例" class="headerlink" title="4 创建实例"></a>4 创建实例</h2><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># [fileName]为3.4中的自定义文件名</span><br>&gt; oradim –NEW-SID [userSid] -INTPWD admin -pfile c:\oracle\ora92\database\[fileName].ora <br>example:<br>&gt; oradim –NEW-SID ming -INTPWD admin -pfile c:\oracle\ora92\database\initdyf.ora.<br></code></pre></td></tr></table></figure>

<img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gjmv8680x1j30fr01jt8h.jpg" alt="oracle52" width="567" data-width="567" data-height="55">

<h2 id="5-创建spfile-必须先启动实例"><a href="#5-创建spfile-必须先启动实例" class="headerlink" title="5 创建spfile(必须先启动实例)"></a>5 创建spfile(必须先启动实例)</h2><p>以<code>win7</code>为例启动实例在<code>开始-&gt;控制面板-&gt;管理工具-&gt;服务</code>,然后找到你创建的实例点击<strong>启动或重新启动</strong>即可。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">&gt; conn sys/password as sysbdba<br>&gt; shutdown immediate<br>&gt; startup nomount pfile=<span class="hljs-string">&#x27;c:\oracle\ora92\database\initming.ora&#x27;</span><br></code></pre></td></tr></table></figure>
<img src="https://tvax2.sinaimg.cn/large/0072YHp3ly1gjmvn380e1j30fn07lgll.jpg" alt="oracle53" width="563" data-width="563" data-height="273">

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; create spfile&#x3D;&#39;c:\oracle\ora92\database\spfileming.ora&#39; from pfile&#x3D;&#39;c:\oracle\ora92\database\initming.ora&#39;;<br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; create database [databaseName]<br>	Maxlogfiles 10<br>	Maxdatafiles 1024<br>	Maxinstances 2<br>	Datafile ‘c:\oracle\oradata\ming\system01.dbf’size 50m<br> Logfile<br> 	Group 1 ’c:\oracle\oradata\ming\red001.ora’ size 10m,<br>	Group 2 ’c:\oracle\oradata\ming\red002.ora’ size 10m;<br>example:<br>&gt; create database ming<br>	Maxlogfiles 10<br>	Maxdatafiles 1024<br>	Maxinstances 2<br>	Datafile &#39;c:\oracle\oradata\ming\system01.dbf&#39; size 50m<br> 	Logfile<br> 	Group 1 (&#39;c:\oracle\oradata\ming\red001.ora&#39;) size 10m,<br>	Group 2 (&#39;c:\oracle\oradata\ming\red002.ora&#39;) size 10m;<br></code></pre></td></tr></table></figure>

<p><code>spfile</code>创建语句建议手打~~~直接复制很可能会报错<i class="fa fa-exclamation" aria-hidden="true"></i> </p>
<img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gjmw53chuej30g906z74a.jpg" alt="oracle54 同样的一句话，手打的就可以运行，复制的报错" width="585" data-width="585" data-height="251">





<p>在创建数据库时尝试好几次会出现这个错误：</p>
<img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gjmy5f6rv1j30cx05jq2t.jpg" alt="oracle55-错误一" width="465" data-width="465" data-height="199">

<p>此时如果再继续创建的话，又会报如下错误：</p>
<img src="https://tva2.sinaimg.cn/large/0072YHp3ly1gjmy4m9eqij30dr07njrb.jpg" alt="oracle56-错误二" width="495" data-width="495" data-height="275">

<p>如果是上图错误（错误二），则可以尝试删除<code>C:\oracle\oradta\ming\</code>中创建的文件再次尝试是否可以成功创建。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Oracle数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo特殊符号使用</title>
    <url>/posts/c8319666.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="hexo特殊符号"><a href="#hexo特殊符号" class="headerlink" title="hexo特殊符号"></a>hexo特殊符号</h1><div class="note modern red icon simple"><i class="note-icon fa fa-bell"></i><p><strong>有些特殊符号不能使用所以只能使用替换的字符：</strong></p>
</div>

<div class="tabs" id="特殊符号对照"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#特殊符号对照-1">原符号</button></li><li class="tab"><button type="button" data-href="#特殊符号对照-2">转义字符</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="特殊符号对照-1"><p><strong>有些特殊符号不能使用所以只能使用替换的字符：</strong></p>
<p><strong>! ! — 惊叹号 Exclamation mark</strong><br><strong>” “ “ 双引号 Quotation mark</strong><br><strong># # — 数字标志 Number sign</strong><br><strong>$ $ — 美元标志 Dollar sign</strong><br><strong>% % — 百分号 Percent sign</strong><br><strong>&amp; &amp; &amp; Ampersand</strong><br><strong>‘ ‘ — 单引号 Apostrophe</strong><br><strong>( ( — 小括号左边部分 Left parenthesis</strong><br><strong>) ) — 小括号右边部分 Right parenthesis</strong><br>*** * — 星号 Asterisk**<br><strong>+ + — 加号 Plus sign</strong><br><strong>&lt; &lt; &lt; 小于号 Less than**<br>**= = — 等于符号 Equals sign**<br>**- - − — 减号**<br>**&gt; &gt; &gt; 大于号 Greater than</strong><br><strong>? ? — 问号 Question mark</strong><br><strong>@ @ — Commercial at</strong><br><strong>[ [ — 中括号左边部分 Left square bracket</strong><br><strong>\ \ — 反斜杠 Reverse solidus (backslash)</strong><br><strong>] ] — 中括号右边部分 Right square bracket</strong><br><strong>{ { — 大括号左边部分 Left curly brace</strong><br><strong>| | — 竖线Vertical bar</strong><br><strong>} } — 大括号右边部分 Right curly brace</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="特殊符号对照-2"><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">! &amp;#33; — 惊叹号 Exclamation mark<br>” &amp;#34; &quot; 双引号 Quotation mark<br># &amp;#35; — 数字标志 Number sign<br>$ &amp;#36; — 美元标志 Dollar sign<br>% &amp;#37; — 百分号 Percent sign<br>&amp; &amp;#38; &amp; Ampersand<br>‘ &#39; — 单引号 Apostrophe<br>( &amp;#40; — 小括号左边部分 Left parenthesis<br>) &amp;#41; — 小括号右边部分 Right parenthesis<br>* &amp;#42; — 星号 Asterisk<br>+ &amp;#43; — 加号 Plus sign<br>&lt; &amp;#60; &lt; 小于号 Less than<br>&#x3D; &amp;#61; — 等于符号 Equals sign<br>- &amp;#45; &amp;minus; — 减号<br>&gt; &amp;#62; &gt; 大于号 Greater than<br>? &amp;#63; — 问号 Question mark<br>@ &amp;#64; — Commercial at<br>[ &amp;#91; --- 中括号左边部分 Left square bracket<br>\ &amp;#92; --- 反斜杠 Reverse solidus (backslash)<br>] &amp;#93; — 中括号右边部分 Right square bracket<br>&#123; &amp;#123; — 大括号左边部分 Left curly brace<br>| &amp;#124; — 竖线Vertical bar<br>&#125; &amp;#125; — 大括号右边部分 Right curly brace<br></code></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Butterfly内置标签</title>
    <url>/posts/d21884bc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Butterfly主题内置标签"><a href="#Butterfly主题内置标签" class="headerlink" title="Butterfly主题内置标签"></a>Butterfly主题内置标签<i class="fa fa-tag" aria-hidden="true"></i></h1><div class="note modern blue no-icon simple"><p><i class="fa fa-tag" aria-hidden="true"></i> 本篇为hexo Butterfly主题内置标签的一些使用样例，供参考使用</p>
</div>

<span id="more"></span>






<h1 id="1-Block-Quote"><a href="#1-Block-Quote" class="headerlink" title="1,Block Quote"></a>1,Block Quote</h1><h1 id="2-Code-Block"><a href="#2-Code-Block" class="headerlink" title="2,Code Block"></a>2,Code Block</h1><h1 id="3-Backtick-Code-Block"><a href="#3-Backtick-Code-Block" class="headerlink" title="3,Backtick Code Block"></a>3,Backtick Code Block</h1><h1 id="4-Pull-Quote"><a href="#4-Pull-Quote" class="headerlink" title="4,Pull Quote"></a>4,Pull Quote</h1><h1 id="5-tag-hide"><a href="#5-tag-hide" class="headerlink" title="5,tag-hide"></a>5,tag-hide</h1><div class="tabs" id="tag-hide"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tag-hide-1">Inline</button></li><li class="tab"><button type="button" data-href="#tag-hide-2">Block</button></li><li class="tab"><button type="button" data-href="#tag-hide-3">Toggle</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tag-hide-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% hideInline content,display,bg,color %&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>content: 文本内容</p>
</li>
<li><p>display: 按钮显示的文字(可选)</p>
</li>
<li><p>bg: 按钮的背景颜色(可选)</p>
</li>
<li><p>color: 按钮文字的颜色(可选)</p>
</li>
</ul>
<p><strong>Demo:</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs MARKDOWN">哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;<br><br>门里站着一个人? &#123;% hideInline 闪 %&#125;<br></code></pre></td></tr></table></figure>

<p>哪个英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案<br>  </button><span class="hide-content">因为西装裤(C装酷)</span></span></p>
<p>门里站着一个人? <span class="hide-inline"><button type="button" class="hide-button button--animated" style>Click<br>  </button><span class="hide-content">闪</span></span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tag-hide-2"><p><code>Block</code>独立的block隐藏内容，可以隐藏很多内容，包括图片，代码块等等</p>
<p>( display 不能包含英文逗号，可用<code>&amp;sbquo;</code>)</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% hideBlock display,bg,color %&#125;<br>content<br>&#123;% endhideBlock %&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>content: 文本内容</li>
<li>display: 按钮显示的文字(可选)</li>
<li>bg: 按钮的背景颜色(可选)</li>
<li>color: 按钮文字的颜色(可选)</li>
</ul>
<p><strong>Demo:</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">查看答案<br>&#123;% hideBlock 1+1=？ %&#125;<br>2<br>&#123;% endhideBlock %&#125;<br></code></pre></td></tr></table></figure>

<p>查看答案</p>
<div class="hide-block"><button type="button" class="hide-button button--animated" style>1+1=
    </button><div class="hide-content"><p>2</p>
</div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tag-hide-3"><p>如果你需要展示的内容太多，可以把它隐藏在收缩框里，需要时再把它展开。</p>
<p>( display 不能包含英文逗号，可用<code>&amp;sbquo;</code>)</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% hideToggle display,bg,color %&#125;<br>content<br>&#123;% endhideToggle %&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Demo:</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% hideToggle Butterfly安装方法 %&#125;<br>在你的博客根目录里<br>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly<br>如果想要安装比较新的dev分支，可以<br>git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly<br>&#123;% endhideToggle %&#125;<br></code></pre></td></tr></table></figure>

<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>Butterfly安装方法</span></div>
    <div class="hide-content"><p>在你的博客根目录里<br>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly<br>如果想要安装比较新的dev分支，可以<br>git clone -b dev <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly</p>
</div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>


<h1 id="6-Gist"><a href="#6-Gist" class="headerlink" title="6,Gist"></a>6,Gist</h1><h1 id="7-iframe"><a href="#7-iframe" class="headerlink" title="7,iframe"></a>7,iframe</h1><iframe src="https://mingsrc.work/" cols="50%,50%" heigth="500px" width="100%" style="width:100%;height:500px;scroll-x:auto;"></iframe>

<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://mingsrc.work&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;50%,50%&quot;</span> <span class="hljs-attr">heigth</span>=<span class="hljs-string">500px</span> <span class="hljs-attr">width</span>=<span class="hljs-string">100%</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100%;height:500px;scroll-x:auto;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h1 id="8-Image"><a href="#8-Image" class="headerlink" title="8,Image"></a>8,Image</h1><p>插入具有指定尺寸的图像。</p>
<p><code>[classname]</code>可选 </p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% img [class names] /path/to/image [width] [height] &#x27;&quot;title text&quot; &quot;alt text&quot;&#x27; %&#125;<br>example:<br>&#123;% img https://tvax3.sinaimg.cn/large/0072YHp3ly1gjlriqpyayj30hs0hswf6.jpg  100 100 &#x27;&quot;博客头像&quot; &quot;头像&quot;&#x27; %&#125;<br></code></pre></td></tr></table></figure>

<img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjlriqpyayj30hs0hswf6.jpg" class width="100" height="100" title="博客头像" alt="头像">

<h1 id="9-Link"><a href="#9-Link" class="headerlink" title="9,Link"></a>9,Link</h1><p>插入具有<code>target =“ _ blank”</code>属性的链接。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% link text url [external] [title] %&#125;<br>example:<br>&#123;% link 博客首页,https://fole-del.github.io , https://tva1.sinaimg.cn/large/0072YHp3ly1gjtb4cmbnjj31s516lav7.jpg %&#125;<br></code></pre></td></tr></table></figure>

<div class="tag link"><a class="link-card" title="博客首页" href="https://fole-del.github.io"><div class="left"><img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gjtb4cmbnjj31s516lav7.jpg"></div><div class="right"><p class="text">博客首页</p><p class="url">https://fole-del.github.io</p></div></a></div>

<h1 id="10-Include-Code"><a href="#10-Include-Code" class="headerlink" title="10,Include Code"></a>10,Include Code</h1><p>将代码段插入到<code>source / downloads / code</code>文件夹中。可以通过配置中的<code>code_dir</code>选项指定文件夹位置。</p>
<h1 id="11-Checkbox"><a href="#11-Checkbox" class="headerlink" title="11,Checkbox"></a>11,Checkbox</h1><div class="checkbox"><input type="checkbox">
            <p>纯文本测试</p>
            </div>
<div class="checkbox checked"><input type="checkbox" checked="checked">
            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>
            </div>
<div class="checkbox red"><input type="checkbox">
            <p>支持自定义颜色</p>
            </div>
<div class="checkbox green checked"><input type="checkbox" checked="checked">
            <p>绿色 + 默认选中</p>
            </div>
<div class="checkbox yellow checked"><input type="checkbox" checked="checked">
            <p>黄色 + 默认选中</p>
            </div>
<div class="checkbox cyan checked"><input type="checkbox" checked="checked">
            <p>青色 + 默认选中</p>
            </div>
<div class="checkbox blue checked"><input type="checkbox" checked="checked">
            <p>蓝色 + 默认选中</p>
            </div>
<div class="checkbox plus green checked"><input type="checkbox" checked="checked">
            <p>增加</p>
            </div>
<div class="checkbox minus yellow checked"><input type="checkbox" checked="checked">
            <p>减少</p>
            </div>
<div class="checkbox times red checked"><input type="checkbox" checked="checked">
            <p>叉</p>
            </div>
<div class="checkbox"><input type="radio">
            <p>纯文本测试</p>
            </div>
<div class="checkbox checked"><input type="radio" checked="checked">
            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>
            </div>
<div class="checkbox red"><input type="radio">
            <p>支持自定义颜色</p>
            </div>
<div class="checkbox green"><input type="radio">
            <p>绿色</p>
            </div>
<div class="checkbox yellow"><input type="radio">
            <p>黄色</p>
            </div>
<div class="checkbox cyan"><input type="radio">
            <p>青色</p>
            </div>
<div class="checkbox blue"><input type="radio">
            <p>蓝色</p>
            </div>

<h1 id="12-Vimeo"><a href="#12-Vimeo" class="headerlink" title="12,Vimeo"></a>12,Vimeo</h1><p>插入自适应或指定大小的Vimeo视频。</p>
<h1 id="13-Include-Posts"><a href="#13-Include-Posts" class="headerlink" title="13,Include Posts"></a>13,Include Posts</h1><h1 id="14-Include-Assets"><a href="#14-Include-Assets" class="headerlink" title="14,Include Assets"></a>14,Include Assets</h1><h1 id="15-Raw"><a href="#15-Raw" class="headerlink" title="15,Raw"></a>15,Raw</h1>]]></content>
      <categories>
        <category>hexo</category>
        <category>butterfly</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows右键添加Windows Terminal</title>
    <url>/posts/3a70d3a5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Windows-Terminal添加到鼠标右键"><a href="#Windows-Terminal添加到鼠标右键" class="headerlink" title="Windows Terminal添加到鼠标右键"></a>Windows Terminal添加到鼠标右键</h1><div class="note modern purple icon simple"><i class="note-icon fa fa-terminal"></i><p><strong>Windows Terminal 右键顺滑上手</strong></p>
<p>折腾博客主题的时候看见了Windows Terminal的快捷打开方式，那就试试~</p>
</div>

<p>如果Windows上有比从cmd和PowerShell好用的终端，还能添加到鼠标右键菜单，你想要试试吗?</p>
<h2 id="下载Windows-Terminal"><a href="#下载Windows-Terminal" class="headerlink" title="下载Windows Terminal"></a>下载Windows Terminal</h2><p><a href="https://www.microsoft.com/zh-cn/p/windows-terminal-preview/9n0dx20hk701?activetab=pivot:overviewtab">Windows Teriminl</a></p>
<p>并且，这个是支持自己去编译的，如果你够厉害，可以根据自己需要修改源文件，github上有源文件。</p>
<p><a href="https://github.com/microsoft/terminal">GitHub - microsoft/terminal: The new Windows Terminal, and the original Windows console host - all in the same place!</a></p>
<h2 id="添加Windows-Terminal到右键菜单"><a href="#添加Windows-Terminal到右键菜单" class="headerlink" title="添加Windows Terminal到右键菜单"></a>添加Windows Terminal到右键菜单</h2><h3 id="测试变量"><a href="#测试变量" class="headerlink" title="测试变量"></a>测试变量</h3><p>先检测下边两个变量是否可以正常输出</p>
<ul>
<li>第一种：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> %USERPROFILE%<br><span class="hljs-built_in">echo</span> %LOCALAPPDATA%<br></code></pre></td></tr></table></figure>

<p>如果输出的是<code>%USERPROFILE%</code>和<code>%LOCALAPPDATA%</code>或者报错的情况下,替换掉<code>%USERPROFILE%</code>和<code>%LOCALAPPDATA%</code>，如下所示，在reg文档中同样：</p>
<ul>
<li>第二种：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> C:\Users\[userName]<br><span class="hljs-built_in">echo</span> C:\Users\[userName]\AppData\Local<br></code></pre></td></tr></table></figure>

<p>如果使用的是第一种，后边的命令行就都可以使用第一种，如果是第二种，后边操作中的文件路径都使用<mark>绝对路径</mark></p>
<p><code>[userName]</code>是你的用户名</p>
<img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gjmavezmhkj30fn04bgls.jpg" alt="image" width="563" data-width="563" data-height="155">

<h3 id="创建terminal文件夹"><a href="#创建terminal文件夹" class="headerlink" title="创建terminal文件夹"></a>创建terminal文件夹</h3><p>打开命令行，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mkdir &quot;%USERPROFILE%\AppData\Local\terminal&quot;<br></code></pre></td></tr></table></figure>

<p>或者直接在<mark>文件管理器</mark><code>[userName]\AppData\Local\</code>直接新建<mark>teriminal</mark>文件夹。</p>
<h3 id="写入注册表"><a href="#写入注册表" class="headerlink" title="写入注册表"></a>写入注册表</h3><p>在Terminal中创建txt文档，后缀名为<code>reg</code>， 右键菜单会出现<code>Windows Terminal</code>的当时有两种，一种是：<code>shift</code>+<code>鼠标右键</code>，另一种是：<code>鼠标右键</code>。接下来根据自己需要选择两种方式中的一种即可：</p>
<ul>
<li><code>shift</code>+<code>鼠标右键</code></li>
</ul>
<p>把下边的内容复制到reg中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">Windows Registry Editor Version 5.00<br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]<br>@=<span class="hljs-string">&quot;Windows Terminal&quot;</span><br><span class="hljs-string">&quot;Extended&quot;</span>=<span class="hljs-string">&quot;&quot;</span><br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\<span class="hljs-built_in">command</span>]<br>@=<span class="hljs-string">&quot;C:\\Users\\[userName]\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</span><br></code></pre></td></tr></table></figure>

<p><mark>注意</mark>:需要把[userName]改为自己电脑的用户名</p>
<ul>
<li><code>右键</code></li>
</ul>
<p>把下边内容复制到reg中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">Windows Registry Editor Version 5.00<br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]<br>@=<span class="hljs-string">&quot;Windows terminal here&quot;</span><br><br>[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\<span class="hljs-built_in">command</span>]<br>@=<span class="hljs-string">&quot;C:\\Users\\[userName]\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</span><br></code></pre></td></tr></table></figure>

<p><mark>注意</mark>:需要把[userName]改为自己电脑的用户名</p>
<h3 id="修改Windows-Terminal的profile-json"><a href="#修改Windows-Terminal的profile-json" class="headerlink" title="修改Windows Terminal的profile.json"></a>修改<mark>Windows Terminal</mark>的<mark>profile.json</mark></h3><p>打开profile.json</p>
<img src="https://tvax1.sinaimg.cn/large/0072YHp3ly1gjmbb19qllj30vd0mtacg.jpg" alt="image" width="1129" data-width="1129" data-height="821">





<p>然后按照下图修改对应的内容就可以：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-string">&quot;startingDirectory&quot;</span>: null<br></code></pre></td></tr></table></figure>

<img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjmbbymoxrj30ix0j3jsf.jpg" alt="image" width="681" data-width="681" data-height="687">

<p>到此，就成功把Terminal添加到鼠标右键了</p>
<img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gjmbgk0sg3j30bc0d8793.jpg" alt="2020-10-12 (2)" width="408" data-width="408" data-height="476">

<h1 id="一些常用的键与命令"><a href="#一些常用的键与命令" class="headerlink" title="一些常用的键与命令"></a>一些常用的键与命令</h1><ol>
<li><kbd>tab</kbd> 命令补全</li>
<li><code>ls</code>  查看文件及文件结构</li>
<li><code>type</code> 查看文件内容<ul>
<li>直接输入文件名会用默认应用打开</li>
</ul>
</li>
<li><code>cd</code> 切换工作目录</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>Windows系列</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>桌面美化</tag>
        <tag>快捷方式</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows不常用快捷键合集</title>
    <url>/posts/d8fac1ab.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Windows不常用快捷键"><a href="#Windows不常用快捷键" class="headerlink" title="Windows不常用快捷键"></a>Windows不常用快捷键</h1><blockquote>
<p>单纯敲键盘比鼠标快的原因，所以整理一些不常用的快捷键给想要速度更快的你</p>
</blockquote>
<span id="more"></span>

<p><img src="https://pic1.zhimg.com/v2-0cc09a51bf30dbaaaa3ed7f9c6c53e1a_r.jpg?source=1940ef5c" alt="preview"></p>
<div class="note [success] [no-icon] [flat] simple"><p>Windows快捷键</p>
</div>

<h1 id="窗口放大缩小快捷键"><a href="#窗口放大缩小快捷键" class="headerlink" title="窗口放大缩小快捷键"></a>窗口放大缩小快捷键</h1><h2 id="最大化"><a href="#最大化" class="headerlink" title="最大化"></a>最大化</h2><p><code>Alt</code>+<code>Space</code>+<code>X</code></p>
<h2 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h2><p><code>Alt</code>+<code>Space</code>+<code>N</code></p>
<h2 id="改变窗口大小"><a href="#改变窗口大小" class="headerlink" title="改变窗口大小"></a>改变窗口大小</h2><p><code>Alt</code>+<code>Space</code>+<code>S</code></p>
<h2 id="多个窗口切换"><a href="#多个窗口切换" class="headerlink" title="多个窗口切换"></a>多个窗口切换</h2><p><code>alt</code>+<code>tab</code></p>
<h2 id="最小化所有窗口"><a href="#最小化所有窗口" class="headerlink" title="最小化所有窗口"></a>最小化所有窗口</h2><p><code>Windows</code>+<code>M</code></p>
<h2 id="全部最小化-即显示zhi桌面"><a href="#全部最小化-即显示zhi桌面" class="headerlink" title="全部最小化(即显示zhi桌面)"></a>全部最小化(即显示zhi桌面)</h2><p><code>WIN</code>+<code>D</code></p>
<h2 id="最大化窗口"><a href="#最大化窗口" class="headerlink" title="最大化窗口"></a>最大化窗口</h2><p><code>win</code>+<code>↑（方向键上）</code></p>
<h2 id="往下缩放窗口。"><a href="#往下缩放窗口。" class="headerlink" title="往下缩放窗口。"></a>往下缩放窗口。</h2><p><code>win</code>+<code>↓（方向键下）</code></p>
<h2 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h2><p><kbd>Win</kbd>+<kbd>Shift</kbd>+<kbd>s</kbd></p>
]]></content>
      <categories>
        <category>Windows系列</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>桌面美化</tag>
        <tag>快捷方式</tag>
      </tags>
  </entry>
  <entry>
    <title>Butterfly主题使用帮助</title>
    <url>/posts/d9efe45d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Butterfly-常用操作"><a href="#Butterfly-常用操作" class="headerlink" title="Butterfly 常用操作"></a>Butterfly 常用操作</h1><blockquote>
<p>详细配置参考：</p>
<p>作者: Jerry<br>連結: <a href="https://demo.jerryc.me/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A">https://demo.jerryc.me/posts/4aa8abbe/#Gallery%E7%9B%B8%E5%86%8A</a><br>來源: Butterfly</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">title:<br>date:<br>updated:<br>tags:<br>categories:<br>keywords:<br>description:<br>top_img:<br>comments:<br>cover:<br>toc:<br>toc_number:<br>auto_open:<br>copyright:<br>copyright_author:<br>copyright_author_href:<br>copyright_url:<br>copyright_info:<br>mathjax:<br>katex:<br>aplayer:<br>highlight_shrink:<br></code></pre></td></tr></table></figure>

<p>静态页面的一些属性：</p>
<table>
<thead>
<tr>
<th>写法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>【必需】文章标题</td>
</tr>
<tr>
<td>date</td>
<td>【必需】文章创建日期</td>
</tr>
<tr>
<td>updated</td>
<td>【可选】文章更新日期</td>
</tr>
<tr>
<td>tags</td>
<td>【可选】文章标签</td>
</tr>
<tr>
<td>categories</td>
<td>【可选】文章分类</td>
</tr>
<tr>
<td>keywords</td>
<td>【可选】文章关键字</td>
</tr>
<tr>
<td>description</td>
<td>【可选】文章描述</td>
</tr>
<tr>
<td>top_img</td>
<td>【可选】文章顶部图片</td>
</tr>
<tr>
<td>cover</td>
<td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将展示缩略图，可设置为false/图片地址/留空)</td>
</tr>
<tr>
<td>comments</td>
<td>【可选】显示文章评论模块(默认 true)</td>
</tr>
<tr>
<td>toc</td>
<td>【可选】显示文章TOC(默认设置为toc的enable配置)</td>
</tr>
<tr>
<td>toc_number</td>
<td>【可选】显示toc_number(默认设置为toc的number配置)</td>
</tr>
<tr>
<td>auto_open</td>
<td>【可选】是否自动打开TOC(默认设置为toc的auto_open配置)</td>
</tr>
<tr>
<td>copyright</td>
<td>【可选】显示文章版权(默认设置为post_copyright的enable配置)</td>
</tr>
<tr>
<td>copyright_author</td>
<td>【可选】文章版的文章作者</td>
</tr>
<tr>
<td>copyright_author_href</td>
<td>【可选】文章版权模块的文章作者链接</td>
</tr>
<tr>
<td>copyright_url</td>
<td>【可选】文章版权模块的文章連結链接</td>
</tr>
<tr>
<td>copyright_info</td>
<td>【可选】文章版版权模块的版权声明文字</td>
</tr>
<tr>
<td>mathjax</td>
<td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td>
</tr>
<tr>
<td>katex</td>
<td>【可选】显示katex(当设置katex的per_page: false時，才需要配置，默认 false)</td>
</tr>
<tr>
<td>aplayer</td>
<td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐配置</td>
</tr>
<tr>
<td>highlight_shrink</td>
<td>【可选】配置代码块是否展开(true/false)(默认值为highlight_shrink的配置)</td>
</tr>
</tbody></table>
<h2 id="1-标签"><a href="#1-标签" class="headerlink" title="1 标签"></a>1 标签</h2><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% note [class] [no-icon] [style] %&#125;<br>Any content (support inline tags too.io).<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Demo："><a href="#Demo：" class="headerlink" title="Demo："></a>Demo：</h3><div class="note [class] [no-icon] [style] simple"><p>Any content (support inline tags too.io).</p>
</div>

<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>【可选】标识，不同的标识有不同的配色<br>（ default / primary / success / info / warning / danger ）</td>
</tr>
<tr>
<td>no-icon</td>
<td>【可选】不显示 icon</td>
</tr>
<tr>
<td>style</td>
<td>【可选】可以覆盖配置中的 style<br>（simple/modern/flat/disabled）</td>
</tr>
</tbody></table>
<p>用法二：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% note [color] [icon] [style] %&#125;<br>Any content (support inline tags too.io).<br>&#123;% endnote %&#125;<br>Demo：<br>&#123;% note orange  &#x27;fas fa-lab&#x27; green %&#125;<br>Any content (support inline tags too.io).<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure>

<div class="note orange fas fa-lab green simple"><p>Any content (support inline tags too.io).</p>
</div>

<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>【可选】顔色<br>(default / blue / pink / red / purple / orange / green)</td>
</tr>
<tr>
<td>icon</td>
<td>【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td>
</tr>
<tr>
<td>style</td>
<td>【可选】可以覆盖配置中的 style<br>（simple/modern/flat/disabled）</td>
</tr>
</tbody></table>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a><strong>样例</strong></h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">第一种格式</button></li><li class="tab"><button type="button" data-href="#test1-2">第二种格式</button></li><li class="tab"><button type="button" data-href="#test1-3">第三种格式</button></li><li class="tab"><button type="button" data-href="#test1-4">对比</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% note simple %&#125;<br>默认 提示块标籤<br>&#123;% endnote %&#125;<br><br>&#123;% note default simple %&#125;<br>default 提示块标籤<br>&#123;% endnote %&#125;<br><br>&#123;% note primary simple %&#125;<br>primary 提示块标籤<br>&#123;% endnote %&#125;<br><br>&#123;% note success simple %&#125;<br>success 提示块标籤<br>&#123;% endnote %&#125;<br><br>&#123;% note info simple %&#125;<br>info 提示块标籤<br>&#123;% endnote %&#125;<br><br>&#123;% note warning simple %&#125;<br>warning 提示块标籤<br>&#123;% endnote %&#125;<br><br>&#123;% note danger simple %&#125;<br>danger 提示块标籤<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure>



<div class="note simple"><p>默认 提示块标籤</p>
</div>

<div class="note default simple"><p>default 提示块标籤</p>
</div>

<div class="note primary simple"><p>primary 提示块标籤</p>
</div>

<div class="note success simple"><p>success 提示块标籤</p>
</div>

<div class="note info simple"><p>info 提示块标籤</p>
</div>

<div class="note warning simple"><p>warning 提示块标籤</p>
</div>

<div class="note danger simple"><p>danger 提示块标籤</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;<br>你是刷 Visa 還是 UnionPay<br>&#123;% endnote %&#125;<br>&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;<br>2021年快到了....<br>&#123;% endnote %&#125;<br>&#123;% note pink &#x27;fas fa-car-crash&#x27; modern  %&#125;<br>小心開車 安全至上<br>&#123;% endnote %&#125;<br>&#123;% note red &#x27;fas fa-fan&#x27; modern  %&#125;<br>這是三片呢？還是四片？<br>&#123;% endnote %&#125;<br>&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;<br>你是刷 Visa 還是 UnionPay<br>&#123;% endnote %&#125;<br>&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;<br>剪刀石頭布<br>&#123;% endnote %&#125;<br>&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;<br>前端最討厭的瀏覽器<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure>



<div class="note icon modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 還是 UnionPay</p>
</div>
<div class="note blue icon modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p>
</div>
<div class="note pink icon modern"><i class="note-icon fas fa-car-crash"></i><p>小心開車 安全至上</p>
</div>
<div class="note red icon modern"><i class="note-icon fas fa-fan"></i><p>這是三片呢？還是四片？</p>
</div>
<div class="note orange icon modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 還是 UnionPay</p>
</div>
<div class="note purple icon modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石頭布</p>
</div>
<div class="note green icon modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最討厭的瀏覽器</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% note no-icon flat %&#125;<br>你是刷 Visa 還是 UnionPay<br>&#123;% endnote %&#125;<br>&#123;% note blue no-icon flat %&#125;<br>2021年快到了....<br>&#123;% endnote %&#125;<br>&#123;% note pink &#x27;fa fa-bicycle flat %&#125;<br>小心開車 安全至上<br>&#123;% endnote %&#125;<br>&#123;% note red no-icon flat %&#125;<br>這是三片呢？還是四片？<br>&#123;% endnote %&#125;<br>&#123;% note orange no-icon flat %&#125;<br>你是刷 Visa 還是 UnionPay<br>&#123;% endnote %&#125;<br>&#123;% note purple no-icon flat %&#125;<br>剪刀石頭布<br>&#123;% endnote %&#125;<br>&#123;% note green no-icon flat %&#125;<br>前端最討厭的瀏覽器<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure>



<div class="note no-icon flat"><p>你是刷 Visa 還是 UnionPay</p>
</div>
<div class="note blue no-icon flat"><p>2021年快到了….</p>
</div>
<div class="note pink icon flat"><i class="note-icon fa fa-bicycle"></i><p>小心開車 安全至上</p>
</div>
<div class="note red no-icon flat"><p>這是三片呢？還是四片？</p>
</div>
<div class="note orange no-icon flat"><p>你是刷 Visa 還是 UnionPay</p>
</div>
<div class="note purple no-icon flat"><p>剪刀石頭布</p>
</div>
<div class="note green no-icon flat"><p>前端最討厭的瀏覽器</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% note no-icon flat %&#125;<br>2021年快到了....<br>&#123;% endnote %&#125;<br>&#123;% note blue no-icon modern %&#125;<br>2021年快到了....<br>&#123;% endnote %&#125;<br>&#123;% note pink &#x27;fa fa-bicycle&#x27; simple %&#125;<br>2021年快到了....<br>&#123;% endnote %&#125;<br>&#123;% note red no-icon disabled  %&#125;<br>2021年快到了....<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure>



<div class="note danger icon flat"><i class="note-icon fa fa-bicycle"></i><p>flat 提示块标籤</p>
</div>
<div class="note danger icon modern"><i class="note-icon fa fa-bicycle"></i><p>modern提示块标籤</p>
</div>
<div class="note danger icon simple"><i class="note-icon fa fa-bicycle"></i><p>simple  提示块标籤</p>
</div>
<div class="note danger icon disabled"><i class="note-icon fa fa-bicycle"></i><p>disabled 提示块标籤</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h2 id="2-butterfly内置标签"><a href="#2-butterfly内置标签" class="headerlink" title="2 butterfly内置标签"></a>2 butterfly内置标签</h2><table>
<thead>
<tr>
<th>标签名</th>
<th>语法</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>行内文本</td>
<td>span 样式参数, 文本内容</td>
<td>logo, code，red, yellow, green, cyan, blue, gray，<br>small, h4, h3, h2, h1, large, huge, ultra，left, center, right</td>
</tr>
<tr>
<td>独立文本</td>
<td>p 样式参数, 文本内容</td>
<td>同上</td>
</tr>
<tr>
<td>普通标签</td>
<td>note 样式参数, 文本内容</td>
<td>quote, info, warning, done/success, error/danger， quote（蓝色引号）<br>info（蓝色叹号）warning(黄色叹号),done（绿色打钩）<br>success（绿色打钩）,error(红色禁止),danger(红色打叉)</td>
</tr>
<tr>
<td>块状标签</td>
<td>noteblock 样式参数  文本段落</td>
<td>同上</td>
</tr>
<tr>
<td>上标式标签</td>
<td>tip 样式参数, 文本内容</td>
<td>空(蓝色叹号上标),success (绿色打钩上标),error(红色叉上标),warning(黄色叹号上标)</td>
</tr>
<tr>
<td>动画标签</td>
<td>tip 标签图标样式 动画效果 文本内容</td>
<td>标签图标样式参考普通标签； 动画效果： faa-horizontal【摇晃】<br>faa-flash【若隐若现】,faa-spin【360度旋转】,faa-shake【小幅度摆动】</td>
</tr>
<tr>
<td>复选框</td>
<td>checkbox 样式参数（可选）, 文本</td>
<td>颜色：red, yellow, green, cyan, blue；<br> 样式：plus, minus, times； 选中状态：checked</td>
</tr>
<tr>
<td>按钮</td>
<td>btn [url],[text],[icon],[color] [style] [layout] [position] [size]</td>
<td>url:链接, text:按钮文字, icon:可选图标, color:可选-按钮背景顔色(默认style时）<br>按钮字体和边框顔色(outline时default/blue/pink/red/purple/orange/green), <br>style:可选按钮样式默认实心outline/留空, layout:可选按钮布局默认为lineblock/留空,<br> position:可选按钮位置前提是设置了layout为block默认为左边center/right/留空, <br>size:可选按钮大小larger/留空</td>
</tr>
<tr>
<td>隐藏按钮</td>
<td>hideInline content,display,bg,color</td>
<td>content: 文本内容， display: 按钮显示的文字(可选)，<br> bg: 按钮的背景颜色(可选)， color: 按钮文字的颜色(可选)</td>
</tr>
<tr>
<td>隐藏款按钮</td>
<td>hideBlock display,bg,color content</td>
<td>同上</td>
</tr>
<tr>
<td>选项卡容器</td>
<td></td>
<td>tab-id：必填，如果一个页面有多个 tabs 时，tab-id 不能重复。<br>tab-name：标签文本。</td>
</tr>
<tr>
<td>折叠容器</td>
<td></td>
<td>颜色：blue, cyan, green, yellow, red；状态：状态填写 open 代表默认打开</td>
</tr>
<tr>
<td>fancybox容器</td>
<td>fancybox 参数, 列数 图片 endfancybox</td>
<td>对齐方向：left, center, right；缩放：stretch；<br>列数：逗号后面直接写列数，支持 2 ～ 8 列。<br>设定列列数之后就是「多行多图」布局，此时图片默认左对齐。<br>为了避免图片大小不一，建议搭配 stretch 来时图片放大填充。</td>
</tr>
<tr>
<td>音频容器</td>
<td>audio 音频链接</td>
<td>无</td>
</tr>
<tr>
<td>食品容器</td>
<td>video 视频链接</td>
<td>对齐方向：left, center,right； <br>列数：逗号后面直接写列数，支持 1 ～ 4 列。</td>
</tr>
<tr>
<td>latex公式</td>
<td>latex公式内容latex公式内容</td>
<td>无</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/fole-del/img@973eaa72d205c2cabdc3d686d74adebbd2d41082/2020/10/11/d804c16eac667d1a4f699b3b08f462a6.png"></p>
<p>出现<code>&#123;&#123;&#125;&#125;</code>解决办法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% raw %&#125;<br> 含有双大括号的内容<br>&#123;% endraw %&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-按钮"><a href="#3-按钮" class="headerlink" title="3 按钮"></a>3 按钮</h2><div class="note modern success icon simple"><i class="note-icon fa fa-podcast"></i><p>按钮具体用法 </p>
</div>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;<br><br>[url]         : 链接<br>[text]        : 按钮文字<br>[icon]        : [可选] 图标<br>[color]       : [可选] 按钮背景顔色(默认style时）<br>                      按钮字体和边框顔色(outline时)<br>                      default&#x2F;blue&#x2F;pink&#x2F;red&#x2F;purple&#x2F;orange&#x2F;green<br>[style]       : [可选] 按钮样式 默认实心<br>                      outline&#x2F;留空<br>[layout]      : [可选] 按钮佈局 默认为line<br>                      block&#x2F;留空<br>[position]    : [可选] 按钮位置 前提是设置了layout为block 默认为左边<br>                      center&#x2F;right&#x2F;留空<br>[size]        : [可选] 按钮大小<br>                      larger&#x2F;留空<br></code></pre></td></tr></table></figure>



<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">This is my website, click the button &#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC %&#125;<br>This is my website, click the button &#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right %&#125;<br>This is my website, click the button &#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,,outline %&#125;<br>This is my website, click the button &#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,outline %&#125;<br>This is my website, click the button &#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,larger %&#125;<br></code></pre></td></tr></table></figure>



<p>This is my website, click the button <a class="btn-beautify button--animated " href="http://www.jerryc.me" title="JerryC"><span>JerryC</span></a><br>This is my website, click the button <a class="btn-beautify button--animated " href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><br>This is my website, click the button <a class="btn-beautify button--animated outline" href="http://www.jerryc.me" title="JerryC"><span>JerryC</span></a><br>This is my website, click the button <a class="btn-beautify button--animated outline" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a><br>This is my website, click the button <a class="btn-beautify button--animated larger" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,block %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,block center larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,block right outline larger %&#125;<br></code></pre></td></tr></table></figure>

<a class="btn-beautify button--animated block" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a>
<a class="btn-beautify button--animated block center larger" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a>
<a class="btn-beautify button--animated block right outline larger" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a>

<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,blue larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,pink larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,red larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,purple larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,orange larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,JerryC,far fa-hand-point-right,green larger %&#125;<br></code></pre></td></tr></table></figure>

<a class="btn-beautify button--animated larger" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a>
<a class="btn-beautify button--animated blue larger" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a>
<a class="btn-beautify button--animated pink larger" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a>
<a class="btn-beautify button--animated red larger" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a>
<a class="btn-beautify button--animated purple larger" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a>
<a class="btn-beautify button--animated orange larger" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a>
<a class="btn-beautify button--animated green larger" href="http://www.jerryc.me" title="JerryC"><i class="far fa-hand-point-right"></i><span>JerryC</span></a>

<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn-center&quot;</span>&gt;</span></span><br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry1,far fa-hand-point-right,outline larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry2,far fa-hand-point-right,outline blue larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry3,far fa-hand-point-right,outline pink larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry4,far fa-hand-point-right,outline red larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry5,far fa-hand-point-right,outline purple larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry6,far fa-hand-point-right,outline orange larger %&#125;<br>&#123;% btn &#x27;http://www.jerryc.me&#x27;,Jerry7,far fa-hand-point-right,outline green larger %&#125;<br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure>
<div class="btn-center">
<a class="btn-beautify button--animated outline larger" href="http://www.jerryc.me" title="Jerry1"><i class="far fa-hand-point-right"></i><span>Jerry1</span></a>
<a class="btn-beautify button--animated outline blue larger" href="http://www.jerryc.me" title="Jerry2"><i class="far fa-hand-point-right"></i><span>Jerry2</span></a>
<a class="btn-beautify button--animated outline pink larger" href="http://www.jerryc.me" title="Jerry3"><i class="far fa-hand-point-right"></i><span>Jerry3</span></a>
<a class="btn-beautify button--animated outline red larger" href="http://www.jerryc.me" title="Jerry4"><i class="far fa-hand-point-right"></i><span>Jerry4</span></a>
<a class="btn-beautify button--animated outline purple larger" href="http://www.jerryc.me" title="Jerry5"><i class="far fa-hand-point-right"></i><span>Jerry5</span></a>
<a class="btn-beautify button--animated outline orange larger" href="http://www.jerryc.me" title="Jerry6"><i class="far fa-hand-point-right"></i><span>Jerry6</span></a>
<a class="btn-beautify button--animated outline green larger" href="http://www.jerryc.me" title="Jerry7"><i class="far fa-hand-point-right"></i><span>Jerry7</span></a>
</div>



<h2 id="4-引用块"><a href="#4-引用块" class="headerlink" title="4 引用块"></a>4 引用块</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% blockquote %&#125;<br>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.<br>&#123;% endblockquote %&#125;<br></code></pre></td></tr></table></figure>

<blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p>
</blockquote>

<h2 id="5-引用书上的句子"><a href="#5-引用书上的句子" class="headerlink" title="5 引用书上的句子"></a>5 引用书上的句子</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% blockquote David Levithan, Wide Awake %&#125;<br>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.<br>&#123;% endblockquote %&#125;<br>example:<br>&#123;% blockquote 艾米莉·狄金森 &#x27;句读&#x27;%&#125;<br>我想你了，可是我不能对你说，怕只怕，说了对你也是一种折磨。<br>&#123;% endblockquote %&#125;<br></code></pre></td></tr></table></figure>

<blockquote><p>我想你了，可是我不能对你说，怕只怕，说了对你也是一种折磨。</p>
<footer><strong>艾米莉·狄金森</strong></footer></blockquote>

<h2 id="6-饼图"><a href="#6-饼图" class="headerlink" title="6 饼图"></a>6 饼图</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% mermaid %&#125;<br>pie<br><span class="hljs-code">    title Key elements in Product X</span><br><span class="hljs-code">    &quot;Calcium&quot; : 42.96</span><br><span class="hljs-code">    &quot;Potassium&quot; : 50.05</span><br><span class="hljs-code">    &quot;Magnesium&quot; : 10.01</span><br><span class="hljs-code">    &quot;Iron&quot; :  5</span><br><span class="hljs-code">&#123;% endmermaid %&#125;</span><br></code></pre></td></tr></table></figure>

<div class="mermaid">pie
    title Key elements in Product X
    &quot;Calcium&quot; : 42.96
    &quot;Potassium&quot; : 50.05
    &quot;Magnesium&quot; : 10.01
    &quot;Iron&quot; :  5</div>

<h2 id="7-选项卡内容"><a href="#7-选项卡内容" class="headerlink" title="7 选项卡内容"></a>7 选项卡内容</h2><blockquote>
<p> Demo 1 - 预设选择第一个【默认】</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% tabs 选项卡一 %&#125;<br>&lt;!-- tab --&gt;<br><span class="hljs-strong">**This is Tab 1.**</span><br>&lt;!-- endtab --&gt;<br><br>&lt;!-- tab --&gt;<br><span class="hljs-strong">**This is Tab 2.**</span><br>&lt;!-- endtab --&gt;<br><br>&lt;!-- tab --&gt;<br><span class="hljs-strong">**This is Tab 3.**</span><br>&lt;!-- endtab --&gt;<br>&#123;% endtabs %&#125;<br></code></pre></td></tr></table></figure>



<div class="tabs" id="选项卡一"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#选项卡一-1">选项卡一 1</button></li><li class="tab"><button type="button" data-href="#选项卡一-2">选项卡一 2</button></li><li class="tab"><button type="button" data-href="#选项卡一-3">选项卡一 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="选项卡一-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡一-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡一-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<blockquote>
<p>Demo 2 - 预设选择tabs</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% tabs 选项卡二(默认为2), 2 %&#125;<br>&lt;!-- tab --&gt;<br><span class="hljs-strong">**This is Tab 1.**</span><br>&lt;!-- endtab --&gt;<br><br>&lt;!-- tab --&gt;<br><span class="hljs-strong">**This is Tab 2.**</span><br>&lt;!-- endtab --&gt;<br><br>&lt;!-- tab --&gt;<br><span class="hljs-strong">**This is Tab 3.**</span><br>&lt;!-- endtab --&gt;<br>&#123;% endtabs %&#125;<br></code></pre></td></tr></table></figure>

<div class="tabs" id="选项卡二(默认为2)"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#选项卡二(默认为2)-1">选项卡二(默认为2) 1</button></li><li class="tab active"><button type="button" data-href="#选项卡二(默认为2)-2">选项卡二(默认为2) 2</button></li><li class="tab"><button type="button" data-href="#选项卡二(默认为2)-3">选项卡二(默认为2) 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="选项卡二(默认为2)-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="选项卡二(默认为2)-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡二(默认为2)-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<blockquote>
<p>Demo 3 - 没有预设值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#123;% tabs 选项卡三（无预设值）, -1 %&#125;<br>&lt;!-- tab --&gt;<br>**This is Tab 1.**<br>&lt;!-- endtab --&gt;<br><br>&lt;!-- tab --&gt;<br>**This is Tab 2.**<br>&lt;!-- endtab --&gt;<br><br>&lt;!-- tab --&gt;<br>**This is Tab 3.**<br>&lt;!-- endtab --&gt;<br>&#123;% endtabs %&#125;<br></code></pre></td></tr></table></figure>

<div class="tabs" id="选项卡三（无预设值）"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#选项卡三（无预设值）-1">选项卡三（无预设值） 1</button></li><li class="tab"><button type="button" data-href="#选项卡三（无预设值）-2">选项卡三（无预设值） 2</button></li><li class="tab"><button type="button" data-href="#选项卡三（无预设值）-3">选项卡三（无预设值） 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="选项卡三（无预设值）-1"><p><strong>This is Tab 1.</strong>  </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡三（无预设值）-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡三（无预设值）-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<blockquote>
<p>Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% tabs 选项卡四（自定义标签） %&#125;<br>&lt;!-- tab 第一个Tab@fa fa-arrow-circle-left --&gt;<br><span class="hljs-strong">**tab名字为第一个Tab**</span><br>&lt;!-- endtab --&gt;<br>&lt;!-- tab @fa fa-arrow-right --&gt;<br><span class="hljs-strong">**只有图标 没有Tab名字**</span><span class="hljs-code">`&lt;i class=&quot;fa fa-podcast&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;`</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-podcast&quot;</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br>&lt;!-- endtab --&gt;<br>&lt;!-- tab grav@fa fa-grav --&gt;<br><span class="hljs-strong">**名字+icon**</span><br>&lt;!-- endtab --&gt;<br>&#123;% endtabs %&#125;<br></code></pre></td></tr></table></figure>

<div class="tabs" id="选项卡四（自定义标签）"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#选项卡四（自定义标签）-1"><i class="fa fa-arrow-circle-left"></i>第一个Tab</button></li><li class="tab"><button type="button" data-href="#选项卡四（自定义标签）-2"><i class="fa fa-arrow-circle-right" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#选项卡四（自定义标签）-3"><i class="fa fa-desktop"></i>grav</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="选项卡四（自定义标签）-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡四（自定义标签）-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="选项卡四（自定义标签）-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>







<p>哪个英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案
  </button><span class="hide-content">因为西装裤(C装酷)</span></span></p>
<p>门里站着一个人? <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: red;color: blue">查看答案
  </button><span class="hide-content">闪</span></span></p>
<h2 id="8-图片格式（演示用）"><a href="#8-图片格式（演示用）" class="headerlink" title="8 图片格式（演示用）"></a>8 图片格式（演示用）</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% gallery %&#125;<br>插入图片链接即可<br>![]()<br>仅支持markdown格式<br>&#123;% endgallery %&#125;<br></code></pre></td></tr></table></figure>



<div class="justified-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg"><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg"><br><img src="https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg"></p>
          </div>

<h2 id="9-隐藏块"><a href="#9-隐藏块" class="headerlink" title="9 隐藏块"></a>9 隐藏块</h2><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>隐藏块</span></div>
    <div class="hide-content"><div class="justified-gallery"><p><img src="https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg"><br><img src="https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg"><br><img src="https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg"><br><img src="https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg"><br><img src="https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg"></p>
          </div></div></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#123;% hideToggle 分割线 %&#125;<br><br>&#123;% endhideToggle %&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hexo</category>
        <category>butterfly</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之行为型模式</title>
    <url>/posts/69f2f423.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><blockquote>
<p>学习笔记之C++设计模式——创建型模式</p>
<p>📑 <a href="/posts/eea0cb26.html" title="设计模式之结构型模式">设计模式之结构型模式</a> <br></p>
<p>📑 <a href="/posts/3dfd8b5b.html" title="设计模式之创建型模式">设计模式之创建型模式</a></p>
</blockquote>
<p>总的来说，行为型模式就是用来对类或对象怎样交互和怎样分配职责进行描述。</p>
<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p><img src="../../../images/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/model.svg" alt="模板方法"></p>
<div class="note green simple"><p><mark style="background:green;border-radius:10px;color:white;padding:0px 3px">AbstractClass（抽象类）：</mark>在抽象类中定义了一系列基本操作（PrimitiveOperations），这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法（Template Method），用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</p>
<p><mark style="background:green;border-radius:10px;color:white;padding:0px 3px">ConcreteClass（具体子类）：</mark>它是抽象类的子类，用于是现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中的已经实现的具体基本操作。</p>
</div>

<h2 id="模板方法案例"><a href="#模板方法案例" class="headerlink" title="模板方法案例"></a>模板方法案例</h2><p><img src="../../../images/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/model_demo.svg" alt="模板方法案例"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>点击展开</span></div>
    <div class="hide-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 模板方法.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 制作饮料</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Beverage</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">// 煮水</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BoilWater</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;烧开水&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-comment">// 冲泡 特殊接口</span><br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// 倒入杯中</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PourinVup</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;倒入杯中&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-comment">// 添加料 特殊接口</span><br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddCondiments</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">// hook 方法，决定某些算法步骤是否挂钩在算法中</span><br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">CustomWantsCondiments</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 模板方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrepareBeverage</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-built_in">BoilWater</span>();<br>		<span class="hljs-built_in">Brew</span>();<br>		<span class="hljs-built_in">PourinVup</span>();<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">CustomWantsCondiments</span>()) &#123;<br>			<span class="hljs-built_in">AddCondiments</span>();<br>		&#125;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br>	<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coffee</span> :</span> <span class="hljs-keyword">public</span> Beverage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;冲泡咖啡豆&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddCondiments</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;添加糖和牛奶&quot;</span> &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tea</span> :</span> <span class="hljs-keyword">public</span> Beverage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;冲泡茶叶&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddCondiments</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;添加柠檬&quot;</span> &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Beverage *pTea = <span class="hljs-keyword">new</span> Tea;<br>	pTea-&gt;<span class="hljs-built_in">PrepareBeverage</span>();<br>	<span class="hljs-keyword">delete</span> pTea;<br><br>	cout &lt;&lt; <span class="hljs-string">&quot;-----------------------&quot;</span> &lt;&lt; endl;<br><br>	Beverage *pCoffee = <span class="hljs-keyword">new</span> Tea;<br>	pCoffee-&gt;<span class="hljs-built_in">PrepareBeverage</span>();<br>	<span class="hljs-keyword">delete</span> pCoffee;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<div style="background:black;font:conloas;color:white;">
烧开水<br>
冲泡茶叶<br>
倒入杯中<br>
添加柠檬<br>
-----------------------<br>
烧开水<br>
冲泡茶叶<br>
倒入杯中<br>
添加柠檬<br>
请按任意键继续. . .    
</div>
</div></div>

<h2 id="模板方法的优缺点"><a href="#模板方法的优缺点" class="headerlink" title="模板方法的优缺点"></a>模板方法的优缺点</h2><div class="note success simple"><ol>
<li>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</li>
<li>模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。</li>
<li>可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。</li>
<li>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则</li>
</ol>
</div>

<div class="note danger simple"><p>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。</p>
</div>

<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li><p>具有统一的操作步骤或操作过程；</p>
</li>
<li><p>具有不同的操作细节；</p>
</li>
<li><p>存在多个具有同样操作步骤的应用场景，但某些具体的操作细节却各不相同</p>
</li>
</ol>
<blockquote>
<p>在抽象类中统一操作步骤，并规定好接口；让子类实现接口。这样可以吧各个具体的子类和操作步骤解耦合。</p>
</blockquote>
<hr>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为模式，其别名为动作(Action)模式或事务（Tranaction）模式。</p>
<p>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>点击展开</span></div>
    <div class="hide-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 命令模式.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Doctor</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">treat_eye</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;医生 治疗 眼科病&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">treat_nose</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;医生 治疗 鼻科病&quot;</span> &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommandTreatEye</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">CommandTreatEye</span>(Doctor *doctor) &#123;<br>		m_doctor = doctor;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">treat</span><span class="hljs-params">()</span> </span>&#123;<br>		m_doctor-&gt;<span class="hljs-built_in">treat_eye</span>();<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	Doctor *m_doctor;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommandTreatNose</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">CommandTreatNose</span>(Doctor *doctor) &#123;<br>		m_doctor = doctor;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">treat</span><span class="hljs-params">()</span> </span>&#123;<br>		m_doctor-&gt;<span class="hljs-built_in">treat_nose</span>();<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	Doctor *m_doctor;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">// 1. 医生直接看病</span><br>	Doctor *doctor = <span class="hljs-keyword">new</span> Doctor;<br>	doctor-&gt;<span class="hljs-built_in">treat_eye</span>();<br>	<br>	<span class="hljs-keyword">delete</span> doctor;<br><br>	cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>	<span class="hljs-comment">// 2. 通过医疗指令来看病</span><br><br>	Doctor *doctorCmd = <span class="hljs-keyword">new</span> Doctor;<br>	CommandTreatEye * cmdEyeDoc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CommandTreatEye</span>(doctorCmd);<br>	cmdEyeDoc-&gt;<span class="hljs-built_in">treat</span>();<br>	<span class="hljs-keyword">delete</span> cmdEyeDoc;<br>	<br>	CommandTreatNose *cmdNoseDoc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CommandTreatNose</span>(doctorCmd);<br>	cmdNoseDoc-&gt;<span class="hljs-built_in">treat</span>();<br>	<span class="hljs-keyword">delete</span> cmdNoseDoc;<br><br>	<span class="hljs-keyword">delete</span> doctorCmd;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>输出：</p>
<div style="background:black;font:conloas;color:white;">
医生 治疗 眼科病<br>
-----------------<br>
医生 治疗 眼科病<br>
医生 治疗 鼻科病<br>
请按任意键继续. . .
</div>
</div></div>

<blockquote>
<p>命令模式的本质是对请求进行封装对应于一个命令，将发出命令的责任和执行命令的责任分割开。</p>
</blockquote>
<h2 id="命令模式中的角色和职责"><a href="#命令模式中的角色和职责" class="headerlink" title="命令模式中的角色和职责"></a>命令模式中的角色和职责</h2><p><img src="../../../images/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/cmd.svg"></p>
<hr>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><hr>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><hr>
]]></content>
      <categories>
        <category>程序员内功</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之结构型模式</title>
    <url>/posts/eea0cb26.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><style>
.dimitt:hover:after{

}
</style>

<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><blockquote>
<p> 学习笔记之C++设计模式——创建型模式</p>
<p>📑 <a href="/posts/eea0cb26.html" title="设计模式之结构型模式">设计模式之结构型模式</a> <br></p>
<p>📑 <a href="/posts/69f2f423.html" title="设计模式之行为型模式">设计模式之行为型模式</a></p>
</blockquote>
<p>Proxy模式又叫做代理模式，是构造型的设计模式之一， 它可以为其他对象提供-种代理( Proxy )以控制对这个对象的访问。所谓代理，是指具有与代理元(被代理的对象)具有相同的接口的类，客户端必须通过代理与被代理的目标类交互，而代理一-般在交互的过程中 (交互前后) , 进行某些特别的处理。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><img src="../../../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211126115058411.png" alt="代理模式"></p>
<p>通俗理解就和海外代购类似，由一个海外代购专门负责所有需要从其他国家购买的这个行为。</p>
<p>以下为代理模式案例及其代码：<img src="../../../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/proxy_demo.png" alt="代理模式案例"></p>
<div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>点击查看</span></div>
    <div class="hide-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 代理模式.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Item</span>(string kind, <span class="hljs-keyword">bool</span> fact) <br>	&#123;<br>		<span class="hljs-keyword">this</span>-&gt;kind = kind;<br>		<span class="hljs-keyword">this</span>-&gt;fact = fact;<br>	&#125;<br><br>	<span class="hljs-function">string <span class="hljs-title">getKind</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> kind;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">getFact</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> fact;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>	string kind;<br>	<span class="hljs-keyword">bool</span> fact;<br>&#125;;<br><br><span class="hljs-comment">// 抽象的购物方式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shopping</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">(Item *it)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KoeraShopping</span> :</span> <span class="hljs-keyword">public</span> Shopping<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">(Item *it)</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;去韩国买了&quot;</span> &lt;&lt; it-&gt;<span class="hljs-built_in">getKind</span>() &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USAShopping</span> :</span> <span class="hljs-keyword">public</span> Shopping<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">(Item * it)</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;去美国买了&quot;</span> &lt;&lt; it-&gt;<span class="hljs-built_in">getKind</span>() &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><br><span class="hljs-comment">// 海外代理</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OverseasProxy</span> :</span> <span class="hljs-keyword">public</span> Shopping<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">OverseasProxy</span>(Shopping *shopping)<br>	&#123;<br>		<span class="hljs-keyword">this</span>-&gt;shopping = shopping;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buy</span><span class="hljs-params">(Item *it)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">if</span> (it-&gt;<span class="hljs-built_in">getFact</span>() == <span class="hljs-literal">true</span>)<br>		&#123;<br>			cout &lt;&lt; <span class="hljs-string">&quot;发现正品&quot;</span> &lt;&lt; endl;<br>			shopping-&gt;<span class="hljs-built_in">buy</span>(it);<br>			cout &lt;&lt; <span class="hljs-string">&quot;---------安检-----------&quot;</span> &lt;&lt; endl;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			cout &lt;&lt; <span class="hljs-string">&quot;发现假货&quot;</span> &lt;&lt; it-&gt;<span class="hljs-built_in">getKind</span>() &lt;&lt; endl;<br>		&#125;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>	Shopping *shopping; <span class="hljs-comment">// 有一个购物方式</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">Item <span class="hljs-title">it1</span><span class="hljs-params">(<span class="hljs-string">&quot;nike鞋子&quot;</span>, <span class="hljs-literal">true</span>)</span></span>;<br>	<span class="hljs-function">Item <span class="hljs-title">it2</span><span class="hljs-params">(<span class="hljs-string">&quot;CET4证书&quot;</span>, <span class="hljs-literal">false</span>)</span></span>;<br><br>	Shopping *Koerashopping = <span class="hljs-keyword">new</span> KoeraShopping;<br>	Shopping *usaShopping = <span class="hljs-keyword">new</span> USAShopping;<br><br>	Shopping *overseaProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OverseasProxy</span>(usaShopping);<br>	<br>	overseaProxy-&gt;<span class="hljs-built_in">buy</span>(&amp;it1);<br>	overseaProxy-&gt;<span class="hljs-built_in">buy</span>(&amp;it2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></div></div>


<h2 id="代理模式的种类"><a href="#代理模式的种类" class="headerlink" title="代理模式的种类"></a>代理模式的种类</h2><h3 id="远程代理（Remote-Proxy）"><a href="#远程代理（Remote-Proxy）" class="headerlink" title="远程代理（Remote Proxy）"></a>远程代理（Remote Proxy）</h3><p>为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另外一台主机中，远程代理又称为大使（Ambassador）。</p>
<div class="note info simple"><p>远程代理： 使得<b>客户端程序可以访问在远程主机上的对象</b>，远程主机可能具有更好的计算性能与处理速度，可以快速相应并处理客户端的请求。远程代理可以<b>将网络的细节隐藏起来，使得客户端不必考虑网络的存在</b>。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。</p>
<p><img src="../../../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/RemoteProxy.png" alt="远程代理示意图"></p>
<blockquote>
<p>如图所示: </p>
<p>客户端对象不能直接访问远程主机中的业务对象，只能采取间接访问的方式。远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端对象而言是透明的。客户端无须关心实现具体业务的是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。</p>
</blockquote>
</div>

<p>在基于<code>.NET</code>平台的分布式技术，例如DCOM（Distribute Component Object Mdoel， 分布式组件对象模型）、Web Service中，都应用了远程代理模式。</p>
<h3 id="虚拟代理（Virtual-Proxy）"><a href="#虚拟代理（Virtual-Proxy）" class="headerlink" title="虚拟代理（Virtual Proxy）"></a>虚拟代理（Virtual Proxy）</h3><p>如果需要创建一个资源消耗巨大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</p>
<div class="note info simple"><p>虚拟代理(Virtual Proxy)也是一种常用的代理模式，<strong>对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理</strong>。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。</p>
<p>通常，在以下两种情况下可以考虑使用虚拟代理：</p>
<p><strong>(1) 由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象</strong>。通常在实现时可以结合多线程技术，一个线程用于显示代理对象，其他线程用于加载真实对象。这种虚拟代理模式可以应用在程序启动的时候，由于创建代理对象在时间和处理复杂度上要少于创建真实对象，因此，在程序启动时，可以用代理对象代替真实对象初始化，大大加速了系统的启动时间。当需要使用真实对象时，再通过代理对象来引用，而此时真实对象可能已经成功加载完毕，可以缩短用户的等待时间。</p>
<p><strong>(2) 当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理</strong>。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象。为了节省内存，在第一次引用真实对象时再创建对象，并且该对象可被多次重用，在以后每次访问时需要检测所需对象是否已经被创建，因此在访问该对象时需要进行存在性检测，这需要消耗一定的系统时间，但是可以节省内存空间，这是一种用时间换取空间的做法。</p>
<p>无论是以上哪种情况，虚拟代理都是用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能。</p>
</div>

<h3 id="保护代理（Protect-Proxy）"><a href="#保护代理（Protect-Proxy）" class="headerlink" title="保护代理（Protect Proxy）"></a>保护代理（Protect Proxy）</h3><p>控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限</p>
<h3 id="缓冲代理（Cache-Proxy）"><a href="#缓冲代理（Cache-Proxy）" class="headerlink" title="缓冲代理（Cache Proxy）"></a>缓冲代理（Cache Proxy）</h3><p>为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果</p>
<div class="note info simple"><p>缓冲代理(Cache Proxy)也是一种较为常用的代理模式，它<strong>为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而可以避免某些方法的重复执行，优化系统性能。</strong></p>
</div>

<h3 id="智能引用代理（Smart-Reference-Proxy）"><a href="#智能引用代理（Smart-Reference-Proxy）" class="headerlink" title="智能引用代理（Smart Reference Proxy）"></a>智能引用代理（Smart Reference Proxy）</h3><p>当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</p>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><blockquote>
<p>装饰模式（decorator Pattern）: 动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</p>
</blockquote>
<p><img src="../../../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211126115029214.png" alt="装饰模式"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src="../../../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/Decorator_Demo.png" alt="装饰模式案例"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>点击查看</span></div>
    <div class="hide-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 装饰模式.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 一个抽象的构件，他是具体构件和抽象装饰类的父类 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><span class="hljs-comment">// 具体的构件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">iPhone</span> :</span> <span class="hljs-keyword">public</span> Phone<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">iPhone</span>(string kind) &#123;<br>		<span class="hljs-keyword">this</span>-&gt;kind = kind;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;秀出了 iPhone- &quot;</span> &lt;&lt; kind &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>	string kind;<br>&#125;;<br><br><span class="hljs-comment">// 具体的构件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mi</span> :</span> <span class="hljs-keyword">public</span> Phone<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Mi</span>(string kind) &#123;<br>		<span class="hljs-keyword">this</span>-&gt;kind = kind;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;秀出了 Mi-&quot;</span> &lt;&lt; kind &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>	string kind;<br>&#125;;<br><br><span class="hljs-comment">// 抽象的手机装饰类，必须包含抽象的构件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeCoratorPhone</span> :</span> <span class="hljs-keyword">public</span> Phone<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">DeCoratorPhone</span>() &#123;<br><br>	&#125;<br>	<span class="hljs-built_in">DeCoratorPhone</span>(Phone *phone) &#123;<br>		<span class="hljs-keyword">this</span>-&gt;phone = phone;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span>	</span>&#123;<br>		<span class="hljs-keyword">this</span>-&gt;phone-&gt;<span class="hljs-built_in">Show</span>();<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>	Phone *phone;<br>&#125;;<br><br><span class="hljs-comment">// 具体的装饰器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeCoratorPhoneMo</span> :</span> <span class="hljs-keyword">public</span> DeCoratorPhone &#123;<br><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">DeCoratorPhoneMo</span>(Phone *phone) &#123;<br>		<span class="hljs-keyword">this</span>-&gt;phone = phone;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>-&gt;phone-&gt;<span class="hljs-built_in">Show</span>();<br>		<span class="hljs-built_in">addMo</span>();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addMo</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;装饰: 手机贴膜&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br><span class="hljs-keyword">private</span>:<br>	Phone *phone;<br><br>&#125;;<br><br><span class="hljs-comment">// 具体的装饰器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeCoratorPhoneKe</span> :</span> <span class="hljs-keyword">public</span> DeCoratorPhone &#123;<br><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">DeCoratorPhoneKe</span>(Phone *phone) &#123;<br>		<span class="hljs-keyword">this</span>-&gt;phone = phone;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>-&gt;phone-&gt;<span class="hljs-built_in">Show</span>();<br>		<span class="hljs-built_in">addMo</span>();<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addMo</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;装饰: 手机装保护壳&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br><span class="hljs-keyword">private</span>:<br>	Phone *phone;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Phone *phone = <span class="hljs-literal">NULL</span>;<br>	DeCoratorPhone * hasMoPhone = <span class="hljs-literal">NULL</span>;<br>	DeCoratorPhone * hasKePhone = <span class="hljs-literal">NULL</span>;<br>	DeCoratorPhone * hasMoKePhone = <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">// 定义一个Iphone 13手机</span><br>	phone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">iPhone</span>(<span class="hljs-string">&quot;iPhone 13&quot;</span>);<br>	<span class="hljs-comment">// 给普通iphone 加上贴膜</span><br>	hasMoPhone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DeCoratorPhoneMo</span>(phone);<br>	<span class="hljs-comment">// 给普通iphone 加上保护套</span><br>	hasKePhone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DeCoratorPhoneKe</span>(phone);<br>	hasMoPhone-&gt;<span class="hljs-built_in">Show</span>();<br>	hasKePhone-&gt;<span class="hljs-built_in">Show</span>();<br><br>	<span class="hljs-comment">// 给有皮套的iphone 加上贴膜</span><br>	hasMoKePhone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DeCoratorPhoneMo</span>(hasKePhone);<br>	hasMoKePhone-&gt;<span class="hljs-built_in">Show</span>();<br><br>	<span class="hljs-keyword">delete</span> hasMoKePhone;<br>	<span class="hljs-keyword">delete</span> hasKePhone;<br>	<span class="hljs-keyword">delete</span> hasMoPhone;<br>	<span class="hljs-keyword">delete</span> phone;<br>	cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br><br>	phone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Mi</span>(<span class="hljs-string">&quot;Mix 4&quot;</span>);<br>	hasMoPhone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DeCoratorPhoneMo</span>(phone);<br>	hasKePhone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DeCoratorPhoneKe</span>(phone);<br>	hasMoPhone-&gt;<span class="hljs-built_in">Show</span>();<br>	hasKePhone-&gt;<span class="hljs-built_in">Show</span>();<br><br>	hasMoKePhone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DeCoratorPhoneKe</span>(hasKePhone);<br>	hasMoKePhone-&gt;<span class="hljs-built_in">Show</span>();<br><br>	<span class="hljs-keyword">delete</span> hasMoKePhone;<br>	<span class="hljs-keyword">delete</span> hasKePhone;<br>	<span class="hljs-keyword">delete</span> hasMoPhone;<br>	<span class="hljs-keyword">delete</span> phone;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出：</p>
<div style="background:black;font:conloas;color:white;">
秀出了 iPhone- iPhone 13:<br>
装饰: 手机贴膜<br>
秀出了 iPhone- iPhone 13:<br>
装饰: 手机装保护壳<br>
秀出了 iPhone- iPhone 13:<br>
装饰: 手机装保护壳<br>
装饰: 手机贴膜<br>
秀出了 Mi-Mix 4:<br>
装饰: 手机贴膜<br>
秀出了 Mi-Mix 4:<br>
装饰: 手机装保护壳<br>
秀出了 Mi-Mix 4:<br>
装饰: 手机装保护壳<br>
装饰: 手机装保护壳<br>
请按任意键继续. . .
</div>
</div></div>


<h2 id="装饰模式的优缺点"><a href="#装饰模式的优缺点" class="headerlink" title="装饰模式的优缺点"></a>装饰模式的优缺点</h2><div class="note success simple"><ol>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加。</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为。</li>
<li>可以对一个对象进行多次装饰。</li>
<li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无需改变，符合“开闭原则”。</li>
</ol>
</div>

<div class="note warning simple"><ol>
<li>使用装饰模式进行系统设计时产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能。</li>
</ol>
</div>

<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li>动态、透明的方式给耽搁对象添加职责</li>
<li>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。</li>
</ol>
<p>装饰器模式关注于在一个对象上动态的添加方法。然而代理模式关注于控制对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将院士对象作为一个参数创给装饰者的构造器。</p>
<hr>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>根据<span class="dimitt">迪米特法则<span>，如果两个类不必彼此直接通信，那么两个类就不应当发生直接的相互作用。</span></span></p>
<blockquote>
<p>一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。</p>
<p>例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个木块的内部实现细节，当一个模块内部的实现发生改变是，不会影响其他模块的使用。（黑盒原理）。</p>
</blockquote>
<p>Facade模式也叫外观模式。是有GoF提出的23中设计模式中的一种。Facade模式为一组具有类似功能的类群，比如类库、子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。</p>
<p><img src="../../../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211126115120902.png" alt="外观模式"></p>
<div class="note purple no-icon flat"><p>Facade(外观角色): 为调用方，定义简单的调用接口</p>
<p>SubSystem(子系统角色): 功能提供者。指提供功能的类群（模块或子系统）。</p>
</div>

<p>更加具体的理解直接看代码就能明白。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>点击展开</span></div>
    <div class="hide-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 外观模式.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	外观模式就是将复杂的子类系统抽象到同一个的接口进行管理</span><br><span class="hljs-comment">	外界只需要通过此接口与子类系统进行交互，而不必直接与复杂的子类系统进行交互。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 这里定义四个字了系统</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Methor1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;子系统方法一&quot;</span> &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem2</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Methor2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;子系统方法二&quot;</span> &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem3</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Methor3</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;子系统方法三&quot;</span> &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem4</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Methor4</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;子系统方法四&quot;</span> &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><br><br><span class="hljs-comment">/* 外观类，接口 */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Facade</span>()<br>	&#123;<br>		one = <span class="hljs-keyword">new</span> SubSystem1;<br>		two = <span class="hljs-keyword">new</span> SubSystem2;<br>		three = <span class="hljs-keyword">new</span> SubSystem3;<br>		four = <span class="hljs-keyword">new</span> SubSystem4;<br>	&#125;<br>	~<span class="hljs-built_in">Facade</span>()<br>	&#123;<br>		<span class="hljs-keyword">delete</span> one;<br>		<span class="hljs-keyword">delete</span> two;<br>		<span class="hljs-keyword">delete</span> three;<br>		<span class="hljs-keyword">delete</span> four;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MethorA</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;方法组A()&quot;</span> &lt;&lt; endl;<br>		one-&gt;<span class="hljs-built_in">Methor1</span>();<br>		two-&gt;<span class="hljs-built_in">Methor2</span>();<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MethorB</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;方法组B()&quot;</span> &lt;&lt; endl;<br>		three-&gt;<span class="hljs-built_in">Methor3</span>();<br>		four-&gt;<span class="hljs-built_in">Methor4</span>();<br>	&#125;<br><br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>	SubSystem1 *one;<br>	SubSystem2 *two;<br>	SubSystem3 *three;<br>	SubSystem4 *four;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Facade facade;<br>	facade.<span class="hljs-built_in">MethorA</span>();<br>	facade.<span class="hljs-built_in">MethorB</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>输出：</p>
<div style="background:black;font:conloas;color:white;">
方法组A()<br>
子系统方法一<br>
子系统方法二<br>
方法组B()<br>
子系统方法三<br>
子系统方法四<br>
请按任意键继续. . .
</div>
</div></div>

<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><p><img src="../../../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211128175348971.png" alt="外观模式——案例影院模式"></p>
<p>外观模式较为简单，实现上述模式依次实现电视、灯、音响、麦克风、DVD、游戏机即可，在此基础上实现外观类Facade（家庭影院）即可。</p>
<h2 id="外观模式的优缺点"><a href="#外观模式的优缺点" class="headerlink" title="外观模式的优缺点"></a>外观模式的优缺点</h2><div class="note success simple"><ol>
<li>他对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，<mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">客户端代码将变得很简单，预支关联的对象也很少。</mark></li>
<li>它实现了子系统与客户端之间的松耦合关系，这使得<mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。</mark></li>
<li><mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">一个子系统的修改对其他子系统没有任何影响。</mark></li>
</ol>
</div>

<div class="note warning simple"><ol>
<li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。</li>
<li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</li>
</ol>
</div>

<h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li>复杂系统需要简单入口使用。</li>
<li>客户端程序与多个子系统之间存在很大的依赖性。</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li>
</ol>
<hr>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<h2 id="适配器模式中的角色和职责"><a href="#适配器模式中的角色和职责" class="headerlink" title="适配器模式中的角色和职责"></a>适配器模式中的角色和职责</h2><p><img src="../../../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211128180531951.png" alt="Adapter"></p>
<div class="note green no-icon modern"><ol>
<li>Target（目标抽象类）：目标抽象类定义客户所需接口，可以使一个抽象类或接口，也可以是具体类。</li>
<li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，他通过继承Target并关联一个Adaptee对象使二者产生联系。</li>
<li>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li>
</ol>
<p>根据对象适配器模式结构图，在对象适配器中，客户端需要调用<code>request()</code>方法，而适配者类Adaptee没有该方法，但是它所提供的<code>SpecificRequest()</code>方法确实客户端所需要的。为了是客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的<code>Request()</code>方法中调用适配者的<code>SpecificRequest()</code>方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式。</p>
</div>

<h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><p><img src="../../../images/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211128184458560.png" alt="适配器案例"></p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><div class="hide-toggle"><div class="hide-button toggle-title" style><i class="fas fa-caret-right fa-fw"></i><span>点击展开</span></div>
    <div class="hide-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 适配器模式.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// target</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">V5</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uesV5</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span>:<br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">V220</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useV220</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;用220V电压进行充电&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">// Adapter 充电器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChargerAdapter</span> :</span> <span class="hljs-keyword">public</span> V5<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uesV5</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;充电器对电压进行适配&quot;</span> &lt;&lt; endl;<br>		m_p220V.<span class="hljs-built_in">useV220</span>();<br>	&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br>	V220 m_p220V;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Phone</span>()<br>	&#123;<br>		v5Adapter = <span class="hljs-keyword">new</span> ChargerAdapter;<br>	&#125;<br>	~<span class="hljs-built_in">Phone</span>()<br>	&#123;<br>		<span class="hljs-keyword">if</span> (v5Adapter != <span class="hljs-literal">NULL</span>)<br>		&#123;<br>			<span class="hljs-keyword">delete</span> v5Adapter;<br>			v5Adapter = <span class="hljs-literal">NULL</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">charge</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;手机进行充电&quot;</span> &lt;&lt; endl;<br>		v5Adapter-&gt;<span class="hljs-built_in">uesV5</span>();<br>	&#125;<br><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-comment">// 5v 手机充电器</span><br>	V5 *v5Adapter;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Phone iphone;<br>	iphone.<span class="hljs-built_in">charge</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<div style="background:black;font:conloas;color:white;">
手机进行充电<br>
充电器对电压进行适配<br>
用220V电压进行充电<br>
请按任意键继续. . .
</div>
</div></div>



<h2 id="适配器模式的优缺点"><a href="#适配器模式的优缺点" class="headerlink" title="适配器模式的优缺点"></a>适配器模式的优缺点</h2><div class="note success simple"><ol>
<li><mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">将目标类和适配者类解耦。</mark>通过引入一个适配器类来重用现有的适配者类，无需修改原有结构。</li>
<li><mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">增加了类的透明性和复用性。</mark>将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li>
<li><mark style="background:royalBlue;border-bottom:lightblue 2px solid;color:white;font-family:consolas">灵活性和扩展性都非常好。</mark>可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li>
</ol>
</div>

<div class="note warning simple"><ol>
<li>适配器中置换适配者类的某些方法比较麻烦。</li>
</ol>
</div>

<h2 id="适应场景"><a href="#适应场景" class="headerlink" title="适应场景"></a>适应场景</h2><ol>
<li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</li>
<li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
</ol>
<p>到此，设计模式之结构型模式。over~~~😀🌝</p>
<p><img src="https://dl4.weshineapp.com/gif/20210717/aef09ea5e8400a6b49fece64c6c360fc.gif?f=micro_" alt="img"></p>
]]></content>
      <categories>
        <category>程序员内功</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>内存分配</title>
    <url>/posts/d5b66195.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自动存储、静态存储和动态存储"><a href="#自动存储、静态存储和动态存储" class="headerlink" title="自动存储、静态存储和动态存储"></a>自动存储、静态存储和动态存储</h1><blockquote>
<p>存储区域主要为<code>栈</code>和<code>自由存储区</code>，栈多服务于临时变量和一些非动态申请的数据类型</p>
<p><code>自由存储区或堆</code>通常为一个概念，存储动态申请的变量和数据类型（new）、vector</p>
</blockquote>
<span id="more"></span>

<h2 id="1、自动存储（栈）"><a href="#1、自动存储（栈）" class="headerlink" title="1、自动存储（栈）"></a>1、自动存储（栈）</h2><blockquote>
<p>自动存储的为<code>自动变量</code>，自动变量一般都是程序云心过程中函数的局部变量，常存储在<code>栈</code>中，所以在执行代码时，是按照<code>后进先出</code>进行变量存储，这也就意味着，在程序执行过程中，栈的大小是不断变化的。 </p>
</blockquote>
<h2 id="2、静态存储（堆）"><a href="#2、静态存储（堆）" class="headerlink" title="2、静态存储（堆）"></a>2、静态存储（堆）</h2><p>​     静态存储的两种方式：</p>
<pre><code>1. 在函数外面定义
2. 在声明变量时，加上关键字static
</code></pre>
<h2 id="3、动态存储（堆）"><a href="#3、动态存储（堆）" class="headerlink" title="3、动态存储（堆）"></a>3、动态存储（堆）</h2><p>==new和delete==的应用，其管理着一个<code>内存池</code>（在C++中也被称为自由存储空间或<code>堆</code>），所创建的变量同存储静态存储的内存是分开的。</p>
<img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjvu5y7zguj310908jamo.jpg" alt="动态存储" width="1305" data-width="1305" data-height="307">

]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher算法</title>
    <url>/posts/9c101d38.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><p><span style="display:block"><img src="https://img.shields.io/badge/主题-马拉车算法-blue"></span></p>
<p>求最长子回文串</p>
<blockquote>
<p>转载声明：<a href="https://ethsonliu.com/2018/04/manacher.html">@刘毅 (Ethson Liu)</a></p>
</blockquote>
<span id="more"></span>



<h1 id="算法过程分析"><a href="#算法过程分析" class="headerlink" title="算法过程分析"></a>算法过程分析</h1><p>由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：</p>
<ol>
<li>在字符串首尾及每个字符间都插入一个 “#”，这样可以使得原先的奇偶回文都变为奇回文；</li>
<li>接着再在首尾两端各插入 “$” 和 “^”，这样中心扩展寻找回文的时候会自动退出循环，不需每次判断是否越界，可参见下面代码。</li>
<li>上述新插入的三个字符，即 “#”、 “$” 和 “^”，必须各异，且不可以与原字符串中的字符相同。</li>
</ol>
<p>举个例子：<code>s=&quot;abbahopxpo&quot;</code>，转换为 <code>s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#^&quot;</code>。如此，s 里起初有一个偶回文 <code>abba</code> 和一个奇回文 <code>opxpo</code>，被转换为 <code>#a#b#b#a#</code> 和 <code>#o#p#x#p#o#</code>，长度都转换成了奇数。</p>
<p>定义一个辅助数组 <code>int p[]</code>，其中 <code>p[i]</code> 表示以 i 为中心的最长回文的半径，例如：</p>
<table>
<thead>
<tr>
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
<th>21</th>
<th>22</th>
</tr>
</thead>
<tbody><tr>
<td>s_new[i]</td>
<td>$</td>
<td>#</td>
<td>a</td>
<td>#</td>
<td>b</td>
<td>#</td>
<td>b</td>
<td>#</td>
<td>a</td>
<td>#</td>
<td>h</td>
<td>#</td>
<td>o</td>
<td>#</td>
<td>p</td>
<td>#</td>
<td>x</td>
<td>#</td>
<td>p</td>
<td>#</td>
<td>o</td>
<td>#</td>
<td>^</td>
</tr>
<tr>
<td>p[i]</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>6</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>可以看出，<code>p[i] - 1</code> 正好是<strong>原字符串中最长回文串的长度</strong>。</p>
<p>接下来的重点就是求解 p 数组，如下图：<br><img src="https://resource.ethsonliu.com/image/20180403_02.png" alt="img"><br>设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是 <code>mx = id + p[id]</code>。</p>
<p>假设我们现在求 <code>p[i]</code>，也就是以 i 为中心的最长回文半径，如果 <code>i &lt; mx</code>，如上图，那么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">if (i &lt; mx)  <br>    p[i] &#x3D; min(p[2 * id - i], mx - i);<br></code></pre></td></tr></table></figure>

<p><code>2 * id - i</code> 为 i 关于 id 的对称点，即上图的 j 点，而 <strong><code>p[j]</code>表示以 j 为中心的最长回文半径</strong>，因此我们可以利用 <code>p[j]</code> 来加快查找。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">char</span> s[<span class="hljs-number">1000</span>];<br><span class="hljs-keyword">char</span> s_new[<span class="hljs-number">2000</span>];<br><span class="hljs-keyword">int</span> p[<span class="hljs-number">2000</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>	s_new[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;$&#x27;</span>;<br>	s_new[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>	<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>	&#123;<br>		s_new[j++] = s[i];<br>		s_new[j++] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>	&#125;<br><br>	s_new[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;   <span class="hljs-comment">// 这是一个好习惯</span><br><br>	<span class="hljs-keyword">return</span> j;  <span class="hljs-comment">// 返回 s_new 的长度</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Manacher</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> len = <span class="hljs-built_in">Init</span>();  <span class="hljs-comment">// 取得新字符串长度并完成向 s_new 的转换</span><br>	<span class="hljs-keyword">int</span> max_len = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 最长回文长度</span><br>	<span class="hljs-keyword">int</span> id;<br>	<span class="hljs-keyword">int</span> mx = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (i &lt; mx)<br>			p[i] = <span class="hljs-built_in">min</span>(p[<span class="hljs-number">2</span> * id - i], mx - i);  <span class="hljs-comment">// 需搞清楚上面那张图含义，mx 和 2*id-i 的含义</span><br>		<span class="hljs-keyword">else</span><br>			p[i] = <span class="hljs-number">1</span>;<br><br>		<span class="hljs-keyword">while</span> (s_new[i - p[i]] == s_new[i + p[i]])  <span class="hljs-comment">// 不需边界判断，因为左有 $，右有 ^</span><br>			p[i]++;<br><br>		<span class="hljs-comment">// 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，</span><br>		<span class="hljs-comment">// 这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率</span><br>		<span class="hljs-keyword">if</span> (mx &lt; i + p[i])<br>		&#123;<br>			id = i;<br>			mx = i + p[i];<br>		&#125;<br><br>		max_len = <span class="hljs-built_in">max</span>(max_len, p[i] - <span class="hljs-number">1</span>);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> max_len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入字符串：&quot;</span>);<br>	cin.<span class="hljs-built_in">getline</span>(s,<span class="hljs-number">10</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最长回文长度为 %d\n\n&quot;</span>, <span class="hljs-built_in">Manacher</span>());<br>	cout &lt;&lt; <span class="hljs-built_in">Manacher</span>();<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序员内功</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>最长回文子串</tag>
        <tag>Manacher算法</tag>
        <tag>马拉车算法</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle创建用户、角色、授权、建表以及查看相应属性</title>
    <url>/posts/1efa294c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><font color="blueviolet" weight="5px"><b>orcale创建及配置角色，参数查看与设置</b></font></p>
<p>oracle的创建以及启动，角色的创建于授权等内容</p>
<p><img src="https://img.shields.io/badge/-Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-yellowgreen"><img src="https://img.shields.io/badge/-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7-information"><img src="https://img.shields.io/badge/-%E5%8F%82%E6%95%B0%E6%9F%A5%E8%AF%A2-blueviolet"></p>
<blockquote>
<p>转载声明： <a href="https://www.cnblogs.com/roger112/p/7685307.html">https://www.cnblogs.com/roger112/p/7685307.html</a></p>
</blockquote>
<span id="more"></span>

<h2 id="oracle创建用户、角色、授权、建表"><a href="#oracle创建用户、角色、授权、建表" class="headerlink" title="oracle创建用户、角色、授权、建表"></a>oracle创建用户、角色、授权、建表</h2><p>oracle<a href="http://www.2cto.com/database/">数据库</a>的权限<a href="http://www.2cto.com/os/">系统</a>分为系统权限与对象权限。系统权限( database system privilege )可以让用户执行特定的命令集。例如，create table权限允许用户创建表，grant any privilege 权限允许用户授予任何系统权限。对象权限( database object privilege )可以让用户能够对各个对象进行某些操作。例如delete权限允许用户删除表或视图的行，select权限允许用户通过select从表、视图、序列(sequences)或快照(snapshots)中查询信息。</p>
<p>每个oracle用户都有一个名字和口令,并拥有一些由其创建的表、视图和其他资源。oracle角色(role)就是一组权限(privilege)(或者是每个用户根据其状态和条件所需的访问类型)。用户可以给角色授予或赋予指定的权限，然后将角色赋给相应的用户。一个用户也可以直接给其他用户授权。</p>
<h3 id="一、创建用户"><a href="#一、创建用户" class="headerlink" title="一、创建用户"></a>一、创建用户</h3><p>oracle内部有两个建好的用户：system和sys。用户可直接登录到system用户以创建其他用户，因为system具有创建别 的用户的 权限。 在安装oracle时，用户或系统管理员首先可以为自己建立一个用户。</p>
<p>语法[创建用户]： create user 用户名 identified by 口令[即密码]；</p>
<p>例子： create user test identified by test;</p>
<p>语法[更改用户]: alter user 用户名 identified by 口令[改变的口令];</p>
<p>例子： alter user test identified by 123456;</p>
<h3 id="二、删除用户"><a href="#二、删除用户" class="headerlink" title="二、删除用户"></a>二、删除用户</h3><p>语法：drop user 用户名;</p>
<p>例子：drop user test;</p>
<p>若用户拥有对象，则不能直接删除，否则将返回一个错误值。指定关键字cascade,可删除用户所有的对象，然后再删除用户。</p>
<p>语法： drop user 用户名 cascade;</p>
<p>例子： drop user test cascade;</p>
<h3 id="三、授权角色"><a href="#三、授权角色" class="headerlink" title="三、授权角色"></a>三、授权角色</h3><p>oracle为兼容以前版本，提供三种标准角色（role）:connect/resource和dba.</p>
<p>（1）讲解三种标准角色：</p>
<p>1》. connect role(连接角色)</p>
<p>–临时用户，特指不需要建表的用户，通常只赋予他们connect role. </p>
<p>–connect是使用oracle简单权限，这种权限只对其他用户的表有访问权限，包括select/insert/update和delete等。</p>
<p>–拥有connect role 的用户还能够创建表、视图、序列（sequence）、簇（cluster）、同义词(synonym)、回话（session）和其他 数据的链（link）</p>
<p>2》. resource role(资源角色)</p>
<p>–更可靠和正式的数据库用户可以授予resource role。</p>
<p>–resource提供给用户另外的权限以创建他们自己的表、序列、过程(procedure)、触发器(trigger)、索引(index)和簇(cluster)。</p>
<p>3》. dba role(数据库管理员角色)</p>
<p>–dba role拥有所有的系统权限</p>
<p>–包括无限制的空间限额和给其他用户授予各种权限的能力。system由dba用户拥有</p>
<p>（2）授权命令</p>
<p>语法： grant connect, resource to 用户名;</p>
<p>例子： grant connect, resource to test;</p>
<p>  （3）撤销权限</p>
<p>语法： revoke connect, resource from 用户名;</p>
<p>列子： revoke connect, resource from test;</p>
<h3 id="四、创建-授权-删除角色"><a href="#四、创建-授权-删除角色" class="headerlink" title="四、创建/授权/删除角色"></a>四、创建/授权/删除角色</h3><p>除了前面讲到的三种系统角色—-connect、resource和dba，用户还可以在oracle创建自己的role。用户创建的role可以由表或系统权限或两者的组合构成。为了创建role，用户必须具有create role系统权限。</p>
<p>1》创建角色</p>
<p>语法： create role 角色名;</p>
<p>例子： create role testRole;</p>
<p>2》授权角色</p>
<p>语法： grant select on class to 角色名;</p>
<p>列子： grant select on class to testRole;</p>
<p>注：现在，拥有testRole角色的所有用户都具有对class表的select查询权限</p>
<p>3》删除角色</p>
<p>语法： drop role 角色名;</p>
<p>例子： drop role testRole;</p>
<p>注：与testRole角色相关的权限将从数据库全部删除</p>
<h2 id="oracle的启动关闭与属性查看修改"><a href="#oracle的启动关闭与属性查看修改" class="headerlink" title="oracle的启动关闭与属性查看修改"></a>oracle的启动关闭与属性查看修改</h2><h3 id="启动和关闭数据库"><a href="#启动和关闭数据库" class="headerlink" title="启动和关闭数据库"></a>启动和关闭数据库</h3><p><img src="../../../../images/orcale1.png"></p>
<h3 id="展示相关参数"><a href="#展示相关参数" class="headerlink" title="展示相关参数"></a>展示相关参数</h3><h4 id="select-from-v-bgprocess-where-paddr-lt-gt-’00’"><a href="#select-from-v-bgprocess-where-paddr-lt-gt-’00’" class="headerlink" title="select * from  v$bgprocess  where  paddr&lt;&gt;’00’;"></a>select * from  v$bgprocess  where  paddr&lt;&gt;’00’;</h4><p><img src="../../../../images/orcale2.png"><img src="../../../../images/orcale3.png"></p>
<p><img src="../../../../images/orcale4.png"></p>
<h4 id="select-from-v-controlfile"><a href="#select-from-v-controlfile" class="headerlink" title="select * from v$controlfile;"></a>select * from v$controlfile;</h4><p><img src="../../../../images/orcale5.png"></p>
<h3 id="查参数是否都可以用此模糊查询"><a href="#查参数是否都可以用此模糊查询" class="headerlink" title="查参数是否都可以用此模糊查询"></a>查参数是否都可以用此模糊查询</h3><p><img src="../../../../images/orcale6.png"></p>
<h3 id="show-parameter-db-cache"><a href="#show-parameter-db-cache" class="headerlink" title="show parameter db_cache"></a>show parameter db_cache</h3><p><img src="../../../../images/orcale7.png"></p>
<h3 id="show-parameter-log"><a href="#show-parameter-log" class="headerlink" title="show parameter log"></a>show parameter log</h3><p><img src="../../../../images/orcale8.png"></p>
<p><img src="../../../../images/orcale9.png"></p>
<h3 id="11-show-parameter-sga"><a href="#11-show-parameter-sga" class="headerlink" title="11) show parameter sga;"></a>11) show parameter sga;</h3><p><img src="../../../../images/orcale10.png"></p>
<h3 id="12-alter-session-set-nls-language-american"><a href="#12-alter-session-set-nls-language-american" class="headerlink" title="12)alter  session  set  nls_language=american;"></a>12)alter  session  set  nls_language=american;</h3><p><img src="../../../../images/orcale11.png"></p>
<h3 id="13-alter-system-set-db-cache-size-16m"><a href="#13-alter-system-set-db-cache-size-16m" class="headerlink" title="13)alter  system  set  db_cache_size=16m;"></a>13)alter  system  set  db_cache_size=16m;</h3><p><img src="../../../../images/orcale12.png"></p>
<h3 id="14-select-from-authers"><a href="#14-select-from-authers" class="headerlink" title="14)select * from  authers;"></a>14)select * from  authers;</h3><h3 id="15-show-parameter-db"><a href="#15-show-parameter-db" class="headerlink" title="15)show  parameter  db"></a>15)show  parameter  db</h3><p><img src="../../../../images/orcale13.png"></p>
<h3 id="16-alter-system-set-db-cache-advice-on"><a href="#16-alter-system-set-db-cache-advice-on" class="headerlink" title="16)alter  system  set  db_cache_advice=on;"></a>16)alter  system  set  db_cache_advice=on;</h3><p><img src="../../../../images/orcale14.png"></p>
<h4 id="17-show-parameter-log-bufffer"><a href="#17-show-parameter-log-bufffer" class="headerlink" title="17)show  parameter log_bufffer"></a>17)show  parameter log_bufffer</h4><h4 id="18-select-from-v-bgprocess-where-paddr-lt-gt-‘00’"><a href="#18-select-from-v-bgprocess-where-paddr-lt-gt-‘00’" class="headerlink" title="18)select * from  v$bgprocess  where  paddr&lt;&gt; ‘00’;"></a>18)select * from  v$bgprocess  where  paddr&lt;&gt; ‘00’;</h4><h4 id="19-archive-log-list-看是否归档模式"><a href="#19-archive-log-list-看是否归档模式" class="headerlink" title="19)archive  log  list            //看是否归档模式"></a>19)archive  log  list            //看是否归档模式</h4><p><img src="../../../../images/orcale15.png"></p>
<h4 id="20-commit-LGWR写"><a href="#20-commit-LGWR写" class="headerlink" title="20)commit                        //LGWR写"></a>20)commit                        //LGWR写</h4><p><img src="../../../../images/orcale16.png"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Oracle数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法(自刷)</title>
    <url>/posts/31380466.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><center><font color="green" face="华文彩云" size="100">二分法</font></center>

<h2 id="二分法代码"><a href="#二分法代码" class="headerlink" title="二分法代码"></a>二分法代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 二分查找（折半查找）：对于已排序，若无序，需要先排序</span><br><br><span class="hljs-comment">// 非递归</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> value , <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (v.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br>	<span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>		<span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">if</span> (v[mid] == value) &#123;<br>			<span class="hljs-keyword">return</span> mid;<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v[mid] &gt; value) &#123;<br>			high = mid - <span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			low = mid + <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinarySearch2</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; v, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (low &gt; high)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">if</span> (v[mid] == value)<br>		<span class="hljs-keyword">return</span> mid;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v[mid] &gt; value)<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">BinarySearch2</span>(v, value, low, mid - <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">BinarySearch2</span>(v, value, mid + <span class="hljs-number">1</span>, high);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>[34. 在排序数组中查找元素的第一个和最后一个位置](###34. 在排序数组中查找元素的第一个和最后一个位置)</p>
<p>[69.x的平方根](###69. x 的平方根)</p>
<p>[153. 寻找旋转排序数组中的最小值](###153. 寻找旋转排序数组中的最小值)</p>
<p>[167. 两数之和 II - 输入有序数组](###167. 两数之和 II - 输入有序数组)</p>
<span id="more"></span>


<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出: [3,4]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出: [-1,-1]<br></code></pre></td></tr></table></figure>

<h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight c++"><figcaption><span>code-banner</span></figcaption><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>         <span class="hljs-comment">// 搜索右边界 right</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m] &lt;= target) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> right = i;<br>        <span class="hljs-comment">// 若数组中无 target ，则提前返回</span><br>        <span class="hljs-keyword">if</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] != target) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">if</span>(j &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-comment">// 搜索左边界 right</span><br>        i = <span class="hljs-number">0</span>; j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= j) &#123;<br>            <span class="hljs-keyword">int</span> m = (i + j) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m] &lt; target) i = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = j;<br>        <span class="hljs-keyword">return</span> &#123;left + <span class="hljs-number">1</span>, right - <span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="解法二-还是二分法"><a href="#解法二-还是二分法" class="headerlink" title="解法二(还是二分法)"></a>解法二(还是二分法)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>,mid;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) <br>        &#123;<br>            mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt; target)<br>                right = mid - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target) <br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[right] &gt; target)<br>                    right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[left] &lt; target)<br>                    left++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[left] == target &amp;&amp; nums[right] == target)<br>                    <span class="hljs-keyword">return</span> &#123;left , right&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></h3><p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: 4<br>输出: 2<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842..., <br>     由于返回类型是整数，小数部分将被舍去。<br><br></code></pre></td></tr></table></figure>

<h4 id="代码（一看就会）"><a href="#代码（一看就会）" class="headerlink" title="代码（一看就会）"></a>代码（一看就会）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> l = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> r = x;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)<br>        &#123;<br>            <span class="hljs-keyword">int</span> mid = (l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (x/mid == mid) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x/mid &gt; mid) &#123;<br>                l = mid+<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l<span class="hljs-number">-1</span>;<br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [3,4,5,1,2]<br>输出: 1<br></code></pre></td></tr></table></figure>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [3,4,5,1,2]<br>输出: 1<br></code></pre></td></tr></table></figure>

<h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><ul>
<li>指针最终指向数组最大和最小的位置</li>
<li>左右两边不断靠近到整个数组最大值与最小值的分界点</li>
<li><img src="http://qgqz63fje.hb-bkt.clouddn.com/20200927190700.png" alt="image-20200927190655851"></li>
</ul>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> min = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(nums[left] &lt; nums[right]) <span class="hljs-keyword">return</span> nums[left];<br>        <span class="hljs-keyword">while</span>(left &lt; right)<br>        &#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(right - left == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> nums[left]&gt;nums[right]?nums[right]:nums[left]; <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[right])<br>                left = mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[right])<br>                right = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h3><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right = numbers.<span class="hljs-built_in">size</span>() <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> sum = numbers[left] + numbers[right];<br>        <span class="hljs-keyword">while</span> ( sum != target)<br>        &#123;<br>            sum = numbers[left] + numbers[right];<br>            <span class="hljs-keyword">if</span>( sum &lt; target)<br>                left++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)&#123;<br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( sum == target)&#123;<br>                <span class="hljs-keyword">return</span> &#123;left+<span class="hljs-number">1</span>,right+<span class="hljs-number">1</span>&#125;;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;left+<span class="hljs-number">1</span>,right+<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈(自刷)</title>
    <url>/posts/149d196b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><div class="note modern purple simple"><p><a href="#%E9%A2%98%E7%9B%AE%E4%B8%80">题目一</a></p>
<h4 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="#%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">剑指 Offer 09. 用两个栈实现队列</a></h4></div>

<span id="more"></span>





<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></p>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：<br>[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：<br>[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]<br></code></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CQueue</span>() &#123;<br><br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        one.<span class="hljs-built_in">push</span>(value);<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(two.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(one.<span class="hljs-built_in">empty</span>())<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(!one.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                two.<span class="hljs-built_in">push</span>(one.<span class="hljs-built_in">top</span>());<br>                one.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">int</span> top = two.<span class="hljs-built_in">top</span>();<br>            two.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">return</span> top;                <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> top = two.<span class="hljs-built_in">top</span>();<br>            two.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">return</span> top;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; one,two; <br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="找出右边第一个比其大的数"><a href="#找出右边第一个比其大的数" class="headerlink" title="找出右边第一个比其大的数"></a>找出右边第一个比其大的数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findMax2</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;num)</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    <span class="hljs-keyword">if</span> (num.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> num;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">res</span>(num.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt;s;<br>    <span class="hljs-keyword">while</span> (i &lt; num.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>() || num[s.<span class="hljs-built_in">top</span>()] &gt;= num[i])<span class="hljs-comment">//如果堆栈里面有的top元素比即将到来的元素大，则入栈，直到右边找到比top元素大的，</span><br>        &#123;<br>            s.<span class="hljs-built_in">push</span>(i++);<span class="hljs-comment">//i增加，遍历下个元素</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//栈里面有元素，且满足num[i] 比栈里面的元素大，则找到s.top()位置对应值，右边第一个元素其大的元素</span><br>        &#123;<br>            res[s.<span class="hljs-built_in">top</span>()] = num[i];<br>            s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//此处仅仅弹出top元素，因为其找到了右边第一个元素比其大的值，而i不变化，是因为num[i]也有可能比pop之后top元素大</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>())<span class="hljs-comment">//如果不为空，说明这些元素没有找到</span><br>    &#123;<br>        res[s.<span class="hljs-built_in">top</span>()] = INT_MAX;<span class="hljs-comment">//直接用INT_MAX标记</span><br>        s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); i++)<br>        cout &lt;&lt; res[i] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> res;<br> <br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法(自刷)</title>
    <url>/posts/45042f99.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="贪心算法（自刷）"><a href="#贪心算法（自刷）" class="headerlink" title="贪心算法（自刷）"></a>贪心算法（自刷）</h1><p><a href="#53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C">53.最大子序和</a></p>
<span id="more"></span>

<h2 id="53最大子序和"><a href="#53最大子序和" class="headerlink" title="53最大子序和"></a>53最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ol>
<li>初始化<ul>
<li>定义一个当前和curSum，为负数的时候就清零从新累计，初始值为0;</li>
<li>定义一个最大和maxSum，每当curSum求出之后都要拿来比较一下，进行更新,初始值为Integer.MIN_VALUE，保证计算第一</li>
<li>元素的时候maxSum就更新为curSum；</li>
</ul>
</li>
<li>遍历，对每一个元素进行如下操作：<ul>
<li>计算当前和curSum;</li>
<li>更新最大和maxSum;</li>
<li>更新当前和curSum，若为负数则清零</li>
</ul>
</li>
<li>返回</li>
</ol>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span><br>        <span class="hljs-keyword">int</span> result = INT_MIN;<br>        <span class="hljs-keyword">int</span> numsSize = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(nums.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++)<br>        &#123;<br>            sum += nums[i];<br>            result = <span class="hljs-built_in">max</span>(result, sum);<br>            <span class="hljs-comment">//如果sum &lt; 0，重新开始找子序串</span><br>            <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>                sum = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="122-买卖股票的最佳时机"><a href="#122-买卖股票的最佳时机" class="headerlink" title="122.买卖股票的最佳时机"></a>122.买卖股票的最佳时机</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。<br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br></code></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果<code>i+1</code>天比<code>i</code>天大，就累加</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> profit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; prices.<span class="hljs-built_in">size</span>(); i++)<br>                profit += <span class="hljs-built_in">max</span>(prices[i+<span class="hljs-number">1</span>] - prices[i], <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> profit;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法(自刷)</title>
    <url>/posts/3e1bc1fc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>自刷</p>
<span id="more"></span>

<h2 id="分治算法的核心思想"><a href="#分治算法的核心思想" class="headerlink" title="分治算法的核心思想"></a>分治算法的核心思想</h2><p>分治算法的核心思想就是四个字,分而治之,也就是将原来的问题划分成n个规模较小,并且结构与原问题相似的子问题,递归地解决这些子问题,然后再合并其结果,就得到原问题的解.<br>  看起来有点像递归,不过要知道分治算法是一种处理问题的思想,递归是一种编程技巧.看起来像是因为分治算法一般都比较适合用递归去实现</p>
<h2 id="分治算法递归实现步骤"><a href="#分治算法递归实现步骤" class="headerlink" title="分治算法递归实现步骤"></a>分治算法递归实现步骤</h2><h3 id="1-分解："><a href="#1-分解：" class="headerlink" title="1. 分解："></a>1. 分解：</h3><p>​    将原问题分解为一系列的子问题</p>
<h3 id="2-解决："><a href="#2-解决：" class="headerlink" title="2. 解决："></a>2. 解决：</h3><p>递归地求解各个子问题，若子问题足够小，则直接求解。</p>
<h3 id="3-合并："><a href="#3-合并：" class="headerlink" title="3. 合并："></a>3. 合并：</h3><p>将子问题的结果合并为原问题</p>
<p><a href="#53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"> 53.最大子序和</a></p>
<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&#96;进阶:<br></code></pre></td></tr></table></figure>

<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="1"><a href="#1" class="headerlink" title="1. "></a>1. <a href="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md/##53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><a href="#">Post not found: 力扣自刷/动态规划</a></a></h3><h3 id="2"><a href="#2" class="headerlink" title="2. "></a>2. <a href="./%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/#53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><a href="#">Post not found: 力扣自刷/贪心算法</a></a></h3><h3 id="3-分治算法"><a href="#3-分治算法" class="headerlink" title="3. 分治算法"></a>3. 分治算法</h3><p> <img src="https://img.shields.io/badge/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-n-red"><img src="https://img.shields.io/badge/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-n-information"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findmax</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; nums, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> v, L, R, midMaxs;<br>	<span class="hljs-keyword">if</span> (y - x == <span class="hljs-number">0</span>) &#123; <br>		<span class="hljs-keyword">return</span>  nums[x]; <br>	&#125;<br>	<span class="hljs-keyword">int</span> m = ( x + y ) / <span class="hljs-number">2</span>; <span class="hljs-comment">//分治第一步，划分成[x,m)和[m,y)两部分</span><br>	midMaxs = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">findmax</span>(nums, x, m), <span class="hljs-built_in">findmax</span>(nums, m + <span class="hljs-number">1</span>, y));<br>	v = <span class="hljs-number">0</span>; L = nums[m]; R = nums[m+<span class="hljs-number">1</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m ; i &gt;= x; i--)<br>	&#123;<br>		L = <span class="hljs-built_in">max</span>(L, v += nums[i]);<br>	&#125;<br>	v = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m + <span class="hljs-number">1</span> ; i &lt;= y; i++)<br>	&#123;<br>		R = <span class="hljs-built_in">max</span>(R, v += nums[i]);<br>	&#125; <br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(L + R, midMaxs);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>	<span class="hljs-keyword">int</span> length = nums.<span class="hljs-built_in">size</span>();<br>	<span class="hljs-keyword">int</span> result = <span class="hljs-built_in">findmax</span>(nums, <span class="hljs-number">0</span>, length<span class="hljs-number">-1</span>);<br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划(自刷)</title>
    <url>/posts/14c322e6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h4><p><a href="#%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%92%8C">最大上升子序和</a></p>
<p><a href="#53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C">最大子序和</a></p>
<p><a href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">最长回文子串</a></p>
<p><a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">不同路径</a></p>
<p><a href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97">最长回文子序列</a></p>
<p><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D">正则表达式匹配</a></p>
<span id="more"></span>

<h2 id="最大上升子序列和"><a href="#最大上升子序列和" class="headerlink" title="最大上升子序列和"></a>最大上升子序列和</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个数的序列bi，当b1 &lt; b2 &lt; … &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …,aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和. 你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)。</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入包含多组测试数据。<br>每组测试数据由两行组成。第一行是序列的长度N (1 &lt;&#x3D; N &lt;&#x3D; 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。<br></code></pre></td></tr></table></figure>

<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">对于每组测试数据，输出其最大上升子序列和。<br></code></pre></td></tr></table></figure>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">7<br>1 7 3 5 9 4 8<br></code></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">18<br></code></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>从前往后依次计算当前位置的最大子序列和：</p>
<p>​                            sum[当前位置] = max( arr[当前位置] , sum[之前] + arr[当前位置])</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; arr;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; sum;<br>	sum.<span class="hljs-built_in">resize</span>(<span class="hljs-number">1000</span>);<br>	<span class="hljs-keyword">int</span> length, resMax = <span class="hljs-number">0</span>;<br>	cin &gt;&gt; length;<br>	<span class="hljs-keyword">while</span> (!cin.<span class="hljs-built_in">eof</span>() &amp;&amp; length--)<br>	&#123;<br>		<span class="hljs-keyword">int</span> temp;<br>		cin &gt;&gt; temp;<br>		arr.<span class="hljs-built_in">push_back</span>(temp);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>; end &lt; arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; end++)<br>	&#123;<br>		sum[end] = arr[end];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>; first &lt; end; first++)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (arr[first] &lt; arr[end])<br>			&#123;<br>				sum[end] = <span class="hljs-built_in">max</span>(sum[end] , arr[end]+sum[first]);<br>			&#125;<br>		&#125;<br>		resMax = <span class="hljs-built_in">max</span>(resMax, sum[end]);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : sum)<br>		cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>	cout &lt;&lt; resMax &lt;&lt; endl;<br><br><br><br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>最大子序和</p>
<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&#96;进阶:<br></code></pre></td></tr></table></figure>

<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><img src="https://img.shields.io/badge/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-n-red"><img src="https://img.shields.io/badge/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-n-information"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sonSum</span><span class="hljs-params">(nums.size())</span></span>;<br>	sonSum[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>	<span class="hljs-keyword">int</span> res = sonSum[<span class="hljs-number">0</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		sonSum[i] = <span class="hljs-built_in">max</span>(nums[i], sonSum[i - <span class="hljs-number">1</span>] + nums[i]);<br>		res = <span class="hljs-built_in">max</span>(res, sonSum[i]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></p>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;babad&quot;<br>输出: &quot;bab&quot;<br>注意: &quot;aba&quot; 也是一个有效答案。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;cbbd&quot;<br>输出: &quot;bb&quot;<br></code></pre></td></tr></table></figure>

<h3 id="代码（时间复杂度高）"><a href="#代码（时间复杂度高）" class="headerlink" title="代码（时间复杂度高）"></a>代码（时间复杂度高）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string str)</span> </span>&#123;<br>                <span class="hljs-comment">//空字符串直接返回0</span><br>        <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">length</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> str;<br>        &#125;<br>        <span class="hljs-comment">//记录下manacher字符串的长度，方便后面使用</span><br>        <span class="hljs-keyword">int</span> len = (<span class="hljs-keyword">int</span>)(str.<span class="hljs-built_in">length</span>() * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//开辟动态数组chaArr记录manacher化的字符串</span><br>        <span class="hljs-comment">//开辟动态数组pArr记录每个位置的回文半径</span><br>        <span class="hljs-keyword">char</span> *chaArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len];<br>        <span class="hljs-keyword">int</span>* pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len;i++) &#123;<br>            chaArr[i] = (i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;#&#x27;</span> : str[index++];<br>        &#125;<br>        <span class="hljs-comment">//到此完成对原字符串的manacher化</span><br>        <span class="hljs-comment">//R是最右回文边界，C是R对应的最左回文中心，maxn是记录的最大回文半径</span><br>        <span class="hljs-keyword">int</span> R = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> C = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> start=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//开始从左到右遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-comment">//第一步直接取得可能的最短的回文半径，当i&gt;R时，最短的回文半径是1，反之，最短的回文半径可能是i对应的i&#x27;的回文半径或者i到R的距离</span><br>            pArr[i] = R &gt; i ? <span class="hljs-built_in">min</span>(R - i, pArr[<span class="hljs-number">2</span> * C - i]) : <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//取最小值后开始从边界暴力匹配，匹配失败就直接退出</span><br>            <span class="hljs-keyword">while</span> (i + pArr[i]&lt;len &amp;&amp; i - pArr[i]&gt;<span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (chaArr[i + pArr[i]] == chaArr[i - pArr[i]]) &#123;<br>                    pArr[i]++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//观察此时R和C是否能够更新</span><br>            <span class="hljs-keyword">if</span> (i + pArr[i] &gt; R) &#123;<br>                R = i + pArr[i];<br>                C = i;<br>            &#125;<br>            <span class="hljs-comment">//更新最大回文半径的值</span><br>            <span class="hljs-keyword">if</span>(maxn&lt;pArr[i])&#123;<br>                maxn = pArr[i];<br>                start=(i-maxn+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-comment">//记得清空动态数组哦</span><br>        <span class="hljs-keyword">delete</span>[] chaArr;<br>        <span class="hljs-keyword">delete</span>[] pArr;<br>        <span class="hljs-keyword">return</span> str.<span class="hljs-built_in">substr</span>(start,maxn<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二（动态规划）"><a href="#解法二（动态规划）" class="headerlink" title="解法二（动态规划）"></a>解法二（动态规划）</h3><p><img src="https://img.shields.io/badge/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-n%C2%B2-red"><img src="https://img.shields.io/badge/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-n%C2%B2-information"></p>
<ul>
<li>建立<code>dp[i][j]</code>数组存入<code>s[i:j]</code>这个区间的字符是否是回文串</li>
<li>判断当前区间<code>s[i:j]</code>是否是回文串只需要判断当前<code>s[i]==s[j] &amp;&amp; dp[i+1][j-1]</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">//建立dp数组  </span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));<br>    string ans;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span> ; l &lt; n; ++l)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i + l &lt; n; ++i)<br>        &#123;<br>            <span class="hljs-keyword">int</span> j = i + l;<br>            <span class="hljs-keyword">if</span>(l == <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l == <span class="hljs-number">1</span>) &#123;<br>                dp[i][j] = (s[i] == s[j]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>            <span class="hljs-comment">//如果发现长度更长的，则更新ans</span><br>            <span class="hljs-keyword">if</span>(dp[i][j] &amp;&amp; l + <span class="hljs-number">1</span> &gt; ans.<span class="hljs-built_in">size</span>())&#123;<br>                ans = s.<span class="hljs-built_in">substr</span>(i , l + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p><a href="https://leetcode-cn.com/problems/unique-paths/">62不同路径</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt="img"></p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: m &#x3D; 3, n &#x3D; 2<br>输出: 3<br>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。<br><br>1. 向右 -&gt; 向右 -&gt; 向下<br>2. 向右 -&gt; 向下 -&gt; 向右<br>3. 向下 -&gt; 向右 -&gt; 向右<br></code></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: m &#x3D; 7, n &#x3D; 3<br>输出: 28<br></code></pre></td></tr></table></figure>



<h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//动态创建一个二维路径答案表</span><br>    <span class="hljs-keyword">int</span> **dp = (<span class="hljs-keyword">int</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span> *) * n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        dp[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * m);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">//最上一行或者最左一列</span><br>                dp[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//静态变量放在class外面（类似全局变量），并初始化。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span> || n == <span class="hljs-number">1</span>)<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (m == <span class="hljs-number">2</span>)<br>		<span class="hljs-keyword">return</span> n;<br>	<span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br>		<span class="hljs-keyword">return</span> m;<br>	<span class="hljs-keyword">if</span> (a[m][n] &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//计算过就直接返回。</span><br>		<span class="hljs-keyword">return</span> a[m][n];<br>	a[m - <span class="hljs-number">1</span>][n] = <span class="hljs-built_in">uniquePaths</span>(m - <span class="hljs-number">1</span>, n);<br>	a[n][m - <span class="hljs-number">1</span>] = a[m - <span class="hljs-number">1</span>][n];<span class="hljs-comment">//由于本题的对称性，可以直接复制到对称位置</span><br>	a[m][n<span class="hljs-number">-1</span>] = <span class="hljs-built_in">uniquePaths</span>(m, n - <span class="hljs-number">1</span>);<br>	a[n - <span class="hljs-number">1</span>][m] = a[m][n - <span class="hljs-number">1</span>];<span class="hljs-comment">//由于本题的对称性，可以直接复制到对称位置</span><br>	a[m][n] = a[m - <span class="hljs-number">1</span>][n] + a[m][n<span class="hljs-number">-1</span>];<br>	<span class="hljs-keyword">return</span>  a[m][n];<span class="hljs-comment">//递归法</span><br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></p>
<p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入:<br>&quot;bbbab&quot;<br>输出:<br>4<br>一个可能的最长回文子序列为 &quot;bbbb&quot;。<br></code></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入:<br>&quot;cbbd&quot;<br>输出:<br>2<br>一个可能的最长回文子序列为 &quot;bb&quot;。<br></code></pre></td></tr></table></figure>

<h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (s[i] == s[j])<br>    <span class="hljs-comment">// 它俩一定在最长回文子序列中</span><br>    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？</span><br>    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure>



<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n,vector&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; i++)<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-comment">//状态转移方程</span><br>                <span class="hljs-keyword">if</span> (s[i] == s[j])<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E5%9B%B0%E9%9A%BE-red"></p>
<p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></p>
<p>强烈推荐大佬的讲解↓！！！</p>
<blockquote>
<p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/">https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/</a></p>
</blockquote>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    map&lt;string,<span class="hljs-keyword">bool</span>&gt; memo;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dp</span><span class="hljs-params">(string&amp; s, <span class="hljs-keyword">int</span> i,string&amp; p,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> m = s.<span class="hljs-built_in">size</span>(), n = p.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (j == n) &#123;<br>        <span class="hljs-keyword">return</span> i == m;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == m) &#123;<br>        <span class="hljs-keyword">if</span> ((n - j) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (; j + <span class="hljs-number">1</span> &lt; n; j += <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p[j + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 记录状态 (i, j)，消除重叠子问题</span><br>    string key = <span class="hljs-built_in">to_string</span>(i) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">to_string</span>(j);<br>    <span class="hljs-keyword">if</span> (memo.<span class="hljs-built_in">count</span>(key)) <span class="hljs-keyword">return</span> memo[key];<br>    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (s[i] == p[j] || p[j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; p[j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            res = <span class="hljs-built_in">dp</span>(s, i, p, j + <span class="hljs-number">2</span>)<br>               || <span class="hljs-built_in">dp</span>(s, i + <span class="hljs-number">1</span>, p, j);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res = <span class="hljs-built_in">dp</span>(s, i + <span class="hljs-number">1</span>, p, j + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; p[j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            res = <span class="hljs-built_in">dp</span>(s, i, p, j + <span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将当前结果记入备忘录</span><br>    memo[key] = res;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(s,<span class="hljs-number">0</span>,p,<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h2><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E4%B8%AD%E7%AD%89-red"></p>
<p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></p>
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>
<p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：strs &#x3D; [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m &#x3D; 5, n &#x3D; 3<br>输出：4<br>解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。<br>其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：strs &#x3D; [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m &#x3D; 1, n &#x3D; 1<br>输出：2<br>解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。<br></code></pre></td></tr></table></figure>

<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> S = strs.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; S; ++l) &#123;<br>            <span class="hljs-keyword">int</span> zero = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> one = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs[l].<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-keyword">if</span> (strs[l][i] == <span class="hljs-string">&#x27;0&#x27;</span>) ++zero;<br>                <span class="hljs-keyword">else</span> ++one;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &gt;= zero; --i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &gt;= one; --j) &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], <span class="hljs-number">1</span> + dp[i - zero][j - one]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>计算爬上n-1阶楼梯的方法数量。因为再爬1阶就到第n阶 </p>
</li>
<li><p>计算爬上n-2阶楼梯体方法数量。因为再爬2阶就到第n阶 那么f(n)=f(n-1)+f(n-2);</p>
</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>||n==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt; n; i++)<br>        &#123;<br>            dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>STL常用函数</title>
    <url>/posts/b84e1b9c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="STL函数"><a href="#STL函数" class="headerlink" title="STL函数"></a>STL函数</h1><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 删除向量中的所有元素，然后将选代器first和last指示范围中的元素插入该向量中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(iterator first,iterator last)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//删除向量中的所有元素，然后将cdl的n个副本插入该向量中</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(size_type n,constT&amp;el=T())</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量中位置为n的元素</span></span><br><span class="hljs-function">T&amp;<span class="hljs-title">at</span><span class="hljs-params">(siz type n)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量中位置为n的元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">const</span> T&amp;<span class="hljs-title">at</span><span class="hljs-params">(size_type n)</span><span class="hljs-keyword">const</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量的最后一个元素</span></span><br><span class="hljs-function">T&amp;<span class="hljs-title">back</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量的最后一个元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">const</span> T&amp;<span class="hljs-title">back</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//返回一个选代器，该选代器引用向量的第一个元素</span></span><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回一个迭代器∶该送代都引用向量的第一个元素</span></span><br><span class="hljs-function">const_iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//返回可以存储在向量中的元素数目</span></span><br><span class="hljs-function">siz_type <span class="hljs-title">capacity</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//清除向量中的所有元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//如果向量不包括元素，则返回true，否则返回false</span></span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回一个迭代器。，该选代器位于向量的最后一个元素之后</span></span><br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回一个const达代器，该达代器位于向量的最后一个元素之后</span></span><br><span class="hljs-function">const_iterator <span class="hljs-title">end</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span> </span><br><span class="hljs-function"><span class="hljs-comment">//除由迭代器i引用的元素，返回一个迭代器，用被除元素之后的元素</span></span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(teator i)</span></span><br><span class="hljs-function"><span class="hljs-comment">//删除迭代器first和last指示范围中的元素，返回一个达代器，引用被除的最后一个元素之后的元素</span></span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(iterator fist,iterator last)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量的第一个元素</span></span><br><span class="hljs-function">T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量的第一个元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">const</span> T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span> </span><br><span class="hljs-function"><span class="hljs-comment">//在由选代器i引用的元素之前插入d，并返回引用新插入元素的选代器</span></span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(iterator <span class="hljs-keyword">const</span> T&amp; el=T())</span> </span><br><span class="hljs-function"><span class="hljs-comment">//在选代器i引用的元素之前插入el的n个副本</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(iterator i,size_type n, <span class="hljs-keyword">const</span> T&amp;el)</span>    </span><br><span class="hljs-function"><span class="hljs-comment">//在选代器i引用的元素之前插入迭代器frs和hst指示范围中的元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(iterator i,iterator fist,iterator last)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量的最大元素数</span></span><br><span class="hljs-function">size _type <span class="hljs-title">max_sizt</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span> </span><br><span class="hljs-function"><span class="hljs-comment">//下标运算符</span></span><br>T&amp;operator[] <br><span class="hljs-comment">//下标运算符</span><br><span class="hljs-keyword">const</span> T&amp; operatof[]<span class="hljs-keyword">const</span> <br><span class="hljs-comment">//删除向量的最后一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//在向量的末尾插入el</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; el)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回引用向量中最后一个元素的迭代器</span></span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rbegin</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回引用向量中最后一个元素的选代器</span></span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">rbegin</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//返回位于向量中第一个元素之前的选代器</span></span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rend</span><span class="hljs-params">()</span>     </span><br><span class="hljs-function"><span class="hljs-comment">//返回位于向量中第一个元素之前的迭代器</span></span><br><span class="hljs-function">const_reverse_iternator <span class="hljs-title">rend</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span>     </span><br><span class="hljs-function"><span class="hljs-comment">//如果向量的容量小于n，该函数就为向量预留保存n项的足够空间</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reserve</span><span class="hljs-params">(size_type n)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//反转向量</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//使向量保存n个元素，方法是∶通过元素el再添加n-size()个位置，或者丢弃向量末尾溢出的sizs()-n个位置</span></span><br>void resize(size_type n,const T&amp;el=T))     <br><span class="hljs-comment">//返回向量中的元素数量</span><br><span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span>    </span><br><span class="hljs-function"><span class="hljs-comment">//与另一个向量v交换内容</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(vector&lt;T&gt;&amp;v)</span>    </span><br><span class="hljs-function"><span class="hljs-comment">//创建空向量</span></span><br><span class="hljs-function"><span class="hljs-title">vector</span><span class="hljs-params">()</span>    </span><br><span class="hljs-function"><span class="hljs-comment">//用类型T的n个el副本创建一个向量（如果没有提供ed，则使用默认的构造函数T()）</span></span><br><span class="hljs-function"><span class="hljs-title">vector</span><span class="hljs-params">(siz_type n, <span class="hljs-keyword">const</span> T&amp;el=T())</span>     </span><br><span class="hljs-function"><span class="hljs-comment">//用达代器fist 和last指示范围中的元素构造一个向量</span></span><br><span class="hljs-function"><span class="hljs-title">vector</span><span class="hljs-params">(iterator fist,iterator last)</span>   </span><br><span class="hljs-function"><span class="hljs-comment">//复制构造函数</span></span><br><span class="hljs-function"><span class="hljs-title">vector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> vector&lt;T&gt;&amp; v)</span> </span><br></code></pre></td></tr></table></figure>



<h3 id="sort-排序函数"><a href="#sort-排序函数" class="headerlink" title="sort()排序函数"></a>sort()排序函数</h3><blockquote>
<p>排序算法具有同样的灵活性，在对向量v5排序的例子中，v5是以升序来排序的。那么v5如何</p>
<p>按降序排序呢?方法之一先对向量进行升序排序，然后用 reverse()算法来反转向量。另一种方法是</p>
<p>强制sort0算法在得出结果时使用&gt;运算符。为此，可以直接把函数对象作为参数∶</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">sort</span>(v5.<span class="hljs-built_in">begin</span>(),v5.<span class="hljs-built_in">end</span>(),greater&lt;<span class="hljs-keyword">int</span>&gt;());<br><br><br><span class="hljs-comment">//或者间接使用</span><br><span class="hljs-built_in">sort</span>(v5.<span class="hljs-built_in">begin</span>(),v5.<span class="hljs-built_in">end</span>(),f2);<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> m &gt; n ;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="greater-函数"><a href="#greater-函数" class="headerlink" title="greater()函数"></a>greater()函数</h5><blockquote>
<p>头文件 #include <functional></functional></p>
<p>STL已定义的函数，这个函数对象定义为模板结构，实际上该函数重载了运算符&gt;。</p>
</blockquote>
<blockquote>
<p>函数size()： 返回向量当前的元素数目（即：向量大小）</p>
<p>函数capacity()：返回向量能够拥有的元素数目（即：向量的容量）</p>
<p>函数resize() ：可以改变函数的容量</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arhc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> a[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>	<span class="hljs-keyword">int</span> b[] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">//	b[1] = 5;</span><br>	<span class="hljs-comment">//cout &lt;&lt; &quot;b1:&quot; &lt;&lt; b[1] &lt;&lt;endl;</span><br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v1;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>; j++)<br>	&#123;<br>		v1.<span class="hljs-built_in">push_back</span>(j);<br>	&#125;<br>	cout &lt;&lt; <span class="hljs-string">&quot;v1:&quot;</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>)</span></span>;<br><br>	cout &lt;&lt; <span class="hljs-string">&quot;v2:&quot;</span> &lt;&lt; v2.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>	<span class="hljs-comment">//获取v1的下标为【1】的元素复制给i1</span><br>	vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator i1 = v1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(i1, i1 + <span class="hljs-number">3</span>)</span></span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;v3:&quot;</span> &lt;&lt; v3.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>) &lt;&lt; endl;<br>	v3[<span class="hljs-number">1</span>] = v3.<span class="hljs-built_in">front</span>();<br>	<span class="hljs-keyword">for</span> (SIZE_T i = <span class="hljs-number">0</span>; i &lt; v3.<span class="hljs-built_in">size</span>(); i++) &#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;V3[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; v3[i] &lt;&lt; endl;<br>	&#125;<br><br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v1)</span></span>; <span class="hljs-comment">// v4=(1 2 3 4 5),size=5,capacity=5</span><br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v5</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// v5=&#123;0 0 0 0 0&#125;</span><br>	v5[<span class="hljs-number">1</span>] = v5.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>)=<span class="hljs-number">9</span>;  <span class="hljs-comment">// v5 = (0 9 0 9 0)</span><br>	v3.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// v3=(2 3),size= 2,capacity=6</span><br>	v4.<span class="hljs-built_in">resize</span>(<span class="hljs-number">7</span>); <span class="hljs-comment">// v4=(1234500),size=7,capacity=10</span><br>	v4.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// v4=(123),size=3,capacity=10</span><br>	v4.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// v4 is empty,size=0,capacity=10(!)</span><br>	v4.<span class="hljs-built_in">insert</span>(v4.<span class="hljs-built_in">end</span>(), v3[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// v4 = (3)</span><br>	v4.<span class="hljs-built_in">insert</span>(v4.<span class="hljs-built_in">end</span>(), v3.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>));  <span class="hljs-comment">// v - (33)</span><br>	v4.<span class="hljs-built_in">insert</span>(v4.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 4=(3344)</span><br>	v4.<span class="hljs-built_in">insert</span>(v4.<span class="hljs-built_in">end</span>(), v1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, v1.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);<span class="hljs-comment">// v4=(3 3 4 4 2 3 4)</span><br>	v4.<span class="hljs-built_in">erase</span>(v4.<span class="hljs-built_in">end</span>() - <span class="hljs-number">2</span>); <span class="hljs-comment">//v4=(3 3 4 4 2 4)</span><br>	v4.<span class="hljs-built_in">erase</span>(v4.<span class="hljs-built_in">begin</span>(), v4.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">4</span>); <span class="hljs-comment">// v4 = (2 4)</span><br>	v4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">// v4 = (8 8 8)</span><br>	v4.<span class="hljs-built_in">assign</span>(a, a + <span class="hljs-number">3</span>);  <span class="hljs-comment">// v4 = (1 2 3)</span><br><br>	<span class="hljs-built_in">replace</span>(v5.<span class="hljs-built_in">begin</span>(), v5.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">7</span>);<br>	<span class="hljs-built_in">printVector</span>(v5);<br><br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s = <span class="hljs-string">&quot;Green&quot;</span>;<br>	<span class="hljs-function">vector&lt;Person&gt; <span class="hljs-title">v6</span><span class="hljs-params">(<span class="hljs-number">1</span>,Person(s,<span class="hljs-number">25</span>))</span></span>;<br>	v6.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Ann&quot;</span>, <span class="hljs-number">30</span>));<br>	v6.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-number">20</span>));<br><br>	<span class="hljs-built_in">sort</span>(v6.<span class="hljs-built_in">begin</span>(), v6.<span class="hljs-built_in">end</span>(),greater&lt;Person&gt;());<br><br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; v6.<span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		info manInfo = v6[i].<span class="hljs-built_in">getInfo</span>(v6[i]);<br>		cout &lt;&lt; manInfo.name &lt;&lt; <span class="hljs-string">&quot;今年&quot;</span> &lt;&lt; manInfo.age &lt;&lt; <span class="hljs-string">&quot;了&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br>	<span class="hljs-built_in">sort</span>(v6.<span class="hljs-built_in">begin</span>(), v6.<span class="hljs-built_in">end</span>(),lesserAge);<br><br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; v6.<span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		info manInfo = v6[i].<span class="hljs-built_in">getInfo</span>(v6[i]);<br>		cout &lt;&lt; manInfo.name &lt;&lt; <span class="hljs-string">&quot;今年&quot;</span> &lt;&lt; manInfo.age &lt;&lt; <span class="hljs-string">&quot;了&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="../../../images/STL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/image-20200908075126062.png"></p>
<p><img src="../../../images/STL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/image-20200908075157346.png"></p>
<p><img src="../../../images/STL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/image-20200908075434653.png"></p>
<p><img src="../../../images/STL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/image-20200908075524946.png"></p>
<p><img src="../../../images/STL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/image-20200908075611896.png" alt="image-20200908075611896"></p>
<p><img src="../../../images/STL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/image-20200908075627415.png" alt="image-20200908075627415"></p>
<p><img src="../../../images/STL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/image-20200908075652847.png"></p>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>STL基本概念</title>
    <url>/posts/ecf76003.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h1><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。</p>
<p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。</p>
<p>STL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采 用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</p>
<span id="more"></span>

<p><em>STL细说六大件：</em></p>
<p>​                        <em>– 容器（Container）</em></p>
<p>​                        <em>– 算法（Algorithm）</em></p>
<p>​                        <em>– 迭代器（Iterator）</em></p>
<p>​                        <em>– 仿函数（Function object）</em></p>
<p>​                        <em>– 适配器（Adaptor）</em></p>
<p>​                        <em>– 空间配制器（allocator）</em></p>
<p>在C++标准中，STL被组织为下面的13个头文 件：&lt;algorithm&gt;、<a href="#deque%E5%AE%B9%E5%99%A8">&lt;deque&gt;</a>、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt;。</p>
<h4 id="说了这么多，使用STL有什么好处呢？"><a href="#说了这么多，使用STL有什么好处呢？" class="headerlink" title="说了这么多，使用STL有什么好处呢？"></a>说了这么多，使用STL有什么好处呢？</h4><p>1）STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p>
<p>2）STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。</p>
<p>3） 程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p>
<p>4） STL具有高可重用性，高性能，高移植性，跨平台的优点。</p>
<p>高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</p>
<p>高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种)</p>
<p>高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。</p>
<p>跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。</p>
<p>5） 了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C＋＋程序员都应该好好学习STL。只有能够熟练使用STL的程序员，才是好的C++程序员。</p>
<p>6） 总之：招聘工作中，经常遇到C++程序员对STL不是非常了解。大多是有一个大致的映像，而对于在什么情况下应该使用哪个容器和算法都感到比较茫然。<em><strong>STL是C++程序员的一项不可或缺的基本技能</strong></em>，掌握它对提升C++编程大有裨益。</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1599604856029&di=7f8b27e773720571452df1eeba4f494d&imgtype=0&src=http://www.linuxeden.com/upimg/allimg/100929/095F1NL-0.jpg" alt="img"></p>
<div align="center">Alexander Stepanov</div>

<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>一些封装数据结构的模板类，简单来说，就是存储数据的结构</p>
<p><font style="color:red">序列式容器：</font>特点是不会对存储的元素进行排序，元素排列的顺序取决于存储它们的顺序。</p>
<p><font style="color:red">关联式容器：</font>在存储元素时会为每个元素在配备一个键，整体以键值对的方式存储到容器中，可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素，默认会根据各元素键值的大小做升序排序。</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>用来遍历容器中的元素的类型，<em>类中类</em>(可以理解为指针)，扮演着容器和算法之间的胶合剂</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>解决问题的方法</p>
<h4 id="容器、迭代器、算法分离案例"><a href="#容器、迭代器、算法分离案例" class="headerlink" title="容器、迭代器、算法分离案例"></a>容器、迭代器、算法分离案例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//算法：求数组元素个数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mcount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *begin,<span class="hljs-keyword">int</span> *end,<span class="hljs-keyword">int</span> arr[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> num=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (begin != end)<br>	&#123;<br>		num++;<br>		begin++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> num;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//容器</span><br>	<span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-comment">//迭代器</span><br>	<span class="hljs-keyword">int</span> *begin = arr;<br>	<span class="hljs-keyword">int</span> *end = &amp;arr[<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr[<span class="hljs-number">0</span>])];<br>	cout&lt;&lt;<span class="hljs-built_in">mcount</span>(begin,end,arr);<br><br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h1><h4 id="string概念"><a href="#string概念" class="headerlink" title="string概念"></a>string概念</h4><ul>
<li>string是STL的字符串类型，通常用来表示字符串。而在使用string之前，字符串通常是用char<em>表示的。string与char</em>都可以用来表示字符串，那么二者有什么区别呢。</li>
</ul>
<p><strong>string和char*的比较</strong></p>
<ul>
<li><p>string是一个类, char*是一个指向字符的指针。</p>
<p>​     <em>string封装了char*，管理这个字符串，是一个char*型的容器</em></p>
</li>
<li><p>string不用考虑内存释放和越界。</p>
<p>​     <em>string管理char</em>所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。*</p>
</li>
<li><p>string提供了一系列的字符串操作函数（这个等下会详讲）</p>
<pre><code>   *查找find，拷贝copy，删除erase，替换replace，插入insert*
</code></pre>
</li>
</ul>
<h4 id="string的构造函数"><a href="#string的构造函数" class="headerlink" title="string的构造函数"></a>string的构造函数</h4><ul>
<li><p>默认构造函数：</p>
<p>​    string();      //构造一个空的字符串string s1。</p>
</li>
<li><p>拷贝构造函数：</p>
<p>​    string(const string &amp;str);    //构造一个与str一样的string。如string s1(s2)。</p>
</li>
<li><p>带参数的构造函数</p>
<pre><code>  string(const char *s);   //用字符串s初始化
</code></pre>
<p>   string(int n,char c);   //用n个字符c初始化</p>
</li>
</ul>
<h4 id="string的存取字符操作"><a href="#string的存取字符操作" class="headerlink" title="string的存取字符操作"></a>string的存取字符操作</h4><ul>
<li><p>char &amp;operator[] (int n);</p>
</li>
<li><p>char &amp;at(int n);</p>
</li>
<li><p>operator[]和at()均返回当前字符串中第n个字符，但二者是有区别的。</p>
<p>主要区别在于at()在越界时会抛出异常，[]在刚好越界时会返回‘\0’，再继续越界时，程序直接中断。如果你的程序希望可以通过try,catch捕获异常，建议采用at()。</p>
</li>
</ul>
<p>从string取得const char*</p>
<ul>
<li>const char *c_str() const;  //返回一个以’\0’结尾的字符串的首地址</li>
<li>const char *data() const;  //同上 </li>
</ul>
<h4 id="把string拷贝到char-指向的内存空间的操作"><a href="#把string拷贝到char-指向的内存空间的操作" class="headerlink" title="把string拷贝到char*指向的内存空间的操作"></a>把string拷贝到char*指向的内存空间的操作</h4><ul>
<li><p>int copy(char *s, int n, int pos=0) const;  </p>
<p>把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目。注意要保证s所指向的空间足够大以容纳当前字符串，不然会越界。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;maye&quot;</span>)</span></span>;<br><span class="hljs-keyword">char</span> arr[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>str.<span class="hljs-built_in">copy</span>(arr, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<h4 id="string的长度"><a href="#string的长度" class="headerlink" title="string的长度"></a>string的长度</h4><ul>
<li><p>int length() const;  //返回当前字符串的长度。长度不包括字符串结尾的’\0’。</p>
</li>
<li><p>int size() const;    //同上</p>
</li>
<li><p>bool empty() const;   //当前字符串是否为空</p>
</li>
</ul>
<h4 id="string的赋值"><a href="#string的赋值" class="headerlink" title="string的赋值"></a>string的赋值</h4><ul>
<li><p>string &amp;operator=(const string &amp;s);//把字符串s赋给当前的字符串</p>
</li>
<li><p>string &amp;assign(const char *s); //把字符串s赋给当前的字符串</p>
</li>
<li><p>string &amp;assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串</p>
</li>
<li><p>string &amp;assign(const string &amp;s);  //把字符串s赋给当前字符串</p>
</li>
<li><p>string &amp;assign(int n,char c);  //用n个字符c赋给当前字符串</p>
</li>
<li><p>string &amp;assign(const string &amp;s,int start, int n);  //把字符串s中从start开始的n个字符赋给当前字符串</p>
</li>
</ul>
<h4 id="string字符串连接"><a href="#string字符串连接" class="headerlink" title="string字符串连接"></a>string字符串连接</h4><ul>
<li><p>string &amp;operator+=(const string &amp;s);  //把字符串s连接到当前字符串结尾</p>
</li>
<li><p>string &amp;operator+=(const char *s);//把字符串s连接到当前字符串结尾</p>
</li>
<li><p>string &amp;append(const char *s);   //把字符串s连接到当前字符串结尾</p>
</li>
<li><p>string &amp;append(const char *s,int n);  //把字符串s的前n个字符连接到当前字符串结尾</p>
</li>
<li><p>string &amp;append(const string &amp;s);  //同operator+=()</p>
</li>
<li><p>string &amp;append(const string &amp;s,int pos, int n);//把字符串s中从pos开始的n个字符连接到当前字符串结尾</p>
</li>
<li><p>string &amp;append(int n, char c);  //在当前字符串结尾添加n个字符c</p>
</li>
</ul>
<h4 id="string比较"><a href="#string比较" class="headerlink" title="string比较"></a>string比较</h4><p>int compare(const string &amp;s) const;  //与字符串s比较</p>
<p>int compare(const char *s) const;  //与字符串s比较</p>
<p>compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。此外还支持&gt;、&gt;=、&lt;、&lt;=、==直接比较</p>
<h4 id="string的子串"><a href="#string的子串" class="headerlink" title="string的子串"></a>string的子串</h4><p>string substr(int pos=0, int n=npos) const;   //返回由pos开始的n个字符组成的子字符串</p>
<h4 id="string的查找和替换"><a href="#string的查找和替换" class="headerlink" title="string的查找和替换"></a>string的查找和替换</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h5><p>int find(char c,int pos=0) const;  //从pos开始查找字符c在当前字符串的位置 </p>
<p>int find(const char *s, int pos=0) const;  //从pos开始查找字符串s在当前字符串的位置</p>
<p>int find(const string &amp;s, int pos=0) const;  //从pos开始查找字符串s在当前字符串中的位置</p>
<p>find函数如果查找不到，就返回-1</p>
<p>int rfind(char c, int pos=npos) const;  //从pos开始从后向前查找字符c在当前字符串中的位置 </p>
<p>int rfind(const char *s, int pos=npos) const;</p>
<p>int rfind(const string &amp;s, int pos=npos) const;</p>
<p>//rfind是反向查找的意思，如果查找不到， 返回-1</p>
<h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a><strong>替换</strong></h5><p>string &amp;replace(int pos, int n, const char *s);//删除从pos开始的n个字符，然后在pos处插入串s</p>
<p>string &amp;replace(int pos, int n, const string &amp;s);  //删除从pos开始的n个字符，然后在pos处插入串s</p>
<p>void swap(string &amp;s2);   //交换当前字符串与s2的值</p>
<h4 id="String的区间删除和插入"><a href="#String的区间删除和插入" class="headerlink" title="String的区间删除和插入"></a>String的区间删除和插入</h4><p>string &amp;insert(int pos, const char *s);</p>
<p>string &amp;insert(int pos, const string &amp;s);</p>
<p>//前两个函数在pos位置插入字符串s</p>
<p>string &amp;insert(int pos, int n, char c);  //在pos位置 插入n个字符c</p>
<p>string &amp;erase(int pos=0, int n=npos);  //删除pos开始的n个字符，返回修改后的字符串</p>
<h1 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h1><h4 id="Vector容器简介"><a href="#Vector容器简介" class="headerlink" title="Vector容器简介"></a>Vector容器简介</h4><p>vector是将元素置于一个动态数组中加以管理的容器。</p>
<p>vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）</p>
<p>vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时</p>
<h4 id="vector的构造函数"><a href="#vector的构造函数" class="headerlink" title="vector的构造函数"></a>vector的构造函数</h4><p>vector采用模板类实现，vector对象的默认构造形式</p>
<p>vector&lt;T&gt; vecT;    //尖括号内还可以设置任意的数据类型。</p>
<p>存放对象的时候值得注意：由于容器元素的存放是按值复制的方式进行的，所以此时类必须提供对象的拷贝构造函数，以保证对象间拷贝正常。</p>
<p>vector(begin,end);   //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。(能取begin的值，不能取end的值)</p>
<p> vector(n,elem);  //构造函数将n个elem拷贝给本身。</p>
<p>vector(const vector &amp;vec);  //拷贝构造函数</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span>  iArray[] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vecIntA</span><span class="hljs-params">(iArray, iArray + <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vecIntB</span><span class="hljs-params">(vecIntA.begin(), vecIntA.end())</span></span>;  <span class="hljs-comment">//用构造函数初始化容器vecIntB </span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vecIntB</span><span class="hljs-params">(vecIntA.begin(), vecIntA.begin() + <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vecIntC</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>)</span></span>; <span class="hljs-comment">//容器vecIntB存放3个元素，每个元素的值是9。</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vecIntD</span><span class="hljs-params">(vecIntA)</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="vector的赋值"><a href="#vector的赋值" class="headerlink" title="vector的赋值"></a>vector的赋值</h4><p> vector.assign(beg,end);   //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
<p>vector.assign(n,elem);  //将n个elem拷贝赋值给本身。</p>
<p>vector&amp; operator=(const vector  &amp;vec);    //重载等号操作符</p>
<p>vector.swap(vec);  // 将vec与本身的元素互换。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; vecIntA, vecIntB, vecIntC, vecIntD;<br><span class="hljs-keyword">int</span>  iArray[] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>vecIntA.<span class="hljs-built_in">assign</span>(iArray, iArray + <span class="hljs-number">5</span>);		<span class="hljs-comment">//把iArray全部赋值给vecIntA</span><br>vecIntB.<span class="hljs-built_in">assign</span>(vecIntA.<span class="hljs-built_in">begin</span>(), vecIntA.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">//用其它容器的迭代器作参数。</span><br>vecIntC.<span class="hljs-built_in">assign</span>(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>);<span class="hljs-comment">//容器vecIntB存放3个元素，每个元素的值是9。</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vecIntD;<br>vecIntD = vecIntA;<br>vecIntA.<span class="hljs-built_in">swap</span>(vecIntD);<span class="hljs-comment">//交换vecIntA和vecIntD的数据</span><br></code></pre></td></tr></table></figure>

<h4 id="vector的大小"><a href="#vector的大小" class="headerlink" title="vector的大小"></a>vector的大小</h4><p>vector.size();      //返回容器中元素的个数</p>
<p>vector.empty();      //判断容器是否为空</p>
<p>vector.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>vector.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<h4 id="vector末尾的添加移除操作"><a href="#vector末尾的添加移除操作" class="headerlink" title="vector末尾的添加移除操作"></a>vector末尾的添加移除操作</h4><p>vector.push_back(data);//在尾部添加一个元素</p>
<p>vector.pop_back();//删除尾部元素</p>
<h4 id="vector的数据存取"><a href="#vector的数据存取" class="headerlink" title="vector的数据存取"></a>vector的数据存取</h4><p>vec.at(index);  //返回索引index所指的数据，如果index越界，抛出out_of_range异常。</p>
<p>vec[index];  //返回索引index所指的数据，越界时，运行直接报错</p>
<h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><h4 id="Deque简介"><a href="#Deque简介" class="headerlink" title="Deque简介"></a>Deque简介</h4><p>deque是“double-ended queue”的缩写，和vector一样都是STL的容器，deque是双端数组，而vector是单端的。</p>
<p>deque在接口上和vector非常相似，在许多操作的地方可以直接替换。</p>
<p>deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法，这个等下会详讲）。</p>
<p>deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。</p>
<p>#include <deque>  </deque></p>
<h4 id="deque对象的默认构造"><a href="#deque对象的默认构造" class="headerlink" title="deque对象的默认构造"></a>deque对象的默认构造</h4><p>deque采用模板类实现，deque对象的默认构造形式：deque<T> deqT;  </T></p>
<p>deque <int> deqInt;       //一个存放int的deque容器。</int></p>
<p>deque <float> deq Float;   //一个存放float的deque容器。</float></p>
<p>deque <string> deq String;   //一个存放string的deque容器。</string></p>
<p>…                  </p>
<p> //尖括号内还可以设置指针类型或自定义类型。 </p>
<h4 id="deque对象的带参数构造"><a href="#deque对象的带参数构造" class="headerlink" title="deque对象的带参数构造"></a>deque对象的带参数构造</h4><p>deque(beg,end);   //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</p>
<p>deque(n,elem);  //构造函数将n个elem拷贝给本身。</p>
<p>deque(const deque  &amp;deq);  //拷贝构造函数。</p>
<h4 id="deque末尾的添加移除操作"><a href="#deque末尾的添加移除操作" class="headerlink" title="deque末尾的添加移除操作"></a>deque末尾的添加移除操作</h4><p>deque.push_back(elem);    //在容器尾部添加一个数据</p>
<p>deque.push_front(elem);    //在容器头部插入一个数据</p>
<p>deque.pop_back();       //删除容器最后一个数据</p>
<p>deque.pop_front();        //删除容器第一个数据</p>
<h4 id="deque的数据存取"><a href="#deque的数据存取" class="headerlink" title="deque的数据存取"></a>deque的数据存取</h4><p>deque.at(idx);  //返回索引idx所指的数据，如果idx越界，抛出out_of_range。</p>
<p>deque[idx];  //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</p>
<p>deque.front();  //返回第一个数据。</p>
<p>deque.back();  //返回最后一个数据</p>
<h4 id="deque的赋值"><a href="#deque的赋值" class="headerlink" title="deque的赋值"></a>deque的赋值</h4><p>deque.assign(beg,end);   //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
<p>deque.assign(n,elem);  //将n个elem拷贝赋值给本身。</p>
<p>deque&amp; operator=(const deque &amp;deq);    //重载等号操作符 </p>
<p>deque.swap(deq);  // 将vec与本身的元素互换</p>
<h4 id="deque的大小"><a href="#deque的大小" class="headerlink" title="deque的大小"></a>deque的大小</h4><p>deque.size();      //返回容器中元素的个数</p>
<p>deque.empty();      //判断容器是否为空</p>
<p>deque.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>deque.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<h4 id="deque的插入"><a href="#deque的插入" class="headerlink" title="deque的插入"></a>deque的插入</h4><p>deque.insert(pos,elem);  //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
<p>deque.insert(pos,n,elem);  //在pos位置插入n个elem数据，无返回值。</p>
<p>deque.insert(pos,beg,end);  //在pos位置插入[beg,end)区间的数据，无返回值。</p>
<h4 id="deque的删除"><a href="#deque的删除" class="headerlink" title="deque的删除"></a>deque的删除</h4><p>deque.clear();    //移除容器的所有数据</p>
<p>deque.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
<p>deque.erase(pos);   //删除pos位置的数据，返回下一个数据的位置。</p>
<h1 id="迭代器基本原理"><a href="#迭代器基本原理" class="headerlink" title="迭代器基本原理"></a>迭代器基本原理</h1><ul>
<li><p>代器是一个“可遍历STL容器内全部或部分元素”的对象。</p>
</li>
<li><p>迭代器指出容器中的一个特定位置。</p>
</li>
<li><p>迭代器就如同一个指针。</p>
</li>
<li><p>迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围。</p>
</li>
</ul>
<h4 id="迭代器的类别"><a href="#迭代器的类别" class="headerlink" title="迭代器的类别"></a>迭代器的类别</h4><p><em><strong>输入迭代器</strong></em>：也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</p>
<p><em><strong>输出迭代器</strong></em>：也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</p>
<p><em><strong>正向迭代器</strong></em>：组合输入迭代器和输出迭代器的功能，还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读/写。</p>
<p><em><strong>双向迭代器</strong></em>：组合正向迭代器的功能，还可以通过++操作符向后移动位置。</p>
<p><strong>随机访问迭代器</strong>：组合双向迭代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</p>
<h4 id="迭代器的操作"><a href="#迭代器的操作" class="headerlink" title="迭代器的操作"></a>迭代器的操作</h4><table>
<thead>
<tr>
<th>迭代器</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>所有迭代器</td>
<td>it++、++it</td>
</tr>
<tr>
<td>输入迭代器</td>
<td>*it、it1=it2、it1==it2、it1！=it2</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>*it、it1=it2</td>
</tr>
<tr>
<td>正向迭代器</td>
<td>提供输入输出迭代器的所有功能</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>it–、–it</td>
</tr>
<tr>
<td>随机迭代器</td>
<td>+=、-=、+、-、[]、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<p>这里用到的容器，都支持双向迭代器或随机访问迭代器，下面将会详细介绍这两个类别的迭代器。</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>对应迭代器类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>vector</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>list</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>set / multiset</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>map / multimap</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_map / unordered_multimap</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_set / unordered_multiset</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
</tbody></table>
<h4 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Data&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Vector</span>() :<span class="hljs-built_in">Array</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">curSize</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">capacity</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>	<span class="hljs-built_in">Vector</span>(<span class="hljs-keyword">int</span> size) :<span class="hljs-built_in">curSize</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">capacity</span>(size)<br>	&#123;<br>		Array = <span class="hljs-keyword">new</span> Data[size];<br>	&#125;<br>	<span class="hljs-built_in">Vector</span>(Vector&amp; arr) :<span class="hljs-built_in">curSize</span>(arr.curSize), <span class="hljs-built_in">capacity</span>(arr.capacity)<br>	&#123;<br>		Array = <span class="hljs-keyword">new</span> Data[capacity];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.curSize; i++)<br>		&#123;<br>			<span class="hljs-keyword">this</span>-&gt;Array[i] = arr.Array[i];<br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Data data)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">if</span> (curSize &lt; capacity)<br>		&#123;<br>			Array[curSize] = data;<br>			curSize++;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		cout &lt;&lt; <span class="hljs-string">&quot;数组越界&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arrMul</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mulNum)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; curSize; i++)<br>		&#123;<br>			Array[i] *= mulNum;<br>			<span class="hljs-comment">//要确保存的数据类型，能够相乘</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>=(Vector&amp; arr)<br>	&#123;<br>		<span class="hljs-comment">//判断当前对象和arr的关系</span><br>		<span class="hljs-keyword">if</span> (capacity &lt; arr.curSize)<br>		&#123;<br>			<span class="hljs-keyword">delete</span>[] Array;<br>			capacity = arr.capacity;<br>			curSize = arr.curSize;<br>			Array = <span class="hljs-keyword">new</span> Data[capacity];<br>		&#125;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.curSize; i++)<br>		&#123;<br>			<span class="hljs-keyword">this</span>-&gt;Array[i] = arr[i];<br>			<span class="hljs-comment">//要确保，存的类型能够相互赋值</span><br>		&#125;<br>		curSize = arr.curSize;<br>	&#125;<br>	Data&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; capacity)<br>		&#123;<br>			<span class="hljs-keyword">return</span> Array[index];<br>		&#125;<br>		cout &lt;&lt; <span class="hljs-string">&quot;数组访问越界&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Vector&amp; Array)<br>	&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Array.curSize; i++)<br>		&#123;<br>			out &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::left) &lt;&lt; Array[i];<br>		&#125;<br>		<span class="hljs-keyword">return</span> out;<br>	&#125;<br>	~<span class="hljs-built_in">Vector</span>()<br>	&#123;<br>		<span class="hljs-keyword">delete</span>[] Array;<br>	&#125;<br>	<span class="hljs-comment">//迭代器</span><br>	<span class="hljs-function">Data* <span class="hljs-title">begin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> Array;<br>	&#125;<br>	<span class="hljs-function">Data* <span class="hljs-title">end</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> &amp;Array[curSize];<br>	&#125;<br>	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">iterotar</span></span><br><span class="hljs-class">	&#123;</span><br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">iterotar</span>(Data *begin=<span class="hljs-literal">nullptr</span>)<br>		&#123;<br>			pmove = begin;<br>		&#125;<br>		~<span class="hljs-built_in">iterotar</span>()<br>		&#123;<br><br>		&#125;<br>		<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(Data* end)<br>		&#123;<br>			<span class="hljs-keyword">return</span> pmove != end;<br>		&#125;<br>		Data* <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>)<br>		&#123;<br>			Data* temp = pmove;<br>			<span class="hljs-keyword">this</span>-&gt;pmove++;<br>			<span class="hljs-keyword">return</span> temp;<br>		&#125;<br>		<span class="hljs-comment">//一定要返回引用，否则匿名对象不接受会出错</span><br>		Data&amp; <span class="hljs-keyword">operator</span>*()<br>		&#123;<br>			<span class="hljs-keyword">return</span> *pmove;<br>		&#125;<br>		Data* <span class="hljs-keyword">operator</span>-&gt;()<br>		&#123;<br>			<span class="hljs-keyword">return</span> pmove;<br>		&#125;<br>	<span class="hljs-keyword">private</span>:<br>		Data* pmove;<br>	&#125;;<br><span class="hljs-keyword">protected</span>:<br>	Data* Array;		<span class="hljs-comment">//数组指针</span><br>	<span class="hljs-keyword">int</span> curSzie;	<span class="hljs-comment">//数组当前大小</span><br>	<span class="hljs-keyword">int</span> capacity;	<span class="hljs-comment">//数组最大容量</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="initializer-list聚合初始化"><a href="#initializer-list聚合初始化" class="headerlink" title="initializer_list聚合初始化"></a>initializer_list聚合初始化</h4><p>前面给大家讲过数组可以用聚合的方式初始化，int arr[]={1,3,1,4,5,2,0};那么咱们自己写的vector能用聚合初始化吗？</p>
<p>答案是否定的，那么怎么做才能使用聚合形式进行初始化呢？</p>
<p>C++11提供的新模板类型initializer_list<T>,有了它之后咱们就可以使用聚合进行初始化啦！</T></p>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(initializer_list&lt;<span class="hljs-keyword">int</span>&gt; ls)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : ls)<br>	&#123;<br>		cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>&#125;<br><br><span class="hljs-built_in">show</span>(&#123; <span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span> &#125;);<span class="hljs-comment">//输出</span><br></code></pre></td></tr></table></figure>

<p>同理，在类中我们可以提供一个initializer_list类型的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//构造聚合初始化</span><br><span class="hljs-built_in">Vector</span>(initializer_list&lt;Data&gt; ls)<br>&#123;<br>	_capacity = ls.<span class="hljs-built_in">size</span>();<br>	_curSize = <span class="hljs-number">0</span>;<br>	_Array = <span class="hljs-keyword">new</span> Data[_capacity];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> Data&amp; temp : ls)<br>	&#123;<br>		<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">push_back</span>(temp);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h1><h4 id="list简介"><a href="#list简介" class="headerlink" title="list简介"></a>list简介</h4><p> list是一个双向链表容器，可高效地进行插入删除元素。</p>
<p> list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok)    it+5(err)</p>
<h4 id="list对象的默认构造"><a href="#list对象的默认构造" class="headerlink" title="list对象的默认构造"></a>list对象的默认构造</h4><p>list采用采用模板类实现,对象的默认构造形式：list<T> lsT;  如：</T></p>
<p>list<int> lstInt;       //定义一个存放int的list容器。</int></p>
<p>list<float> lstFloat;   //定义一个存放float的list容器。</float></p>
<p>list<string> lstString;   //定义一个存放string的list容器。</string></p>
<p>…                  </p>
<p>//尖括号内还可以设置指针类型或自定义类型。</p>
<h4 id="list头尾的添加移除操作"><a href="#list头尾的添加移除操作" class="headerlink" title="list头尾的添加移除操作"></a>list头尾的添加移除操作</h4><p>list.push_back(elem);      //在容器尾部加入一个元素</p>
<p>list.pop_back();        //删除容器中最后一个元素</p>
<p>list.push_front(elem);   //在容器开头插入一个元素</p>
<p>list.pop_front();        //从容器开头移除第一个元素</p>
<h4 id="list的数据存取"><a href="#list的数据存取" class="headerlink" title="list的数据存取"></a>list的数据存取</h4><p>list.front();  //返回第一个元素。</p>
<p>list.back();  //返回最后一个元素。</p>
<h4 id="list与迭代器"><a href="#list与迭代器" class="headerlink" title="list与迭代器"></a>list与迭代器</h4><p>list.begin();           //返回容器中第一个元素的迭代器。</p>
<p>list.end();            //返回容器中最后一个元素之后的迭代器。</p>
<p>list.rbegin();     //返回容器中倒数第一个元素的迭代器。</p>
<p>list.rend();     //返回容器中倒数最后一个元素的后面的迭代器。</p>
<h4 id="list对象的带参数构造"><a href="#list对象的带参数构造" class="headerlink" title="list对象的带参数构造"></a>list对象的带参数构造</h4><p>list(beg,end);   //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</p>
<p>list(n,elem);  //构造函数将n个elem拷贝给本身。</p>
<p>list(const list &amp;lst);  //拷贝构造函数。</p>
<h4 id="list的赋值"><a href="#list的赋值" class="headerlink" title="list的赋值"></a>list的赋值</h4><p>list.assign(beg,end);   //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</p>
<p>list.assign(n,elem);  //将n个elem拷贝赋值给本身。</p>
<p>list&amp; operator=(const list &amp;lst);    //重载等号操作符</p>
<p>list.swap(lst);  // 将lst与本身的元素互换。</p>
<h4 id="list的大小"><a href="#list的大小" class="headerlink" title="list的大小"></a>list的大小</h4><p>list.size();      //返回容器中元素的个数</p>
<p>list.empty();      //判断容器是否为空</p>
<p>list.resize(num);  //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<p>list.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<h4 id="list的插入"><a href="#list的插入" class="headerlink" title="list的插入"></a>list的插入</h4><p>list.insert(pos,elem);  //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
<p>list.insert(pos,n,elem);  //在pos位置插入n个elem数据，无返回值。</p>
<p>list.insert(pos,beg,end);  //在pos位置插入[beg,end)区间的数据，无返回值。</p>
<h4 id="list的删除"><a href="#list的删除" class="headerlink" title="list的删除"></a>list的删除</h4><p>list.clear();        //移除容器的所有数据</p>
<p>list.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
<p>list.erase(pos);   //删除pos位置的数据，返回下一个数据的位置。</p>
<p>lst.remove(elem);  //删除容器中所有与elem值匹配的元素。</p>
<p> <em><strong>当使用一个容器的insert或者erase函数通过迭代器插入或删除元素”可能”会导致迭代器失效，因此我们为了避免危险，应该获取insert或者erase返回的迭代器，以便用重新获取的新的有效的迭代器进行正确的操作</strong></em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-keyword">int</span>&gt; ls;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>	ls.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>list&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = ls.<span class="hljs-built_in">begin</span>(); it != ls.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>	<span class="hljs-keyword">if</span> (*it == <span class="hljs-number">5</span>)<br>	&#123;<br>		it=ls.<span class="hljs-built_in">erase</span>(it);<br>	&#125;<br>	cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="list的反序排列"><a href="#list的反序排列" class="headerlink" title="list的反序排列"></a>list的反序排列</h4><p>lst.reverse();   //反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>一、容器deque的使用方法</p>
<p>​    适合在头尾添加移除元素。使用方法与vector类似。</p>
<p>二、容器queue,stack的使用方法</p>
<p>​    适合队列，堆栈的操作方式。</p>
<p>三、容器list的使用方法</p>
<p>​    适合在任意位置快速插入移除元素</p>
<h1 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h1><p>Stack简介</p>
<p>stack是堆栈容器，是一种“先进后出”的容器。</p>
<p>stack是简单地装饰deque容器而成为另外的一种容器。</p>
<p>#include <stack>  </stack></p>
<h4 id="stack对象的默认构造"><a href="#stack对象的默认构造" class="headerlink" title="stack对象的默认构造"></a>stack对象的默认构造</h4><p>stack采用模板类实现， stack对象的默认构造形式： stack <T> stkT;  </T></p>
<p>stack <int> stkInt;       //一个存放int的stack容器。</int></p>
<p>stack <float> stkFloat;   //一个存放float的stack容器。</float></p>
<p>stack <string> stkString;   //一个存放string的stack容器。</string></p>
<p>…                  </p>
<p>//尖括号内还可以设置指针类型或自定义类型。</p>
<h4 id="stack元素获取与删除"><a href="#stack元素获取与删除" class="headerlink" title="stack元素获取与删除"></a>stack元素获取与删除</h4><p>stack.push(elem);  //往栈头添加元素</p>
<p>stack.pop();  //从栈头移除第一个元素</p>
<p>stack.top();     //返回最栈顶元素</p>
<h4 id="stack对象的拷贝构造与赋值"><a href="#stack对象的拷贝构造与赋值" class="headerlink" title="stack对象的拷贝构造与赋值"></a>stack对象的拷贝构造与赋值</h4><p>stack(const stack &amp;stk);           //拷贝构造函数</p>
<p>stack&amp; operator=(const stack &amp;stk);    //重载等号操作符</p>
<h4 id="stack的大小"><a href="#stack的大小" class="headerlink" title="stack的大小"></a>stack的大小</h4><p>stack.empty();  //判断堆栈是否为空</p>
<p>stack.size();        //返回堆栈的大小</p>
<h1 id="Queue容器"><a href="#Queue容器" class="headerlink" title="Queue容器"></a>Queue容器</h1><h4 id="Queue简介"><a href="#Queue简介" class="headerlink" title="Queue简介"></a>Queue简介</h4><p>queue是队列容器，是一种“先进先出”的容器。</p>
<p>queue是简单地装饰deque容器而成为另外的一种容器。</p>
<p>#include <queue>  </queue></p>
<h4 id="queue对象的默认构造"><a href="#queue对象的默认构造" class="headerlink" title="queue对象的默认构造"></a>queue对象的默认构造</h4><p>queue采用模板类实现，queue对象的默认构造形式：queue<T> queT;  如：</T></p>
<p>queue<int> queInt;       //一个存放int的queue容器。</int></p>
<p>queue<float> queFloat;   //一个存放float的queue容器。</float></p>
<p>queue<string> queString;   //一个存放string的queue容器。</string></p>
<p>…                  </p>
<p>//尖括号内还可以设置指针类型或自定义类型。 </p>
<h4 id="queue的数据存取"><a href="#queue的数据存取" class="headerlink" title="queue的数据存取"></a>queue的数据存取</h4><p>queue.push(elem);  //往队尾添加元素</p>
<p>queue.pop();  //从队头移除第一个元素</p>
<p>queue.back();  //返回最后一个元素</p>
<p>queue.front();  //返回第一个元素</p>
<h4 id="queue对象的拷贝构造与赋值"><a href="#queue对象的拷贝构造与赋值" class="headerlink" title="queue对象的拷贝构造与赋值"></a>queue对象的拷贝构造与赋值</h4><p>queue(const queue &amp;que);           //拷贝构造函数</p>
<p>queue&amp; operator=(const queue &amp;que);    //重载等号操作符</p>
<h4 id="queue的大小"><a href="#queue的大小" class="headerlink" title="queue的大小"></a>queue的大小</h4><p>queue.empty();  //判断队列是否为空</p>
<p>queue.size();        //返回队列的大小</p>
<h1 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h1><h4 id="set-multiset的简介"><a href="#set-multiset的简介" class="headerlink" title="set/multiset的简介"></a>set/multiset的简介</h4><p>set是一个<em><strong>集合</strong></em>容器，其中所包含的元素是<em><strong>唯一</strong></em>的，<em><strong>集合中的元素按一定的顺序排列</strong></em>。元素插入过程是按排序规则插入，所以不能指定插入位置。</p>
<p>set采用<em><strong>红黑树</strong></em>变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。</p>
<p>set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</p>
<p style="color:red;">multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。</p>

<p><font style="color:blue">不可以直接修改set或multiset容器中的元素值</font>，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。</p>
<p>#include <set>  </set></p>
<h4 id="set-multiset对象的默认构造"><a href="#set-multiset对象的默认构造" class="headerlink" title="set/multiset对象的默认构造"></a>set/multiset对象的默认构造</h4><p>set<int> setInt;       //一个存放int的set容器。</int></p>
<p>set<float> setFloat;   //一个存放float的set容器。</float></p>
<p>set<string> setString;   //一个存放string的set容器。</string></p>
<p>multiset<int> mulsetInt;       //一个存放int的multi set容器。</int></p>
<p>multi set<float> multisetFloat;   //一个存放float的multi set容器。</float></p>
<p>multi set<string> multisetString;   //一个存放string的multi set容器。</string></p>
<h4 id="set的插入"><a href="#set的插入" class="headerlink" title="set的插入"></a>set的插入</h4><p>set.insert(elem);   //在容器中插入元素。</p>
<h4 id="Set集合的元素排序"><a href="#Set集合的元素排序" class="headerlink" title="Set集合的元素排序"></a>Set集合的元素排序</h4><p>set&lt;int,less<int> &gt;  setIntA;  //该容器是按升序方式排列元素。</int></p>
<p>set&lt;int,greater<int>&gt; setIntB;  //该容器是按降序方式排列元素。</int></p>
<p>set<int> 相当于 set&lt;int,less<int>&gt;。</int></int></p>
<p>less<int>与greater<int>中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。</int></int></p>
<p>疑问1： less&lt;&gt;与greate&lt; &gt;是什么？</p>
<p>疑问2：如果set&lt;&gt;不包含int类型，而是包含自定义类型，set容器如何排序？</p>
<p>要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。</p>
<p>下面将讲解什么是functor以及用法。</p>
<p>使用stl提供的函数对象</p>
<p>set&lt;int,greater<int>&gt; setIntB;  </int></p>
<p>setIntB.insert(3);</p>
<p>setIntB.insert(1);</p>
<p>setIntB.insert(5);</p>
<p>setIntB.insert(2);</p>
<p>此时容器setIntB就包含了按顺序的5,3,2,1元素</p>
<h4 id="函数对象functor的用法"><a href="#函数对象functor的用法" class="headerlink" title="函数对象functor的用法"></a>函数对象functor的用法</h4><p>尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。</p>
<p>functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。</p>
<p>greater&lt;&gt;与less&lt;&gt;就是函数对象。</p>
<p>下面举出greater<int>的简易实现原理。 </int></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">greater</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; iLeft, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; iRight)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> iLeft &gt; iRight;  <span class="hljs-comment">//如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);</span><br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>容器就是调用函数对象的operator()方法去比较两个值的大小。</p>
<h5 id="仿函数练习"><a href="#仿函数练习" class="headerlink" title="仿函数练习"></a>仿函数练习</h5><p>学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//学生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CStudent</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">CStudent</span>(<span class="hljs-keyword">int</span> iID, string strName)<br>	&#123;<br>		m_iID = iID;<br>		m_strName = strName;<br>	&#125;<br>	<span class="hljs-comment">//private:</span><br>	<span class="hljs-keyword">int</span> m_iID;		<span class="hljs-comment">//学号</span><br>	string m_strName; 	<span class="hljs-comment">//姓名</span><br>&#125;;<br><span class="hljs-comment">//为保持主题鲜明，本类不写拷贝构造函数，不类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。</span><br><span class="hljs-comment">//函数对象</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StuFunctor</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CStudent&amp; stu1,<span class="hljs-keyword">const</span> CStudent&amp; stu2)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> (stu1.m_iID &lt; stu2.m_iID);<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	set&lt;CStudent, StuFunctor&gt; setStu;<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;小张&quot;</span>));<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小李&quot;</span>));<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;小王&quot;</span>));<br>	setStu.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">CStudent</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;小刘&quot;</span>));<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : setStu)<br>	&#123;<br>		cout &lt;&lt; i.m_iID &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="set对象的拷贝构造与赋值"><a href="#set对象的拷贝构造与赋值" class="headerlink" title="set对象的拷贝构造与赋值"></a>set对象的拷贝构造与赋值</h4><p>set(const set &amp;st);           //拷贝构造函数</p>
<p>set&amp; operator=(const set &amp;st);    //重载等号操作符</p>
<p>set.swap(st);                //交换两个集合容器</p>
<h4 id="set的大小"><a href="#set的大小" class="headerlink" title="set的大小"></a>set的大小</h4><p>set.size();    //返回容器中元素的数目</p>
<p>set.empty();//判断容器是否为空</p>
<h4 id="set的删除"><a href="#set的删除" class="headerlink" title="set的删除"></a>set的删除</h4><p>set.clear();        //清除所有元素</p>
<p>set.erase(pos);    //删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
<p>set.erase(beg,end);      //删除区间[beg,end)的所有元素    ，返回下一个元素的迭代器。</p>
<p>set.erase(elem);   //删除容器中值为elem的元素。</p>
<h4 id="set的查找"><a href="#set的查找" class="headerlink" title="set的查找"></a>set的查找</h4><p>set.find(elem);  //查找elem元素，返回指向elem元素的迭代器。</p>
<p>set.count(elem);  //返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</p>
<p>set.lower_bound(elem);      //返回第一个&gt;=elem元素的迭代器。</p>
<p>set.upper_bound(elem);      //  返回第一个&gt;elem元素的迭代器。</p>
<p>set.equal_range(elem);        //返回一对迭代器，这两个迭代器分别用于发现set中其键大于指定键的第一个元素，以及集中其键等于或大于指定键的第一个元素。</p>
<p>以上函数返回两个迭代器，而这两个迭代器被封装在pair中。</p>
<h5 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h5><p>以下讲解pair的含义与使用方法。</p>
<h4 id="pair的使用"><a href="#pair的使用" class="headerlink" title="pair的使用"></a>pair的使用</h4><p>pair译为对组，可以将两个值视为一个单元。</p>
<p>pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。</p>
<p>pair.first是pair里面的第一个值，是T1类型。</p>
<p>pair.second是pair里面的第二个值，是T2类型。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>一、容器set/multiset的使用方法；</p>
<p>​            红黑树的变体，查找效率高，插入不能指定位置，插入时自动排序。</p>
<p>二、functor的使用方法；</p>
<pre><code>      类似于函数的功能，可用来自定义一些规则，如元素比较规则。
</code></pre>
<p>三、pair的使用方法。</p>
<p>​            对组，一个整体的单元，存放两个类型(T1,T2，T1可与T2一样)的两个元素。</p>
<h1 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map\multimap容器"></a>map\multimap容器</h1><h4 id="map-multimap的简介"><a href="#map-multimap的简介" class="headerlink" title="map/multimap的简介"></a>map/multimap的简介</h4><p>map是标准的关联式容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。</p>
<p>map中key值是唯一的。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。</p>
<p>map的具体实现采用红黑树变体的平衡二叉树的数据结构。在插入操作和删除操作上比vector快。</p>
<p>map可以直接存取key所对应的value，支持[]操作符，如map[key]=value。</p>
<p>multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]和at操作。</p>
<p>#include <map>  </map></p>
<img src="//tvax4.sinaimg.cn/large/0072YHp3ly1gjq0vc5loyj30dt04xmyx.jpg" alt="map" width="497" data-width="497" data-height="177">

<h4 id="map-multimap对象的默认构造"><a href="#map-multimap对象的默认构造" class="headerlink" title="map/multimap对象的默认构造"></a>map/multimap对象的默认构造</h4><p>map&lt;T1,T2&gt; mapTT; </p>
<p>multimap&lt;T1,T2&gt;  multimapTT;  </p>
<h4 id="map的插入与迭代器"><a href="#map的插入与迭代器" class="headerlink" title="map的插入与迭代器"></a>map的插入与迭代器</h4><p>map.insert(…);   //往容器插入元素，返回pair&lt;iterator,bool&gt;</p>
<p>在map中插入元素的三种方式：</p>
<p>假设  map&lt;int, string&gt; mapStu;</p>
<p><strong>一、通过pair的方式插入对象</strong></p>
<p>mapStu.insert(  pair&lt;int,string&gt;(3,”小张”)  );</p>
<p><strong>二、通过pair的方式插入对象</strong></p>
<p>mapStu.inset(make_pair(-1, “校长-1”));</p>
<p><strong>三、通过value_type的方式插入对象</strong></p>
<p>mapStu.insert(  map&lt;int,string&gt;::value_type(1,”小李”)  );</p>
<p><strong>四、通过数组的方式插入值</strong>(multimap不支持)</p>
<p>mapStu[3] = “小刘”;</p>
<p>mapStu.at(4) = “小王”；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-keyword">int</span>, string&gt; chess;<br>chess.<span class="hljs-built_in">insert</span>(pair&lt;<span class="hljs-keyword">int</span>,string&gt;(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;将&quot;</span>));<br>chess.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;士&quot;</span>));<br>chess.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-keyword">int</span>, string&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;像&quot;</span>));<br>chess.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>) = <span class="hljs-string">&quot;马&quot;</span>;<br>chess[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;車&quot;</span>;<br></code></pre></td></tr></table></figure>



<p>前三种方法，采用的是insert()方法，该方法<em><strong>返回值为pair&lt;iterator,bool&gt;</strong></em> </p>
<p>第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值<em><strong>修改</strong></em>成“小刘”。若发现已存在3这个键，则修改这个键对应的value。</p>
<p>string strName = mapStu[2];  //取操作或插入操作</p>
<p>只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值。</p>
<h4 id="函数对象functor的用法-1"><a href="#函数对象functor的用法-1" class="headerlink" title="函数对象functor的用法"></a>函数对象functor的用法</h4><p>map&lt;T1,T2,less<T1> &gt;  mapA;  //该容器是按键的升序方式排列元素。未指定函数对象，默认采用less<T1>函数对象。</T1></T1></p>
<p>map&lt;T1,T2,greater<T1>&gt; mapB;  //该容器是按键的降序方式排列元素。</T1></p>
<p>less<T1>与greater<T1>  可以替换成其它的函数对象functor。</T1></T1></p>
<p>可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。</p>
<h4 id="map对象的拷贝构造与赋值"><a href="#map对象的拷贝构造与赋值" class="headerlink" title="map对象的拷贝构造与赋值"></a>map对象的拷贝构造与赋值</h4><p>map(const map &amp;mp);           //拷贝构造函数</p>
<p>map&amp; operator=(const map &amp;mp);    //重载等号操作符</p>
<p>map.swap(mp);                //交换两个集合容器</p>
<h4 id="map的大小"><a href="#map的大小" class="headerlink" title="map的大小"></a>map的大小</h4><p>map.size();    //返回容器中元素的数目</p>
<p>map.empty();//判断容器是否为空</p>
<h4 id="map的删除"><a href="#map的删除" class="headerlink" title="map的删除"></a>map的删除</h4><p>map.clear();        //删除所有元素</p>
<p>map.erase(pos);    //删除pos迭代器所指的元素，返回下一个元素的迭代器。</p>
<p>map.erase(beg,end);      //删除区间[beg,end)的所有元素    ，返回下一个元素的迭代器。</p>
<p>map.erase(keyElem);   //删除容器中key为keyElem的对组。</p>
<h4 id="map的查找"><a href="#map的查找" class="headerlink" title="map的查找"></a>map的查找</h4><p>map.find(key);  查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</p>
<p>map.count(keyElem);  //返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</p>
<p>map.equal_range(keyElem);        //返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。 </p>
<p>以上函数返回两个迭代器，而这两个迭代器被封装在pair中。 </p>
<p>Multimap 案例:</p>
<p>//1个key值可以对应多个value  = 分组 </p>
<p>//公司有销售部 sale （员工2名）、技术研发部 development （1人）、财务部 Financial （2人） </p>
<p>//人员信息有：姓名，年龄，电话、工资等组成</p>
<p>//通过 multimap进行 信息的插入、保存、显示</p>
<p>//分部门显示员工信息 </p>
<h1 id="STL容器共性机制"><a href="#STL容器共性机制" class="headerlink" title="STL容器共性机制"></a>STL容器共性机制</h1><p>STL容器所提供的都是值（value）寓意，而非引用（reference）寓意，也就是说当我们给容器中插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另行拷贝一份放入到容器中，而不是将原数据元素直接放进容器中，也就是说我们提供的元素必须能够被拷贝。</p>
<ul>
<li><p>除了queue和stack之外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。</p>
</li>
<li><p>通过STL不会抛出异常，需要使用者传入正确参数。</p>
</li>
<li><p>每个容器都提供一个默认的构造函数和默认的拷贝构造函数。</p>
</li>
<li><p>大小相关的构造方法：</p>
<ul>
<li>（1）size()返回容器中元素的个数；</li>
<li>（2）empty()判断容器是否为空。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody><tr>
<td>内存结构</td>
<td>单端数组</td>
<td>双端数组</td>
<td>双向链表</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
</tr>
<tr>
<td>可随机存取</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>对key而言：是</td>
<td>否</td>
</tr>
<tr>
<td>元素查找速度</td>
<td>慢</td>
<td>慢</td>
<td>非常慢</td>
<td>快</td>
<td>快</td>
<td>对key而言：快</td>
<td>对key而言：快</td>
</tr>
<tr>
<td>元素添加移除</td>
<td>尾端</td>
<td>头尾两端</td>
<td>任何位置</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="各容器使用场景"><a href="#各容器使用场景" class="headerlink" title="各容器使用场景"></a>各容器使用场景</h4><p><strong>在实际使用过程中，到底选择这几种容器中的哪一个，应该根据遵循以下原则：</strong></p>
<p>１、如果需要高效的随机存取，不在乎插入和删除的效率，使用vector；</p>
<p>2、如果需要大量的插入和删除元素，不关心随机存取的效率，使用list；</p>
<p>3、如果需要随机存取，并且关心两端数据的插入和删除效率，使用deque；</p>
<p>4、如果打算存储数据字典，并且要求方便地根据key找到value，一对一的情况使用map，一对多的情况使用multimap；</p>
<p>5、如果打算查找一个元素是否存在于某集合中，唯一存在的情况使用set，不唯一存在的情况使用multiset。</p>
<p>6、如果要求很快的查找速度，根据情况选择使用unordered_map或unordered_set。</p>
<h1 id="STL算法"><a href="#STL算法" class="headerlink" title="STL算法"></a>STL算法</h1><h4 id="sort-排序函数"><a href="#sort-排序函数" class="headerlink" title="sort()排序函数"></a>sort()排序函数</h4><p>该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>降序排序规则），甚至还可以自定义排序规则。</p>
<p>需要注意的是，sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：</p>
<ol>
<li><p>容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 <font style="color:red">array、vector、deque</font> 这 3 个容器提供支持。</p>
</li>
<li><p>如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持<code>&lt;</code>小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；</p>
<p>sort()函数有两种用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对 [first, last) 区域内的元素做默认的升序排序</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(first, last)</span></span>;<br><span class="hljs-comment">//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span> <span class="hljs-params">(first, last, Compare comp)</span></span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="transform-转换函数"><a href="#transform-转换函数" class="headerlink" title="transform()转换函数"></a>transform()转换函数</h4><p>将指定范围内的元素进行转换，并将结果存储在从result开始的范围中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Iterator <span class="hljs-title">transform</span> <span class="hljs-params">(first, last,result, <span class="hljs-keyword">const</span> T&amp; val)</span></span>;<br><span class="hljs-built_in">transform</span>(maye.<span class="hljs-built_in">begin</span>(), maye.<span class="hljs-built_in">end</span>(), maye.<span class="hljs-built_in">begin</span>(), toupper);<span class="hljs-comment">//转大写</span><br><span class="hljs-built_in">transform</span>(maye.<span class="hljs-built_in">begin</span>(), maye.<span class="hljs-built_in">end</span>(), maye.<span class="hljs-built_in">begin</span>(), tolower);<span class="hljs-comment">//转小写</span><br></code></pre></td></tr></table></figure>

<h4 id="find-查找函数"><a href="#find-查找函数" class="headerlink" title="find()查找函数"></a>find()查找函数</h4><p>该函数专门用来对容器或普通数组中，指定范围内查找和目标元素值相等的第一个元素。</p>
<p>find()函数用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Iterator <span class="hljs-title">find</span> <span class="hljs-params">(first, last, <span class="hljs-keyword">const</span> T&amp; val)</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="find-if-查找"><a href="#find-if-查找" class="headerlink" title="find_if()查找"></a>find_if()查找</h4><p>使用自定义的比较函数代替find函数默认的 == 比较操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> i == <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_find_if</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-keyword">auto</span> temp=<span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), cmp);<br>	<span class="hljs-keyword">if</span> (temp != v.<span class="hljs-built_in">end</span>())<br>	&#123;<br>		cout &lt;&lt; *temp ;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find()"></a>adjacent_find()</h4><p>指定范围内查找连续的两个连续相等的元素，并返回第一个元素的迭代器，如果没有找到，返回end迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> i == j;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_adjacent_find</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-keyword">auto</span> temp=<span class="hljs-built_in">adjacent_find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), cmp);<br>	<span class="hljs-keyword">if</span> (temp != v.<span class="hljs-built_in">end</span>())<br>	&#123;<br>		cout &lt;&lt; *temp;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="count-统计函数"><a href="#count-统计函数" class="headerlink" title="count()统计函数"></a>count()统计函数</h4><p>该函数专门用来对容器或普通数组中，指定范围内查找和目标元素值相等的所有元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(first,last,<span class="hljs-keyword">const</span> T&amp; val)</span></span>;<br></code></pre></td></tr></table></figure>



<h4 id="for-each函数"><a href="#for-each函数" class="headerlink" title="for_each函数"></a>for_each函数</h4><p>该函数专门用来对容器或普通数组中指定范围内的元素进行处理，把处理功能用函数封装。返回一个函数对象</p>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FUNC <span class="hljs-title">for_each</span><span class="hljs-params">(first, last, 函数对象)</span></span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span> &#125;;<br>for_each(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[<span class="hljs-number">6</span>], show);<br></code></pre></td></tr></table></figure>



<h4 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy()函数"></a>copy()函数</h4><p>把一个容器指定范围内的元素，拷贝到另一个容器中（目标容器必须内存足够）。返回一个迭代器，指向目标容器被拷贝元素范围的末尾</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Iterator <span class="hljs-title">count</span><span class="hljs-params">(first,last,destit)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_copy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(v.size())</span></span>;<br>	<span class="hljs-comment">//list&lt;int&gt; v1(v.size()+10);</span><br>	cout &lt;&lt; *<span class="hljs-built_in">copy</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), v1.<span class="hljs-built_in">begin</span>()) &lt;&lt; endl;;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v1)<br>	&#123;<br>		cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="更多算法"><a href="#更多算法" class="headerlink" title="更多算法"></a>更多算法</h4><p><a href="http://www.cplusplus.com/reference/algorithm/">C++参考手册</a></p>
<h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1><h4 id="为什么要有仿函数？"><a href="#为什么要有仿函数？" class="headerlink" title="为什么要有仿函数？"></a>为什么要有仿函数？</h4><p>从一个非常简单的问题入手，来了解为什么要有仿函数。</p>
<p>假设我们现在有一个数组，数组中存有任意数量的数字，我们希望能够统计出这个数组中大于 10 的数字的数量(按照容器、迭代器、算法分离来实现)</p>
<p>一般这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">FUNC</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">arrNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* first, <span class="hljs-keyword">int</span>* last, FUNC func)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> _count = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (first != last)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">func</span>(*first))<br>		&#123;<br>			_count++;<br>		&#125;<br>		first++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> _count;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> num &gt; <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">68</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">45</span>,<span class="hljs-number">3</span>,<span class="hljs-number">164</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">64</span> &#125;;<br>	<span class="hljs-comment">//求出数组中大于5的元素个数</span><br>	<span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr[<span class="hljs-number">0</span>]);<br>	<span class="hljs-keyword">int</span> num=<span class="hljs-built_in">arrNum</span>(arr, arr + len, isRight);<br>	cout &lt;&lt; <span class="hljs-string">&quot;共有..个：&quot;</span> &lt;&lt;num &lt;&lt; endl;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>arrNum()函数的第三个参数是一个函数指针，用于回调，而 isRight() 函数也是外部定义好的，它只接受一个参数的函数。如果此时希望将判定的阈值也作为一个变量传入，变为如下函数就不可行了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isRight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> threshold)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> num &gt; threshold;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然这个函数看起来可以，但是它不能满足已经定义好的函数指针参数的要求，因为函数指针参数的类型是bool (*)(int)，与函数arrNum()的类型不兼容。如果一定要完成这个任务，按照以往的经验，我们可以考虑如下途径：<br>（1）阈值作为函数的局部变量。局部变量不能在函数调用中传递，故不可行；<br>（2）函数传参。这种方法我们已经讨论过了，多个参数不适用于已定义好的 arrNum() 函数。<br>（3）全局变量。我们可以将阈值设置成一个全局变量。这种方法虽然可行，但是不优雅，且非常容易引入 Bug，比如全局变量容易同名，造成命名空间污染。</p>
<p>那么有什么好的处理方法呢？仿函数应运而生。</p>
<h4 id="仿函数的定义"><a href="#仿函数的定义" class="headerlink" title="仿函数的定义"></a>仿函数的定义</h4><p>仿函数（Functor）又称为函数对象（Function Object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载 operator() 运算符。因为调用仿函数，实际上就是通过类对象调用重载后的 operator() 运算符。</p>
<p>如果编程者要将某种“操作”当做算法的参数，一般有两种方法：<br>（1）一个办法就是先将该“操作”设计为一个函数，再将函数指针当做算法的一个参数。上面的实例就是该做法；<br>（2）将该“操作”设计为一个仿函数（就语言层面而言是个 class），再以该仿函数产生一个对象，并以此对象作为算法的一个参数。</p>
<p>很明显第二种方法会更优秀，因为第一种方法扩展性较差，当函数参数有所变化，则无法兼容旧的代码，具体在第一小节已经阐述。正如上面的例子，在我们写代码时有时会发现有些功能代码，会不断地被使用。</p>
<p>这时就可以使用仿函数了，写一个简单类，除了维护类的基本成员函数外，只需要重载 operator() 运算符 。这样既可以免去对一些公共变量的维护，也可以使重复使用的代码独立出来，以便下次复用。</p>
<p>STL 中也大量涉及到仿函数，有时仿函数的使用是为了函数拥有类的性质，以达到安全传递函数指针、依据函数生成对象、甚至是让函数之间有继承关系、对函数进行运算和操作的效果。比如 STL 中的容器 set 就使用了仿函数 less ，而 less 继承的 binary_function，就可以看作是对于一类函数的总体声明，这是函数做不到的。</p>
<p>所以使用仿函数之后可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">isRight</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-built_in">isRight</span>(<span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>):<span class="hljs-built_in">res</span>(res) &#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> num &gt; res;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">int</span> res;<br>&#125;;<br><span class="hljs-keyword">using</span> FUNC = isRight;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">arrNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* first, <span class="hljs-keyword">int</span>* last, FUNC func)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> _count = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (first != last)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">func</span>(*first))<br>		&#123;<br>			_count++;<br>		&#125;<br>		first++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> _count;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">68</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">45</span>,<span class="hljs-number">3</span>,<span class="hljs-number">164</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">64</span> &#125;;<br>	<span class="hljs-comment">//求出数组中大于5的元素个数</span><br>	<span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(arr[<span class="hljs-number">0</span>]);<br>	<span class="hljs-keyword">int</span> num = <span class="hljs-built_in">arrNum</span>(arr, arr + len, <span class="hljs-built_in">isRight</span>(<span class="hljs-number">10</span>));<br>	cout &lt;&lt; <span class="hljs-string">&quot;共有..个：&quot;</span> &lt;&lt; num &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h4><p>谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果<br>operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词<br>可作为一个判断式</p>
<h4 id="函数对象适配器"><a href="#函数对象适配器" class="headerlink" title="函数对象适配器"></a>函数对象适配器</h4><p>函数对象适配器是完成一些配接工作，这些配接包括绑定(bind)，否定(negate),以及对一<br>般函数或成员函数的修饰，使其成为函数对象，重点掌握函数对象适配器(红色字体):</p>
<p><font style="color:red"> bind1st</font>        将参数绑定为函数对象的第一个参数</p>
<p><font style="color:red"> bind2nd</font>        将参数绑定为函数对象的第二个参数</p>
<p><font style="color:red"> not1</font>                对一元函数对象取反</p>
<p><font style="color:red"> not2</font>                对二元函数对象取反</p>
<p>ptr_fun            将普通函数修饰成函数对象</p>
<p>mem_fun        修饰成员函数(容器里存的是对象)</p>
<p>mem_fun_ref    修饰成员函数(容器里存的是指针)</p>
<h5 id="bind1st"><a href="#bind1st" class="headerlink" title="bind1st"></a>bind1st</h5><p>将一个二元函数转换成一个一元函数。（绑定到第一个参数）</p>
<p><code>其他同下</code></p>
<h5 id="bind2nd"><a href="#bind2nd" class="headerlink" title="bind2nd"></a>bind2nd</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Operation</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br>  <span class="hljs-function">binder2nd&lt;Operation&gt; <span class="hljs-title">bind2nd</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> Operation&amp; op, <span class="hljs-keyword">const</span> T&amp; x)</span></span>;<br></code></pre></td></tr></table></figure>

<p>将一个二元函数转换成一个一元函数。（绑定到第二个参数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTest</span> :</span><span class="hljs-keyword">public</span> binary_function&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">void</span>&gt;<br>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> val)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; val &lt;&lt;<span class="hljs-string">&quot; = &quot;</span>&lt;&lt;i+val&lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">obj3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind2nd</span>(<span class="hljs-built_in">CTest</span>(), <span class="hljs-number">10</span>));<br>	<span class="hljs-comment">//for_each(v.begin(), v.end(), bind1st(CTest(),10));</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="not1"><a href="#not1" class="headerlink" title="not1"></a>not1</h5><p>一元函数取反适配器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Mycmp1</span>:</span><span class="hljs-keyword">public</span> unary_function&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">bool</span>&gt;<br>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1)</span><span class="hljs-keyword">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> v1 &gt; <span class="hljs-number">5</span>;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_not1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">not1</span>(<span class="hljs-built_in">Mycmp1</span>()));<br>	<span class="hljs-keyword">if</span> (it != v.<span class="hljs-built_in">end</span>())<br>	&#123;<br>		cout &lt;&lt; *it &lt;&lt; endl;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="not2"><a href="#not2" class="headerlink" title="not2"></a>not2</h5><p>二元函数取反适配器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MCMP1</span> :</span><span class="hljs-keyword">public</span> binary_function&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> a == b;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_not2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">50</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span> &#125;;<br>	<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">adjacent_find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">not2</span>(<span class="hljs-built_in">MCMP1</span>()));<br>	cout &lt;&lt; *it &lt;&lt; endl;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v)<br>	&#123;<br>		cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="ptr-fun"><a href="#ptr-fun" class="headerlink" title="ptr_fun"></a>ptr_fun</h5><p>把普通函数转成仿函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mycmp2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> v1 &gt; <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_not1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123; <span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>	<span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">not1</span>(<span class="hljs-built_in">ptr_fun</span>(mycmp2)));<br>	<span class="hljs-keyword">if</span> (it != v.<span class="hljs-built_in">end</span>())<br>	&#123;<br>		cout &lt;&lt; *it &lt;&lt; endl;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="mem-fun"><a href="#mem-fun" class="headerlink" title="mem_fun"></a>mem_fun</h5><p>把类的成员函数转成仿函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> id):_age(age),_id(id)&#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;id: &quot;</span> &lt;&lt; _id &lt;&lt; <span class="hljs-string">&quot;age: &quot;</span> &lt;&lt; _age &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">int</span> _age;<br>	<span class="hljs-keyword">int</span> _id;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_cref</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Person p1(1, 2), p2(3, 4), p3(5, 6);<br>	vector&lt; Person*&gt; v = &#123; &amp;p1,&amp;p2,&amp;p3 &#125;;<br>	for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fun</span>(&amp;Person::show));<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="mem-fun-ref"><a href="#mem-fun-ref" class="headerlink" title="mem_fun_ref"></a>mem_fun_ref</h5><p>同上，把类的成员函数转成仿函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Person</span>(<span class="hljs-keyword">int</span> age,<span class="hljs-keyword">int</span> id):_age(age),_id(id)&#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;id: &quot;</span> &lt;&lt; _id &lt;&lt; <span class="hljs-string">&quot;age: &quot;</span> &lt;&lt; _age &lt;&lt; endl;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">int</span> _age;<br>	<span class="hljs-keyword">int</span> _id;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun_cref</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Person p1(1, 2), p2(3, 4), p3(5, 6);<br>	vector&lt; Person&gt; v = &#123; p1,p2,p3 &#125;;<br>	for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">mem_fun_ref</span>(&amp;Person::show));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>mem_fun和mem_fun_ref的区别在哪？</p>
<p>当存的是<font style="color:red;">对象</font>时使用mem_fun_ref</p>
<p>存放的是<font style="color:red;">对象的指针</font>时使用mem_fun</p>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之创建型模式</title>
    <url>/posts/3dfd8b5b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote>
<p> 学习笔记之C++设计模式——创建型模式</p>
<p>📑 <a href="/posts/eea0cb26.html" title="设计模式之结构型模式">设计模式之结构型模式</a> <br></p>
<p>📑 <a href="/posts/69f2f423.html" title="设计模式之行为型模式">设计模式之行为型模式</a></p>
</blockquote>
<span id="more"></span>

<h1 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	定义一个水果抽象类。供具体水果实现，和工厂使用</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> :</span> <span class="hljs-keyword">public</span> Fruit&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;我是苹果&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Banana</span> :</span> <span class="hljs-keyword">public</span> Fruit &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;我是香蕉&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">//抽象的工厂类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> Fruit  * <span class="hljs-title">createFruit</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>&#125;;<br><span class="hljs-comment">//通过具体的某一产品的工厂生产某种产品</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleFactory</span> :</span> <span class="hljs-keyword">public</span> AbstractFactory <br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> Fruit * <span class="hljs-title">createFruit</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BananaFactory</span> :</span> <span class="hljs-keyword">public</span> AbstractFactory<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> Fruit * <span class="hljs-title">createFruit</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Banana;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//来一个香蕉工厂</span><br>	AbstractFactory * bananaFactory = <span class="hljs-keyword">new</span> BananaFactory;<br>	<span class="hljs-comment">//给我来一个水果</span><br>	Fruit * banana = bananaFactory-&gt;<span class="hljs-built_in">createFruit</span>();<br>	banana-&gt;<span class="hljs-built_in">getName</span>();<br><br>	<span class="hljs-keyword">delete</span> bananaFactory;<br>	<span class="hljs-keyword">delete</span> banana;<br><br>	AbstractFactory * appleFactory = <span class="hljs-keyword">new</span> AppleFactory;<br>	Fruit * apple = appleFactory-&gt;createFruit;<br>	apple-&gt;<span class="hljs-built_in">getName</span>(); <br><br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvttbzuvuj30ih0a2dhy.jpg" alt="工厂模式" width="665" data-width="665" data-height="362">

<h2 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><div class="note blue no-icon modern"><ol>
<li>不需要记住具体类名，甚至连具体参数都不用记忆。</li>
<li>实现了对象创建和使用的分离。</li>
<li>系统的可扩展性也就变得个非常好，无需修改接口和原类。</li>
</ol>
</div>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><div class="note green no-icon modern"><ol>
<li><p>增加系统中类的个数，复杂度和理解度增加。</p>
</li>
<li><p>增加了系统的抽象性和理解难度。</p>
</li>
</ol>
</div>

<h1 id="二、抽象工厂模式"><a href="#二、抽象工厂模式" class="headerlink" title="二、抽象工厂模式"></a>二、抽象工厂模式</h1><blockquote>
<p>工厂方法模式通过引入工厂等级结构,解决了简单工厂模式中工厂类职责太重的问题,但<mark>由于工厂方法模式中的每个工厂只生产-产品，可能会导致系统中存在大量的工厂类,势必会增加系统的开销</mark>。此时,我们可以考虑将一些相关的产品组成一个”产品族”, 由同-个工厂来统-生产,这就是我们本文将要学习的抽象工厂模式的基本思想。</p>
</blockquote>
<h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gjvttp6a05j30l90n2k08.jpg" alt="抽象工厂模式" width="765" data-width="765" data-height="830">

<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;main.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//抽象产品类 供具体产地产品实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractApple</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBanana</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractPear</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USAApple</span> :</span> <span class="hljs-keyword">public</span> AbstractApple &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;美国苹果&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChinaApple</span> :</span> <span class="hljs-keyword">public</span> AbstractApple &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;中国苹果&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JapanApple</span> :</span> <span class="hljs-keyword">public</span> AbstractApple &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;日本苹果&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USABanana</span> :</span> <span class="hljs-keyword">public</span> AbstractBanana &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;美国香蕉&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChinaBanana</span> :</span> <span class="hljs-keyword">public</span> AbstractBanana &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;中国香蕉&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JapanBanana</span> :</span> <span class="hljs-keyword">public</span> AbstractBanana &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;日本香蕉&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USAPear</span> :</span> <span class="hljs-keyword">public</span> AbstractPear &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;美国鸭梨&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChinaPear</span> :</span> <span class="hljs-keyword">public</span> AbstractPear &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;中国鸭梨&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JapanPear</span> :</span> <span class="hljs-keyword">public</span> AbstractPear &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;日本鸭梨&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-comment">//抽象的工厂类，供具体产品族的实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple * <span class="hljs-title">creatApple</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana * <span class="hljs-title">creatBanana</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear * <span class="hljs-title">creatPear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//具体的工厂</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">USAFactory</span> :</span> <span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple * <span class="hljs-title">creatApple</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> USAApple;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana * <span class="hljs-title">creatBanana</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> USABanana;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear * <span class="hljs-title">creatPear</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> USAPear;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChinaFactory</span> :</span> <span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple * <span class="hljs-title">creatApple</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaApple;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana * <span class="hljs-title">creatBanana</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaBanana;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear * <span class="hljs-title">creatPear</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaPear;<br>	&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JapanFactory</span> :</span> <span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple * <span class="hljs-title">creatApple</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JapanApple;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana * <span class="hljs-title">creatBanana</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JapanBanana;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear * <span class="hljs-title">creatPear</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JapanPear;<br>	&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//现在要准备一个 中国的苹果，中国的香蕉</span><br>	AbstractApple *AA = <span class="hljs-literal">NULL</span>;<br>	AbstractBanana *AB = <span class="hljs-literal">NULL</span>;<br>	AbstractPear *AP = <span class="hljs-literal">NULL</span>;<br><br>	AbstractFactory *factory = <span class="hljs-literal">NULL</span>;<br>	factory = <span class="hljs-keyword">new</span> ChinaFactory;<br>	<span class="hljs-comment">//中国的苹果</span><br>	AA = factory-&gt;<span class="hljs-built_in">creatApple</span>();<br>	<span class="hljs-comment">//中国的香蕉</span><br>	AB = factory-&gt;<span class="hljs-built_in">creatBanana</span>();<br>	AP = factory-&gt;<span class="hljs-built_in">creatPear</span>();<br>    <br>	AA-&gt;<span class="hljs-built_in">getName</span>();<br>	AB-&gt;<span class="hljs-built_in">getName</span>();<br>	AP-&gt;<span class="hljs-built_in">getName</span>();<br><br>	<span class="hljs-keyword">delete</span> AA;<br>	<span class="hljs-keyword">delete</span> AB;<br>	<span class="hljs-keyword">delete</span> AP;<br>    <span class="hljs-keyword">delete</span> factory;<br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>抽象工厂模式不符合“开闭原则”</p>
</blockquote>
<h2 id="抽象工厂模式的优缺点"><a href="#抽象工厂模式的优缺点" class="headerlink" title="抽象工厂模式的优缺点"></a>抽象工厂模式的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><div class="note red no-icon flat"><ol>
<li>拥有工厂方法模式的优点</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li>
<li>增加新的产品族很方便，无需修改已有系统，符合“开闭原则”。</li>
</ol>
</div>

<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><div class="note #01c5c4 no-icon flat"><ol>
<li>增加新的产品结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，带来较大的不便，违背了“开闭原则”。</li>
</ol>
</div>

<p>抽象模式的应用：可以自己写一个计算机产品相关</p>
<blockquote>
<p>简单工厂模式 + “开闭原则” = 工厂方法模式</p>
<p>工厂方法模式 + “产品族” = 抽象工厂模式</p>
<p>简单工厂模式（规模较小的模型）</p>
<p>工厂方法模式（中等）</p>
<p>抽象工厂模式（复杂的）</p>
</blockquote>
<p>借鉴了《Easy搞定设计模式》</p>
<h1 id="三-单例模式"><a href="#三-单例模式" class="headerlink" title="三 单例模式"></a>三 单例模式</h1><blockquote>
<p>保证一个类、只有一个实例存在，同时提供能对该实例加以访问的的全局访问方法。</p>
</blockquote>
<h2 id="三个要点："><a href="#三个要点：" class="headerlink" title="三个要点："></a>三个要点：</h2><p>一是某个类只能有一个实例；</p>
<p>二是它必须自行创建这个实例；</p>
<p>三是它必须自行向整个系统提供这个实例。</p>
<p><img src="../../../images/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/UML%E7%B1%BB%E5%9B%BE.png" alt="image-20201119180254196"></p>
<h2 id="角色和职责"><a href="#角色和职责" class="headerlink" title="角色和职责"></a>角色和职责</h2><p>Singleton（单例）：在单例类的内部实现只生成一个实例，同时是他提供一个静态的getInstance()方法，让客户可以访问他的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个<code>Singleton</code>类型的静态对象，作为外部共享的唯一实例。</p>
<h2 id="单例模式的使用步骤"><a href="#单例模式的使用步骤" class="headerlink" title="单例模式的使用步骤"></a>单例模式的使用步骤</h2><ol>
<li>构造函数私有化</li>
<li>提供一个全局的静态方法（全局访问点） 来获取单例对象。</li>
<li>在类中定义一个静态指针，指向本类的变量的静态变量指针</li>
</ol>
<h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>主要就是为了只让类只有一个实例而把构造函数私有化。定义一个全局的静态实例。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">三个步骤：</span><br><span class="hljs-comment">	1.构造函数私有化（为了不让在类的外部再创建多余的实例）</span><br><span class="hljs-comment">	2.提供一个全局的静态类指针指向唯一实例</span><br><span class="hljs-comment">	3.提供一个全局的静态函数获取实例</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">// 静态类函数 返回静态实例</span><br>	<span class="hljs-function"><span class="hljs-keyword">static</span> Singleton * <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> instance;<br>	&#125;<br><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-comment">//不让类的外部创建实例</span><br>	<span class="hljs-built_in">Singleton</span>() &#123;<br>		Singleton *single = <span class="hljs-built_in">getInstance</span>();<br>	&#125;<br><br>	<span class="hljs-function">Singleton <span class="hljs-title">getsingle</span><span class="hljs-params">()</span> </span>&#123;<br><br>	&#125;<br>	<span class="hljs-keyword">static</span> Singleton * instance; <span class="hljs-comment">//指向本类的唯一实例指针</span><br>&#125;;<br><span class="hljs-comment">//静态类变量在类外初始化</span><br>Singleton*Singleton::instance = <span class="hljs-keyword">new</span> Singleton;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//通过getInstance()获取实例</span><br>	Singleton * s1 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>在程序执行期间再去判断是否需要实例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton1</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">//提供一个返回实例的方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">static</span> Singleton1 * <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 不确定程序在编译期间是否需要实例</span><br>        <span class="hljs-comment">// 如果是多线程下，需要在这里加锁</span><br>		<span class="hljs-keyword">if</span> (instance1 == <span class="hljs-literal">NULL</span>) &#123;<br>			instance1 = <span class="hljs-keyword">new</span> Singleton1;<br>		&#125;<br>        <span class="hljs-comment">// 释放锁</span><br>		cout &lt;&lt; <span class="hljs-string">&quot;Singleton1&quot;</span> &lt;&lt; endl;<br>		<span class="hljs-keyword">return</span> instance1;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-built_in">Singleton1</span>() &#123;<br>	&#125;<br>	<span class="hljs-keyword">static</span> Singleton1 *instance1;<br>&#125;;<br><span class="hljs-comment">//懒汉式的初始化方式 饿汉式在初始化时已经指向了singleton</span><br>Singleton1 * Singleton1::instance1 = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p> 针对单例模式去判断是否是同一实例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Singleton *s1 = Singleton::<span class="hljs-built_in">getinstace</span>();<br>Singleton *s2 = Singleton::<span class="hljs-built_in">getinstace</span>();<br><span class="hljs-keyword">if</span> (s1 == s2 )<br>    cout &lt;&lt; <span class="hljs-string">&quot;s1 == s2&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;s1 != s2&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h2 id="单例模式的应用——打印机"><a href="#单例模式的应用——打印机" class="headerlink" title="单例模式的应用——打印机"></a>单例模式的应用——打印机</h2><p>用单例模式实现一个打印机程序，用以记录打印的次数和内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Printer</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">static</span> Printer * <span class="hljs-title">getinstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> instance;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(string text)</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;打印的内容为：&quot;</span> &lt;&lt; text &lt;&lt; endl;<br>		sequence++;<br>		cout &lt;&lt; <span class="hljs-string">&quot;打印机今天使用了&quot;</span> &lt;&lt; sequence &lt;&lt; <span class="hljs-string">&quot;次&quot;</span> &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSequence</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> sequence;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 定义一个类去析构单例</span><br>	<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Garbo</span> &#123;</span><br>	<span class="hljs-keyword">private</span>:<br>		~<span class="hljs-built_in">Garbo</span>() &#123;<br>			<span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">NULL</span>) &#123;<br>				<span class="hljs-keyword">delete</span> instance;<br>			&#125;<br>		&#125;<br>	&#125;;<br>	<span class="hljs-keyword">static</span> Garbo garbo; <span class="hljs-comment">// 在静态区域开辟一个对象，Garbo</span><br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sequence;<br>	<span class="hljs-keyword">static</span> Printer * instance;<br>&#125;;<br><span class="hljs-keyword">int</span> Printer::sequence = <span class="hljs-number">0</span>;<br>Printer *Printer::instance = <span class="hljs-keyword">new</span> Printer;<br>Printer::Garbo Printer::garbo;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//三个peple使用打印机</span><br>	Printer * p1 = Printer::<span class="hljs-built_in">getinstance</span>();<br>	p1-&gt;<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;亿封简历&quot;</span>);<br><br>	Printer *p2 = Printer::<span class="hljs-built_in">getinstance</span>();<br>	p2-&gt;<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一份工作汇报&quot;</span>);<br><br>	Printer *p3 = Printer::<span class="hljs-built_in">getinstance</span>();<br>	p3-&gt;<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;离职申请&quot;</span>);<br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<div class="note green icon flat"><i class="note-icon fa fa-battery"></i><p>以上就是几种常见的创建型设计模式。</p>
</div>]]></content>
      <categories>
        <category>程序员内功</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试题汇总</title>
    <url>/posts/e72c822.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2021届秋招笔试题汇总"><a href="#2021届秋招笔试题汇总" class="headerlink" title="2021届秋招笔试题汇总"></a>2021届秋招笔试题汇总</h1><span id="more"></span>

<ul>
<li><a href="#%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E20200815">科大讯飞</a></li>
<li><a href="#%E5%A4%A7%E7%96%862020816">大疆</a></li>
<li><a href="#%E7%BE%8E%E7%9A%8420200820">美的</a></li>
<li><a href="#%E5%95%86%E6%B1%A4%E7%A7%91%E6%8A%8020200820">商汤科技</a>  </li>
<li>[中兴1](#中兴20200824）</li>
<li><a href="#%E6%B1%87%E9%A1%B6%E7%A7%91%E6%8A%8020200824">汇顶科技</a>  </li>
<li><a href="#%E7%83%BD%E7%81%AB%E7%A7%91%E6%8A%8020200829">烽火科技</a></li>
<li><a href="#oppo20200829">oppo</a></li>
<li><a href="#%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E20200829">科大讯飞</a></li>
<li><a href="#%E7%BE%8E%E7%9A%8420200831">美的</a></li>
<li><a href="#%E4%B8%AD%E5%85%B420200903">中兴2</a></li>
<li><a href="#%E6%B7%B1%E4%BF%A1%E6%9C%8D20200910">深信服</a></li>
<li><a href="#%E7%BD%91%E6%98%9320200912">网易</a></li>
<li><a href="#VIVO20200912">VIVO</a></li>
<li><a href="#%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%8420200913">美团点评</a></li>
</ul>
<h1 id="科大讯飞20200815"><a href="#科大讯飞20200815" class="headerlink" title="科大讯飞20200815"></a>科大讯飞20200815</h1><h1 id="第1题"><a href="#第1题" class="headerlink" title="第1题"></a>第1题</h1><p>定义一个n*m的数字矩阵，要求你再当中找到两个不在用一行同一列的数组，使得乘积最大</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><blockquote>
<p>第一行数字n、m表示矩阵大小<br>接下来又n行数字，每行m个数字，约定n和m都是小于等于1000，大于等于1的整数。</p>
</blockquote>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote>
<p>一个数字表示最大的乘积值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n , m;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">arr</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(m, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            cin &gt;&gt; arr[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-keyword">int</span> num1 = arr[i][j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; n; ++x) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; m; ++y) &#123;<br>                    <span class="hljs-keyword">int</span> num2 = arr[x][y];<br>                    <span class="hljs-keyword">if</span> (x == i || y == j) <span class="hljs-keyword">continue</span>;<br>                    MAX = <span class="hljs-built_in">max</span>(MAX, num1 * num2);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt;MAX&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第2题"><a href="#第2题" class="headerlink" title="第2题"></a>第2题</h1><p>用某种排序方法对32位整数序列<code>(25,84,21,47,15,27,68,35,20)</code>进行行排序，序列变化的情况如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">21 25 84 47 15 27 68 35 20  <br>15 20 21 25 35 27 47 68 84<br>15 20 21 25 27 35 47 68 84<br></code></pre></td></tr></table></figure>
<p>请以该排序方法对其他的输入序列进行排序并输出结果</p>
<h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><blockquote>
<p>第一行为给定数字序列中的元素个数<br>第二行为给定的数字序列，以空格分割  </p>
</blockquote>
<h3 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h3><blockquote>
<p>输出排序后的数字序列，以空格分割  </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">help</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tmp = arr[left];<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= tmp) right--;<br>        arr[left] = arr[right];<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= tmp) left++;<br>        arr[right] = arr[left];<br>    &#125;<br>    arr[left] = tmp;<br>    <span class="hljs-keyword">return</span>  left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-built_in">help</span>(arr, left, right);<br>    <span class="hljs-built_in">qsort</span>(arr, left, mid - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">qsort</span>(arr, mid + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt;arr[i];<br>    &#125;<br>    <span class="hljs-built_in">qsort</span>(arr, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cout &lt;&lt; arr[i] &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第3题"><a href="#第3题" class="headerlink" title="第3题"></a>第3题</h1><p>统计数字二进制形式1的个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num;<br>    cin &gt;&gt; num;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (num) &#123;<br>        <span class="hljs-keyword">if</span> (num &amp; <span class="hljs-number">1</span>) cnt++;<br>        num &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h1><p>将一个长度位m的字符串左移n位</p>
<h3 id="输入描述：-1"><a href="#输入描述：-1" class="headerlink" title="输入描述："></a>输入描述：</h3><blockquote>
<p>第一行位长度位m的字符串<br>第二行位左移的位数n<br>1 &lt; n,m &lt; 2000</p>
</blockquote>
<h3 id="输出描述：-1"><a href="#输出描述：-1" class="headerlink" title="输出描述："></a>输出描述：</h3><blockquote>
<p>一行输出左移后的字符串</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str;<br>    <span class="hljs-keyword">int</span> n ;<br>    <span class="hljs-built_in">getline</span>(cin, str);<br>    cin &gt;&gt; n;<br>    n %= str.<span class="hljs-built_in">size</span>();<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">int</span> cnt = str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> idx = n;<br>    <span class="hljs-keyword">while</span> (cnt--) &#123;<br>        idx %= str.<span class="hljs-built_in">size</span>();<br>        res += str[idx++];<br>    &#125;<br>    cout &lt;&lt; res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="大疆2020816"><a href="#大疆2020816" class="headerlink" title="大疆2020816"></a>大疆2020816</h1><p>给定一个整数序列，你需要找到两个的子段，保证这两个子段不能重复，并且使得这两个子段中得所有整数得和最大。</p>
<h3 id="输入描述：-2"><a href="#输入描述：-2" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">第1行整数，测试用例数<br>每个测试用例包括3行，<br>第1行整数，整数序列得长度n<br>第2行，n个整数<br>第3行空格<br></code></pre></td></tr></table></figure>
<h3 id="输出描述：-2"><a href="#输出描述：-2" class="headerlink" title="输出描述："></a>输出描述：</h3><p>每个测试用例一行，输出一个整数表示最大子段和</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">input:<br>3<br>10<br>1 -1 2 2 3 -3 4 -4 5 -5<br>5<br>-5 9 -5 11 20<br>10<br>-1 -1 -1 -1 -1 -1 -1 -1 -1 -1<br>output:<br>13<br>40<br>-2<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span>&amp; left, <span class="hljs-keyword">int</span>&amp; right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(len)</span></span>;<br>    <span class="hljs-keyword">int</span> maxSum = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>] + nums[i] &lt; nums[i])&#123;<br>                dp[i] = nums[i];<br>                left = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (maxSum&lt;dp[i]) &#123;<br>            right = i;<br>            maxSum = dp[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>        left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt;<br>    cin &gt;&gt; cnt;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">input</span>(cnt);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++i) &#123;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; n;<br>        input[i].<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            cin &gt;&gt; input[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++i) &#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">maxSubArray</span>(input[i], left, right);<br>        <span class="hljs-built_in">sort</span>(input[i].<span class="hljs-built_in">begin</span>(), input[i].<span class="hljs-built_in">begin</span>()+ right - left + <span class="hljs-number">1</span>, less&lt;<span class="hljs-keyword">int</span>&gt;());<br>        res = left != right ? res - *input[i].<span class="hljs-built_in">begin</span>() : input[i][<span class="hljs-number">0</span>] * <span class="hljs-number">2</span>;<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="美的20200820"><a href="#美的20200820" class="headerlink" title="美的20200820"></a>美的20200820</h1><ul>
<li>部分选择题  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/******************【1】**********************/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>  clrscr() 100</span><br><span class="hljs-built_in">main</span>()<br>&#123;<br>    <span class="hljs-built_in">clrscr</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">clrscr</span>());<br>&#125;<br><span class="hljs-comment">/******************【2】**********************/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span>* p = <span class="hljs-string">&quot;ayqm&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, ++*(p++));<br>&#125;<br><span class="hljs-comment">/******************【3】**********************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span>* p = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ++(*p));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/******************【4】**********************/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">emp</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>        <span class="hljs-keyword">int</span> age;<br>        <span class="hljs-keyword">float</span> sal;<br>    &#125;;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">emp</span> <span class="hljs-title">e</span> =</span> &#123;<span class="hljs-string">&quot;Tiger&quot;</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d %f&quot;</span>, e.age, e.sal);<br>&#125;<br><span class="hljs-comment">/******************【5】**********************/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-keyword">long</span> a1;<br>    <span class="hljs-keyword">short</span> a2;<br>    <span class="hljs-keyword">int</span> a3;<br>    <span class="hljs-keyword">int</span> *a4;<br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">char</span> c2;<br>&#125;;<br><span class="hljs-comment">/******************【6】**********************/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S1</span> &#123;</span><br>    <span class="hljs-keyword">char</span> c;<br>    <span class="hljs-keyword">int</span> i[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">double</span> v;<br>&#125; SA1;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S2</span>&#123;</span><br>    <span class="hljs-keyword">double</span> x;<br>    <span class="hljs-keyword">int</span> i[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">char</span> c;<br>&#125;SA2;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n sizeof S1 %d: sizeof S2 %d&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(SA1), <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(SA2));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/******************【7】**********************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> s[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br>    <span class="hljs-keyword">char</span> *p, *str, *str1;<br>    p = &amp;s[<span class="hljs-number">3</span>];<br>    str = p;<br>    str1 = s;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ++*p + ++*str1 - <span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/******************【8】**********************/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>i = <span class="hljs-number">10</span>, j = <span class="hljs-number">20</span>, k = <span class="hljs-number">50</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ++k);<br>&#125;<br><span class="hljs-comment">/******************【9】**********************/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE -1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NULL 0</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NULL&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(FALSE)<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;TRUE&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;FALSE&quot;</span>);<br>&#125;<br><span class="hljs-comment">/******************【10】**********************/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">32</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%X&quot;</span>, ~m);<br>&#125;<br><span class="hljs-comment">/******************【11】**********************/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> square(x) x * x</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i ;<br>    i = <span class="hljs-number">64</span> / <span class="hljs-built_in">square</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, i);<br>&#125;<br><span class="hljs-comment">/******************【12】**********************/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span> </span>&#123;<br>    *a ^= *b;<br>    *b ^= *a;<br>    *a ^= *b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>, y = <span class="hljs-number">8</span>;<br>    <span class="hljs-built_in">swap</span>(&amp;x, &amp;y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %d y = %d&quot;</span>, x, y);<br>&#125;<br><span class="hljs-comment">/******************【13】**********************/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> something == 0</span><br><span class="hljs-keyword">int</span> some = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> thing = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, some, thing);<br>&#125;<br><span class="hljs-comment">/******************【14】**********************/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> *p;<br>    p = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, *&amp;*p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="商汤科技20200820"><a href="#商汤科技20200820" class="headerlink" title="商汤科技20200820"></a>商汤科技20200820</h1><h3 id="选择题："><a href="#选择题：" class="headerlink" title="选择题："></a>选择题：</h3><p>2、 transformer的位置编码使用交替的多维sin、cos函数实现，不属于设计原理的一项是。    </p>
<ul>
<li>对于不同长度的序列，其相隔同样距离的两个序列元素，进行位置编码后的编码值的距离相同。</li>
<li>保持序列中的绝对位置关系。  </li>
<li>保证序列中元素在一定范围内的相对位置关系。  </li>
<li>限定在固定值域内，避免不同长度序列取值范围不同，以及过大数值对序列的影响。<br>3、 链表访问i位置的时间复杂度。<br>4、 现代CPU都有较大的缓存，cache来提高内存的访问效率。    </li>
<li>c的数组的访问可以使用cache来加速，但数组大小不要超过cache大小    </li>
<li>cache使用需要考虑到不用的cpu核的同步    </li>
<li>cache的访问时按cache entry来进行的，c的数组需要按行优先访问    </li>
<li>一般的cache越大，程序效率越高<br>5、 当多个程序连接动态库，所占内存是多少<br>6、 docker使用什么技术来运行环境的隔离    <h3 id="编程题："><a href="#编程题：" class="headerlink" title="编程题："></a>编程题：</h3>给出一个数字矩阵，寻找一条最上上升路径，每个位置只能向上下左右四个位置移动  <h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">9 1 4<br>6 2 8 <br>5 5 7<br>[1, 2, 5, 7, 8]<br>输出5<br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> row, col;<br><span class="hljs-keyword">int</span> cnt;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-keyword">int</span> dff[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; arr, vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; isVis)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isVis[x][y]) <span class="hljs-keyword">return</span>;<br>    isVis[x][y] = <span class="hljs-literal">true</span>;<br>    cnt++;<br><br>    <span class="hljs-keyword">int</span> MAX = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> m = x + dff[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> n = y + dff[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (m &lt; row &amp;&amp; m &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt; col &amp;&amp; n &gt;= <span class="hljs-number">0</span>)&#123;<br>            MAX = <span class="hljs-built_in">max</span>(MAX, arr[m][n]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (arr[x][y] &gt; MAX) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(cnt);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> m = x + dff[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> n = y + dff[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (m &lt; row &amp;&amp; m &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt; col &amp;&amp; n &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[m][n] &gt; arr[x][y])&#123;<br>            <span class="hljs-built_in">dfs</span>(m, n,arr,isVis);<br>        &#125;<br>    &#125;<br>    isVis[x][y] = <span class="hljs-literal">false</span>;<br>    cnt--;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; row;<br>    cin &gt;&gt; col;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">arr</span>(row, vector&lt;<span class="hljs-keyword">int</span>&gt;(col, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            cin &gt;&gt; arr[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> MIN = INT_MAX;<br>    <span class="hljs-keyword">int</span> min_x = <span class="hljs-number">0</span>, min_y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i][j] &lt; MIN) &#123;<br>                min_x = i;<br>                min_y = j;<br>                MIN = arr[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">isVis</span>(row, vector&lt;<span class="hljs-keyword">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br><br>    <span class="hljs-built_in">dfs</span>(min_x, min_y, arr, isVis);<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    cout &lt;&lt; res.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="中兴20200824"><a href="#中兴20200824" class="headerlink" title="中兴20200824"></a>中兴20200824</h1><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><p>1、shell语言连接到127.0.0.1：8080服务器上的所有ip。<code>netstat -anp | grep &quot;127.0.0.1:8080&quot; | awk - F&#39;:&#39; &#39;&#123;print $5&#125;&#39;</code><br>2、手动测试和自动化测试的区别。<br>3、在浏览器里面输入http网址，哪些协议不会用到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ARP,SMTP,IP,HTTP,DNS,TCP<br></code></pre></td></tr></table></figure>
<p>4、平衡二叉树AVL失衡，时空复杂度。<br>5、构建类的设计模式。<br>6、某个服务器通过域名+端口无法访问，但通过IP+端口可以访问的原因  </p>
<h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><h1 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h1><p>给定一个长度为n得数组a,求最大连续子区间内平均数最大得值。  </p>
<h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">9					&#x2F;&#x2F; 数组长度<br>3 5 3 7 7 6 6 5 6	&#x2F;&#x2F; 数组<br></code></pre></td></tr></table></figure>
<h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">7		&#x2F;&#x2F; 最大平均子区间为[4, 5],值为7<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">int</span> arr[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        cin &gt;&gt; arr[i];<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> avg = (dp[i - <span class="hljs-number">1</span>] + arr[i]) / (i - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (avg &gt; arr[i]) &#123;<br>            dp[i] = avg;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[i] = arr[i];<br>            left = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>());<br>    cout &lt;&lt; dp[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h1><p>给出一个字符串S，S中可能包含(0-9)和(A-Z),现在我们将字符串S(x)看作一个由x进制转为十进制的数字，<br>给定l和r(l &lt;= r)，问S(l) + S(l + 1) … S(r - 1) + S(r - 1)是奇数还是偶数？  </p>
<h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2			&#x2F;&#x2F; 测试的字符串组数<br>101 2 3		&#x2F;&#x2F; 计算2进制到3进制所有数字十进制下之和，并判断奇偶。<br>4B 12 13<br></code></pre></td></tr></table></figure>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1<br>0<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">transfer</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>,k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)<br>            sum += (s[i] - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">1</span> + <span class="hljs-number">9</span>) * k;<br>        <span class="hljs-keyword">else</span><br>            sum += (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * k;<br>        k *= x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">num</span><span class="hljs-params">(n)</span></span>;<br>    vector&lt;int&gt; x(n), y(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; num[i] &gt;&gt; x[i] &gt;&gt; y[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = x[i]; j &lt;= y[i]; ++j) &#123;<br>            ans += <span class="hljs-built_in">transfer</span>(num[i], j);<br>        &#125;<br>        cout &lt;&lt; ((ans &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="汇顶科技20200824"><a href="#汇顶科技20200824" class="headerlink" title="汇顶科技20200824"></a>汇顶科技20200824</h1><h3 id="部分选择题"><a href="#部分选择题" class="headerlink" title="部分选择题"></a>部分选择题</h3><p>奇偶校验<br>static关键字作用<br>do while循环次数   </p>
<h3 id="编程题-1"><a href="#编程题-1" class="headerlink" title="编程题"></a>编程题</h3><p>查找一行字符串中子字符串的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">del_sub</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str, <span class="hljs-keyword">char</span>* sub)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*str != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">char</span>* s1 = str;<br>        <span class="hljs-keyword">char</span>* s2 = sub;<br>        <span class="hljs-keyword">while</span>(*s2 == *s1 &amp;&amp; *s2 != <span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; *s1 != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>            s2++;<br>            s1++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(*s2 == <span class="hljs-string">&#x27;\0&#x27;</span>) cnt++;<br>        str++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">char</span> sub[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,sub);<br>    num = <span class="hljs-built_in">del_sub</span>(str, sub);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,num);<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="科大讯飞20200829"><a href="#科大讯飞20200829" class="headerlink" title="科大讯飞20200829"></a>科大讯飞20200829</h1><h1 id="编程题-2"><a href="#编程题-2" class="headerlink" title="编程题"></a>编程题</h1><h3 id="第一题：-1"><a href="#第一题：-1" class="headerlink" title="第一题："></a>第一题：</h3><p>写一个函数用递归实现将一个正整数分解质因数，如50，则程序打印”2<em>5</em>5”</p>
<h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">50<br></code></pre></td></tr></table></figure>
<h3 id="输出描述：-3"><a href="#输出描述：-3" class="headerlink" title="输出描述："></a>输出描述：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2*5*5<br></code></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">string s;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>            s += (<span class="hljs-string">&#x27;0&#x27;</span> + i);<br>            s += <span class="hljs-string">&#x27;*&#x27;</span>;<br>            <span class="hljs-built_in">fun</span>(n / i);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">fun</span>(n);<br>    s.<span class="hljs-built_in">pop_back</span>();<br>    cout &lt;&lt; s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="第二题：-1"><a href="#第二题：-1" class="headerlink" title="第二题："></a>第二题：</h3><p>去除多余的下划线，要求再原串上进行操作</p>
<h3 id="输入描述-4"><a href="#输入描述-4" class="headerlink" title="输入描述"></a>输入描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">___aaa__b___c__dd__<br></code></pre></td></tr></table></figure>
<h3 id="输出描述：-4"><a href="#输出描述：-4" class="headerlink" title="输出描述："></a>输出描述：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">aaa_b_c_dd<br></code></pre></td></tr></table></figure>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteSpace</span><span class="hljs-params">(string&amp; str)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (str[cur] == <span class="hljs-string">&#x27;_&#x27;</span>) cur++;<br>    <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur &lt; str.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (str[cur] != <span class="hljs-string">&#x27;_&#x27;</span>)<br>            str[tail++] = str[cur];<br>        <span class="hljs-keyword">if</span> (str[cur] == <span class="hljs-string">&#x27;_&#x27;</span> &amp;&amp; str[cur - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;_&#x27;</span>)<br>            str[tail++] = str[cur];<br>        cur++;<br>    &#125;<br>    cur--;<br>    <span class="hljs-keyword">while</span> (str[cur] == <span class="hljs-string">&#x27;_&#x27;</span>) &#123;<br>        str.<span class="hljs-built_in">pop_back</span>();<br>        cur--;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str;<br>    cin &gt;&gt; str;<br>    <span class="hljs-built_in">deleteSpace</span>(str);<br>    cout &lt;&lt; str;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="美的20200831"><a href="#美的20200831" class="headerlink" title="美的20200831"></a>美的20200831</h1><ul>
<li>部分选择题<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> prod(a, b) a * b</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>,y = <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">prod</span>(x + <span class="hljs-number">2</span>, y <span class="hljs-number">-1</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> C = <span class="hljs-number">32</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, C ^= C, !(C &amp; <span class="hljs-number">128</span>) &amp;&amp; !(C &amp; <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> s[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br>    <span class="hljs-keyword">char</span> *p, *str, *str1;<br>    p = &amp;s[<span class="hljs-number">3</span>];<br>    str = p;<br>    str1 = s;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ++*p + ++*str1 - <span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> square(x) x * x</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i ;<br>    i = <span class="hljs-number">64</span> / <span class="hljs-built_in">square</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">float</span> a = <span class="hljs-number">5.375</span>;<br>    <span class="hljs-keyword">char</span> *p;<br>    <span class="hljs-keyword">int</span> i;<br>    p = (<span class="hljs-keyword">char</span>*) &amp;a;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02X&quot;</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>)p[i]);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max(a,b) (a &gt; b) ? a : b</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a,b;a=<span class="hljs-number">3</span>;b=<span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ++<span class="hljs-built_in">max</span>(a++,b--));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> f(g, g2) g##g2</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> var12 = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-built_in">f</span>(var,<span class="hljs-number">12</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span> &amp;b,<span class="hljs-keyword">int</span> c)</span></span>&#123;<br>    c =* a;<br>    b = <span class="hljs-number">30</span>;<br>    *a = <span class="hljs-number">20</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>, c = <span class="hljs-number">30</span>;<br>    <span class="hljs-built_in">change</span>(&amp;a,b, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %d, %d&quot;</span>, a, b, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myStruct</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b;<br>&#125;*ptr;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myStruct</span> <span class="hljs-title">ms</span> =</span> &#123;<span class="hljs-number">400</span>,<span class="hljs-string">&#x27;A&#x27;</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d  %d&quot;</span>, ptr-&gt;a, ptr-&gt;b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">typedef</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Error</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> warning;<br>    <span class="hljs-keyword">int</span> error;<br>    <span class="hljs-keyword">int</span> exception;<br>&#125;error;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    error g1;<br>    g1.error = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, g1.error);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<br>    i = !i &gt; <span class="hljs-number">14</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i=%d&quot;</span>,i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x, y = <span class="hljs-number">2</span>, z, a;<br>    x = (y *= <span class="hljs-number">2</span>) + ( z = a = y);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> i = <span class="hljs-number">0x80</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>,i &lt;&lt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> *p;<br>    p = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, *&amp;*p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x, y = <span class="hljs-number">2</span>, z, a;<br>    <span class="hljs-keyword">if</span> (x = y % <span class="hljs-number">2</span>);<br>    z=<span class="hljs-number">2</span>;<br>    a=<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,z,x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="中兴20200903"><a href="#中兴20200903" class="headerlink" title="中兴20200903"></a>中兴20200903</h1><h2 id="编程题二："><a href="#编程题二：" class="headerlink" title="编程题二："></a>编程题二：</h2><p>A城和B城是双向路径，求A城到B城的最短路径</p>
<h3 id="输入描述：-3"><a href="#输入描述：-3" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">5 3 3	&#x2F;&#x2F; n m q 代表：n个城市 m条双向路径 q次询问<br>1 2 1	&#x2F;&#x2F; x y l 代表x到y有一条距离为l的双向路径<br>2 3 1	<br>3 5 2<br>1 2		&#x2F;&#x2F; a b 代表要询问的两个城市<br>2 4<br>1 5<br></code></pre></td></tr></table></figure>

<h3 id="输出描述：-5"><a href="#输出描述：-5" class="headerlink" title="输出描述："></a>输出描述：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1		&#x2F;&#x2F; 查询的最短路，若不存在输出-1<br>-1<br>4<br></code></pre></td></tr></table></figure>

<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; graph;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; dist;<br>vector&lt;<span class="hljs-keyword">bool</span>&gt; isVis;<br><span class="hljs-keyword">int</span> MIN = INT_MAX;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> dst, <span class="hljs-keyword">int</span> distance)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == dst) &#123;<br>        MIN = <span class="hljs-built_in">min</span>(MIN, distance);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : graph[cur]) &#123;<br>        <span class="hljs-keyword">if</span> (isVis[v]) <span class="hljs-keyword">continue</span>;<br>        isVis[v] = <span class="hljs-literal">true</span>;<br>        distance += dist[cur][v];<br>        <span class="hljs-built_in">dfs</span>(v, dst, distance);<br>        isVis[v] = <span class="hljs-literal">false</span>;<br>        distance -= dist[cur][v];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, q;<br>    cin &gt;&gt; n;<br>    cin &gt;&gt; m;<br>    cin &gt;&gt; q;<br>    graph.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>    dist.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    isVis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>, v = <span class="hljs-number">0</span>, dis = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; u;<br>        cin &gt;&gt; v;<br>        cin &gt;&gt; dis;<br>        graph[u].<span class="hljs-built_in">push_back</span>(v);<br>        graph[v].<span class="hljs-built_in">push_back</span>(u);<br>        dist[u][v] = dis;<br>        dist[v][u] = dis;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> src[q], dst[q];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>        cin &gt;&gt; src[i];<br>        cin &gt;&gt; dst[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>        MIN = INT_MAX;<br>        <span class="hljs-built_in">dfs</span>(src[i], dst[i], <span class="hljs-number">0</span>);<br>        cout &lt;&lt; ((MIN == INT_MAX) ? <span class="hljs-number">-1</span> : MIN) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="深信服20200910"><a href="#深信服20200910" class="headerlink" title="深信服20200910"></a>深信服20200910</h1><h3 id="选择题考点："><a href="#选择题考点：" class="headerlink" title="选择题考点："></a>选择题考点：</h3><ul>
<li>时间复杂度</li>
<li>结构体内存对齐</li>
<li>位运算符</li>
<li>八大排序算法时间复杂度</li>
</ul>
<h3 id="编程题：-1"><a href="#编程题：-1" class="headerlink" title="编程题："></a>编程题：</h3><p>x*y的矩阵，从一个房间进入，从另一个房间出来，要求不重复的走完全部房间的路径数量。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> off[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; isVis;<br><span class="hljs-keyword">int</span> row, col;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> endX, endY;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> depth)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (isVis[x][y]) <span class="hljs-keyword">return</span>;<br>	isVis[x][y] = <span class="hljs-literal">true</span>;<br>	depth++;<br>	<span class="hljs-keyword">if</span> (x == endX &amp;&amp; y == endY &amp;&amp; depth == row * col) &#123;<br>		cnt++;<br>		isVis[x][y] = <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>		<span class="hljs-keyword">int</span> m = x + off[i][<span class="hljs-number">0</span>];<br>		<span class="hljs-keyword">int</span> n = y + off[i][<span class="hljs-number">1</span>];<br>		<span class="hljs-keyword">if</span> (m &gt;= <span class="hljs-number">0</span> &amp;&amp; m &lt; row &amp;&amp; n &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt; col &amp;&amp; !isVis[m][n])<br>			<span class="hljs-built_in">dfs</span>(m, n, depth);<br>	&#125;<br>	depth--;<br>	isVis[x][y] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin &gt;&gt; row;<br>	cin &gt;&gt; col;<br>	isVis.<span class="hljs-built_in">resize</span>(row, vector&lt;<span class="hljs-keyword">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br>	<span class="hljs-keyword">int</span> stratX, startY;<br>	cin &gt;&gt; stratX;<br>	cin &gt;&gt; startY;<br>	cin &gt;&gt; endX;<br>	cin &gt;&gt; endY;<br>	<span class="hljs-built_in">dfs</span>(stratX, startY, <span class="hljs-number">0</span>);<br>	cout &lt;&lt; cnt &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="网易20200912"><a href="#网易20200912" class="headerlink" title="网易20200912"></a>网易20200912</h1><h3 id="编程题1"><a href="#编程题1" class="headerlink" title="编程题1"></a>编程题1</h3><p>一颗二叉树，叶子结点定义为“樱桃”，统计一串上刚好有两颗“樱桃”的串的个数</p>
<h3 id="输入描述：-4"><a href="#输入描述：-4" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">3 2		&#x2F;&#x2F; 3个结点 2条边<br>1 1 2	&#x2F;&#x2F; 1的左子树为2<br>1 2 3	&#x2F;&#x2F; 1的右子树为3<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>	<span class="hljs-keyword">int</span> val;<br>	TreeNode *left;<br>	TreeNode *right;<br>	<span class="hljs-built_in">TreeNode</span>(<span class="hljs-keyword">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>	<span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;right &amp;&amp;<br>		!root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right &amp;&amp; <br>		!root-&gt;right-&gt;left &amp;&amp; !root-&gt;right-&gt;right) <br>		cnt++;<br>	<span class="hljs-built_in">dfs</span>(root-&gt;left);<br>	<span class="hljs-built_in">dfs</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> n, m;<br>	cin &gt;&gt; n;<br>	cin &gt;&gt; m;<br>	unordered_map&lt;<span class="hljs-keyword">int</span>, TreeNode*&gt; hash;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>		<span class="hljs-keyword">int</span> uid, dir, vid;<br>		cin &gt;&gt; uid;<br>		cin &gt;&gt; dir;<br>		cin &gt;&gt; vid;<br>		<br>		<span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(uid) == hash.<span class="hljs-built_in">end</span>()) &#123;<br>			hash[uid] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(uid);<br>		&#125;<br>		<br>		<span class="hljs-keyword">if</span> (dir == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// left</span><br>			<span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(vid) == hash.<span class="hljs-built_in">end</span>())<br>				hash[vid] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vid);<br>			hash[uid]-&gt;left = hash[vid];<br>		&#125; <span class="hljs-keyword">else</span> &#123;			<span class="hljs-comment">// right</span><br>			<span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(vid) == hash.<span class="hljs-built_in">end</span>())<br>				hash[vid] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(vid);<br>			hash[uid]-&gt;right = hash[vid];<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-built_in">dfs</span>(hash[<span class="hljs-number">1</span>]);<br>	cout &lt;&lt; cnt;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="编程题2"><a href="#编程题2" class="headerlink" title="编程题2"></a>编程题2</h3><p>快递员城市中送快递，每个城市距离1km，求图的最大深度</p>
<h3 id="输入描述：-5"><a href="#输入描述：-5" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">6 3			&#x2F;&#x2F; 共6个城市 还能再开3公里<br>0 0 2 3 3 	&#x2F;&#x2F; 想象成一个数组S[5] 下标i+1 到 S[i]之间有一条路径<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">bool</span>&gt; isVis;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; G;<br><span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> MAX = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root)</span> </span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (isVis[root]) <span class="hljs-keyword">return</span>;<br>	isVis[root] = <span class="hljs-literal">true</span>;<br>	depth++;<br>	MAX = <span class="hljs-built_in">max</span>(MAX, depth);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : G[root]) &#123;<br>		<span class="hljs-built_in">dfs</span>(v);<br>	&#125;<br>	depth--;<br>	isVis[root] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> n, k;<br>	cin &gt;&gt; n;<br>	cin &gt;&gt; k;<br>	G.<span class="hljs-built_in">resize</span>(n);<br>	isVis.<span class="hljs-built_in">resize</span>(n, <span class="hljs-literal">false</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>		<span class="hljs-keyword">int</span> v;<br>		cin &gt;&gt; v;<br>		G[i+<span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(v);<br>		G[v].<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>	&#125;<br>	<span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>	cout &lt;&lt; (MAX &gt; (k + <span class="hljs-number">1</span>) ? (k + <span class="hljs-number">1</span>) : MAX);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="编程题3"><a href="#编程题3" class="headerlink" title="编程题3"></a>编程题3</h3><p>给定一个字符串，求最长字符串的长度，前提这个字符串满足aeiou元音字母在字符串中出现次数刚好为偶数次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//暴力法会超时</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;str)</span> </span>&#123;<br>	<span class="hljs-keyword">char</span> count[<span class="hljs-number">256</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> i : str) &#123;<br>		count[i]++;<br>	&#125;<br>	<span class="hljs-keyword">return</span> count[<span class="hljs-string">&#x27;a&#x27;</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp;<br>		count[<span class="hljs-string">&#x27;e&#x27;</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp;<br>		count[<span class="hljs-string">&#x27;i&#x27;</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp;<br>		count[<span class="hljs-string">&#x27;o&#x27;</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp;<br>		count[<span class="hljs-string">&#x27;u&#x27;</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sol</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> maxVal = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; s.<span class="hljs-built_in">length</span>(); j++) &#123;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">judge</span>(s.<span class="hljs-built_in">substr</span>(i, j + <span class="hljs-number">1</span> - i))) &#123;<br>				maxVal = <span class="hljs-built_in">max</span>(maxVal, j - i + <span class="hljs-number">1</span>);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> maxVal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	string str;<br>	<span class="hljs-built_in">getline</span>(cin, str);<br>	cout &lt;&lt; <span class="hljs-built_in">sol</span>(str);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="VIVO20200912"><a href="#VIVO20200912" class="headerlink" title="VIVO20200912"></a>VIVO20200912</h1><h3 id="编程题1-1"><a href="#编程题1-1" class="headerlink" title="编程题1"></a>编程题1</h3><p>给定非空字符串str，在最多可以删除一个字符情况下，判定能够成为回文串，<br>如果可以则输出首次删除一个字符所能得到的回文字，如果不行则输出字符串“false”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPali</span><span class="hljs-params">(string str)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>		<span class="hljs-keyword">if</span> (str[left] != str[right]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		left++, right--;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	string str;<br>	<span class="hljs-built_in">getline</span>(cin, str);<br>	string res = <span class="hljs-string">&quot;false&quot;</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>		string s = str;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPoli</span>(s)) &#123;<br>			res = s;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPali</span>(s.<span class="hljs-built_in">erase</span>(i, <span class="hljs-number">1</span>))) &#123;<br>			res = s;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>	<br>	cout &lt;&lt; res;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="编程题2-1"><a href="#编程题2-1" class="headerlink" title="编程题2"></a>编程题2</h3><p>矩形格子，字符 ‘@’ 和 ‘#’ 代表障碍物，指定起点和终点，求最短路径的长度，无法到达则返回-1</p>
<h3 id="输入描述-5"><a href="#输入描述-5" class="headerlink" title="输入描述"></a>输入描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">3			&#x2F;&#x2F; 维度为3*3的矩形<br>0 0 2 2		&#x2F;&#x2F; 起点 （0，0）终点（2，2）<br>1@3			&#x2F;&#x2F; 迷宫描述<br>1@#<br>123<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt; map;<br>vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; isVis;<br><span class="hljs-keyword">int</span> endX, endY, n;<br><span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> MIN = INT_MAX;<br><span class="hljs-keyword">int</span> off[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125; &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (isVis[x][y]) <span class="hljs-keyword">return</span>;<br>	isVis[x][y] = <span class="hljs-literal">true</span>;<br>	depth++;<br><br>	<span class="hljs-keyword">if</span> (x == endX &amp;&amp; y == endY) &#123;<br>		MIN = <span class="hljs-built_in">min</span>(MIN, depth);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>		<span class="hljs-keyword">int</span> xi = x + off[i][<span class="hljs-number">0</span>];<br>		<span class="hljs-keyword">int</span> yi = y + off[i][<span class="hljs-number">1</span>];<br>		<span class="hljs-keyword">if</span> (xi &gt;= <span class="hljs-number">0</span> &amp;&amp; xi &lt; n &amp;&amp; yi &gt;= <span class="hljs-number">0</span> &amp;&amp; yi &lt; n &amp;&amp;<br>			map[xi][yi] != <span class="hljs-string">&#x27;#&#x27;</span> &amp;&amp; map[xi][yi] != <span class="hljs-string">&#x27;@&#x27;</span>) &#123;<br>			<span class="hljs-built_in">dfs</span>(xi, yi);<br>		&#125;<br>	&#125;<br>	depth--;<br>	isVis[x][y] = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> startX, startY;<br>	cin &gt;&gt; n;<br>	cin &gt;&gt; startX;<br>	cin &gt;&gt; startY;<br>	cin &gt;&gt; endX;<br>	cin &gt;&gt; endY;<br>	map.<span class="hljs-built_in">resize</span>(n, vector&lt;<span class="hljs-keyword">char</span>&gt;(n, <span class="hljs-string">&#x27; &#x27;</span>));<br>	isVis.<span class="hljs-built_in">resize</span>(n, vector&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>			cin &gt;&gt; map[i][j];<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-built_in">dfs</span>(startX, startY);<br>	cout &lt;&lt; (MIN == INT_MAX ?  <span class="hljs-number">-1</span> : MIN );<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="美团点评20200913"><a href="#美团点评20200913" class="headerlink" title="美团点评20200913"></a>美团点评20200913</h1><h3 id="编程题1-2"><a href="#编程题1-2" class="headerlink" title="编程题1"></a>编程题1</h3><p>回文矩阵，按行回文，找到最小非回文矩阵</p>
<h3 id="输入描述：-6"><a href="#输入描述：-6" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">8 3		&#x2F;&#x2F; 8 * 3矩阵<br>1 0 1<br>0 1 0<br>0 1 0<br>1 0 1<br>1 0 1<br>0 1 0<br>0 1 0<br>1 0 1<br></code></pre></td></tr></table></figure>
<h3 id="输出描述：-6"><a href="#输出描述：-6" class="headerlink" title="输出描述："></a>输出描述：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1 0 1<br>0 1 0<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> n, m;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; arr;<br><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> != (<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; v1, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; v2) &#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v1.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>		<span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPali</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; arr)</span> </span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>		<span class="hljs-keyword">if</span> (arr[left] != arr[right])<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		left++, right--;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main1</span><span class="hljs-params">()</span> </span>&#123;<br>	cin &gt;&gt; n;<br>	cin &gt;&gt; m;<br>	arr.<span class="hljs-built_in">resize</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(m, <span class="hljs-number">0</span>));<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>			cin &gt;&gt; arr[i][j];<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">int</span> right = n;<br>	<span class="hljs-keyword">while</span> (right) &#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPali</span>(arr)) &#123;<br>			right /= <span class="hljs-number">2</span>;<br>			arr.<span class="hljs-built_in">erase</span>(arr.<span class="hljs-built_in">begin</span>() + right, arr.<span class="hljs-built_in">end</span>());<br>			<span class="hljs-keyword">continue</span>;<br>		&#125; <br>		<span class="hljs-keyword">break</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> lev : arr) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : lev) &#123;<br>			cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>		&#125;<br>		cout &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="编程题2-2"><a href="#编程题2-2" class="headerlink" title="编程题2"></a>编程题2</h3><p>一个齿轮，26个齿A~Z，每个齿轮两个按钮，按钮1：跟前轮啮合并逆时针转一格，按钮2：跟后轮啮合并逆时针转一格，按完按钮恢复原状。<br>用所有齿轮正上方的字母组成一个字符串，给定初始齿轮状态，统计所有无重复字符串的个数。<br>注意：A不能转到Z，Z不能转到A, </p>
<h3 id="输入描述：-7"><a href="#输入描述：-7" class="headerlink" title="输入描述："></a>输入描述：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">2	&#x2F;&#x2F; 2个齿轮<br>BB	&#x2F;&#x2F; 2个齿轮初始状态 B B<br>3	&#x2F;&#x2F; 3个齿轮<br>ABA	&#x2F;&#x2F; 3个齿轮初始状态 A B A <br></code></pre></td></tr></table></figure>
<h3 id="输出描述：-7"><a href="#输出描述：-7" class="headerlink" title="输出描述："></a>输出描述：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">3	&#x2F;&#x2F; 结果对998244353取模<br>3	<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; res;<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">sol</span><span class="hljs-params">(string str)</span> </span>&#123;<br>	res.<span class="hljs-built_in">clear</span>();<br>	string s = str;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>		<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>			s = str;<br>			s[i] += <span class="hljs-number">1</span>;<br>			s[i + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span> (s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; s[i + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;A&#x27;</span>)<br>				res.<span class="hljs-built_in">push_back</span>(s);<br>		&#125; <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> (i == str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>			s = str;<br>			s[i] += <span class="hljs-number">1</span>;<br>			s[i - <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span> (s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;A&#x27;</span>)<br>				res.<span class="hljs-built_in">push_back</span>(s);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			s = str;<br>			s[i] += <span class="hljs-number">1</span>;<br>			s[i + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span> (s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; s[i + <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;A&#x27;</span>)<br>				res.<span class="hljs-built_in">push_back</span>(s);<br>			s = str;<br>			s[i] += <span class="hljs-number">1</span>;<br>			s[i - <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">if</span> (s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] &gt;= <span class="hljs-string">&#x27;A&#x27;</span>)<br>				res.<span class="hljs-built_in">push_back</span>(s);<br>		&#125;<br>	&#125;<br>	<span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">set</span><span class="hljs-params">(res.begin(), res.end())</span></span>;<br>	<span class="hljs-keyword">return</span> (set.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) % <span class="hljs-number">998244353</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> n;<br>	string str;<br>	vector&lt;string&gt; strs;<br>	<span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, str)) &#123; 	<span class="hljs-comment">// 必须使用ctrl + z结束输入</span><br>		<span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>		strs.<span class="hljs-built_in">push_back</span>(str);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>		cout &lt;&lt; <span class="hljs-built_in">sol</span>(strs[i]) &lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="联发科20200915"><a href="#联发科20200915" class="headerlink" title="联发科20200915"></a>联发科20200915</h1><h3 id="选择题考点：-1"><a href="#选择题考点：-1" class="headerlink" title="选择题考点："></a>选择题考点：</h3><ul>
<li>linux进程间通信有哪些</li>
<li>关于内存泄漏</li>
<li>C++函数中参数传递的方式</li>
<li>static修饰的局部变量、全局变量、函数、成员变量的作用分别是</li>
<li>列举TCP/IP五层参考模型</li>
<li>可执行程序加载时系统分配的内存可以分为哪几段</li>
</ul>
<h3 id="编程题1-3"><a href="#编程题1-3" class="headerlink" title="编程题1"></a>编程题1</h3><p>手写查找子字符串C函数<code>int strstr(char * str1, char * str2)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：&quot;abcdefabcdef&quot;,&quot;def&quot;<br>输出：3		&#x2F;&#x2F;找到输出第一个下标 没找到输出-1<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">my_strstr</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str1, <span class="hljs-keyword">char</span>* str2)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (str2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (*str1 != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>		<span class="hljs-keyword">if</span> (*str1 != *str2) &#123;<br>			str1++;<br>			idx++;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">char</span> * p1 = str1;<br>			<span class="hljs-keyword">char</span> * p2 = str2;<br>			<span class="hljs-keyword">while</span> (*p2 != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>				<span class="hljs-keyword">if</span> (*p2 == *p1) &#123;<br>					p1++; p2++;<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (*p2 == <span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-keyword">return</span> idx;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">char</span> str1[<span class="hljs-number">100</span>];<br>	<span class="hljs-keyword">char</span> str2[<span class="hljs-number">100</span>];<br>	cin &gt;&gt; str1;<br>	cin &gt;&gt; str2;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">my_strstr</span>(str1, str2));<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux指令（转载）</title>
    <url>/posts/10ebf187.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p>
<span id="more"></span>

<h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><ul>
<li><a href="#%E5%88%87%E6%8D%A2%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB">切换运行级别</a>  </li>
<li><a href="#%E5%B8%AE%E5%8A%A9%E6%8C%87%E4%BB%A4">帮助指令</a>  </li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%B1%BB">文件目录</a>  </li>
<li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91">重定向(覆盖追加操作)</a>  </li>
<li><a href="#%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%91%BD%E4%BB%A4">时间日期</a>  </li>
<li><a href="#%E6%90%9C%E7%B4%A2%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4">搜索查找</a>  </li>
<li><a href="#%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B">压缩解压</a>  </li>
</ul>
<h2 id="切换运行级别"><a href="#切换运行级别" class="headerlink" title="切换运行级别"></a>切换运行级别</h2><p><code>0:关机</code> <code>1:单用户</code> <code>2:多用户没有网络</code> <code>3:多用户有网络</code><br><code>4:系统未使用保留给用户</code> <code>5:图像界面</code> <code>6:系统重启</code> 常用3和5，忘记密码时切到1改密码<br></p>
<pre><code>init 0~5
</code></pre>
<h2 id="帮助指令-不如百度）"><a href="#帮助指令-不如百度）" class="headerlink" title="帮助指令(不如百度）"></a>帮助指令(不如百度）</h2><pre><code>man ls                                 //获取帮助信息
help cd                                //获取shell内置命令帮助信息
</code></pre>
<h2 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h2><pre><code>pwd                                     //当前绝对路径
ls -al                                  //列表方式显示所有文件和目录包括隐藏的
cd ~  
cd                                      //回到家目录
cd ..                                   //回到上一级目录
mkdir -p /home/animals/dog              //创建多级目录 
rmdir /home/animals/dog                 //删除空目录
rm -rf                                  //删除非空目录 -r递归 -f忽略警告
rm                                      //删除文件
tough hello.txt world.txt               //创建多个空文件
cp hello.txt dest/                      //将文件拷贝到dest
cp -r source/ dest/                     //将source整个目录所有文件拷贝到dest，同名文件回提示
\cp -r source/ dest/                    //强制覆盖同名文件且不提示
mv old.txt new.txt                      //重命名
mv old.txt /root/                       //将当前目录中old文件移动到根目录中   
</code></pre>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title=" 查看文件"></a> 查看文件</h2><pre><code>cat -n /etc/profile                     //只读方式查看文件内容 -n显示行号
cat -n /etc/profile | more              //长配合一个管道 more分页浏览
more                                    //space下翻 enter上翻 q离开 ctrl+f下滚 ctrl+b上滚
less                                    //适合加载查看大日志，space pageDown pageUp上下翻 q离开
head /etc/profile                       //查看前10行
head -n 5 /etc/profile                  //查看前5行
tail /etc/profile                       //查看后10行
tail -n 5 /etc/profile                  //查看后5行
tail -f data.txt                        //实时监控，如有变化立即显示
</code></pre>
<h2 id="重定向-覆盖追加操作）"><a href="#重定向-覆盖追加操作）" class="headerlink" title="重定向(覆盖追加操作）"></a>重定向(覆盖追加操作）</h2><pre><code>ls -l &gt; new.txt                         //列表内容覆盖写入文件
ls -l /home/ &gt; /home/info.txt           //home目录列表写入文件中
ls -l &gt;&gt; new.txt                        //只追加
cat /etc/profile &gt; new.txt              //覆盖
echo &quot;hello&quot;                            //输出内容到控制台
echo $PATH                              //输出环境变量
history 10                              //显示最近使用过的10个命令
！5                                     //执行编号为5的指令
</code></pre>
<h2 id="时间日期命令"><a href="#时间日期命令" class="headerlink" title=" 时间日期命令"></a> 时间日期命令</h2><pre><code>data                        //显示当前时间
data &quot;+%Y-%m-%d %H:%M:%S&quot;   //年-月-日 时：分：秒
data -s &quot;2020-3-3 23:22:00&quot; //设置系统当前时间
cal                         //显示本月日历
cal 2020                    //显示一年的
</code></pre>
<h2 id="搜索查找命令"><a href="#搜索查找命令" class="headerlink" title="搜索查找命令"></a>搜索查找命令</h2><pre><code>find /home -name hello.txt              //搜home目录下（包括子目录）名为hello的文件，
find /opt -user lwt                     //搜索用户为lwt的所有文件
find / -size +20M                       //搜整个系统下大于20m的文件
find / -size -20M                       //小于
find / -name *.txt                      //搜所有后缀为txt文件
updatedb                                //第一次使用locate命令前必须先更新数据库
locate hello.txt                        //快速定位文件路径
cat hello.txt |grep -n yes              //过滤查找，查找yes所在行显示行号，区分大小写
cat hello.txt |grep -ni yes             //过滤查找，区分大小写
</code></pre>
<h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><pre><code>gzip hello.txt                          //压缩不保留原来文件，压缩成*.gz文件 
gunzip hello.txt.gz                     //当前目录下解压
zip -r package.zip /home/               //将home下所有文件压缩成package.zip
unzip -d /opt/tmp package.zip           //解压到/opt/tmp目录下
tar -zcvf dest.tar.gz source1.txt source2.txt  //压缩多个文件，打包结尾*.tar.gz文件
tar -zcvf dest.tar.gz /home/            //压缩整个honme文件
tar -zxvf dest.tar.gz                   //解压到当前目录
tar -zxvf dest.tar.gz -C /opt/tmp       //-C指定到目录，tmp必须先存在
</code></pre>
<p>​    </p>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>github</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Liux</tag>
        <tag>Linux指令</tag>
      </tags>
  </entry>
  <entry>
    <title>🐳链表🐳</title>
    <url>/posts/2bc70af9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🐳链表🐳"><a href="#🐳链表🐳" class="headerlink" title="🐳链表🐳"></a>🐳链表🐳</h1><span id="more"></span>

<p>排序由易到难  </p>
<ul>
<li><a href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9">19.删除链表的倒数第N个节点</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">21.合并两个有序链表</a></li>
<li><a href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9">24.两两交换链表中的节点</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">83.删除排序链表中的重复元素</a></li>
<li><a href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">141.环形链表</a></li>
<li><a href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8">160.相交链表</a></li>
<li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">206.反转链表</a></li>
<li><a href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">234.回文链表</a></li>
<li><a href="#%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8">328.奇偶链表</a></li>
<li><a href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II">445.两数相加II</a></li>
<li><a href="#%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8">725.分隔链表</a>  </li>
<li><a href="#%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6">817.链表组件</a></li>
</ul>
<h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">Leetcode</a>  给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>使用快慢指针法，让快指针提前先走n+1步，再同步快慢指针直到快指针指向链表结尾时，慢指针刚好停留在需要删除结点的前驱。</li>
<li>添加头结点 <code>dummy</code> 是为了统一对链表增删的操作。</li>
<li>删除结点相当于链接时跳过此结点<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next=head;<br>    ListNode* fast=dummy;<br>    ListNode* slow=dummy；<br>    <span class="hljs-keyword">int</span> cnt=n+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(cnt--)&#123;<br>        fast=fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(fast)&#123;<br>        fast=fast-&gt;next;<br>        slow=slow-&gt;next;<br>    &#125;<br>    slow-&gt;next=slow-&gt;next-&gt;next;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">Leetcode</a>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3></li>
<li>合并为一个新的链表用尾插法，三个指针：l1，l2用于遍历两个链表，cur用于遍历新的链表</li>
<li>涉及新建链表一般都需要new一个头结点和定义一个指针用于遍历。</li>
<li>同时遍历两个链表，把比较小的结点用尾插法插入到新的链表中，再更新指针。</li>
<li> <code>while</code>结束标志为：其中一个链表遍历结束</li>
<li>如果一个链表遍历结束，另一个未结束，则把未结束的剩余部分链接上<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    ListNode* head=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* cur=head;<br>    <span class="hljs-comment">//尾插法</span><br>    <span class="hljs-keyword">while</span>(l1 &amp;&amp; l2)&#123;<br>        <span class="hljs-keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;<br>            cur-&gt;next=l1;<br>            l1=l1-&gt;next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cur-&gt;next=l2;<br>            l2=l2-&gt;next;<br>        &#125;<br>        cur=cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!l1) cur-&gt;next=l2;<br>    <span class="hljs-keyword">if</span>(!l2) cur-&gt;next=l1;<br>    <span class="hljs-keyword">return</span> head-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">Leetcode</a>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3></li>
<li>使用头节点，用于链表第一结点与其他结点增删改的统一。</li>
<li>定义三个指针，cur用于遍历原链表，p1,p2用于交换（p2指向p1的后继结点）</li>
<li>链接的顺序：1-&gt;3  2-&gt;1 cur-&gt;2</li>
<li>注意：cur指针每次向前跳两步。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next=head;<br>    ListNode* cur=dummy;<br>    ListNode* p1=dummy;<br>    ListNode* p2=dummy;<br>    <span class="hljs-keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123;<br>        p1=cur-&gt;next;<br>        p2=cur-&gt;next-&gt;next;<br>        p1-&gt;next=p2-&gt;next;<br>        p2-&gt;next=p1;<br>        cur-&gt;next=p2;<br>        cur=cur-&gt;next-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素  "></a>删除排序链表中的重复元素  </h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">Leetcode</a>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li> 链表中删除一个结点相当于指针越过该结点（next指针指向要删除结点的后继）</li>
<li> 直到cur与下一个结点值不同时，更新指针<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">   <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>       ListNode* cur=head;<br>       <span class="hljs-keyword">while</span>(cur &amp;&amp; cur-&gt;next)&#123;<br>           <span class="hljs-keyword">if</span>(cur-&gt;val == cur-&gt;next-&gt;val) <br>cur-&gt;next=cur-&gt;next-&gt;next;<br>           <span class="hljs-keyword">else</span> <br>cur=cur-&gt;next; <br>       &#125;<br>       <span class="hljs-keyword">return</span> head;<br>   &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">leetcode</a>给定一个链表，判断链表中是否有环。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>当快指针检查到无下一节点时，说明该链表无环，当链表中不存在环时，快指针终将优先到达链表尾部。</li>
<li>当快指针与慢指针相遇（指向同一个节点）时，说明该链表有环。快指针追上慢指针了。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    ListNode* slow = head;<br>    ListNode* fast = head;<br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">leetcode</a>编写一个程序，找到两个单链表相交的起始节点。  </p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>分别遍历一条链表，当遍历到结尾时让指针指向另一条链表的头部继续遍历另一条，当两个指针相等时即相交的位置</li>
<li>原理：加入两条链表相交，链表1为<code>A+C</code>,链表2为<code>B+C</code>， C为两条链表相交以后的公共部分，此时指针p1遍历的长度为<code>A+C+B</code>,指针p2遍历长度为<code>B+C+A</code>,两指针刚好落在相交部分的开头，因为如果继续遍历的话，两个指针都将同时遍历C部分。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">NULL</span> &amp;&amp; headB == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">NULL</span> || headB == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    ListNode* p1 = headA;<br>    ListNode* p2 = headB;<br>    <span class="hljs-keyword">while</span>(p1 != p2) &#123;<br>        p1 = p1 == <span class="hljs-literal">NULL</span> ? headB : p1-&gt;next;<br>        p2 = p2 == <span class="hljs-literal">NULL</span> ? headA : p2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表  "></a>反转链表  </h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">Leetcode</a> 反转一个单链表。</p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>链表的头插法实现反转，需要两个指针，当前指针<code>cur</code>,新链表头部指针<code>pre</code></li>
<li>因为需要改变当前结点next指针指向pre，所以必须先记录下next指针最后再恢复，才能让cur继续在链中遍历下去。 <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* pre = <span class="hljs-literal">NULL</span>;<br>    ListNode* cur = head;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">leetcode</a>请判断一个链表是否为回文链表。  <h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3></li>
<li>用快慢指针法先找到中间结点，用头插法反转后一半链表，用双指针比较两个链表。</li>
<li>快慢指针注意while的结束条件：<ul>
<li>如果<code>while(fast &amp;&amp; fast-&gt;next)</code>则奇数链表慢指针指向中间结点，偶数链表慢指针指向后一半链表头部。</li>
<li>如果<code>while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next</code>则不论奇数偶数链表，慢指针都指向后一半链表的前一个结点。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    ListNode * slow = head;<br>    ListNode * fast = head;<br>    <span class="hljs-keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br>    ListNode* cur = slow-&gt;next;<br>    ListNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = tmp;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (pre &amp;&amp; head) &#123;<br>        <span class="hljs-keyword">if</span>(pre-&gt;val != head-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = pre-&gt;next;<br>        head =head-&gt;next;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h1><p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">leetcode</a>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。  </p>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>需要两个指针，一个指向奇数结点，一个指向偶数结点，分别往后跳跃遍历</li>
<li>注意while循环的结束条件，因为两个指针都是跳跃一步的往后遍历，所以只有指针的下一步不是NULL时才能跳跃。</li>
<li>注意提前保存偶数链表的头部，用于之后的拼接。  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>     ListNode* odd = head;<br>     ListNode* even = head-&gt;next;<br>     ListNode* preEven = even;<br>     <span class="hljs-keyword">while</span> (odd-&gt;next &amp;&amp; even-&gt;next) &#123;<br>         odd-&gt;next = odd-&gt;next-&gt;next;<br>         odd = odd-&gt;next;<br>         even-&gt;next = even-&gt;next-&gt;next;<br>         even = even-&gt;next;<br>     &#125;<br>     odd-&gt;next = preEven;<br>     <span class="hljs-keyword">return</span> head;<br> &#125; <br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="两数相加II"><a href="#两数相加II" class="headerlink" title="两数相加II"></a>两数相加II</h1><p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">leetcode</a>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。<br>你可以假设除了数字 0 之外，这两个数字都不会以零开头。如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>题意，不能反转链表，那么对于这种逆序操作第一要想到用栈。</li>
<li>本体使用了三种技巧：1、使用栈逆序储存，2、两数相加（涉及到进位carry的操作），3、头插法建立链表.</li>
<li>注意：当某一个位没有数时（即栈为空时）用0代替，进行相加。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; sck1, sck2;<br>    <span class="hljs-keyword">while</span> (l1) &#123;<br>        sck1.<span class="hljs-built_in">push</span>(l1-&gt;val);<br>        l1 = l1-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l2) &#123;<br>        sck2.<span class="hljs-built_in">push</span>(l2-&gt;val);<br>        l2 = l2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, carry = <span class="hljs-number">0</span>;<br>    ListNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (!sck1.<span class="hljs-built_in">empty</span>() || !sck2.<span class="hljs-built_in">empty</span>() || carry) &#123;<br>        <span class="hljs-keyword">if</span> (!sck1.<span class="hljs-built_in">empty</span>()) &#123;<br>            a = sck1.<span class="hljs-built_in">top</span>();<br>            sck1.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            a = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!sck2.<span class="hljs-built_in">empty</span>()) &#123;<br>            b = sck2.<span class="hljs-built_in">top</span>();<br>            sck2.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            b = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> sum = a + b + carry;<br>        carry = sum / <span class="hljs-number">10</span>;<br>        sum %= <span class="hljs-number">10</span>;<br>        ListNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum);<br>        newNode-&gt;next = pre;<br>        pre = newNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h1><p><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">leetcode</a>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。<br>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。<br>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。<br>返回一个符合上述规则的链表的列表。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: <br>root &#x3D; [1, 2, 3], k &#x3D; 5<br>输出: [[1],[2],[3],[],[]]<br><br>输入: <br>root &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k &#x3D; 3<br>输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>本体涉及的技巧有：计算链表长度，计算每段的长度，分割并储存链表(定位尾部，保存头部)</li>
<li>首先计算链表总长度，根据k值求出每段的平均长度，由题意任意两部分的长度差距不能超过 1，且较长的在前面，所以将余的部分平均分给前面的链表长度上面。</li>
<li>得到每一段的长度后，开始分割链表，链表的分割只需要遍历到尾结点，在尾节点后加NULL即可，而储存链表时只需要储存链表头结点即可。</li>
<li>注意：已知链表长度，通过<code>while(--len &gt; 0）</code>来定位链表尾部时，<code>while</code>里面要先自减。</li>
<li>注意：在尾结点后加NULL分割链表之前，防止下一步丢失，要事先保存下一步的结点，以便更新当前结点。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">splitListToParts</span><span class="hljs-params">(ListNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    ListNode* cur = root;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        len++;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">int</span> averageLen = len / k;<br>    <span class="hljs-keyword">int</span> surplusLen = len % k;<br>    <span class="hljs-keyword">int</span> curLen = <span class="hljs-number">0</span>;<br>    cur = root;<br>    vector&lt;ListNode*&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(cur);<br>        <span class="hljs-keyword">if</span> (surplusLen-- &gt; <span class="hljs-number">0</span>) &#123;<br>            curLen = averageLen + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            curLen = averageLen;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (--curLen &gt; <span class="hljs-number">0</span> )&#123;<br>            cur = cur-&gt;next;   <br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>            ListNode* tmp = cur-&gt;next;<br>            cur-&gt;next = <span class="hljs-literal">NULL</span>;<br>            cur = tmp;<br>        &#125;   <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="链表组件"><a href="#链表组件" class="headerlink" title="链表组件"></a>链表组件</h1><p><a href="https://leetcode-cn.com/problems/linked-list-components/">leetcode</a>给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。<br>同时给定列表 G，该列表是上述链表中整型值的一个子集。<br>返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: <br>head: 0-&gt;1-&gt;2-&gt;3<br>G &#x3D; [0, 1, 3]<br>输出: 2<br>解释: <br>链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。<br><br>输入: <br>head: 0-&gt;1-&gt;2-&gt;3-&gt;4<br>G &#x3D; [0, 3, 1, 4]<br>输出: 2<br>解释: <br>链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。<br><br></code></pre></td></tr></table></figure>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>首先为<code>G</code>列表的值建立一个bool类数组，（也可以使用哈希表，但是效率太低）用于遍历链表时检查结点是否属于G列表中的结点。</li>
<li>一遍遍历整个链表，当遇到第一个属于<code>G</code>列表中的结点时，组件数量就加1，并继续往后遍历找到组件的结尾，非<code>G</code>列表中的结点直接忽略即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> isIn[<span class="hljs-number">10000</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numComponents</span><span class="hljs-params">(ListNode* head, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; G)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : G) &#123;<br>        isIn[it] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    ListNode* cur = head;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (isIn[cur-&gt;val] == <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> &amp;&amp; isIn[cur-&gt;val] == <span class="hljs-literal">true</span>) <br>                cur = cur-&gt;next;<br>            cnt++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur-&gt;next;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>C++&amp;LeetCode</title>
    <url>/posts/da77844e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>🎨程序员面试金典🎨</title>
    <url>/posts/2eef4cb2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🎨程序员面试金典🎨"><a href="#🎨程序员面试金典🎨" class="headerlink" title="🎨程序员面试金典🎨"></a>🎨程序员面试金典🎨</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p>
<span id="more"></span>

<ul>
<li><a href="#%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80">1.判定字符是否唯一</a></li>
<li><a href="#%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92">2.判定是否互为字符重排</a></li>
<li><a href="#URL%E5%8C%96">3.URL化</a></li>
<li><a href="#%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97">4.回文排列</a></li>
<li><a href="#%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91">5.一次编辑</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9">6.字符串压缩</a></li>
<li><a href="#%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5">7.旋转矩阵</a></li>
<li><a href="#%E9%9B%B6%E7%9F%A9%E9%98%B5">8.零矩阵</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC">9.字符串轮转</a></li>
<li><a href="#%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9">10.移除重复节点</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">11.返回倒数第k个节点</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9">12.删除中间节点</a></li>
<li><a href="#%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8">13.分割链表</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C">14.链表求和</a></li>
<li><a href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">15.回文链表</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4">16.链表相交</a></li>
<li><a href="#%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B">17.环路检测</a></li>
<li><a href="#%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC">18.栈的最小值</a></li>
<li><a href="#%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F">19.化栈为队</a></li>
<li><a href="#%E6%A0%88%E6%8E%92%E5%BA%8F">20.栈排序</a></li>
</ul>
<h1 id="判定字符是否唯一"><a href="#判定字符是否唯一" class="headerlink" title="判定字符是否唯一"></a>判定字符是否唯一</h1><p><a href="https://leetcode-cn.com/problems/is-unique-lcci/">leetcode</a>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>首先想到哈希表统计各字母出现频率，只遍历一次，频率大于1就返回false。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isUnique</span><span class="hljs-params">(string astr)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; astr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cnt[astr[i]]++;<br>        <span class="hljs-keyword">if</span> (cnt[astr[i]] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>如果面试官不想用哈希表，或者不能用额外的数据结构解题，就用一个整形数组代替来记录26个字母出现次数。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isUnique</span><span class="hljs-params">(string astr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt[<span class="hljs-number">26</span>];<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">26</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; astr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cnt[astr[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">if</span> (cnt[astr[i] - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>但是对于这种统计只出现一次，或者两次的题，都能够给位运算符操作</li>
<li>本题的思路是，把每个字母转换成二进制，例如 <code>a-&gt; 0001 b -&gt; 0010 c-&gt; 0100 d-&gt;1000</code>一次类推剩下所有字母。</li>
<li>还需要维护一个掩码mask，将遍历过的所有字母的二进制数合并起来(|=运算)，<code>例如遍历了abcd,mask就等于1111</code>,再次碰到<code>a~d</code>,就能通过&amp;发现重复。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isUnique</span><span class="hljs-params">(string astr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : astr) &#123;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (mask &amp; num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> mask |= num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="判定是否互为字符重排"><a href="#判定是否互为字符重排" class="headerlink" title="判定是否互为字符重排"></a>判定是否互为字符重排</h1><p><a href="https://leetcode-cn.com/problems/check-permutation-lcci/">leetcode</a><br>给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><ul>
<li>不用哈希表的方式，记录26个字母出现的频率，同时遍历两个字符串，一个加次数，一个减次数。最后看是否所有字母的次数为0。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckPermutation</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> cnt[<span class="hljs-number">26</span>];<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">26</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s1.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cnt[s1[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        cnt[s2[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (cnt[i] != <span class="hljs-number">0</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="URL化"><a href="#URL化" class="headerlink" title="URL化"></a>URL化</h1><p><a href="https://leetcode-cn.com/problems/string-to-url-lcci/">leetcode</a><br>URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：&quot;Mr John Smith    &quot;, 13<br>输出：&quot;Mr%20John%20Smith&quot;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>理解题意很重要，在原数组的基础上进行修改，两种思路：从头开始或从尾部开始，既然原字符串在结尾已经给我预留了足够多的空位，那更方便从尾部开始插入。</li>
<li>维护两个指针，一个指向读入数据的位置（字符串真实长度的尾部），一个指向插入数据的位置（原字符串尾部）</li>
<li>读入数据进行判断，是空格，就在尾部连续插入3个字符’0’’2’’%’,否则正常插入读入的数据。</li>
<li>最后，将修改后的结果从字符串中提取出来，<code>substr()</code>从写入指针最后停止的位置开始提取到尾部。</li>
<li>substr()小技巧：如果没有指定长度或超出了源字符串的长度，则子字符串将延续到源字符串的结尾<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpaces</span><span class="hljs-params">(string S, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> writePos = S.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">int</span> readPos = length - <span class="hljs-number">1</span> - i;<br>        <span class="hljs-keyword">if</span> (S[readPos] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            S[writePos--] = S[readPos];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            S[writePos--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            S[writePos--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            S[writePos--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (writePos &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//S = S.substr(writePos + 1, S.size() - writePos - 1);</span><br>        S = S.<span class="hljs-built_in">substr</span>(writePos + <span class="hljs-number">1</span>); <br>    &#125;<br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="回文排列"><a href="#回文排列" class="headerlink" title="回文排列"></a>回文排列</h1><p><a href="https://leetcode-cn.com/problems/palindrome-permutation-lcci/">leetcode</a><br>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。<br>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。<br>回文串不一定是字典当中的单词。</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>就是判断一个字符串能否变为一个回文串</li>
<li>统计每个字符出现的次数，偶数次数一定能组成回文，而奇数次数的字符只能有一个。<br>遍历每个字符，如果有2个以上包括2个的字母出现的次数为奇数，则不能变为回文。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPermutePalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) &#123;<br>        cnt[ch]++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> m : cnt) &#123;<br>        <span class="hljs-keyword">if</span> (m.second % <span class="hljs-number">2</span>) res++;<br>        <span class="hljs-keyword">if</span> (res &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="一次编辑"><a href="#一次编辑" class="headerlink" title="一次编辑"></a>一次编辑</h1><p><a href="https://leetcode-cn.com/problems/one-away-lcci/">leetcode</a><br>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: <br>first &#x3D; &quot;pale&quot;<br>second &#x3D; &quot;ple&quot;<br>输出: True<br><br></code></pre></td></tr></table></figure>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>能够通过增删换一次操作使两个字符相同的前提一定是，两个字符个数绝对差不超过1.</li>
<li>使用两个指针同时遍历两个字符，字幕相同就继续同时往后遍历</li>
<li>如果发现字母不同，cnt++记录需要操作的次数。</li>
<li>删除操作实质上就是指针跳过这个字符。至于是哪个指针进行跳过，就要就比较哪个字符串比较长，就删除哪个字符串的字符。</li>
<li>如果两个字符串长度相等，就只能进行替换操作，替换完，两个指针是要同时前进的<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">oneEditAway</span><span class="hljs-params">(string first, string second)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len1 = first.<span class="hljs-built_in">size</span>(), len2 = second.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(len1 - len2) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p1 &lt;= len2 &amp;&amp; p2 &lt;= len2) &#123;<br>        <span class="hljs-keyword">if</span> (first[p1] == second[p2]) &#123;<br>            p1++,p2++;<span class="hljs-keyword">continue</span>;<br>        &#125;<br>        len1 == len2 ? p1++,p2++ : len1 &gt; len2 ? p1++ : p2++;<br>        cnt++;<br>        <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="字符串压缩"><a href="#字符串压缩" class="headerlink" title="字符串压缩"></a>字符串压缩</h1><p><a href="https://leetcode-cn.com/problems/compress-string-lcci/">leetcode</a><br>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：&quot;aabcccccaaa&quot;<br>输出：&quot;a2b1c5a3&quot;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>遍历字符串，先取第一个字符作为当前值，从下标1开始遍历，统计与当前字符相等的个数。</li>
<li>当遍历不相等的字符时，更新当前值和个数</li>
<li>注意：因为每次遍历到不同的字符时，指针都会指向下一个字符，因此当遍历到最后一个字符时，需要跟字符串结尾的<code>\0</code>进行比较，所以遍历边界就不能再是<code>i &lt; s.size()</code>应改为<code>i &lt; size() + 1</code>。让i可以指向<code>\0</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">compressString</span><span class="hljs-params">(string S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> S;<br>    <span class="hljs-keyword">char</span> cur = S[<span class="hljs-number">0</span>];<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; S.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;<br>        res += cur;<br>        <span class="hljs-keyword">while</span> (i &lt; S.<span class="hljs-built_in">size</span>() &amp;&amp; S[i] == cur) cnt++, i++;<br>        cur = S[i];<br>        res += <span class="hljs-built_in">to_string</span>(cnt);<br>    &#125;<br>    <span class="hljs-keyword">return</span> S.<span class="hljs-built_in">size</span>() &gt; res.<span class="hljs-built_in">size</span>() ? res : S;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h1><p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/">leetcode</a><br>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。<br>不占用额外内存空间能否做到？</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">给定 matrix &#x3D; <br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],<br><br>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br></code></pre></td></tr></table></figure>
<ul>
<li>最简单的方式就是使用辅助矩阵，只要找到翻转后位置的对应关系即可，第row行变为第col行，第col列变为第n-1-row列（倒数的row列）</li>
<li><code>matrix[j][n-1-i] = matrix[i][j]</code><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">auto</span> newMat = matrix;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            newMat[j][n - <span class="hljs-number">1</span> - i] = matrix[i][j];<br>        &#125;<br>    &#125;<br>    matrix = newMat;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>如果面试要求原地进行翻转，首先要知道<code>matrix[j][n-1-i] = matrix[i][j]</code>会覆盖掉第2个点，</li>
<li>第一：因此我们需要先旋转第2个点，但第2点又会覆盖第3个点，所以先旋转第3点，第3点会覆盖第4点，第4个点刚好就是第1个点，形成一个循环，这样我们先记录第1个点，将后面得点依次覆盖，即可完成4个点得同时旋转。</li>
<li>第二：因为一次旋转4个点，所以我们需要知道遍历哪些点才能不重复。偶数边矩阵：最左上角的小矩阵，奇数矩阵：因为多了中间一列，所以选择最左上角的小矩阵 + 中间列。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; ++j) &#123;<br>            <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>            matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>            matrix[n - j - <span class="hljs-number">1</span>][i] = matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>];<br>            matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>] = matrix[j][n - i - <span class="hljs-number">1</span>];<br>            matrix[j][n - i - <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>用对折翻转代替旋转，这种算法除非做过原题，一般是想不到</li>
<li>先水平翻转，再对角线翻转</li>
<li>注意：翻转需要两个元素：1、翻转前后点得对应关系。2、枚举需要遍历的点。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 水平翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[n - <span class="hljs-number">1</span> - i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 对角线翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h1><p><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/">leetcode</a><br>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>暴力法；先全部遍历，找到并记录全部0的行列坐标。</li>
<li>第二次只遍历这些0的位置，模拟操作：往上下左右四个方向进行置0操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; indexs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                indexs.<span class="hljs-built_in">push_back</span>(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(i, j));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (indexs.<span class="hljs-built_in">size</span>() == row * col) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : indexs) &#123;<br>        <span class="hljs-keyword">int</span> i = it.first;<br>        <span class="hljs-keyword">int</span> j = it.second;<br>        <span class="hljs-keyword">int</span> i1 = i;<br>        <span class="hljs-keyword">while</span> (++i1 &lt; row) &#123;<br>            matrix[i1][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i2 = i;<br>        <span class="hljs-keyword">while</span> (--i2 &gt;= <span class="hljs-number">0</span>) &#123;<br>            matrix[i2][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> j1 = j;<br>        <span class="hljs-keyword">while</span> (++j1 &lt; col) &#123;<br>            matrix[i][j1] = <span class="hljs-number">0</span>;<br>        &#125; <br>        <span class="hljs-keyword">int</span> j2 = j;<br>        <span class="hljs-keyword">while</span> (--j2 &gt;= <span class="hljs-number">0</span>) &#123;<br>            matrix[i][j2] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>同样是先记录所以出现0的行和列，然后第二次遍历时，判断当前行或者列是否是需要置0的</li>
<li>需要两个bool数组，记录每个行或列是否是需要置0的行<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">bool</span> isZeroRow[n], isZeroCol[m];<br>    <span class="hljs-built_in">memset</span>(isZeroRow, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">bool</span>) * n);<br>    <span class="hljs-built_in">memset</span>(isZeroCol, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">bool</span>) * m);<br>    <span class="hljs-comment">// 统计哪些行，列需要全置位0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                isZeroRow[i] = <span class="hljs-literal">true</span>;<br>                isZeroCol[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (isZeroRow[i] || isZeroCol[j]) <br>                matrix[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="字符串轮转"><a href="#字符串轮转" class="headerlink" title="字符串轮转"></a>字符串轮转</h1><p><a href="https://leetcode-cn.com/problems/string-rotation-lcci/">leetcode</a><br>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。</p>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>两个思路，一种暴力的方式，旋转s2，判断s1 和s2是否相等，不相等继续旋转s2</li>
<li>使用C库<code>int strcmp(const char* s1, const char* s2)</code>字符串需要转换为<code>char*</code>类型，且strcmp是采用逐位相减来判断的，返回0表示相等，大于0表示大于<code>s1 &gt; s2</code>，<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isFlipedString</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">int</span> n = s1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">char</span> temp = s2[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            s2[j] = s2[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        s2[<span class="hljs-number">0</span>] = temp;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(s1.<span class="hljs-built_in">c_str</span>(), s2.<span class="hljs-built_in">c_str</span>()) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li>思路二：既然是循环字符串，就一定要想到拼接思想，通过s1 + s1 拼接后找是否存在s2子串的方式</li>
<li>找子串有两种方式：1、分割出子串<code>string substr(int index, int count)</code>需要参数位置和个数,返回分割的子串，进行比较<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isFlipedString</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">int</span> n = s1.<span class="hljs-built_in">size</span>();<br>    s2 = s2 + s2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s1[<span class="hljs-number">0</span>] == s2[i] &amp;&amp; s1 == s2.<span class="hljs-built_in">substr</span>(i, n)) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>2、或使用stl库得find函数找子串，找到返回首个字符的下标，否则返回<code>npos</code><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isFlipedString</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>    <span class="hljs-comment">// slt</span><br>    <span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">size</span>() != s2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> (s1 + s1).<span class="hljs-built_in">find</span>(s2) != string::npos;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="移除重复节点"><a href="#移除重复节点" class="headerlink" title="移除重复节点"></a>移除重复节点</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/">leetcode</a><br>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：[1, 2, 3, 3, 2, 1]<br>输出：[1, 2, 3]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>本题是对未排序的链表进行删重，所以需要先遍历一遍记录不重复的有哪些值。</li>
<li>第二次遍历针对非记录中的进行删除</li>
<li>链表的删除需要前驱，所以head结点我们也需要新建一个前驱，删除结点的操作最好都是枚举遍历前驱，当前结点通过前驱获得。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">removeDuplicateNodes</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode* pre = dummy;<br>    unordered_set&lt;<span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">while</span> (pre-&gt;next) &#123;<br>        ListNode* cur = pre-&gt;next;	<span class="hljs-comment">// 获取待删除结点</span><br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(cur-&gt;val) == hash.<span class="hljs-built_in">end</span>()) &#123;    <span class="hljs-comment">// 没有找到</span><br>            hash.<span class="hljs-built_in">insert</span>(cur-&gt;val);<br>            pre = pre-&gt;next;		<span class="hljs-comment">// 只有遇到新元素才更新</span><br>        &#125; <span class="hljs-keyword">else</span>	<br>            pre-&gt;next = pre-&gt;next-&gt;next; <br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="返回倒数第-k-个节点"><a href="#返回倒数第-k-个节点" class="headerlink" title="返回倒数第 k 个节点"></a>返回倒数第 k 个节点</h1><p><a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/">leetcode</a><br>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。<br>注意：本题相对原题稍作改动</p>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k &#x3D; 2<br>输出： 4<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>两个思路，第一快慢指针法，第二翻转链表，但是时间复杂度相对较高<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthToLast</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    ListNode* slow = head;<br>    ListNode* fast = head;<br>    <span class="hljs-keyword">while</span> (k--)<br>        fast = fast-&gt;next;<br>    <span class="hljs-keyword">while</span> (fast) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow-&gt;val;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>翻转链表法<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthToLast</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    ListNode* cur = head;<br>    ListNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = temp;<br>    &#125;<br>    k--;    <span class="hljs-comment">// 第k个元素，跳k-1次就可以</span><br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        pre = pre-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre-&gt;val;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="删除中间节点"><a href="#删除中间节点" class="headerlink" title="删除中间节点"></a>删除中间节点</h1><p><a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/">leetcode</a><br>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p>
<h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c<br>结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>此题题意难以理解，意思是一般我们删除链表的某一个结点都通过遍历到待删除结点的前驱，通过更改前驱指针进行删除<br>本题的目的是，只给你当前待删除的结点指针，完成原地删除操作。</li>
<li>思路是，将当前结点替换为它的后继结点，即更新它的值和next指针<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>    node-&gt;val = node-&gt;next-&gt;val;<br>    node-&gt;next = node-&gt;next-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>结点的本质是结构体，通过将后继的内存内容直接覆盖掉当前待删除结点内存空间完成替换。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>    *node = *(node-&gt;next);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="分割链表"><a href="#分割链表" class="headerlink" title="分割链表"></a>分割链表</h1><p><a href="https://leetcode-cn.com/problems/partition-list-lcci/">leetcode</a><br>编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。</p>
<h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: head &#x3D; 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1, x &#x3D; 5<br>输出: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>读懂题意就很难，大致目的是根据x值将一个链表分成两条链表，其中一个是大于等于<code>x</code>的值组成的，另一条是小于<code>x</code>的值，分割完后再进行前后拼接。</li>
<li>用到的技巧就是分割和组装链表</li>
<li>新建链表需要得是头结点和用于遍历的指针，插入时用尾插法</li>
<li>组装链表将其中一条链表尾部<code>next</code>指针指向另一条链表的第一个元素，最后在尾部添加<code>NULL</code>完成组装。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    ListNode* small = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* big = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* cur = head;<br>    ListNode* smallCur = small;<br>    ListNode* bigCur = big;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;val &lt; x) &#123;<br>            smallCur-&gt;next = cur;<br>            smallCur = smallCur-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            bigCur-&gt;next = cur;<br>            bigCur = bigCur-&gt;next;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    smallCur-&gt;next = big-&gt;next;<br>    bigCur-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> small-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h1><p><a href="https://leetcode-cn.com/problems/sum-lists-lcci/">leetcode</a><br>给定两个用链表表示的整数，每个节点包含一个数位。<br>这些数位是反向存放的，也就是个位排在链表首部。<br>编写函数对这两个整数求和，并用链表形式返回结果。</p>
<h3 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295<br>输出：2 -&gt; 1 -&gt; 9，即912<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>两个指针分别遍历两个链表，将其中的数相加，大于10的部分作为进位参与下一轮的求和，个位数即为新结点的值</li>
<li>关键在于边界条件，当其中一条链表遍历结束后，指向了null，因此将它的值全部赋予0，继续参与之后每轮的求和。</li>
<li>当两链表全部遍历结束后，再次判断还有没有剩余的进位，如果有就最后新建一个结点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    ListNode* p1 = l1;<br>    ListNode* p2 = l2;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<br><br>    ListNode* preHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* cur = preHead;<br>    <span class="hljs-keyword">while</span> (p1 || p2) &#123;<br>        <span class="hljs-keyword">int</span> val1 = p1 == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : p1-&gt;val;<br>        <span class="hljs-keyword">int</span> val2 = p2 == <span class="hljs-literal">NULL</span> ? <span class="hljs-number">0</span> : p2-&gt;val;<br>        sum = val1 + val2 + c;<br>        c = sum / <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span> val = sum % <span class="hljs-number">10</span>;<br>        ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>        cur-&gt;next = node;<br>        cur = cur-&gt;next;<br>        <span class="hljs-keyword">if</span>(p1) p1 = p1-&gt;next;<br>        <span class="hljs-keyword">if</span>(p2) p2 = p2-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>        ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(c);<br>        cur-&gt;next = node;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> preHead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/">leetcode</a><br>编写一个函数，检查输入的链表是否是回文的。</p>
<h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>翻转一半的链表进行逐点比较。</li>
<li>先用快慢指针寻找中间点，为了方便奇数偶数链表的统一，我们新建头结点开始遍历。这样当快指针结束时，慢指针正好指向后一半链表的前驱上，无论是否是奇数偶数链表。</li>
<li>翻转链表用了头插法<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode* slow = dummy;<br>    ListNode* fast = dummy;<br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br>    <br>    ListNode* pre = <span class="hljs-literal">NULL</span>;<br>    ListNode* cur = slow-&gt;next;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = tmp;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (head &amp;&amp; pre) &#123;<br>        <span class="hljs-keyword">if</span> (head-&gt;val != pre-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        head = head-&gt;next;<br>        pre = pre-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">leetcode</a><br>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。</p>
<h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>判断两个链表是否相交，经典做法拼接两个链表，即当第一个链表遍历结束后继续从第二条头部遍历，第二条链表同样如此</li>
<li>这样两个链表相等的长度，当两个指针指向同一块地址时，不是null就是相交点。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    ListNode* p1 = headA;<br>    ListNode* p2 = headB;<br>    <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>        p1 = p1 == <span class="hljs-literal">NULL</span> ? headB : p1-&gt;next;<br>        p2 = p2 == <span class="hljs-literal">NULL</span> ? headA : p2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1; <br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="环路检测"><a href="#环路检测" class="headerlink" title="环路检测"></a>环路检测</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/">leetcode</a><br>给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。</p>
<h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>题目要我们除了要判断是否是环路，还要返回环路的头部结点</li>
<li>判断是否环路使用快慢指针，当快指针追上慢指针时即为环路</li>
<li>寻找头部就需要数学推导，结论就是当快指针追上慢指针后，让快指针从头开始走，步数和慢指针相同，两指针会在环头部相遇。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    ListNode* slow = head;<br>    ListNode* fast = head;<br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span> (fast == slow) &#123; <span class="hljs-comment">// 有环</span><br>            fast = head;<br>            <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>                fast = fast-&gt;next;<br>                slow = slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> fast;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="栈的最小值"><a href="#栈的最小值" class="headerlink" title="栈的最小值"></a>栈的最小值</h1><p><a href="https://leetcode-cn.com/problems/min-stack-lcci/">leetcode</a><br>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p>
<h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>维护两个栈，数据栈和扎顶储存当前数据栈中的最小值的最小栈</li>
<li>入栈时判断入栈元素是否比当前数据中的最小值还小，还小就如栈。</li>
<li>出栈时需要判断出栈元素是否刚好就是当前数据中的最小值，是就同步出栈。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; data;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; minSck;<br>    <span class="hljs-built_in">MinStack</span>() &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        data.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">if</span> (minSck.<span class="hljs-built_in">empty</span>()) &#123;<br>            minSck.<span class="hljs-built_in">push</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (minSck.<span class="hljs-built_in">top</span>() &gt;= x)<br>                minSck.<span class="hljs-built_in">push</span>(x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">top</span>() == minSck.<span class="hljs-built_in">top</span>()) &#123;<br>            data.<span class="hljs-built_in">pop</span>();<br>            minSck.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            data.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minSck.<span class="hljs-built_in">top</span>();<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="化栈为队"><a href="#化栈为队" class="headerlink" title="化栈为队"></a>化栈为队</h1><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/">leetcode</a><br>实现一个MyQueue类，该类用两个栈来实现一个队列。</p>
<h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>队列是先进先出，栈先进后出，所以通过两个栈反转实现先进先出</li>
<li>出栈的时候先反转栈内的数据，将数据栈全部如辅助栈中，pop的数据就是辅助栈的栈顶元素。</li>
<li>只有当辅助栈弹空时，再继续反转数据栈内的数据进入辅助栈补充<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (helpSck.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (!dataSck.<span class="hljs-built_in">empty</span>()) &#123;<br>            helpSck.<span class="hljs-built_in">push</span>(dataSck.<span class="hljs-built_in">top</span>());<br>            dataSck.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = helpSck.<span class="hljs-built_in">top</span>();<br>    helpSck.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (helpSck.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (!dataSck.<span class="hljs-built_in">empty</span>()) &#123;<br>            helpSck.<span class="hljs-built_in">push</span>(dataSck.<span class="hljs-built_in">top</span>());<br>            dataSck.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> helpSck.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="栈排序"><a href="#栈排序" class="headerlink" title="栈排序"></a>栈排序</h1><p><a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci/">leetcode</a><br>栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。</p>
<h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>本题相当于对栈内的元素进行排序，维护栈顶到栈底从小到大排序</li>
<li>因此栈顶遇到比它大的数时，先弹出比他小的元素到辅助栈中，直到到他的合适位置后，再将辅助栈内的元素倒入原栈中。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(!s1.<span class="hljs-built_in">empty</span>() &amp;&amp; s1.<span class="hljs-built_in">top</span>() &lt; val)&#123;<br>        s2.<span class="hljs-built_in">push</span>(s1.<span class="hljs-built_in">top</span>());<br>        s1.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    s1.<span class="hljs-built_in">push</span>(val);<br>    <span class="hljs-keyword">while</span>(!s2.<span class="hljs-built_in">empty</span>())&#123;<br>        s1.<span class="hljs-built_in">push</span>(s2.<span class="hljs-built_in">top</span>());<br>        s2.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!s1.<span class="hljs-built_in">empty</span>())<br>        s1.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!s1.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">top</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>面试</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面试</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>树🌲</title>
    <url>/posts/ca16bf90.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="seedling-树"><a href="#seedling-树" class="headerlink" title=":seedling:树"></a>:seedling:树</h1><span id="more"></span>

<ul>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">94.二叉树的中序遍历</a>  </li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">144.二叉树的前序遍历</a>  </li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">145.二叉树的后序遍历</a>  </li>
<li><a href="%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">98.验证二叉搜索树</a></li>
<li><a href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">101.对称二叉树</a>  </li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">102.二叉树的层序遍历</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86II">107.二叉树的层次遍历II</a></li>
<li><a href="#103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86">103.二叉树的锯齿形层次遍历</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">104.二叉树的最大深度</a>  </li>
<li><a href="#110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">110.平衡二叉树</a>  </li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6">111.二叉树的最小深度</a>  </li>
<li><a href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C">112.路径总和</a>  </li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C">124.二叉树中的最大路径和</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0">230.二叉搜索树中第K小的元素</a>  </li>
<li><a href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">226.翻转二叉树</a>  </li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">236.二叉树的最近公共祖先</a></li>
<li><a href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC">513.找树左下角的值</a>     </li>
<li><a href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91">617.合并二叉树</a>  </li>
<li><a href="#%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84">687.最长同值路径</a>  </li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9">671.二叉树中第二小的节点</a>  </li>
<li><a href="#%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">669.修剪二叉搜索树</a>  </li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C">701.二叉搜索树中的插入操作</a></li>
</ul>
<!--more-->

<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">Leetcode</a>给定一个二叉树，返回它的迭代中序遍历。  </p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>使用辅助栈，中序遍历是访问顺序左-中-右</li>
<li>所以每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;res;<br>    stack&lt;TreeNode*&gt;sck;<br>    TreeNode*cur=root;<br>    <span class="hljs-keyword">while</span>(cur || !sck.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            sck.<span class="hljs-built_in">push</span>(cur);<br>            cur=cur-&gt;left;<br>        &#125;<br>        cur=sck.<span class="hljs-built_in">top</span>();<br>        res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        sck.<span class="hljs-built_in">pop</span>();<br>        cur=cur-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">Leetcode</a>  </p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>非递归实现需要辅助栈</li>
<li>因为栈是先进后出，而前序遍历顺序是：<code>root =&gt; left =&gt; right</code>  所以right先入栈left后入栈</li>
<li>由于一开始的left和right的地址需要通过root结点获得，所以开始需要先将root入栈<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; sck;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    TreeNode*cur = <span class="hljs-literal">NULL</span>;<br>    sck.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!sck.<span class="hljs-built_in">empty</span>())&#123;<br>        cur = sck.<span class="hljs-built_in">top</span>();<br>        res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        sck.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cur-&gt;right) sck.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        <span class="hljs-keyword">if</span>(cur-&gt;left) sck.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">Leetcode</a>  </p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>后序遍历顺序<code>left =&gt; right =&gt; root</code> ,变换的前序遍历顺序<code>root =&gt; right =&gt; left</code>，结果反转则为后序</li>
<li>前序遍历 + 反转结果即可<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    stack&lt;TreeNode*&gt; sck;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    sck.<span class="hljs-built_in">push</span>(root);<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(!sck.<span class="hljs-built_in">empty</span>())&#123;<br>        cur = sck.<span class="hljs-built_in">top</span>();<br>        res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        sck.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(cur-&gt;left) sck.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(cur-&gt;right) sck.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(res);<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; arr)</span></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; --i)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">leetcode</a>给定一个二叉树，判断其是否是一个有效的二叉搜索树。<br>假设一个二叉搜索树具有如下特征：<br>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>二叉搜索树的典型特点：中序遍历就是一个升序的序列，所以验证的方法就显而易见</li>
<li>中序遍历存入数组，验证数组是否是严格单调递增的</li>
<li>看大佬得题解还有更简洁的方法 : 因为是中序遍历，所以只要维护一个记录上一个结点值得变量，每遍历一个点进行一次比较和更新，如果发现小于上个结点值就返回<code>false</code>，注意比较和更新得顺序不能反。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">inorder</span>(root);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; res.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (res[i - <span class="hljs-number">1</span>] &gt;= res[i]) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>    res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure>
更简洁得方式：<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">long</span> pre = Long.MIN_VALUE;<br><span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == null)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidBST</span>(root.left)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    <span class="hljs-keyword">if</span> (root.val &lt;= pre)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    pre = root.val;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isValidBST</span>(root.right);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">Leetcode</a>给定一个二叉树，检查它是否是镜像对称的。</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>双指针再树中应用。</li>
<li>两个指针分别递归遍历两颗树。</li>
<li>两棵树要想对称，首先他们的子树必须对称，其次他们的根结点必须相等，可以使用后序遍历<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(root-&gt;left, root-&gt;right);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span>&#123;<br>   <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> || right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(left-&gt;left, right-&gt;right) &amp;&amp; <br>          	<span class="hljs-built_in">isSymmetric</span>(left-&gt;right, right-&gt;left) &amp;&amp;<br>          	left-&gt;val == right-&gt;val;  <br> &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">leetcode</a>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">3<br>   &#x2F; \<br>  9  20<br>    &#x2F;  \<br>   15   7<br>返回其层次遍历结果：<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>典型的BFS遍历二叉树，使用了队列，</li>
<li>牢记模板，注意：输出的数组是二维数组，并不是简单的遍历，中间需要<code>size</code>变量来记录每一行的个数。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res; <br>    queue&lt;TreeNode*&gt; que;<br>    <span class="hljs-keyword">if</span> (root) que.<span class="hljs-built_in">push</span>(root);<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; level;<br>        <span class="hljs-keyword">while</span> (size--) &#123;               <br>            cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            level.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right) que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125; <br>        <span class="hljs-keyword">if</span> (!level.<span class="hljs-built_in">empty</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;  <br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的层次遍历II"><a href="#二叉树的层次遍历II" class="headerlink" title="二叉树的层次遍历II"></a>二叉树的层次遍历II</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">leetcode</a>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>基本过程与上题的层序遍历一样，</li>
<li>区别在对结果的处理，两种方式：<code>reverse()</code>反转结果，或者插入的时候用头插法，但是因为使用的是vector所以头插法效率极低。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br>    queue&lt;TreeNode*&gt; que;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; level;<br>        <span class="hljs-keyword">while</span> (size--) &#123;<br>            cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            level.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur-&gt;left !=<span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right !=<span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(level);<br>        <span class="hljs-comment">//res.insert(res.begin(),level); // 头插法</span><br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的锯齿形层次遍历"><a href="#二叉树的锯齿形层次遍历" class="headerlink" title="二叉树的锯齿形层次遍历"></a>二叉树的锯齿形层次遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">leetcode</a>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>主题部分与上两题的层序遍历一致，只是多了一个层数的变量，当层数为偶数从左到右插入，层数为奇数头插法实现从右到左。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>    queue&lt;TreeNode*&gt; que;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">int</span> levelNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; level;<br>        <span class="hljs-keyword">while</span> (size--) &#123;<br>            cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (levelNum % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                level.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                level.<span class="hljs-built_in">insert</span>(level.<span class="hljs-built_in">begin</span>(), cur-&gt;val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right) que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        levelNum++;<br>        res.<span class="hljs-built_in">push_back</span>(level);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">Leetcode</a>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>每个结点得最大深度都需要先知道其两个子结点的最大深度，所以使用后序遍历，先遍历左右子树。</li>
<li>函数意义：返回该结点的最大深度。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">maxDepth</span>(root-&gt;left);<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">maxDepth</span>(root-&gt;right);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">Leetcode</a>给定一个二叉树，判断它是否是高度平衡的二叉树。<br>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>先判断左右两个子节点是否平衡，再处理当前结点，所以采用后序遍历</li>
<li>使用哈希表来记录每个结点的最高高度，而每个结点的最高高度也是受其左右子结点的影响，所以可以借着第一条的后序遍历来添加每个结点的高度 <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">unordered_map&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; height;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        height[root] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isBalanced</span>(root-&gt;left) || !<span class="hljs-built_in">isBalanced</span>(root-&gt;right)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    height[root] = <span class="hljs-built_in">max</span>(height[root-&gt;left], height[root-&gt;right]) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(height[root-&gt;left] - height[root-&gt;right]) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">leetcode</a>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>与二叉树最大深度类似，要求每个结点的深度都需要先计算其左右子节点的深度，所以采用后序遍历</li>
<li>注意：有些结点只有一个子结点，再比较左右子结点的最小值时，返回值可能会返回最小值0，所以应该避免这种情况，返回非空的那条子结点深度  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">minDepth</span>(root-&gt;left);<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">minDepth</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(left, right) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h1><p><a href="https://leetcode-cn.com/problems/path-sum/">leetcode</a>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>从root结点开始遍历，每经过一个结点，sum 值就减去当前节点的权值，直到sum值为0时表示发现路径，由题意路径结尾必须是叶子，所以还需要判断最后是否是叶子结点  </li>
<li>因为每个子结点需要处理的sum值都与母结点有关，所以采用自上而下的先序遍历，先处理母结点，再处理子结点  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    sum-=root-&gt;val;<br>    <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span> &amp;&amp; root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">leetcode</a>给定一个非空二叉树，返回其最大路径和。<br>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>这种可以不经过root结点的路径和，首先想到一条路径一定由三部分构成，<code>左子树路径+中间结点+右子树路径</code></li>
<li>当前结点的最大路径和与他的左右子树相关，所以先访问子树，是后序遍历。</li>
<li> 注意：一个结点返回的不应该是此结点的最大路径和，而应该是单边最大路径给上游</li>
<li>注意：因为路径和可能会有负数出现，可以采用<code>max(0,)</code>的方式去掉负值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = INT_MIN;<br>    <span class="hljs-built_in">maxPathSum</span>(root, sum);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>&amp; sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">maxPathSum</span>(root-&gt;left, sum));<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">maxPathSum</span>(root-&gt;right, sum));<br>    sum = <span class="hljs-built_in">max</span>(sum, left + right + root-&gt;val);<br>    <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(left, right);<br>&#125; <br></code></pre></td></tr></table></figure>


<h1 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h1><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">Leetcode</a>   </p>
<ul>
<li>对于二叉搜索树中序遍历=从小到大排序</li>
<li>需要记录遍历个数的变量  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>,val=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">inorder</span>(root,k);<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode*root,<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;left,k);<br>    <span class="hljs-keyword">if</span>(++cnt==k)val=root-&gt;val;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;right,k);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">Leetcode</a>    </p>
<ul>
<li>反转二叉树并返回根节点，交换当前根结点的左右子树<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode*tmp=<span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>    root-&gt;left=<span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>    root-&gt;right=tmp;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">leetcode</a>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<blockquote>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>首先什么样的结点才会是公共祖先：当某个结点，他的左子树中有p点，右子树中有q点，这个结点即为他俩的公共祖先</li>
<li>后序遍历：因为判断一个结点是否是祖先，需要知道他的左右子树有无p或q结点，所以需要先遍历子树。</li>
<li>注意：当发现中间结点的左右两个子树有一个返回为null说明这条路没有找到，而另一颗子树找到了，那么这个中间结点也需要向上游传递（返回）<code>我找到了的信息</code>.<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p ,q);<br>    TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p ,q);<br>    <span class="hljs-keyword">if</span>(root == p || root == q) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h1><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">Leetcode</a>  </p>
<ul>
<li>层序遍历（用队列实现），从右往左，最后一个元素即为所求。</li>
<li>前序中序后续（用栈实现）<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    queue&lt;TreeNode*&gt; NodeQueue;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    TreeNode*current=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//先让根节点入队</span><br>    NodeQueue.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-comment">//弹空队列</span><br>    <span class="hljs-keyword">while</span>(!NodeQueue.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-comment">//每个元素出队时，让其子节点入队</span><br>        current=NodeQueue.<span class="hljs-built_in">front</span>();<br>        NodeQueue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//保存每层数值</span><br>        res=current-&gt;val;*<br>        <span class="hljs-comment">//每层从右往左入队，最后一个元素即为最底层最左边的值</span><br>        <span class="hljs-keyword">if</span>(current-&gt;right!=<span class="hljs-literal">NULL</span>)NodeQueue.<span class="hljs-built_in">push</span>(current-&gt;right);<br>        <span class="hljs-keyword">if</span>(current-&gt;left!=<span class="hljs-literal">NULL</span>)NodeQueue.<span class="hljs-built_in">push</span>(current-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">Leetcode</a> 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。<br>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>函数意义：t2归并到t1里，返回t1</li>
<li>选择t1为主树，更新结点值到t1里。</li>
<li>因为树结构发生变化，所以需要重新链接左右子树</li>
<li>结束条件：当两个都是null结点则返回null，其中一个是null则返回另一个<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!t1 &amp;&amp; !t2) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(!t2) <span class="hljs-keyword">return</span> t1;<br>    <span class="hljs-keyword">if</span>(!t1) <span class="hljs-keyword">return</span> t2;<br>    t1-&gt;val+=t2-&gt;val;<br>    t1-&gt;left=<span class="hljs-built_in">mergeTrees</span>(t1-&gt;left,t2-&gt;left);<br>    t1-&gt;right=<span class="hljs-built_in">mergeTrees</span>(t1-&gt;right,t2-&gt;right);<br>    <span class="hljs-keyword">return</span> t1;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="最长同值路径"><a href="#最长同值路径" class="headerlink" title="最长同值路径"></a>最长同值路径</h1><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/">Leetcode</a><br>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。<br>注意：两个节点之间的路径长度由它们之间的边数表示。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ul>
<li>寻找最长路径，即需要一个变量<code>ans</code>记录当前最长值，递归时用于比较。</li>
<li>路径可能穿过某个根结点，所以需要遍历每一个结点，将其左子树最长路径加上右子树最长路径。</li>
<li>设计递归函数：返回当前结点下的左右中其中一条最长路径的长度</li>
<li>注意如果结点值与子树的值不连续，路径即为0</li>
<li>路径=结点数-1<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">height</span>(root, ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* node, <span class="hljs-keyword">int</span> &amp;ans)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">height</span>(root-&gt;left, ans);<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">height</span>(root-&gt;right, ans);<br>    left = (root-&gt;left &amp;&amp; root-&gt;val == root-&gt;left-&gt;val) ? left + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    right = (root-&gt;right &amp;&amp; root-&gt;val == root-&gt;right-&gt;val) ? right + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    ans = <span class="hljs-built_in">max</span>(ans, left + right);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right);<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树中第二小的节点"><a href="#二叉树中第二小的节点" class="headerlink" title="二叉树中第二小的节点"></a>二叉树中第二小的节点</h1><p><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">Leetcode</a><br>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 <br>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p>
<h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>题干关键信息：节点的值不大于它的子节点的值，即root结点就是整棵树的最小值，因此第二小的值只能是<code>min(root-&gt;left-&gt;val,root-&gt;right-&gt;val)</code>。</li>
<li>但是当root的值与它其中一个子结点刚好相等时，第二小的值才有可能出现在更深层的子节点中，才需要继续递归搜索第二小值。</li>
<li>函数意义：返回第二小的值。</li>
<li>递归结束条件：null结点或者叶子结点（因为叶子结点的左右子结点都是null，无法访问它）。</li>
<li>哪边找到就返回哪边，都找到则返回较小者。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">int</span> l=root-&gt;left-&gt;val;<br>    <span class="hljs-keyword">int</span> r=root-&gt;right-&gt;val;<br>    <span class="hljs-keyword">if</span>(root-&gt;val == l) l=<span class="hljs-built_in">findSecondMinimumValue</span>(root-&gt;left);<br>    <span class="hljs-keyword">if</span>(root-&gt;val == r) r=<span class="hljs-built_in">findSecondMinimumValue</span>(root-&gt;right);<br>    <span class="hljs-keyword">if</span>(l!=<span class="hljs-number">-1</span> &amp;&amp; r!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(l,r);<br>    <span class="hljs-keyword">if</span>(l==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> r;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h1><p><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">Leetcode</a>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>
<h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>函数意义：修剪二叉树并完返回修剪好的二叉树的根结点</li>
<li>递归结束条件：遇到null</li>
<li>如果根结点的值小于给定的左边界L，那么当前结点及其左子树就会被修剪掉，修剪后的树应该是其右子树，所以返回修剪后的右子树。</li>
<li>涉及到改变树的结构，就需要更新链接，如果当前结点值在范围内，那么修建其左右子树，并且更新左右链接。最后 将当前修剪好的子树返回。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;val &lt; L) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right,L,R);<br>    <span class="hljs-keyword">if</span>(root-&gt;val &gt; R) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left,L,R);<br>    root-&gt;left=<span class="hljs-built_in">trimBST</span>(root-&gt;left,L,R);<br>    root-&gt;right=<span class="hljs-built_in">trimBST</span>(root-&gt;right,L,R);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h1><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">leetcode</a>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。<br>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果</p>
<h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>凡是看到对一个二叉树进行过修改得题，递归得时候一定要对root的左右两个子树重新赋值</li>
<li>若 <code>val &gt; root.val</code>，插入到右子树。</li>
<li>若 <code>val &lt; root.val</code>，插入到左子树。</li>
<li>若 <code>root == null</code>， 即找到了该插入的地方，返回新建的 TreeNode(val)结点。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>    <span class="hljs-keyword">else</span> root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="450">
<li><h1 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h1><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">leetcode</a>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。<br>一般来说，删除节点可分为两个步骤：<br>首先找到需要删除的节点；<br>如果找到了，删除它。<h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3></li>
</ol>
<ul>
<li>必须掌握二叉树的三个性质：<ul>
<li>中序遍历=递增序列 </li>
<li>比当前节点大的最小节点，简称中序遍历序列中的后继节点。先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。</li>
<li>比当前节点小的最大节点，简称中序遍历序列中的前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点</li>
</ul>
</li>
<li>当找到要删除的结点后，该结点有4中状态：<ul>
<li>如果是叶子结点，删除它就等于向上返回null结点</li>
<li>如果只有一个子树，删除它就等于向上返回他的那唯一一颗子树</li>
<li>如果两颗子树都存在，应该按照第三条性质，左子树链接到右子树中的最左下角的结点后面，然后向上返回右子树。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; key) root-&gt;left  = <span class="hljs-built_in">deleteNode</span>(root-&gt;left,  key);<br>    <span class="hljs-keyword">else</span> &#123;	<span class="hljs-comment">// 找到要删除的结点</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;	<span class="hljs-comment">// 该节点是叶子</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left  == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root-&gt;right;<br>        <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root-&gt;left;<br>        <br>        TreeNode* cur = root-&gt;right;<br>        <span class="hljs-keyword">while</span> (cur-&gt;left != <span class="hljs-literal">NULL</span>) &#123;<br>            cur = cur-&gt;left;<br>        &#125;<br>        cur-&gt;left = root-&gt;left;<br>        <span class="hljs-keyword">return</span> root-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/posts/8d66b5f2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🚑栈和队列🚑"><a href="#🚑栈和队列🚑" class="headerlink" title="🚑栈和队列🚑"></a>🚑栈和队列🚑</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p>
<span id="more"></span>

<ul>
<li><a href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC">7.整数反转</a> </li>
<li><a href="#%E5%9B%9E%E6%96%87%E6%95%B0">9.回文数</a></li>
<li><a href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7">20.有效的括号</a> </li>
<li><a href="#%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">232.用栈实现队列</a></li>
<li><a href="#%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88">225.用队列实现栈</a></li>
<li><a href="#%E6%9C%80%E5%B0%8F%E6%A0%88">155.最小栈</a>   </li>
<li><a href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">150.逆波兰表达式求值</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81">394.字符串解码</a></li>
<li><a href="#%E5%85%8B%E9%9A%86%E5%9B%BE">133.克隆图</a></li>
<li><a href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F">200.岛屿数量</a></li>
<li><a href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2">84.柱状图中最大的矩形</a></li>
<li><a href="#01%E7%9F%A9%E9%98%B5">542.01矩阵</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">622.设计循环队列</a></li>
</ul>
<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><p><a href="https://leetcode-cn.com/problems/reverse-integer/">Leetcode</a>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>从低到高位依次加入队列，然后输出</li>
<li>注意反转后的溢出问题<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rev=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(rev&gt;INT_MAX/<span class="hljs-number">10</span> || rev&lt;INT_MIN/<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        rev=rev*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;<br>         x/=<span class="hljs-number">10</span>;<br>     &#125;<br>     <span class="hljs-keyword">return</span> rev;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/">Leetcode</a>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一位数一定是回文数</li>
<li>负数或者个位是0的一定不是回文数。</li>
<li>反转整数，只反转到一半，然后进行比较（对于奇数个数得回文数，去掉中间位再比较）<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;=<span class="hljs-number">9</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(x%<span class="hljs-number">10</span>==<span class="hljs-number">0</span> || x&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> rev=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x&gt;rev)&#123;<br>        rev=rev*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;<br>        x/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> rev/<span class="hljs-number">10</span>==x || rev==x;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">Leetcode</a>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ ===的字符串，判断字符串是否有效。<br>有效字符串需满足：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1. 左括号必须用相同类型的右括号闭合。<br>2. 左括号必须以正确的顺序闭合。<br></code></pre></td></tr></table></figure>
<p>注意空字符串可被认为是有效字符串。</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>个数为奇数肯定不对</li>
<li>首字符为右符号肯定不对</li>
<li>遇到左符号入栈</li>
<li>遇到右符号与栈顶元素进行匹配，配对则出栈，否则返回false，最后栈空了则说明是有效的<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()%<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;&#125;&#x27;</span> || s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;)&#x27;</span> || s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    stack&lt;<span class="hljs-keyword">char</span>&gt; sck;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;s[i]!=<span class="hljs-string">&#x27;\0&#x27;</span>;++i)&#123;<br>        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;[&#x27;</span> || s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span> || s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            sck.<span class="hljs-built_in">push</span>(s[i]);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; sck.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;&#123;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; sck.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;[&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; sck.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            sck.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> sck.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">Leetcode</a>  </p>
<ul>
<li>栈的顺序为后进先出，而队列的顺序为先进先出。</li>
<li>使用两个栈实现队列，一个元素需要经过两个栈才能出队列<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:   <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(stack2.<span class="hljs-built_in">empty</span>())&#123;                  <span class="hljs-comment">//只有当stack2为空时，才重新加载</span><br>            <span class="hljs-keyword">while</span>(!stack1.<span class="hljs-built_in">empty</span>())&#123;         <span class="hljs-comment">//stack1装填到stack2</span><br>                stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());  <span class="hljs-comment">//c++ pop()函数返回值额为void</span><br>                stack1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res=stack2.<span class="hljs-built_in">top</span>();<br>        stack2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stack2.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(!stack1.<span class="hljs-built_in">empty</span>())&#123;<br>                stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>                stack1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack2.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack1.<span class="hljs-built_in">empty</span>() &amp;&amp; stack2.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stack1;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; stack2;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">Leetcode</a>  </p>
<ul>
<li>一个队列  </li>
<li>push之前判断当前是否为空</li>
<li>不为空则将元素插入到尾部，前面的全部弹出再去入队</li>
<li><code>push</code>时间复杂度O(n),而<code>pop</code>的时间复杂度O(1)    </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyStack</span>() &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(queue1.<span class="hljs-built_in">empty</span>())&#123;<br>            queue1.<span class="hljs-built_in">push</span>(x);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> cnt=queue1.<span class="hljs-built_in">size</span>();<br>            queue1.<span class="hljs-built_in">push</span>(x);<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)&#123;<br>                queue1.<span class="hljs-built_in">push</span>(queue1.<span class="hljs-built_in">front</span>());<br>                queue1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res=queue1.<span class="hljs-built_in">front</span>();<br>        queue1.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue1.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> queue1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; queue1;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ul>
<li><code>push</code>时间复杂度O(1),而<code>pop</code>的时间复杂度O(n)  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q1; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        q1.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        queue&lt;<span class="hljs-keyword">int</span>&gt;q2;<br>        <span class="hljs-keyword">while</span>(q1.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            q2.<span class="hljs-built_in">push</span>(q1.<span class="hljs-built_in">front</span>());<br>            q1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">int</span> res=q1.<span class="hljs-built_in">front</span>();<br>        q1=q2;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        queue&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">q2</span>(q1);<br>        <span class="hljs-keyword">while</span>(q1.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            q1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">int</span> res=q1.<span class="hljs-built_in">front</span>();<br>        q1=q2;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈  "></a>最小栈  </h1><a href="https://leetcode-cn.com/problems/min-stack/">Leetcode</a>  </li>
<li>维护两个栈：<code>数据栈</code> <code>最小栈</code></li>
<li>同步简单，异步节省<code>最小栈</code>空间</li>
<li>异步：当新插入的元素比最小值还小（或相等）时，插入最小栈，出栈时只有当两个栈栈顶元素相同时，两个栈同时pop，否则只有<code>数据栈</code>pop  </li>
<li>同步：两个栈的大小始终相同，只是<code>最小栈</code>每次都插入当前最小值，出栈时两栈同时pop  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        dataStack.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">if</span>(miniStack.<span class="hljs-built_in">empty</span>())&#123;<br>            miniStack.<span class="hljs-built_in">push</span>(x);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> min=miniStack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(min&gt;=x)&#123;                         <span class="hljs-comment">//相等时也要插入</span><br>                miniStack.<span class="hljs-built_in">push</span>(x);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>( dataStack.<span class="hljs-built_in">top</span>()==miniStack.<span class="hljs-built_in">top</span>())&#123;  <span class="hljs-comment">//只有相等时才同时弹出否则只弹出dataStack</span><br>            dataStack.<span class="hljs-built_in">pop</span>();<br>            miniStack.<span class="hljs-built_in">pop</span>();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dataStack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dataStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> miniStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; dataStack;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; miniStack;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h1 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h1><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">leetcode</a>根据 逆波兰表示法，求表达式的值。<br>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：<br>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]<br>输出: 9<br>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>典型的后缀表达式，栈得应用场景</li>
<li>遍历字符串数组，遇到字符就弹出栈顶两个元素进行运算，再将结果填入栈。遇到数字就直接入栈</li>
<li>这里使用了c语言<code>stoi()</code>函数直接将字符串转换为数字，也可以使用ASCII值转，<code>atoi(string.c_str())</code><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; sck;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : tokens) &#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-string">&quot;+&quot;</span>) &#123;<br>            <span class="hljs-keyword">int</span> a = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">int</span> b = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            sck.<span class="hljs-built_in">push</span>(b + a);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (it == <span class="hljs-string">&quot;-&quot;</span>) &#123;<br>            <span class="hljs-keyword">int</span> a = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">int</span> b = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            sck.<span class="hljs-built_in">push</span>(b - a);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (it == <span class="hljs-string">&quot;*&quot;</span>)&#123;<br>            <span class="hljs-keyword">int</span> a = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">int</span> b = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            sck.<span class="hljs-built_in">push</span>(a * b);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (it == <span class="hljs-string">&quot;/&quot;</span>)&#123;<br>            <span class="hljs-keyword">int</span> a = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">int</span> b = sck.<span class="hljs-built_in">top</span>();<br>            sck.<span class="hljs-built_in">pop</span>();<br>            sck.<span class="hljs-built_in">push</span>(b / a);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sck.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(it));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sck.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h1><p><a href="https://leetcode-cn.com/problems/decode-string/">leetcode</a>给定一个经过编码的字符串，返回它解码后的字符串。<br>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。<br>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。<br>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;3[a]2[bc]&quot;<br>输出：&quot;aaabcbc&quot;<br><br>输入：s &#x3D; &quot;3[a2[c]]&quot;<br>输出：&quot;accaccacc&quot;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一看到<code>[</code> <code>]</code> 匹配得题，首先想到使用栈，既有数字又有字母，想到使用两个栈</li>
<li>这类题基本思路就是找到什么时候入栈，什么时候出栈。</li>
<li>同时涉及了遍历数组，提取数字和提取字符串算法</li>
<li>本题的当遍历到’[‘时同时入栈，遍历到’]’时出栈进行操作,strSck.top()可以理解为到当前为止前面已经展开的字符串，cur为刚刚<code>[ ]</code>中合成的字符串。</li>
<li>讲道理此题过于难以理解🐛<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    string cur = <span class="hljs-string">&quot;&quot;</span>;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; numSck;<br>    stack&lt;string&gt; strSck;<br>    <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            val = val * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>            numSck.<span class="hljs-built_in">push</span>(val);<br>            strSck.<span class="hljs-built_in">push</span>(cur);<br>            val = <span class="hljs-number">0</span>;<br>            cur = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;=<span class="hljs-string">&#x27;z&#x27;</span>) || (s[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>)) &#123;<br>            cur += s[i];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <span class="hljs-keyword">int</span> cnt = numSck.<span class="hljs-built_in">top</span>();<br>            numSck.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; ++i) &#123;<br>                strSck.<span class="hljs-built_in">top</span>() += cur;<br>            &#125;<br>            cur = strSck.<span class="hljs-built_in">top</span>();<br>            strSck.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="克隆图"><a href="#克隆图" class="headerlink" title="克隆图"></a>克隆图</h1><p><a href="https://leetcode-cn.com/problems/clone-graph/">leetcode</a>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。<br>图中的每个节点都包含它的值<code> val  int</code> 和其邻居的列表<code>vector[Node]</code>。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]<br>输出：[[2,4],[1,3],[2,4],[1,3]]<br>解释：<br>图中有 4 个节点。<br>节点 1 的值是 1，它有两个邻居：节点 2 和 4 。<br>节点 2 的值是 2，它有两个邻居：节点 1 和 3 。<br>节点 3 的值是 3，它有两个邻居：节点 2 和 4 。<br>节点 4 的值是 4，它有两个邻居：节点 1 和 3 。<br><br></code></pre></td></tr></table></figure>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>图得遍历有两种深度DFS和广度BFS</li>
<li>深度优先遍历：使用递归同时还需要记录哪些是已经复制过得，函数得意义是复制并返回复制得结点，如果发现该结点已经复制过，直接返回复制得结点</li>
<li>由于是深拷贝，一定需要new，所以该结点没有复制，就new一个新结点，并标记已经拷贝过。</li>
<li>新得结点还需要链接它得邻接点，遍历它得所以邻接点，并继续复制。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">Node* isClone[<span class="hljs-number">101</span>];<br><span class="hljs-function">Node* <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (isClone[node-&gt;val] != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> isClone[node-&gt;val];<br>    Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>    isClone[node-&gt;val] = newNode;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : node-&gt;neighbors) &#123;<br>        newNode-&gt;neighbors.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">cloneGraph</span>(it));<br>    &#125;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>使用广度优先遍历就必须使用队列</li>
<li>首先先复制第一个结点并加入到队列中，然后进入循环，注意：队列加入得都是原结点不是新创建得结点，因为新结点还没有链接邻接点</li>
<li>对每个出队列得结点广度遍历，即遍历完它得所有邻接点，没有复制过得就新建并加入队列，最后链接新建的结点和邻接点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">   Node* isClone[<span class="hljs-number">101</span>];<br>   <span class="hljs-function">Node* <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>       queue&lt;Node*&gt; que;<br>       Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>       isClone[node-&gt;val] = newNode;<br>       que.<span class="hljs-built_in">push</span>(node);<br>       <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>Node* cur = que.<span class="hljs-built_in">front</span>();<br>que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (Node* e : cur-&gt;neighbors) &#123;<br>       <span class="hljs-keyword">if</span> (isClone[e-&gt;val] == <span class="hljs-literal">NULL</span>) &#123;<br>	que.<span class="hljs-built_in">push</span>(e);<br>	isClone[e-&gt;val] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(e-&gt;val);<br>       &#125;<br>       isClone[cur-&gt;val]-&gt;neighbors.<span class="hljs-built_in">push_back</span>(isClone[e-&gt;val]);<br>&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h1 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h1><p><a href="https://leetcode-cn.com/problems/number-of-islands/">leetcode</a>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入:<br>[<br>[&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;0&#39;],<br>[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;],<br>[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],<br>[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;]<br>]<br>输出: 1<br></code></pre></td></tr></table></figure>
<h3 id="DFS解题思路"><a href="#DFS解题思路" class="headerlink" title="DFS解题思路"></a>DFS解题思路</h3><ul>
<li>把二维表格当作一个图来处理，每个结点的上下左右都是它的邻接点</li>
<li>两个for循环遍历二维数组，当遇到<code>1</code>时开始深度遍历它的邻接点，凡是dfs遍历途中遇到<code>1</code>的都改为0，直到所有相连的1全部改为0，这就算找到了一个岛，后面继续遍历改后的二维数组。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(grid, i, j);<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; grid, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">szie</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">szie</span>() - <span class="hljs-number">1</span>;<br>    grid[row][col] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (x &lt; row &amp;&amp; grid[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-built_in">dfs</span>(grid, x + <span class="hljs-number">1</span>, y);<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>   &amp;&amp; grid[x - <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-built_in">dfs</span>(grid, x - <span class="hljs-number">1</span>, y);<br>    <span class="hljs-keyword">if</span> (y &lt; col &amp;&amp; grid[x][y + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-built_in">dfs</span>(grid, x, y + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span>   &amp;&amp; grid[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-built_in">dfs</span>(grid, x, y - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BFS解题"><a href="#BFS解题" class="headerlink" title="BFS解题"></a>BFS解题</h3></li>
<li>md，超出时间限制找了一个多小时的原因，一个字一个字对比最后才发现，一个<code>= </code>写成<code>==</code>，日啊。第二次犯这种错误了<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (grid.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; que;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                cnt++;<br>                grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>(i, j));<br>                <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>                    pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; cur = que.<span class="hljs-built_in">front</span>();<br>                    que.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">int</span> x = cur.first;<br>                    <span class="hljs-keyword">int</span> y = cur.second;<br>                    <span class="hljs-keyword">if</span> (x - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>  &amp;&amp; grid[x - <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        grid[x - <span class="hljs-number">1</span>][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        que.<span class="hljs-built_in">push</span>(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(x - <span class="hljs-number">1</span>, y));<br>                    &#125;  <br>                    <span class="hljs-keyword">if</span> (y - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>  &amp;&amp; grid[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        que.<span class="hljs-built_in">push</span>(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(x, y - <span class="hljs-number">1</span>));<br>                        grid[x][y - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    &#125;  <br>                    <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt; row &amp;&amp; grid[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        que.<span class="hljs-built_in">push</span>(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(x + <span class="hljs-number">1</span>, y));<br>                        grid[x + <span class="hljs-number">1</span>][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (x + <span class="hljs-number">1</span> &lt; row &amp;&amp; grid[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        que.<span class="hljs-built_in">push</span>(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(x + <span class="hljs-number">1</span>, y));<br>                        grid[x + <span class="hljs-number">1</span>][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (y + <span class="hljs-number">1</span> &lt; col &amp;&amp; grid[x][y + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                        que.<span class="hljs-built_in">push</span>(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(x, y + <span class="hljs-number">1</span>));<br>                        grid[x][y + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h1><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">leetcode</a>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png">dd</a><br>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>暴力解法可以枚举以每个柱形为高度的最大矩形的面积。具体来说就是：依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。</li>
<li>左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标；</li>
<li>右边看一下，看最多能向右延伸多长；找到大于等于当前柱形高度的最右边元素的下标。</li>
<li>以下题解会超时。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (heights.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">int</span> left = i, right = i; <br>        <span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span> &amp;&amp; heights[left - <span class="hljs-number">1</span>] &gt;= heights[i]) left--;<br>        <span class="hljs-keyword">while</span> (right &lt; heights.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; heights[right + <span class="hljs-number">1</span>] &gt;= heights[i]) right++;<br>        <span class="hljs-keyword">int</span> len = right - left + <span class="hljs-number">1</span>;<br>        res = <span class="hljs-built_in">max</span>(res, heights[i] * len);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="01矩阵"><a href="#01矩阵" class="headerlink" title="01矩阵"></a>01矩阵</h1><p><a href="https://leetcode-cn.com/problems/01-matrix/">leetcode</a><br>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。<br>两个相邻元素间的距离为 1 。</p>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs 输入:"><br>0 0 0<br>0 1 0<br>1 1 1<br>输出:<br><br>0 0 0<br>0 1 0<br>1 2 1<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>理解题意比较难，题意要求我们找到每个1离0最近的距离，正常会想到遍历每个1，最每个1进行DFS或者BFS，但是这样就涉及到对上下左右每个分支的距离最短筛选的操作。时间复杂度也会大大增加。</li>
<li>因此我们可以反过来遍历，先遍历找到所有0的结点，他的4个上下左右分支点一定是1，而1的上下左右4个未访问过的分支点一定是2，依次展开。</li>
<li>BFS解法一般都涉及队列的使用：<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> off[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix) &#123;<br>    <span class="hljs-keyword">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">bool</span> isVis[row][col];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-built_in">memset</span>(isVis[i], <span class="hljs-number">0</span>, col);<br>    &#125;<br>    <span class="hljs-comment">// 入队列的顺序：所有0的位置，所有离0点距离为1的点，所有离0点距离为2的点....</span><br>    queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; que;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                que.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>                isVis[i][j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">int</span> x = que.<span class="hljs-built_in">front</span>().first;<br>        <span class="hljs-keyword">int</span> y = que.<span class="hljs-built_in">front</span>().second;<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-keyword">int</span> xi = x + off[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> yi = y + off[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (xi &gt;= <span class="hljs-number">0</span> &amp;&amp; xi &lt; row &amp;&amp; yi &gt;= <span class="hljs-number">0</span> &amp;&amp; yi &lt; col &amp;&amp; !isVis[xi][yi]) &#123;<br>                isVis[xi][yi] = <span class="hljs-literal">true</span>;<br>                matrix[xi][yi] = matrix[x][y] + <span class="hljs-number">1</span>; <br>                que.<span class="hljs-built_in">push</span>(&#123;xi, yi&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> matrix;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="设计循环队列"><a href="#设计循环队列" class="headerlink" title="设计循环队列"></a>设计循环队列</h1><p><a href="https://leetcode-cn.com/problems/design-circular-queue/">leetcode</a>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p>
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。<br>你的实现应该支持如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">MyCircularQueue(k): 构造器，设置队列长度为 k 。<br>Front: 从队首获取元素。如果队列为空，返回 -1 。<br>Rear: 获取队尾元素。如果队列为空，返回 -1 。<br>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。<br>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。<br>isEmpty(): 检查循环队列是否为空。<br>isFull(): 检查循环队列是否已满。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>两个指针，<code>head</code>和<code>tail</code>，注意满队和空队的条件，满队时：<code>tail</code>就在<code>head</code>的前一格，空队时：<code>tail</code>和<code>head</code>都指向-1。</li>
<li>凡涉及到循环，指针移动后都要对<code>size</code>取模才能保证不超过<code>size</code>大小。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularQueue</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; data;<br>    <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">int</span> head;<br>    <span class="hljs-keyword">int</span> tail;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyCircularQueue</span>(<span class="hljs-keyword">int</span> k) &#123;<br>        data.<span class="hljs-built_in">resize</span>(k);<br>        size = k;<br>        head = <span class="hljs-number">-1</span>;<br>        tail = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFull</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) head = <span class="hljs-number">0</span>;<br>        tail = (tail + <span class="hljs-number">1</span>) % size;<br>        data[tail] = value;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (head == tail) &#123;     <span class="hljs-comment">// 只剩一个元素时</span><br>            head = <span class="hljs-number">-1</span>;<br>            tail = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        head = (head + <span class="hljs-number">1</span>) % size;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> data[head];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> data[tail];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> head == <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (tail + <span class="hljs-number">1</span>) % size == head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/posts/340249a9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li><a href="#%E5%A5%BD%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE">5460. 好数对的数目</a></li>
</ul>
<span id="more"></span>

<h1 id="好数对的数目"><a href="#好数对的数目" class="headerlink" title=" 好数对的数目"></a> 好数对的数目</h1><p><a href="https://leetcode-cn.com/problems/number-of-good-pairs/">leetcode</a><br>给你一个整数数组 nums 。<br>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。<br>返回好数对的数目。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,2,3,1,1,3]<br>输出：4<br>解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始<br></code></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>只要想到用一个二维数组的方式来判断就很简单，用到双层for循环暴力解决。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIdenticalPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[j])<br>                cnt ++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>📸排序📸</title>
    <url>/posts/bafd3c38.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="📸排序📸"><a href="#📸排序📸" class="headerlink" title="📸排序📸"></a>📸排序📸</h1><span id="more"></span>

<p>堆排序、快速排序  </p>
<ul>
<li><a href="%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0">215.数组中的第K个最大元素</a>  </li>
</ul>
<p>建立哈希表并排序  </p>
<ul>
<li><a href="%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0">347.前K个高频元素</a></li>
<li><a href="%E6%8C%89%E7%85%A7%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F">451.按照字符出现次数对字符串排序</a>  </li>
</ul>
<p>荷兰国旗问题  </p>
<ul>
<li><a href="%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97">75.按颜色进行排序</a></li>
</ul>
<h1 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h1><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">leetcode</a>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<h3 id="使用SLT库排序"><a href="#使用SLT库排序" class="headerlink" title="使用SLT库排序"></a>使用SLT库排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() - k];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="堆排序解题思路"><a href="#堆排序解题思路" class="headerlink" title="堆排序解题思路"></a>堆排序解题思路</h3><ul>
<li>堆排序会使用到优先队列<code>priority_queue</code>，可以当成一种高级队列，只不过这个队列是已经排好序的。</li>
<li>维护一个个数为k的小顶堆，堆从从上到下按从小到大排序</li>
<li>始终保持堆的大小为k，超出k就pop(),直到遍历结束位置，堆中存放着前k个最大元素，堆顶的元素就是正确答案。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; queue;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : nums) &#123;<br>        queue.<span class="hljs-built_in">push</span>(it);<br>        <span class="hljs-keyword">if</span> (queue.<span class="hljs-built_in">size</span>() &gt; k) queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> queue.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="快速排序解题思路"><a href="#快速排序解题思路" class="headerlink" title="快速排序解题思路"></a>快速排序解题思路</h3></li>
<li>不使用STL库的情况下，手写一个快速排序算法</li>
<li>注意：快速排序使用的是递归，所以记得一定要写个递归结束条件<code> if (left &gt; right) return ;。</code></li>
<li>注意：在partition函数中while里处理要判断nums[right] &gt;= p，还要判断left &lt; right。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() - k];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-built_in">partition</span>(nums, left, right);<br>    <span class="hljs-built_in">quickSort</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quickSort</span>(nums, mid + <span class="hljs-number">1</span>,right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p = nums[left];<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">while</span> (nums[right] &gt;= p &amp;&amp; left &lt; right) right--;<br>        nums[left] = nums[right];<br>        <span class="hljs-keyword">while</span> (nums[left] &lt;= p &amp;&amp; left &lt; right) left++;<br>        nums[right] = nums[left];<br>    &#125;<br>    nums[left] = p;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h1><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">leetcode</a>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>建立哈希表统计数字出现频率，</li>
<li>利用隐式转换，把无序hash转换为pair类型方便按照频率多少进行排序</li>
<li>使用SLT的sort()函数进行排序，大小的比较规则cmp函数需要自己写。</li>
<li>将排好序的前k元素输出<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; v1, pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; v2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> v1.second &gt; v2.second;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        hash[nums[i]]++;<br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">arr</span>(hash.<span class="hljs-built_in">begin</span>(), hash.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(arr[i].first);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="按照字符出现次数对字符串排序"><a href="#按照字符出现次数对字符串排序" class="headerlink" title="按照字符出现次数对字符串排序"></a>按照字符出现次数对字符串排序</h1><p><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">leetcode</a>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>哈希表建立的频率表是无序的，所以需要转换为其他数据结构，再使用排序算法对其排序</li>
<li>可以使用隐式的类型转换为<code>pair&lt;char,int&gt;</code>，再使用STL里面的sort()函数进行排序，sort的好处是可以自定义排序的规则。</li>
<li>sort()函数自定义的排序规则需要写成静态的函数<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; a, pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : s) &#123;<br>        hash[it]++;<br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">arr</span>(hash.<span class="hljs-built_in">begin</span>(), hash.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>    string res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : arr) &#123;<br>        <span class="hljs-keyword">while</span> (it.second--) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(it.first);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="荷兰国旗"><a href="#荷兰国旗" class="headerlink" title="荷兰国旗"></a>荷兰国旗</h1><p><a href="https://leetcode-cn.com/problems/sort-colors/">Leetcode</a>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一共三个指针，p0一直指向0的后一位，p2一直指向2的前一位，cur是用于遍历的指针。</li>
<li>本题属于荷兰旗帜问题：思想是遇到0就跟p0所指的数交换位置，遇到2就跟p2所指的数交换位置，遇到1就跳过。</li>
<li>注意：遇到2交换完位置后，cur指针不前进，因为要再次判断交换过来的数是0还是1。</li>
<li>注意2：while结束是 <code>cur &lt; p2</code>而不是<code>cur &lt; nums.size()</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>, p2 = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur &lt; p2) &#123;<br>        <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">1</span>) cur++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(nums[p0++], nums[cur++]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">2</span>) <span class="hljs-built_in">swap</span>(nums[cur],nums[p2--]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/posts/fc81fbfd.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p>
<span id="more"></span>

<h1 id="⚡️字符串⚡️"><a href="#⚡️字符串⚡️" class="headerlink" title="⚡️字符串⚡️  "></a>⚡️字符串⚡️  </h1><!--more-->

<ul>
<li><a href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">242.有效的字母异位词</a>  </li>
<li><a href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2">409.最长回文串</a>  </li>
<li><a href="#%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2">205.同构字符串</a>  </li>
<li><a href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">647.回文子串</a>  </li>
<li><a href="#%E5%9B%9E%E6%96%87%E6%95%B0">9.回文数</a>  </li>
<li><a href="#%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2">696.计数二进制子串</a>  </li>
</ul>
<p>滑动窗口思想(双指针进阶版）</p>
<ul>
<li><a href="#%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2">76.最小覆盖子串</a></li>
</ul>
<h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词  "></a>有效的字母异位词  </h1><p><a href="https://leetcode-cn.com/problems/valid-anagram/description/">Leetcode</a>  </p>
<ul>
<li>示例：<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;<br>输出: true<br></code></pre></td></tr></table></figure></li>
<li>哈希表<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">    <span class="hljs-comment">//构建哈希数组，用索引0~26代表a~z</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">length</span>()!=t.<span class="hljs-built_in">length</span>())<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//普通数组必须提前分配空间，或者用动态数组</span><br>        <span class="hljs-keyword">int</span> hashArr[<span class="hljs-number">26</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();++i)&#123;<br>            hashArr[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;     <br>        &#125;     <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;t.<span class="hljs-built_in">length</span>();++i)&#123;<br>            hashArr[t[i]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-comment">//判断个数也可用i&lt;26</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(hashArr)/<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(hashArr[<span class="hljs-number">0</span>]);++i)&#123;<br><br>            <span class="hljs-keyword">if</span>(hashArr[i]!=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串  "></a>最长回文串  </h1><p><a href="https://leetcode-cn.com/problems/longest-palindrome/description/">Leetcode</a><br>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。<br>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">    <span class="hljs-comment">//hash表统计字符出现频率</span><br>    <span class="hljs-comment">//偶数加入长度</span><br>    <span class="hljs-comment">//奇数-1加入长度</span><br>    <span class="hljs-comment">//最后回文长度小于字符集长度说明一定有未使用的字符，回文长度再加1</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> longestLength=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> hash[<span class="hljs-number">127</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();++i)&#123;<br>            hash[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(hash)/<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(hash[<span class="hljs-number">0</span>]);++i)&#123;<br>            <span class="hljs-keyword">if</span>(hash[i]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                longestLength+=hash[i];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                longestLength+=hash[i]<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> longestLength&lt;s.<span class="hljs-built_in">length</span>()?++longestLength:longestLength;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="同构字符串"><a href="#同构字符串" class="headerlink" title="同构字符串"></a>同构字符串</h1><p><a href="https://leetcode-cn.com/problems/isomorphic-strings/description/">Leetcode</a>  </p>
<ul>
<li>示例：<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;<br>输出: true<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">    <span class="hljs-comment">//哈希交叉映射</span><br>    <span class="hljs-comment">//比如对于tit和pap，</span><br>    <span class="hljs-comment">//对于tit所有的t对应p，所有的i对应a</span><br>    <span class="hljs-comment">//对于pap所有的p对应t，所有的a对应i</span><br>    <span class="hljs-comment">//同时遍历两个字符串，就去map中寻找 该字母是否有对应值（映射），</span><br>    <span class="hljs-comment">//如果有就去查该映射的值是否与另一个字符串中对应位字母相同，如果不同就不是同构字符串</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">char</span>&gt; sHash;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">char</span>&gt; tHash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;s[i]!=<span class="hljs-string">&#x27;\0&#x27;</span>;++i)&#123;<br>            <span class="hljs-keyword">if</span>(sHash.<span class="hljs-built_in">count</span>(s[i]) &amp;&amp; s[i]!=tHash[t[i]])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tHash.<span class="hljs-built_in">count</span>(t[i]) &amp;&amp; t[i]!=sHash[s[i]])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123; <br>                tHash[t[i]]=s[i];<br>                sHash[s[i]]=t[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h1><p><a href="https://leetcode-cn.com/problems/palindromic-substrings/description/">Leetcode</a>    </p>
<ul>
<li>中心扩展思想  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//回文字符串：奇数个数和偶数个数两种</span><br>    <span class="hljs-comment">//所以有两种中心扩展方式，以当前字符为中心、以当前字符和下一个字符为中心向两边拓展</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;s[i]!=<span class="hljs-string">&#x27;\0&#x27;</span>;++i)&#123;<br>            <span class="hljs-built_in">expandSubString</span>(s,i,i);<br>            <span class="hljs-built_in">expandSubString</span>(s,i,i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <span class="hljs-comment">//中心扩散，回文字符串对称特点，两端相等</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">expandSubString</span><span class="hljs-params">(string s,<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(start&gt;=<span class="hljs-number">0</span> &amp;&amp; end&lt;s.<span class="hljs-built_in">length</span>() &amp;&amp; s[start]==s[end])&#123;<br>            start--;<br>            end++;<br>            cnt++;  <br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/description/">Leetcode</a>  </p>
<ul>
<li>用整数实现队列<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">    <span class="hljs-comment">//将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等。</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;<span class="hljs-number">10</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span> || x%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//我们将原始数字除以 10，然后给反转后的数字乘上 10</span><br>        <span class="hljs-comment">//当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字</span><br>        <span class="hljs-keyword">int</span> reverse=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(reverse&lt;x)&#123;<br>            reverse=reverse*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;<br>            x/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> reverse==x || reverse/<span class="hljs-number">10</span>==x?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="计数二进制子串"><a href="#计数二进制子串" class="headerlink" title="计数二进制子串"></a>计数二进制子串</h1></li>
<li>统计二进制字符串中 <code>连续 1 和连续 0 数量相同的子字符</code> 串个数  </li>
<li>对于长字符串会超出时间限制<br>示例：<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;00110011&quot;<br>输出: 6<br>解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。<br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;10101&quot;<br>输出: 4<br>解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。<br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//题目含义：字串必须有0，1，子串的的0和1数量相等，且所有0或1是组合在一起，即一边全是0或者1</span><br>    <span class="hljs-comment">//使用中心扩展思想，遇到01，或10时进行扩展</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//避免数组越界</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i+<span class="hljs-number">1</span>&lt;s.<span class="hljs-built_in">length</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]!=s[i+<span class="hljs-number">1</span>])&#123;<br>	<span class="hljs-comment">//指针跳过中间部分，指向上个子字符串结尾</span><br>                <span class="hljs-keyword">int</span> next=<span class="hljs-built_in">expandSubString</span>(s,i,i+<span class="hljs-number">1</span>)；<br>                i=next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">expandSubString</span><span class="hljs-params">(string s,<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">char</span> f=s[start];<br>        <span class="hljs-keyword">char</span> e=s[end];<br>        <span class="hljs-keyword">while</span>(start&gt;=<span class="hljs-number">0</span> &amp;&amp; end&lt;s.<span class="hljs-built_in">length</span>() &amp;&amp; s[start]==f &amp;&amp; s[end]==e)&#123;<br>            start--;<br>            end++;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> end<span class="hljs-number">-1</span><span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


<h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">leetcode</a>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;<br>输出: &quot;BANC&quot;<br></code></pre></td></tr></table></figure>
<p>说明：字符串T可以有重复的字母，S必须全部包含T（意思是不光要包含字母的种类，相同字母的个数也得相等）。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>子串问题基本上都是滑动窗口思想<blockquote>
<p>滑动窗口思想:在滑动窗口类型的问题中都会有两个指针。一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; window, need;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : t) &#123;<br>        need[ch]++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 满足的字母种类个数</span><br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 最小子串的开始索引和长度</span><br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, minLen = INT_MAX;<br><br>    <span class="hljs-keyword">while</span> (right &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">char</span> ch = s[right];<br>        right++;<br>        <span class="hljs-keyword">if</span> (need.<span class="hljs-built_in">find</span>(ch) != need.<span class="hljs-built_in">end</span>()) &#123;    <span class="hljs-comment">// 查看ch是否属于t</span><br>            window[ch]++;<br>            <span class="hljs-keyword">if</span> (window[ch] == need[ch]) &#123;<br>                valid++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (valid == need.<span class="hljs-built_in">size</span>()) &#123;  <span class="hljs-comment">// 能进来都表示已经全覆盖了t</span><br>            <span class="hljs-comment">// 先判断当前是否事最小子串</span><br>            <span class="hljs-keyword">if</span> (right - left  &lt; minLen) &#123;<br>                minLen = right - left ;<br>                start = left;<br>            &#125;<br><br>            ch = s[left];<br>            left++;<br>            <span class="hljs-keyword">if</span> (need.<span class="hljs-built_in">find</span>(ch) != need.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">if</span> (window[ch] == need[ch])<br>                    valid--;<br>                window[ch]--;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> minLen == INT_MAX ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(start, minLen);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/posts/850f2080.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="⚗哈希表⚗"><a href="#⚗哈希表⚗" class="headerlink" title="⚗哈希表⚗"></a>⚗哈希表⚗</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p>
<span id="more"></span>

<ul>
<li><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C">1.两数之和</a>  </li>
<li><a href="#%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2">205.同构字符串</a>  </li>
<li><a href="#%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">217.存在重复元素</a>  </li>
<li><a href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">242.有效的字母异位词</a></li>
<li><a href="#%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0">347.前K个高频元素</a></li>
<li><a href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2">409.最长回文串</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F">451.根据字符出现频率排序</a></li>
<li><a href="#%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97">594.最长和谐子序列 </a></li>
</ul>
<!--more-->

<h1 id="C-哈希表的基本使用"><a href="#C-哈希表的基本使用" class="headerlink" title="C++哈希表的基本使用  "></a>C++哈希表的基本使用  </h1><ul>
<li>查找元素是否存在<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">若有unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mp;<br>查找x是否在map中<br>方法<span class="hljs-number">1</span>:  若存在  mp.<span class="hljs-built_in">find</span>(x)!=mp.<span class="hljs-built_in">end</span>()；<br>方法<span class="hljs-number">2</span>:  若存在  mp.<span class="hljs-built_in">count</span>(x)!=<span class="hljs-number">0</span>；<br></code></pre></td></tr></table></figure></li>
<li>遍历map<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">    unordered_map&lt;key,T&gt;::iterator it;<br>    (*it).first;        <br>    (*it).second  <br>    <span class="hljs-keyword">for</span>(unordered_map&lt;key,T&gt;::iterator iter=mp.<span class="hljs-built_in">begin</span>();iter!=mp.<span class="hljs-built_in">end</span>();iter++)<br>          cout&lt;&lt;<span class="hljs-string">&quot;key value is&quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="hljs-string">&quot; the mapped value is &quot;</span>&lt;&lt; iter-&gt;second;<br></code></pre></td></tr></table></figure></li>
<li>用高级for循环时<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; it : mp)&#123;<br>        cout&lt;&lt; it.first &lt;&lt;it.second;<br>&#125;<br>````<br><br>两数之和    <br>=============  <br>[Leetcode](https:<span class="hljs-comment">//leetcode-cn.com/problems/two-sum/description/)给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍<br>### 解题思路<br>* 一次遍历法<br>*  如果发现满足条件的key值就<span class="hljs-keyword">return</span>它得值出去，没发现就加入map中<br>```cpp<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target) &#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(target - nums[i]) != hash.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;hash[target - nums[i]], i&#125;;<br>            &#125;<br>            hash[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="同构字符串"><a href="#同构字符串" class="headerlink" title="同构字符串"></a>同构字符串</h1><p><a href="https://leetcode-cn.com/problems/isomorphic-strings/">leetcode</a>给定两个字符串 s 和 t，判断它们是否是同构的。<br>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。<br>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>哈希交叉映射</li>
<li>比如对于tit和pap，对于tit所有的t对应p，所有的i对应a。对于pap所有的p对应t，所有的a对应i</li>
<li>同时遍历两个字符串，就去map中寻找 该字母是否有对应值（映射），</li>
<li>如果有就去查该映射的值是否与另一个字符串中对应位字母相同，如果不同就不是同构字符串<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() != t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">char</span>&gt; shash;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">char</span>&gt; thash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (shash.<span class="hljs-built_in">find</span>(s[i]) != shash.<span class="hljs-built_in">end</span>() &amp;&amp; shash[s[i]] != t[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (thash.<span class="hljs-built_in">find</span>(t[i]) != thash.<span class="hljs-built_in">end</span>() &amp;&amp; thash[t[i]] != s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        shash[s[i]] = t[i];<br>        thash[t[i]] = s[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素  "></a>存在重复元素  </h1><p><a href="https://leetcode-cn.com/problems/contains-duplicate/description/">Leetcode</a>给定一个整数数组，判断是否存在重复元素。<br>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。  </p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>哈希表建立每个数字出现的频率</li>
<li>大于1说明重复<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; frequence;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : nums)&#123;<br>        <span class="hljs-keyword">if</span>(++frequence[it] &gt; <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><p><a href="https://leetcode-cn.com/problems/valid-anagram/">leetcode</a>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;<br>输出: true<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>对字符串s建立字母的哈希频率表，再遍历t串，对应的字母频率-1，最后遍历哈希表，如果仍有字母频率不为0，说明有多余的字母。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() != t.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        hash[s[i]]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; t[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        hash[t[i]]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : hash) &#123;<br>        <span class="hljs-keyword">if</span> (it.second) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h1><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">leetcode</a>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>建立哈希表统计数字出现频率，</li>
<li>利用隐式转换，把无序hash转换为pair类型方便按照频率多少进行排序</li>
<li>使用SLT的sort()函数进行排序，大小的比较规则cmp函数需要自己写。</li>
<li>将排好序的前k元素输出<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; v1, pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; v2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> v1.second &gt; v2.second;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        hash[nums[i]]++;<br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">arr</span>(hash.<span class="hljs-built_in">begin</span>(), hash.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(arr[i].first);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h1><p><a href="https://leetcode-cn.com/problems/longest-palindrome/">leetcode</a>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。<br>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>根据题意，只需求出最长回文串的长度，而不需要找出最长回文串，所以我们只需利用回文串的特性，统计哪些字母出现了偶数次，哪些出现了奇数次，只需计算他们次数即可。</li>
<li>出现偶数次的字母一定是回文串的一部分，奇数次的字母只需-1次也能组成回文串，最后如果组成的回文串长度小于母串，还可以再再中间加一个字母组成回文串。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : s) &#123;<br>        hash[it]++;<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : hash) &#123;<br>       res += it.second % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? it.second : it.second - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res = res &lt; s.<span class="hljs-built_in">size</span>() ? res + <span class="hljs-number">1</span> : res ;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="根据字符出现频率排序"><a href="#根据字符出现频率排序" class="headerlink" title="根据字符出现频率排序"></a>根据字符出现频率排序</h1><p><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">leetcode</a>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>哈希表建立的频率表是无序的，所以需要转换为其他数据结构，再使用排序算法对其排序</li>
<li>可以使用隐式的类型转换为<code>pair&lt;char,int&gt;</code>，再使用STL里面的sort()函数进行排序，sort的好处是可以自定义排序的规则。</li>
<li>sort()函数自定义的排序规则需要写成静态的函数<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; a, pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;hash;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : s) &#123;<br>        hash[it]++;<br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">arr</span>(hash.<span class="hljs-built_in">begin</span>(), hash.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), cmp);<br>    string res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : arr) &#123;<br>        <span class="hljs-keyword">while</span> (it.second--) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(it.first);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="最长和谐子序列"><a href="#最长和谐子序列" class="headerlink" title="最长和谐子序列  "></a>最长和谐子序列  </h1><p><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/description/">Leetcode</a>  和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。<br>现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。    </p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [1,3,2,2,5,2,3,7]<br>输出: 5<br>原因: 最长的和谐数组是：[3,2,2,2,3].<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>找最长的长度，一定需要一个数字去记录当前最长值，并不断跟后面的数进行比较</li>
<li>统计数字出现频率，遍历哈希表的每一个key时，找当前key值大1的数也存不存在哈希表中，如果存在就相加与当前的max变量进行比较。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLHS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; hash;<br>    <span class="hljs-keyword">int</span> longest = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> it : nums) &#123;<br>        hash[it]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : hash) &#123;<br>        <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(it.first+<span class="hljs-number">1</span>) != hash.<span class="hljs-built_in">end</span>())&#123;<br>            longest = <span class="hljs-built_in">max</span>(longest, it.second + hash[it.first+<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> longest;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/posts/91a7e4d1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🐛双指针🐛"><a href="#🐛双指针🐛" class="headerlink" title="🐛双指针🐛"></a>🐛双指针🐛</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p>
<span id="more"></span>

<ul>
<li><a href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9">19. 删除链表的倒数第N个节点</a></li>
<li><a href="#%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB">75.颜色分类</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">88.合并两个有序数组</a></li>
<li><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">167.两数之和II-输入有序数组</a></li>
<li><a href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D">345.反转字符串中的元音字母</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D">524.通过删除字母匹配到字典里最长单词</a></li>
<li><a href="#%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C">633.平方数之和</a></li>
<li><a href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">647.回文子串</a></li>
<li><a href="#%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1">680.验证回文字符串Ⅱ</a></li>
<li><a href="#%E4%BB%85%E5%90%AB1%E7%9A%84%E5%AD%90%E4%B8%B2%E6%95%B0">5461.仅含1的子串数</a></li>
</ul>
<h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">leetcode</a>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>使用快慢指针，让快指针提前先走n+1步，然后双指针再同时让前走，当快指针指到结尾时，慢指针指向要删除结点得前驱  </li>
<li>为了让整个链表得删除操作都统一起来，所以加入了头节点<code>dummy</code>,因为删除某个结点得操作需要它得前驱，而第一个结点没有前驱，所以加入头结点会更方便，删除操作与其他结点统一。</li>
<li>链表所谓删除结点，即前一个结点得next指针越过此结点，指向下一结点<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode* slow = dummy;<br>    ListNode* fast = dummy;<br>    n++;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        fast = fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (fast) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next;<br>    &#125;<br>    slow-&gt;next = slow-&gt;next-&gt;next;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h1><p><a href="https://leetcode-cn.com/problems/sort-colors/">Leetcode</a>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。<br>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一共三个指针，p0一直指向0的后一位，p2一直指向2的前一位，cur是用于遍历的指针。</li>
<li>本题属于荷兰旗帜问题：思想是遇到0就跟p0所指的数交换位置，遇到2就跟p2所指的数交换位置，遇到1就跳过。</li>
<li>注意：遇到2交换完位置后，cur指针不前进，因为要再次判断交换过来的数是0还是1。</li>
<li>注意2：while结束是 <code>cur &lt; p2</code>而不是<code>cur &lt; nums.size()</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>, p2 = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur &lt; p2) &#123;<br>        <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">1</span>) cur++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(nums[p0++], nums[cur++]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">2</span>) <span class="hljs-built_in">swap</span>(nums[cur],nums[p2--]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">leetcode</a>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>合并有两种写法：while结束条件不同可分为写在while里和while外。</li>
<li>注意：数组的边界条件,对于链表指针<code>cur = NULL</code>为结束，而数组是<code>i = -1</code>和<code>i = size()</code>为结束。</li>
<li>思路：从后往前插入num1，两个指针分别从后往前遍历两个数组，较大值插入num1中。<h3 id="用-amp-amp-与作为结束条件"><a href="#用-amp-amp-与作为结束条件" class="headerlink" title="用&amp;&amp;与作为结束条件"></a>用&amp;&amp;与作为结束条件</h3></li>
<li>意思是：当两个数组其中一个遍历结束时，结束while循环，所以还需要将另一个数组的剩余部分依次插入nums1。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">int</span> m, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> p1 = m - <span class="hljs-number">1</span>, p2 = n - <span class="hljs-number">1</span>, cur = m + n - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> ( p1 &gt;= <span class="hljs-number">0</span> &amp;&amp; p2 &gt;= <span class="hljs-number">0</span>)&#123;<br>          nums1[cur--] = nums1[p1] &gt; nums2[p2] ? nums1[p1--] : nums2[p2--];<br>      &#125;<br>      <span class="hljs-keyword">if</span> (p1 &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">while</span> (p2 &gt;= <span class="hljs-number">0</span>)<br>              nums1[cur--] = nums2[p2--];<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<h3 id="用-或作为结束条件"><a href="#用-或作为结束条件" class="headerlink" title="用||或作为结束条件"></a>用||或作为结束条件</h3></li>
<li>意思是，只要当两个数组全部遍历完后，才结束while循环，所以再循环体内就要考虑其中一个遍历结束后的操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">int</span> m, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> p1 = m - <span class="hljs-number">1</span>, p2 = n - <span class="hljs-number">1</span>, cur = n + m - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(cur &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> (p1 &lt; <span class="hljs-number">0</span>) nums1[cur--] = nums2[p2--];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2 &lt; <span class="hljs-number">0</span>) nums1[cur--] = nums1[p1--];<br>        <span class="hljs-keyword">else</span> nums1[cur--] = nums1[p1] &gt; nums2[p2] ? nums1[p1--] : nums2[p2--];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="两数之和II-输入有序数组"><a href="#两数之和II-输入有序数组" class="headerlink" title="两数之和II-输入有序数组"></a>两数之和II-输入有序数组</h1><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">Leetcode</a>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>双指针相向遍历，</li>
<li>因为是有序数组，所以left指向小的数，right指向大的数，当两指针所指的数之和大于target，就前移right指针缩小大的数，当和小于target，就后移left指针，增大小的数。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] == target)&#123;<br>            <span class="hljs-keyword">return</span> &#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] &lt; target) &#123;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] &gt; target) &#123;<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="反转字符串中的元音字母"><a href="#反转字符串中的元音字母" class="headerlink" title="反转字符串中的元音字母"></a>反转字符串中的元音字母</h1><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">leetcode</a>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>首尾各一个指针，当都指向元音字母时，交换字符串<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isVolew</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;a&#x27;</span> || ch==<span class="hljs-string">&#x27;e&#x27;</span>||ch==<span class="hljs-string">&#x27;i&#x27;</span> || ch==<span class="hljs-string">&#x27;o&#x27;</span>||ch==<span class="hljs-string">&#x27;u&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;A&#x27;</span> || ch==<span class="hljs-string">&#x27;E&#x27;</span>||ch==<span class="hljs-string">&#x27;I&#x27;</span> || ch==<span class="hljs-string">&#x27;O&#x27;</span>||ch==<span class="hljs-string">&#x27;U&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">reverseVowels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isVolew</span>(s[left])) ++left;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isVolew</span>(s[right])) --right;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isVolew</span>(s[left]) &amp;&amp; <span class="hljs-built_in">isVolew</span>(s[right])) &#123;<br>            <span class="hljs-built_in">swap</span>(s[left++], s[right--]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="通过删除字母匹配到字典里最长单词"><a href="#通过删除字母匹配到字典里最长单词" class="headerlink" title="通过删除字母匹配到字典里最长单词"></a>通过删除字母匹配到字典里最长单词</h1><p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">leetcode</a>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入:<br>s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]<br>输出: <br>&quot;apple&quot;<br>输入:<br>s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<br>输出: <br>&quot;a&quot;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>核心时判断一个字符串是不是另一个字符串的子序列，注意这里是子序列而不是子串，子序列是指每个字母在母串中的前后顺序不变。</li>
<li>使用双指针判断子序列，2各指针指向两个串，相同字母时指针后移，不同字母时只有母串指针后移，直到结束，看另一个指针是否指向结尾。</li>
<li>根据题意，要寻找最长的，所以一定要有一个变量储存当前最长值，然后不断进行比较。</li>
<li>compare()函数可以根据字典顺序比较，&lt;0表示字典顺序在前<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">findLongestWord</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; d)</span> </span>&#123;<br>    string longest = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; d.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>        <span class="hljs-keyword">if</span>(d[i].<span class="hljs-built_in">size</span>() &lt; longest.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(d[i].<span class="hljs-built_in">size</span>() == longest.<span class="hljs-built_in">size</span>() &amp;&amp; longest.<span class="hljs-built_in">compare</span>(d[i]) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSub</span>(s, d[i])) longest = d[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> longest;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSub</span><span class="hljs-params">(string s,string d)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; d.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == d[j])&#123;<br>            i++;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j == d.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="平方数之和"><a href="#平方数之和" class="headerlink" title="平方数之和"></a>平方数之和</h1><p><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/">Leetcode</a>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。</p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>a,b可以为0，所以左指针从0开始而不是1，右指针sqrt(c)开始,效率高。</li>
<li>因为a和b可能是同一个数，所以while里的l可以=r。</li>
<li>考虑s可能溢出，所以用r使用long型。<h3 id="为什么防止s溢出要将r设置为long型："><a href="#为什么防止s溢出要将r设置为long型：" class="headerlink" title="为什么防止s溢出要将r设置为long型："></a>为什么防止s溢出要将r设置为long型：</h3></li>
<li>问题在于计算过程中溢出了，计算式完全是以int运算来执行的，并且只有在运算完成之后，其结果才被提升为 long，而此时已经太迟：计算已经溢出。</li>
<li>解决方法使计算表达式的其中一个因子明确为long型，这样可以强制表达式中所有的后续计算都用long运算来完成，防止溢出<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> right = <span class="hljs-built_in">sqrt</span>(c);<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> sum = left * left + right * right;<br>        <span class="hljs-keyword">if</span> (sum &lt; c) &#123;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; c) &#123;<br>            right--;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum == c)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h1><a href="https://leetcode-cn.com/problems/palindromic-substrings/">Leetcode</a>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;aaa&quot;<br>输出: 6<br>说明: 6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3></li>
<li>双指针应用：中心扩展</li>
<li>回文串特性：对称相同</li>
<li>回文串：奇数个数和偶数个数，因此有两种扩展：当前字符向两边扩展笔记，当前字符和下一个字符向两边扩展比较。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i)&#123;<br>         <span class="hljs-built_in">expand</span>(s, i, i+<span class="hljs-number">1</span>, cnt);<br>         <span class="hljs-built_in">expand</span>(s, i, i, cnt);<br>     &#125;<br>     <span class="hljs-keyword">return</span> cnt;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">expand</span><span class="hljs-params">(string s,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span>&amp; cnt)</span></span>&#123;<br>     <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[left] == s[right])&#123;<br>         left--;<br>         right++;<br>         cnt++;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="680-验证回文字符串Ⅱ"><a href="#680-验证回文字符串Ⅱ" class="headerlink" title="680.验证回文字符串Ⅱ"></a>680.验证回文字符串Ⅱ</h1><p><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">Leetcode</a><br>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>传统思路：遍历每个结点，判断剩余结点能否形成回文，时间复杂度O(n^2)</li>
<li>因为回文对称相等，所以从两头开始遍历，当遇到不相同时，再删除其中一个再进行判断</li>
<li>优化：一开始就是从两头遍历的，所以已经遍历过的地方一定是相等，所以在<code>isPalindrome()</code>函数中不用从两头再重复遍历<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (s[left] != s[right]) <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">isPalindrome</span>(s, left + <span class="hljs-number">1</span>, right) || <span class="hljs-built_in">isPalindrome</span>(s, left, right - <span class="hljs-number">1</span>);<br>        left++; right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (s[left] != s[right]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        left++;<br>        right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="仅含-1-的子串数"><a href="#仅含-1-的子串数" class="headerlink" title="仅含 1 的子串数"></a>仅含 1 的子串数</h1><p><a href="https://leetcode-cn.com/problems/number-of-substrings-with-only-1s/">leetcode</a><br>给你一个二进制字符串 s（仅由 ‘0’ 和 ‘1’ 组成的字符串）。<br>返回所有字符都为 1 的子字符串的数目。<br>由于答案可能很大，请你将它对 10^9 + 7 取模后返回。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;0110111&quot;<br>输出：9<br>解释：共有 9 个子字符串仅由 &#39;1&#39; 组成<br>&quot;1&quot; -&gt; 5 次<br>&quot;11&quot; -&gt; 3 次<br>&quot;111&quot; -&gt; 1 次<br><br></code></pre></td></tr></table></figure>

<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>刚开始想到用双指针，类似于滑动窗口的思想，每次窗口把连续的1框住，计算窗口中最大子串数。</li>
<li>滑动窗口思想，左右指针从0开始，先移动右指针，当右指针达到要求后，再移动左子针，直到左指针也满足一定要求，最后处理中间的字符，处理完继续移动右指针。</li>
<li>这里右指针的要求指向连续1的最后一位，即当<code>right</code>指向1，而<code>right+1</code>指向0,然后开始移动左子针，直到做指针指向第一个1停，至此形成一个窗口，处理结束后记得更新左指针。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSub</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (right + <span class="hljs-number">1</span> &lt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (s[right] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[right + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span> || <br>            s[right] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[right + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>            <span class="hljs-keyword">while</span> (s[left] == <span class="hljs-string">&#x27;0&#x27;</span>) left++;<br>            <span class="hljs-keyword">long</span> len = right - left + <span class="hljs-number">1</span>;<br>            res += (<span class="hljs-number">1</span> + len ) * len / <span class="hljs-number">2</span>;<br>            res %= <span class="hljs-number">1000000007</span>;<br>            left = right + <span class="hljs-number">1</span>;<br>        &#125;  <br>        right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>如果仔细发现当中的规律，1个1有1个子串，2个连续的有3个子串，3个连续的1有6个子串，n个连续的1有<code>1 + 2 + 3+...+n)</code>个子串,即连续1每当增加一个1就会多加len(1)个子串。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSub</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; ch : s) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            len++;<br>            res += len;<br>            res %= <span class="hljs-number">1000000007</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            len = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/posts/a80d0031.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🙈动态规划🙈"><a href="#🙈动态规划🙈" class="headerlink" title="🙈动态规划🙈"></a>🙈动态规划🙈</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p>
<span id="more"></span>

<p>==========</p>
<ul>
<li><a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">198.打家劫舍</a>  </li>
<li><a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII">213.打家劫舍II</a>  </li>
<li><a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII">337.打家劫舍III</a>  </li>
</ul>
<p>矩阵 (10%)</p>
<ul>
<li><a href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">120.三角形最小路径和</a>  </li>
<li><a href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">64.最小路径和</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">62.不同路径</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II">63.不同路径II</a></li>
</ul>
<p>序列(40%)</p>
<ul>
<li><a href="#%E7%88%AC%E6%A5%BC%E6%A2%AF">70.爬楼梯</a></li>
<li><a href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F">55.跳跃游戏</a></li>
<li><a href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII">45.跳跃游戏II</a></li>
<li><a href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2II">132.分割回文串II</a></li>
<li><a href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97">300.最长上升子序列</a></li>
<li><a href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">139.单词拆分</a>    </li>
<li><a href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">322.零钱兑换</a></li>
</ul>
<p>双序列(40%)</p>
<ul>
<li><a href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">1143.最长公共子序列</a></li>
<li><a href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">72.编辑距离</a>  </li>
<li><a href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">5.最长回文子串</a></li>
</ul>
<h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯  "></a>爬楼梯  </h1><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">Leetcode</a> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？  </p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>到达第n阶台阶有两种方式，一个是在第<code>n-1</code>个台阶处+1阶或在<code>n-2个</code>台阶处+2阶</li>
<li>建立一个dp数组，记录到达每一层时的所有方法总数</li>
<li>所以到达第n个台阶的方法与到底第<code>n-1</code>和<code>n-2</code>个台阶相关，<code>dp[n]=dp[n-1]+dp[n-2]</code><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)&#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) wayNums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i==<span class="hljs-number">1</span>) wayNums.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">else</span> wayNums.<span class="hljs-built_in">push_back</span>(dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h1><p><a href="https://leetcode-cn.com/problems/jump-game/">leetcode</a>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个位置。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>动态规划：建立一个bool类型的dp数组用来记录每个格子是否能够到达</li>
<li>当前格子能否到达与它前面的每个格子都有关系，所以需要遍历它前面的所有格子，只要有一个格子本身能够到达且也能够跳到当前格子，则当前格子就能到达。</li>
<li>本体使用动态规划的时间复杂度比较大,主要用于培养动规的思想。</li>
<li>针对力扣提交的用例，在遍历当前格子之前的格子时，从后往前遍历不容易超时。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            <span class="hljs-keyword">if</span> (dp[j] == <span class="hljs-literal">true</span> &amp;&amp; nums[j] &gt;= i - j) &#123;<br>                dp[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h1><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">leetcode</a>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>如果要用动规的思想去解决，那么需要建立一个记录达到每个格子的最小跳跃次数的dp数组，</li>
<li>当前格子的最少次数 = 它前面所有能到达当前位置的格子的步数最小值 + 1，所以还是要遍历当前格子之前的所以格子，时间复杂度会相当高，超过时间限制。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">int</span> less = <span class="hljs-number">0x3f3f3f3f</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;    <br>                <span class="hljs-keyword">if</span> (j + nums[j] &gt;= i) &#123;<br>                    less = <span class="hljs-built_in">min</span>(less, dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            dp[i] = less;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>还可以想办法继续优化，例如加上贪心的算法，因为既然有多个格子可以跳跃到当前格子，从最少跳跃次数的角度考虑，我当然希望是离当前格子最远的地方跳跃过来，也就是我们只需要正向遍历到第一个能够跳跃到当前格子的位置就行了。</li>
<li>当然用c++还是会超时间限制，可以用java<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; j + nums[j] &lt; i)  j++;<br>        dp[i] = dp[j] + <span class="hljs-number">1</span>;<br>    &#125;  <br>    <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="分割回文串-II"><a href="#分割回文串-II" class="headerlink" title="分割回文串 II"></a>分割回文串 II</h1><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">leetcode</a>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回符合要求的最少分割次数。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;aab&quot;<br>输出: 1<br>解释: 进行一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>首先建立dp数组，记录每到一个字母，和它前面所组成的字符串，能使每个子串都是回文串最少分割次数。</li>
<li>动态规划的思路就是，找到当前<code>dp[i]</code>的值与<code>dp[i-1]、dp[i-2].....</code>有怎么的联系</li>
<li>对于本题，通过遍历<code>i</code>之前的所有下标<code>j</code>，找到所有能和<code>i</code>组成回文串的<code>j</code>下标，在这么多能和i组成的回文串的<code>j</code>下标中，通过比较找出最少分割数的dp[j],再+1就是当前位置dp[i]的值.</li>
<li>如果一整个串就是一个回文串，那么最小分割数自然为0</li>
<li>下面的代码会超时，主要学习动规的思路，可以通过优化判断回文串isPalindrome()的方法。这里只用了最简单的方式。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size(), <span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, <span class="hljs-number">0</span>, i))&#123;<br>            dp[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= <span class="hljs-number">0</span>; --j)&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, j, i))&#123;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(right == left) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (s[left] != s[right]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        left++, right--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><p><a href="https://leetcode-cn.com/problems/house-robber/">Leetcode</a> 计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。  在不触动警报装置的情况下，能够偷窃到的最高金额。  </p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>dp数组储存抢劫每户时的最大抢劫量，dp[i]表示抢到第i个房间时的最大抢劫量</li>
<li>因为不能相邻抢劫，所以如果抢劫了<code>i-1</code>户，就不能抢劫第i户，或者是<code>i-2</code>户再加上当前户<code>i</code></li>
<li><code>dp[i]=max(dp[i-1],dp[i-2]+nums[i])</code>;</li>
<li>dp数组第一个值和第二个值分别为<code>nums[0]</code>和<code>max(nums[0].nums[1])</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp.<span class="hljs-built_in">push_back</span>(nums[<span class="hljs-number">0</span>]);           <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) dp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]));<br>        <span class="hljs-keyword">else</span> dp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II  "></a>打家劫舍II  </h1><p>所有的房屋都围成一圈.<br><a href="https://leetcode-cn.com/problems/house-robber-ii/">Leetcode</a>  </p>
<ul>
<li>打劫问题升级版，因为是环形的，所以多了一个限制条件：</li>
<li>如果从第一户开始偷，那么最后一户就不能偷，下标:<code>0~n-2</code></li>
<li>如果从第二户开始偷，最后一户就可以偷，下标为:<code>1~n-1</code></li>
<li>环形问题分解为两条子序列，子序列使用动态规划，比较者最大值<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">rob</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>),<span class="hljs-built_in">rob</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp;nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-comment">//根据left和right确定开辟dp数组的大小</span><br>    <span class="hljs-keyword">int</span> cnt = left - right + <span class="hljs-number">1</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dp;<br>    <span class="hljs-comment">//cur是dp数组的下标，不是nums的下标，cur从0，即dp的第一元素开始</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>; cur &lt; cnt; cur++)&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) dp.<span class="hljs-built_in">push_back</span>(nums[left]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur ==<span class="hljs-number">1</span>) dp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">max</span>(nums[left], nums[left + <span class="hljs-number">1</span>]));<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//max里比的是dp数组里的值，不是nums数组的</span><br>            dp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">max</span>(dp[cur - <span class="hljs-number">1</span>], dp[cur - <span class="hljs-number">2</span>] + nums[left + cur]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h1><p><a href="https://leetcode-cn.com/problems/house-robber-iii/">Leetcode</a>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。<br>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。  </p>
<h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>树形动态规划问题</li>
<li>首先要明确相邻的节点不能偷，也就是’爷爷’选择偷，’儿子’就不能偷了，但是’孙子’可以偷</li>
<li>二叉树只有左右两个孩子，1个’爷爷’最多 2 个’儿子’，4 个’孙子’</li>
<li>4 个’孙子’偷的钱 + ‘爷爷’的钱 VS 两个’儿子’偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root = <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> money = root-&gt;val;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) money += <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left) + <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) money += <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left) + <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(money, <span class="hljs-built_in">rob</span>(root-&gt;left) + <span class="hljs-built_in">rob</span>(root-&gt;right)); <br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="建立dp缓存的动态规划"><a href="#建立dp缓存的动态规划" class="headerlink" title="建立dp缓存的动态规划"></a>建立dp缓存的动态规划</h2><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>我们发现’爷爷’在计算自己能偷多少钱的时候，同时计算了 4 个’孙子’能偷多少钱，也计算了 2 个’儿子’能偷多少钱。这样在’儿子’当’爷爷’时，就会产生重复计算一遍’孙子’节点</li>
<li>动态规划的关键优化点 ‘重复子问题’</li>
<li>使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。</li>
<li>由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value,记录每个计算过得结点值<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    unordered_map&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt;dp;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rob</span>(root, dp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root, unordered_map&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; dp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (dp.<span class="hljs-built_in">count</span>(root) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[root];<br>    <span class="hljs-keyword">int</span> money=root-&gt;val;<br>    <span class="hljs-keyword">if</span> (root-&gt;left) money += <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left, dp) + <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right, dp);<br>    <span class="hljs-keyword">if</span> (root-&gt;right) money += <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left, dp) + <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right, dp);<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">max</span>(money,<span class="hljs-built_in">rob</span>(root-&gt;left,dp) + <span class="hljs-built_in">rob</span>(root-&gt;right, dp));<br>    dp[root] = res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
终极解法</li>
</ul>
<hr>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>上面两种解法用到了’孙子’节点，计算’爷爷’节点能偷的钱还要同时去计算’孙子’节点投的钱</li>
<li>每个节点储存偷或者不偷两种状态得最大值</li>
<li>我们使用一个大小为 2 的数组来表示,下标0存不偷的值，下标1存偷的值</li>
<li>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱</li>
<li>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</li>
<li>自下而上选择后序遍历<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    res = <span class="hljs-built_in">postOrder</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; left = <span class="hljs-built_in">postOrder</span>(root-&gt;left);<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; right = <span class="hljs-built_in">postOrder</span>(root-&gt;right);<br>    res[<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>    res[<span class="hljs-number">1</span>] = root-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h1><p><a href="https://leetcode-cn.com/problems/triangle/">leetcode</a>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<br>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>自顶向下，所以每一行的元素都与上一行的元素有关，第一行除外，所以遍历从第二行开始</li>
<li>建立dp数组，dp[i][j]表示到达此此处的最小路径和，dp数组中最后一行的最小值即为所求。</li>
<li>公式：每一项都与他的上一行有关<code>dp[i][j] = min(dp[i-1][j] + dp[i-1][j]) + triangle[i][j]</code></li>
<li>需要考虑边界，因为时三角形的，例如每一行的第0个元素，他的上一行没有<code>0-1</code>的元素;还有每一行的最后一个第i元素，他的上一行只有<code>i-1</code>这个元素。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = triangle.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,vector&lt;<span class="hljs-keyword">int</span>&gt;(len,<span class="hljs-number">0x3f3f3f3f</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; triangle[i].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + triangle[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == i) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + triangle[i][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) + triangle[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(dp[len<span class="hljs-number">-1</span>].<span class="hljs-built_in">begin</span>(), dp[len<span class="hljs-number">-1</span>].<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> dp[len<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3></li>
<li>自底向上，所以每一个元素都与下一行的元素有关，最后一行除外，所以遍历从倒数第二行开始</li>
<li>公式：<code>dp[i][j] = min(dp[i+i][j], dp[i+1][j]) + triangle[i][j]</code></li>
<li>因为是三角形，边界的元素在下一行必有相邻的元素存在，所以免去了边界检测。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;<br>    <span class="hljs-comment">// 自底向上</span><br>    <span class="hljs-comment">// 从倒数第二行开始</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = triangle.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; triangle[i].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            triangle[i][j] += <span class="hljs-built_in">min</span>(triangle[i+<span class="hljs-number">1</span>][j], triangle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h1><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">leetcode</a>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1 的总和最小。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>上一题是三角形，这一题变矩形，首先考虑自左上角到右下角，那么每个元素的最小路径和都与他的上一个元素或者左边的元素有关，但是考虑到边界，第一列和第一行的元素并没有左或者上面的于元素，所以需要单独考虑，同时第一个元素左和上都没有，也需要单独考虑。</li>
<li>剩下的元素公式为：<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];</code><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(row, vector&lt;<span class="hljs-keyword">int</span>&gt;(col, <span class="hljs-number">0x3f3f3f3f</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span>      (i == <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span>)  dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] + grid[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> &amp;&amp; i &gt; <span class="hljs-number">0</span>)  dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + grid[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) dp[i][j] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[row<span class="hljs-number">-1</span>][col <span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3></li>
<li>如果是自右下至左上，对于本题仍然有边界需要考虑，每个元素的最小路径和都与他的右边和下边的值有关，但是对于最后一行和最后一列并没有下或者右边的值，需要单独考虑，最右下角的值右和下都没有，更需要单独考虑</li>
<li>对于其他元素,可以不用建立dp数组的方式实现，取他的右和下最小值相加：<code>grid[i][j] += min(grid[i+1][j], grid[i][j+1]);</code><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            <span class="hljs-keyword">if</span> (i == row<span class="hljs-number">-1</span> &amp;&amp; j == col<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == row<span class="hljs-number">-1</span>) grid[i][j] += grid[i][j+<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == col<span class="hljs-number">-1</span>) grid[i][j] += grid[i+<span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span> grid[i][j] += <span class="hljs-built_in">min</span>(grid[i+<span class="hljs-number">1</span>][j], grid[i][j+<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h1><p><a href="https://leetcode-cn.com/problems/unique-paths/">leetcode</a>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>问总共有多少条不同的路径？</p>
<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>此题是上一题<a href="#%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">最小路径和</a>的简易版,这里就只写了一种自右下至左上的思路</li>
<li>需要一个dp数组来记录到某个格子的所有路径个数，因为是自右下往左上，所以每个格子都可以从他的右边或者下面到达，所以这个格子的路径数就等于他下面和右边格子路径数之和。</li>
<li>大部分格子的公式:dp[i][j] = dp[i+1][j] + dp[i][j+1];但是又边界的考虑，例如最后一列和最后一行的格子没有右或者下面的格子，就必须单独考虑。最右下角的格子右边和下面都没有，更需要拎出来单独考虑了。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,vector&lt;<span class="hljs-keyword">int</span>&gt;(n,<span class="hljs-number">0x3f3f3f3f</span>));<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m<span class="hljs-number">-1</span>; i &gt;=<span class="hljs-number">0</span>; --i) &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>           <span class="hljs-keyword">if</span> (i == m<span class="hljs-number">-1</span> &amp;&amp; j == n<span class="hljs-number">-1</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == m<span class="hljs-number">-1</span>) dp[i][j] = dp[i][j+<span class="hljs-number">1</span>];<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n<span class="hljs-number">-1</span>) dp[i][j] = dp[i+<span class="hljs-number">1</span>][j];<br>           <span class="hljs-keyword">else</span> dp[i][j] = dp[i+<span class="hljs-number">1</span>][j] + dp[i][j+<span class="hljs-number">1</span>];<br>       &#125;<br>   &#125; <br>   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a>不同路径 II</h1><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">leetcode</a>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>输出: 2<br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：<br>1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br>2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>此题就体现出了从右下往左上建立dp表的优势，因为障碍物的出现只会影响上面和左边的格子，但是因为遍历的顺序是从右下往左上，所以一定是先遍历到障碍物的格子，之后才会遍历到被它所影响到的格子。</li>
<li>既然是先遍历到障碍物，那直接将其在dp数组中的路径数设为0，对于被他影响的格子就相当于此路不通，不走这个障碍物格子。</li>
<li>其他正常的格子路径还是：<code>dp[i][j] = dp[i+1][j] + dp[i][j+1];</code></li>
<li>对于两个边界：最后一列的格子:<code>dp[i][j] = dp[i+1][j];</code>,最后一行的格子<code>dp[i][j] = dp[i][j+1];</code><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> row = obstacleGrid.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-keyword">int</span> col = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>   vector&lt;vector&lt;<span class="hljs-keyword">long</span>&gt;&gt; <span class="hljs-built_in">dp</span>(row,vector&lt;<span class="hljs-keyword">long</span>&gt;(col,<span class="hljs-number">0x3f3f3f3f</span>));<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row<span class="hljs-number">-1</span>; i &gt;=<span class="hljs-number">0</span>; --i) &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>           <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>)  &#123;dp[i][j] = <span class="hljs-number">0</span>; <span class="hljs-keyword">continue</span>;&#125;<br>           <span class="hljs-keyword">if</span> (i == row<span class="hljs-number">-1</span> &amp;&amp; j == col<span class="hljs-number">-1</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == row<span class="hljs-number">-1</span>) dp[i][j] = dp[i][j+<span class="hljs-number">1</span>];<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == col<span class="hljs-number">-1</span>) dp[i][j] = dp[i+<span class="hljs-number">1</span>][j];<br>           <span class="hljs-keyword">else</span> dp[i][j] = dp[i+<span class="hljs-number">1</span>][j] + dp[i][j+<span class="hljs-number">1</span>];<br>       &#125;<br>   &#125; <br>   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">leetcode</a>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [10,9,2,5,3,7,101,18]<br>输出: 4 <br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>使用暴力法动态规划：定义dp[i] 为考虑前 i 个元素，必须以第 i个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取为最长上升子序列之中。</li>
<li>所以状态转移方程为:<code> dp[i] = max(dp[j], dp[j-1].......） + 1</code> 其中j表示i之前的所以元素。</li>
<li>因为是升序序列，j在i之前，所以一定<code>nums[j] &lt; nums[i]</code> 才行。</li>
<li>注意返回值不在是<code>dp[nums.size()-1]</code>，而是dp数组中的最大值，因为dp[i]代表的是以nums[i]为序列结尾的最长个数。实际最长的序列不一定是以最后一个数字<code>nums[size()-1]</code>为结尾的。</li>
<li><code>max_element()</code>在头文件 <code>#include &lt;algorithm&gt;</code> 中，返回的是迭代器，所以输出值的话要在前面加 *,默认是从小到大排列.<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size() , <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i])&#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h1><p><a href="https://leetcode-cn.com/problems/word-break/">leetcode</a>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p>
<h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]<br>输出: true<br>解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。<br>输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]<br>输出: true<br>解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。<br>     注意你可以重复使用字典中的单词。<br><br></code></pre></td></tr></table></figure>


<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">leetcode</a>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。<br>若这两个字符串没有公共子序列，则返回 0。</p>
<h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; <br>输出：3  <br>解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>动规面试题高频题型，最长公共子序列（Longest Common Subsequence，简称 LCS）</li>
<li>对于子序列类型的问题，暴力点就是穷举问题，而动态规划算法做的就是穷举 + 剪枝，所以可以说只要涉及子序列问题，基本上就是动规解决</li>
<li>因为两个字符串就要建立一个dp table来解决，首先明白dp数组的含义是<code>dp[i][j]</code>表示：对于 <code>s1[1..i]</code> 和 <code>s2[1..j]</code>，它们的 LCS 长度是 <code>dp[i][j]</code>。</li>
<li>由于两个字符串有可能其中一个是空串，所以dp数组还需要多加一列和一行，他们的dp[i][j]永远是0，因为是空串，永远不会有lcs。所以之后i和j的遍历时从1开始.szie()结束。</li>
<li>状态转移方程，二维的dp table，每个状态值都是由前面的三个状态影响：<code>dp[i][j] = (dp[i-1][j], dp[i][j-1], dp[i-1][j-1)</code></li>
<li>还要明白，如果一个字母，两个串都有，那么他一定属于LCS，LCS长度就要+1。</li>
<li>i和j指针所指的如果不相等，那么就取前面两个状态的最大值即可。</li>
<li>超详细原理请参考其他大佬的：<a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/">动态规划之最长公共子序列</a><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len1 = text1.<span class="hljs-built_in">size</span>(); <br>    <span class="hljs-keyword">int</span> len2 = text2.<span class="hljs-built_in">size</span>(); <br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(len1 + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(len2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len1 + <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; len2 + <span class="hljs-number">1</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>]) &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len1][len2];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p><a href="https://leetcode-cn.com/problems/edit-distance/">leetcode</a>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<h3 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;<br>输出：3<br>解释：<br>horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)<br>rorse -&gt; rose (删除 &#39;r&#39;)<br>rose -&gt; ros (删除 &#39;e&#39;)<br><br></code></pre></td></tr></table></figure>

<h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>参考大佬的解题思路：<a href="https://leetcode-cn.com/problems/edit-distance/solution/zi-di-xiang-shang-he-zi-ding-xiang-xia-by-powcai-3/">powcai</a></li>
<li><code>dp[i][j]</code> 代表 <code>word1</code> 到 <code>i</code> 位置转换成 <code>word2</code> 到<code> j</code> 位置需要最少步数</li>
<li>当 <code>word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；</code></li>
<li>当 <code>word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code></li>
<li>因为我们要将<code>word1</code>变为<code>word2</code>,也就是用删除，增加，替换操作将<code>word1</code>的每个字母变成<code>word2</code>的字母</li>
<li>说明 更容易理解些： dp[i-1][j-1]到dp[i][j]需要进行替换操作，dp[i-1][j]到d[i][j]需要进行删除操作，dp[i][j-1] 到d[i][j]需要进行添加操作。</li>
<li>dp table第一行，是 <code>word1</code> 为空变成 <code>word2</code> 最少步数，就是插入操作</li>
<li>第一列，是 <code>word2</code> 为空，需要的最少步数，就是删除操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len1 = word1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> len2 = word2.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(len1 + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(len2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len1 + <span class="hljs-number">1</span>; ++i) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len2 + <span class="hljs-number">1</span>; ++i) &#123;<br>        dp[<span class="hljs-number">0</span>][i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len1 + <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; len2 + <span class="hljs-number">1</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>]) &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><p><a href="https://leetcode-cn.com/problems/coin-change/">leetcode</a>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> coin : coins) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; coin) <span class="hljs-keyword">continue</span>;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i-coin] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">0x3f3f3f3f</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">leetcode</a><br>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>动态规划，要想知道长度为n的字符串是否是回文，需要先了解长度n-2的字符串是否是回文，同时首尾的字符也必须相等才行。</li>
<li><code>dp[i][j] = dp[i + 1][j - 1] &amp;&amp; s[i] == s[j]</code> 表示从第i个字符开始到第j个字符结束</li>
<li>判断长得字符串是否回文需要先判断短得字符串是否成立，所以必须从长度 <code>len = 0</code> 开始遍历建立dp数组。</li>
<li>边界条件1，长度为1即len = 0时，一个字母一定是回文串，所以为true</li>
<li>边界条件2，长度为2即len = 1时，两个字母只有相等时才是true<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n ,<span class="hljs-literal">false</span>));<br>    string res;<br>    <span class="hljs-keyword">int</span> MAX = INT_MIN;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>; len &lt; n; ++len) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + len &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> j = i + len;<br>            <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) dp[i][j] = (s[i] == s[j]);<br>            <span class="hljs-keyword">else</span> dp[i][j] = (s[i] == s[j] &amp;&amp; dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; len + <span class="hljs-number">1</span> &gt; MAX) &#123;<br>                MAX = len + <span class="hljs-number">1</span>;<br>                res = s.<span class="hljs-built_in">substr</span>(i, len + <span class="hljs-number">1</span>); <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣周赛</title>
    <url>/posts/f5327a3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="力扣周赛"><a href="#力扣周赛" class="headerlink" title="力扣周赛"></a>力扣周赛</h1><span id="more"></span>



<h3 id="第200场周赛"><a href="#第200场周赛" class="headerlink" title="第200场周赛"></a>第200场周赛</h3><ul>
<li><a href="#5475.%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84">5475.统计好三元组</a></li>
<li><a href="#5476.%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F%E7%9A%84%E8%B5%A2%E5%AE%B6">5476.找出数组游戏的赢家</a></li>
<li><a href="#5477.%E6%8E%92%E5%B8%83%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BD%91%E6%A0%BC%E7%9A%84%E6%9C%80%E5%B0%91%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0">5477.排布二进制网格的最少交换次数</a></li>
</ul>
<h1 id="5475-统计好三元组"><a href="#5475-统计好三元组" class="headerlink" title="5475.统计好三元组"></a>5475.统计好三元组</h1><p><a href="https://leetcode-cn.com/problems/count-good-triplets/">leetcode</a><br>给你一个整数数组 arr ，以及 a、b 、c 三个整数。请你统计其中好三元组的数量。<br>如果三元组 (arr[i], arr[j], arr[k]) 满足下列全部条件，则认为它是一个 好三元组 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">0 &lt;&#x3D; i &lt; j &lt; k &lt; arr.length<br>|arr[i] - arr[j]| &lt;&#x3D; a<br>|arr[j] - arr[k]| &lt;&#x3D; b<br>|arr[i] - arr[k]| &lt;&#x3D; c<br>其中 |x| 表示 x 的绝对值。<br></code></pre></td></tr></table></figure>
<p>返回 好三元组的数量 。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>暴力就完事了,在<code>i &lt; j &lt; k</code>统计满足条件的次数<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countGoodTriplets</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j + <span class="hljs-number">1</span>; k &lt; n; ++k) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(arr[i] - arr[j]) &lt;= a &amp;&amp;<br>                    <span class="hljs-built_in">abs</span>(arr[j] - arr[k]) &lt;= b &amp;&amp;<br>                    <span class="hljs-built_in">abs</span>(arr[i] - arr[k]) &lt;= c)<br>                cnt++;   <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="5476-找出数组游戏的赢家"><a href="#5476-找出数组游戏的赢家" class="headerlink" title="5476.找出数组游戏的赢家"></a>5476.找出数组游戏的赢家</h1><p><a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/">leetcode</a><br>给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。<br>每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。<br>返回赢得比赛的整数。<br>题目数据 保证 游戏存在赢家。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：arr &#x3D; [2,1,3,5,4,6,7], k &#x3D; 2<br>输出：5<br>解释：一起看一下本场游戏每回合的情况：<br>因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。<br></code></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/30/q-example.png" alt="tu"></p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>取第一个数为当前值，统计当前值之后有多少个数小于它，如果正好有k个就返回它</li>
<li>一旦后面有一个数大于当前值，就重新更新次数和当前值。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getWinner</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> num = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (num &gt; arr[i]) &#123;<br>            cnt++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            num = arr[i];<br>            cnt = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt == k) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li>双向队列模拟操作</li>
<li>先判断如果k值过大，可以直接返回数组中的最大值</li>
<li>定义一个记录每个数连胜次数的cnt数组</li>
<li>每次操作先取出队列的第一个数作为当前值，如果此时的队列头部元素小于当前值就pop出push到尾部<br>当前值得连胜记录<code>cnt++</code>,如果满足k就返回当前值</li>
<li>如果队列头部元素大于当前值，就将当前值push到队尾，同时将头部元素的连胜记录更新为1，更新当前元素。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getWinner</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k &gt; arr.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> arr[arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt; que;<br>    que.<span class="hljs-built_in">assign</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">int</span> cur = que.<span class="hljs-built_in">front</span>();<br>    <span class="hljs-keyword">int</span>* cnt = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">1000000</span>);<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">1000000</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        que.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">while</span> (cur &gt; que.<span class="hljs-built_in">front</span>()) &#123;<br>            ++cnt[cur];<br>            <span class="hljs-keyword">if</span> (cnt[cur] == k) <span class="hljs-keyword">return</span> cur;<br>            que.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>());<br>            que.<span class="hljs-built_in">pop_front</span>();<br>        &#125; <br>        que.<span class="hljs-built_in">push_back</span>(cur);<br>        cnt[que.<span class="hljs-built_in">front</span>()] = <span class="hljs-number">1</span>;<br>        cur = que.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="5477-排布二进制网格的最少交换次数"><a href="#5477-排布二进制网格的最少交换次数" class="headerlink" title="5477.排布二进制网格的最少交换次数"></a>5477.排布二进制网格的最少交换次数</h1><p><a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/">leetcode</a><br>给你一个 n x n 的二进制网格 grid，每一次操作中，你可以选择网格的 相邻两行 进行交换。<br>一个符合要求的网格需要满足主对角线以上的格子全部都是 0 。<br>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 -1 。<br>主对角线指的是从 (1, 1) 到 (n, n) 的这些格子。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：grid &#x3D; [[0,0,1],[1,1,0],[1,0,0]]<br>输出：3<br></code></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/02/fw.jpg" alt="tu"></p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>统计行末尾连续出现0的次数，然后进行排序，从上到下每行至少应该满足<code>col - 1 - i</code>个0</li>
<li>然后使用贪心思想来模拟交换的过程，统计需要交换行的次数</li>
<li>遍历每行，检查当前行末尾0个数是否满足条件，满足就跳过</li>
<li>如果不满足，就从当前行以下找满足条件的行的下标。如果找到了就开始往上交换，顺便统计次数，如果发现遍历到最后一行都没有发现满足条件的就返回-1没有找到。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSwaps</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> cnt[row];<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * row);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = col - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">0</span>) &#123;<br>                cnt[i]++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 贪心 + 模拟</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(cnt[i] &gt;= col - i - <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> j = i; <br>            <span class="hljs-keyword">while</span> (j &lt; row &amp;&amp; cnt[j] &lt; col - i - <span class="hljs-number">1</span>) j++;<br>            <span class="hljs-keyword">if</span>(j == row) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>            <span class="hljs-keyword">while</span> (j &gt; i) &#123;<br>                <span class="hljs-built_in">swap</span>(cnt[j], cnt[j - <span class="hljs-number">1</span>]); <br>                res++; <br>                j--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>🎨剑指offer🎨</title>
    <url>/posts/234402f4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🎨剑指offer🎨"><a href="#🎨剑指offer🎨" class="headerlink" title="🎨剑指offer🎨"></a>🎨剑指offer🎨</h1><span id="more"></span>



<ul>
<li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">1.数组中重复的数字</a></li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">2.二维数组中的查找</a></li>
<li><a href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">3.替换空格</a></li>
<li><a href="#%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">4.从尾到头打印链表</a></li>
<li><a href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">5.重建二叉树</a></li>
<li><a href="#%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">6.用两个栈实现队列</a></li>
<li><a href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">7.斐波那契数列</a></li>
<li><a href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98">8.青蛙跳台阶问题</a></li>
<li><a href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">9.旋转数组的最小数字</a></li>
<li><a href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">10.矩阵中的路径</a></li>
<li><a href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4">11.机器人的运动范围</a></li>
<li><a href="#%E5%89%AA%E7%BB%B3%E5%AD%90">12.剪绳子</a></li>
<li><a href="#%E5%89%AA%E7%BB%B3%E5%AD%90II">13.剪绳子II</a></li>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">14.二进制中1的个数</a></li>
<li><a href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9">15.数值的整数次方</a></li>
<li><a href="#%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0">16.打印从1到最大的n位数</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9">17.删除链表的节点</a></li>
<li><a href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2">18.调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">19.链表中倒数第k个节点</a></li>
<li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">20.反转链表</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">21.合并两个排序的链表</a></li>
<li><a href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">22.树的子结构</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F">23.二叉树的镜像</a></li>
<li><a href="#%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91">24.对称的二叉树</a></li>
<li><a href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5">25.顺时针打印矩阵</a></li>
<li><a href="#%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88">26.包含min函数的栈</a></li>
<li><a href="#%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97">27.栈的压入、弹出序列</a></li>
<li><a href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">28.从上到下打印二叉树</a></li>
<li><a href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91II">29.从上到下打印二叉树II</a></li>
<li><a href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91III">30.从上到下打印二叉树III</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97">31.二叉搜索树的后序遍历序列</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84">32.二叉树中和为某一值的路径</a></li>
<li><a href="#%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">33.复杂链表的复制</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">34.二叉搜索树与双向链表</a></li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91">35.序列化二叉树</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97">36.字符串的排列</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97">37.数组中出现次数超过一半的数字</a></li>
<li><a href="#%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0">38.最小的k个数</a></li>
<li><a href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">39.连续子数组的最大和</a></li>
<li><a href>40.连续子数组的最大和</a></li>
<li><a href="#1%EF%BD%9En%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">41.1～n整数中1出现的次数</a></li>
<li><a href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0">42.把数组排成最小的数</a></li>
<li><a href="#%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2">43.把数字翻译成字符串</a></li>
<li><a href="#%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC">44.礼物的最大价值</a></li>
<li><a href="#%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2">45.最长不含重复字符的子字符串</a></li>
<li><a href="#%E4%B8%91%E6%95%B0">46.丑数</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6">47.第一个只出现一次的字符</a></li>
<li><a href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9">48.两个链表的第一个公共节点</a></li>
<li><a href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97I">49.在排序数组中查找数字I</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9">50.二叉搜索树的第k大节点</a></li>
<li><a href="#0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97">51.0～n-1中缺失的数字</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">52.二叉树的深度</a></li>
<li><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">53.平衡二叉树</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0">54.数组中数字出现的次数</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0II">55.数组中数字出现的次数II</a></li>
<li><a href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97">56.和为s的两个数字</a></li>
<li><a href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97">57.和为s的连续正数序列</a></li>
<li><a href="#%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F">58.翻转单词顺序</a></li>
<li><a href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">59.左旋转字符串</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC">60.滑动窗口的最大值</a></li>
<li><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC">61.队列的最大值</a></li>
<li><a href="#n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0">62.n个骰子的点数</a></li>
<li><a href="#%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90">63.扑克牌中的顺子</a></li>
<li><a href="#%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97">64.圆圈中最后剩下的数字</a></li>
<li><a href="#%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6">65.股票的最大利润</a></li>
<li><a href="#%E6%B1%821+2+%E2%80%A6+n">66.求1+2+…+n</a></li>
<li><a href="#%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95">67.不用加减乘除做加法</a></li>
<li><a href="#%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84">68.构建乘积数组</a></li>
<li><a href="#%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0">69.把字符串转换成整数</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">70.二叉搜索树的最近公共祖先</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">71.二叉树的最近公共祖先</a></li>
<li><a href="#%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97">72.数字序列中某一位的数字</a></li>
</ul>
<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">leetcode</a> 找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h3 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h3><ul>
<li>建立哈希表或者数组记录数字出现次数，大于1就返回<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> cnt[<span class="hljs-number">100000</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cnt[nums[i]]++;<br>        <span class="hljs-keyword">if</span> (cnt[nums[i]] &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h3></li>
<li>先排序，遍历发现前后两个值一样，就是重复的数<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[i <span class="hljs-number">-1</span> ]) <span class="hljs-keyword">return</span> nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">leetcode</a>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一般规律性很强的矩阵，数列，一定要找一个关键位置的数字，作为比较，用这个数字能够完成一部分筛选</li>
<li>例如本题的左下角，因为他是本行的最小值，所以如果<code>target</code>比他还要小，说明target一定不在此行。他又是本列的最大值，如果<code>target</code>比他还要大，那target一定不在这一列。通过这样可以筛选掉一行或者一列。</li>
<li>直到左下角的值等于target时结束。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (matrix[row][col] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target) row--;<br>        <span class="hljs-keyword">else</span> col++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>方法二：因为是有序数组，就想到二分查找，每一行都使用二分法找target,但是此方法没有利用列得有序性  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> row = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(matrix, i, target)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix[row].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (matrix[row][mid] &lt; target) left = mid + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][mid] &gt; target) right = mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][mid] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> matrix[row][left] == target;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">leetcode</a>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;We are happy.&quot;<br>输出：&quot;We%20are%20happy.&quot;<br></code></pre></td></tr></table></figure>
<p>限制：<br>0 &lt;= s 的长度 &lt;= 10000</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>方法1：遍历找到空格，删除空格，插入新字符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            s.<span class="hljs-built_in">erase</span>(i, <span class="hljs-number">1</span>);<br>            s.<span class="hljs-built_in">insert</span>(i, <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;%20&quot;</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>方法2：使用额外空间，创建空字符，遇到空格就push新字符，非空格push正常字符。</li>
<li>注意 <code>？a ：b</code>运算符中a和b必须属于同一类型，<code>“%20”</code>是const char*类型，而<code>ch</code>属于char类型，只能用以下形式来写。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : s) <br>        ans = (ch == <span class="hljs-string">&#x27; &#x27;</span>) ? ans + <span class="hljs-string">&quot;%20&quot;</span> : ans + ch ;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br>    string res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            res += <span class="hljs-string">&quot;%20&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res += s[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>如果面试官要求不能使用额外得空间，实现原地修改，可以先统计空格数量，再原字符串后添加足够长得空间<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) cnt++;<br>    &#125;<br>    s += <span class="hljs-built_in">string</span>(cnt * <span class="hljs-number">2</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-keyword">int</span> p1 = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> p2 = len - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p2 &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (s[p2] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            s[p1--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            s[p1--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            s[p1--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            s[p1--] = s[p2];<br>        &#125;<br>        p2--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">leetcode</a>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>反转一般想到头插法或者栈实现<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>     ListNode* pre = <span class="hljs-literal">NULL</span>;<br>     ListNode* cur = head;<br>     <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>         ListNode * tmp = cur-&gt;next;<br>         cur-&gt;next = pre;<br>         pre = cur;<br>         cur = tmp;<br>     &#125;<br>     vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>     <span class="hljs-keyword">while</span> (pre != <span class="hljs-literal">NULL</span>) &#123;<br>         res.<span class="hljs-built_in">push_back</span>(pre-&gt;val);<br>         pre = pre-&gt;next;<br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125; <br></code></pre></td></tr></table></figure></li>
<li>用栈反转<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; sck;<br>    <span class="hljs-keyword">while</span> (head) &#123;<br>        sck.<span class="hljs-built_in">push</span>(head-&gt;val);<br>        head = head-&gt;next;<br>    &#125;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span> (!sck.<span class="hljs-built_in">empty</span>()) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(sck.<span class="hljs-built_in">top</span>());<br>        sck.<span class="hljs-built_in">pop</span>(); <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>最low 的方法是用遍历链表，输出每个结点的值到数组中，然后用reverse()进行反转。  </li>
</ul>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">leetcode</a>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">前序遍历 preorder &#x3D; [3,9,20,15,7]<br>中序遍历 inorder &#x3D; [9,3,15,20,7]<br></code></pre></td></tr></table></figure>
<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">  3<br> &#x2F; \<br>9  20<br>  &#x2F;  \<br> 15   7<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>新建/改变树结构的，在递归函数中一定要新建<code>root</code>结点并给<code>root-&gt;left</code>和<code>root-&gt;right</code>赋值。</li>
<li>用两个指针在树中遍历时：结束条件就是<code>left &gt; right</code>,<code>left=right</code>是最后一个结点或者说叶子节点。</li>
<li>新建树一定是先序遍历，先建立根再建立左右子树，递归函数的参数表示，<code>pre_root</code>根结点再先序列中的索引，<code>in_left</code>中序列中左子树左边界 <code>in_right </code>中序列中右子树右边界。</li>
<li>根节点都是从先序中找，第一个结点一定是根，根后一个结点一定是左子树的根节点，根后+左子树大小+1就是右子树的根结点。</li>
<li>左子树的大小则通过中序遍历得到，因为在中序列中根节点左边全是左子树的结点。</li>
<li>因为涉及根据值取他得索引，所以事先要建立id映射表<code>idHash</code>。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">  unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; idHash;<br>  vector&lt;<span class="hljs-keyword">int</span>&gt; pre;<br>  <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>      pre = preorder;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>          idHash[inorder[i]] = i;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTree</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pre_root, <span class="hljs-keyword">int</span> in_left, <span class="hljs-keyword">int</span> in_right)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (in_left &gt; in_right) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>      TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[pre_root]);<br>      <span class="hljs-keyword">int</span> in_root = idHash[pre[pre_root]];<br>      root-&gt;left = <span class="hljs-built_in">buildTree</span>(pre_root + <span class="hljs-number">1</span>, in_left, in_root - <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 左节点个数是：in_root - in_left + 1 经常容易写错</span><br>      root-&gt;right = <span class="hljs-built_in">buildTree</span>(pre_root + in_root - in_left + <span class="hljs-number">1</span>, in_root + <span class="hljs-number">1</span>, in_right);<br>      <span class="hljs-keyword">return</span> root;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">leetcode</a><br>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>插入时，按正常入栈，但弹出时需要从最先入栈的即栈底开始，所以要用到辅助栈，将栈底元素倒出来到辅助栈的栈顶</li>
<li>只有当辅助栈的元素全部弹空后，再开始新一轮从数据栈往辅助栈倒</li>
<li>两个栈都为空时，才是真的空了。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-keyword">int</span>&gt; sck1;<br>stack&lt;<span class="hljs-keyword">int</span>&gt; sck2;<br><span class="hljs-built_in">CQueue</span>() &#123; &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    sck1.<span class="hljs-built_in">push</span>(value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sck2.<span class="hljs-built_in">empty</span>() &amp;&amp; sck1.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (sck2.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (!sck1.<span class="hljs-built_in">empty</span>()) &#123;<br>            sck2.<span class="hljs-built_in">push</span>(sck1.<span class="hljs-built_in">top</span>());<br>            sck1.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> front = sck2.<span class="hljs-built_in">top</span>();<br>    sck2.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> front;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">leetcode</a><br>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下,斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>经典的动规问题，出了前两个元素，其他任意一个元素值都与他的前两个元素相关，所以状态方程为：<code>dp[i] = dp[i -1] + dp[i -2]</code></li>
<li>注意答案要取模<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dp[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> dp[i] = (dp[i - <span class="hljs-number">1</span>]  + dp[i - <span class="hljs-number">2</span>]) % <span class="hljs-number">1000000007</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>如果面试管要求较少的空间，可以只需要三个变量，实时记录当前值，他的前一个值和前二个值，每次遍历都进行一个更新。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> first = <span class="hljs-number">0</span>, second = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> ans = n == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        ans = (first + second) % <span class="hljs-number">1000000007</span>;<br>        first = second;<br>        second = ans;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h1><p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">leetcode</a><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>PS:为什么要模1000000007（跟我念，一，八个零，七）,int64位的最大值为2^63-1，用最大值模1000000007的结果求平方，不会在int64中溢出。<br>所以在大数相乘问题中,相乘时两边都对1000000007取模，保存在int64里面不会溢出.</li>
<li>建立dp数组建立跳到当前台阶的方法数，那么对于任意台阶，可以从他前一个台阶或者前两个台阶跳到，状态方程为：’dp[i] = dp[i - 1] + dp[i - 2]’  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dp[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span> dp[i] = (dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]) % <span class="hljs-number">1000000007</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>节省空间的做法：<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> first = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> second = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>        res = (first + second) % <span class="hljs-number">1000000007</span>;<br>        first = second;<br>        second = res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">leetcode</a><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>典型的二分查找，要查找的数左右两边的特点，他的左边都是大于数组的最后一个数，他的右边都是小于数组最后一个数。</li>
<li>本题的不同之处在于存在重复数字，所以会出现mid所指与right所指之数相等，导致无法判断最小值出现在mid左边还是右边，因此需要删除一个重复值，暴力的缩小范围。<code>right--</code><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[right]) left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[right]) right = mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == nums[right]) right--;                           <br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[left];<br>&#125;  <br></code></pre></td></tr></table></figure></li>
<li>暴力法：遍历整个数组，如果发现后面一个数小于前面一个数，说明找到了分界点。</li>
<li>如果没有找到分界点，说明整个数组都是一个数重复，就返回第一个数即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; numbers.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (numbers[i] &gt; numbers[i + <span class="hljs-number">1</span>]) <br>            <span class="hljs-keyword">return</span> numbers[i + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h1><p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">leetcode</a><br>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。<br>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]<br>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>本题第一想到DFS或BFS</li>
<li>使用DFS时应该注意递归结束条件有哪些：坐标越界、已经访问过、递归的深度超过word长度、字符不等于word对应位置的字符。</li>
<li>这里介绍另一种标记已访问过的方法：就是访问时将数组中的数字提取出来，原位置用其他不常用字符代替，因为递归时只访问word中字符，所以访问过的一定不会再访问，递归结束后记得回复原样（不恢复也行）<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, i, j, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; b, string&amp; w, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= b.<span class="hljs-built_in">size</span>() || i &lt; <span class="hljs-number">0</span> || j &gt;= b[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || j &lt; <span class="hljs-number">0</span> || b[i][j] != w[k])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (k == w.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">char</span> temp = b[i][j];<br>        b[i][j] = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-keyword">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> q = <span class="hljs-number">0</span>; q &lt; <span class="hljs-number">4</span>; q ++ ) &#123;<br>            <span class="hljs-keyword">int</span> m = i + dx[q], n = j + dy[q];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(b, w, m, n, k + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        b[i][j] = temp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>第二版解题思路，类似此类问题：通过dfs在多条路径中寻找其中一条满足条件的路径。</li>
<li>注意：第一次通过遍历先发现头节点，再根据次节点展开深度递归，记录路径长度或者储存路径信息的变量都要再每次dfs前重新定义。</li>
<li>注意：每次递归完要恢复isVis标志位。只有一种情况不需要恢复就是，只从一个节点开始dfs，只需要找到一条满足的路径即可，不需要回溯。</li>
<li>dfs模板：先判断是否已经访问，再写递归结束的条件，最后只有满足一定条件的子节点才进行dfs。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> off[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; isVis;<br>string word;<br>vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt; board;<br><span class="hljs-keyword">int</span> row;<br><span class="hljs-keyword">int</span> col;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>    row = board.<span class="hljs-built_in">size</span>();<br>    col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">this</span>-&gt;isVis.<span class="hljs-built_in">resize</span>(row, vector&lt;<span class="hljs-keyword">bool</span>&gt;(col, <span class="hljs-literal">false</span>));<br>    <span class="hljs-keyword">this</span>-&gt;board = board;<br>    <span class="hljs-keyword">this</span>-&gt;word = word;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == word[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i, j, depth)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;  <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> depth)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isVis[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    isVis[x][y] = <span class="hljs-literal">true</span>;<br>    cout &lt;&lt; board[x][y];<br>    <span class="hljs-keyword">if</span> (depth == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>        <span class="hljs-keyword">int</span> m = x + off[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> n = y + off[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (m &lt; row &amp;&amp; m &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt; col &amp;&amp; n &gt;= <span class="hljs-number">0</span> &amp;&amp; board[m][n] == word[depth + <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(m, n, depth + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    isVis[x][y] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h1><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">leetcode</a><br>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>此题的难度在于理解上面，并不是暴力的遍历全部结点，判断哪个符合条件，因为题目时运动范围即，所以符合要求的结点都时连接在一起的。</li>
<li>因为数组中的值仅仅为两位数，因此’ x / 10 + x %10’就是个位与十位的数位和</li>
<li>这里用了一个二维数组记录访问过的结点，一定要初始化二维数组。</li>
<li>因为本题求得是机器人得运动范围，不是求某一最长得路径，因此再dfs结束后不需要回复isVis数组。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> m, n, k;<br><span class="hljs-keyword">int</span> off[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-keyword">bool</span>** isVis;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;m = m;<br>    <span class="hljs-keyword">this</span>-&gt;n = n;<br>    <span class="hljs-keyword">this</span>-&gt;k = k;<br><br>    isVis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>*[m];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        isVis[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[n];<br>        <span class="hljs-built_in">memset</span>(isVis[i], <span class="hljs-number">0</span>, n * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">bool</span>));<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, isVis);<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">bool</span>** isVis)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isVis[i][j]) <span class="hljs-keyword">return</span>;<br>    isVis[i][j] = <span class="hljs-literal">true</span>;<br>    cnt++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>; z &lt; <span class="hljs-number">4</span>; ++z) &#123;<br>        <span class="hljs-keyword">int</span> x = i + off[z][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> y = j + off[z][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n &amp;&amp;<br>           (x / <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span> + y / <span class="hljs-number">10</span> + y % <span class="hljs-number">10</span> &lt;= k)) <br>                <span class="hljs-built_in">dfs</span>(x, y, isVis);      <br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h1><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">leetcode</a><br>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: 2<br>输出: 1<br>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1<br><br>输入: 10<br>输出: 36<br>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>贪心+暴力解决  </li>
<li>要想积最大，每段长度都尽量相等或接近就行，首先想到用平均值avg，如果平均下来有剩余值，就降剩余值再平均前面每个值上，就变avg + 1，所以最终分段完每段的长度不是avg就是avg + 1</li>
<li>设分了m段,那么余数有多少，就有多少个avg + 1,剩下的就是avg</li>
<li>pow(int num, int exp);求乘方函数。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">2</span>; m &lt;=n; ++m) &#123;<br>        <span class="hljs-keyword">int</span> avg = n / m; <br>        <span class="hljs-keyword">int</span> sum = n % m ? <span class="hljs-built_in">pow</span>(avg, m - n % m) * <span class="hljs-built_in">pow</span>(avg + <span class="hljs-number">1</span>, n % m) : <span class="hljs-built_in">pow</span>(avg, m);<br>        res = <span class="hljs-built_in">max</span>(res, sum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="剪绳子II"><a href="#剪绳子II" class="headerlink" title="剪绳子II"></a>剪绳子II</h1><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">leetcode</a><br>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>本题与上一题得区别在于存在大数操作，<code>2 &lt;= n &lt;= 1000</code></li>
<li>对于本题需要了解数学知识，要想使成绩最大化，就需要将绳子尽可能的多分段，因此每段长度有，1，2，3中长度考虑，1显然不行，2或3中，3更合适，因此此题就变为求3的幂操作。</li>
<li>幂操作因为指数级别的增加，很容易溢出int32甚至int64，所以为了不让溢出，就需要对幂结果求余，采用分割后分别求余。</li>
<li>循环求幂：大数取余满足分配律，<code>(xy)⊙p=[(x⊙p)(y⊙p)]⊙p</code><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">4</span>) &#123;<br>        res = res * <span class="hljs-number">3</span> % <span class="hljs-number">1000000007</span>;<br>        n -= <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res * n % <span class="hljs-number">1000000007</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>方法二，用贪心+快速幂指法<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickPow</span>(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span> % <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickPow</span>(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * (b + <span class="hljs-number">3</span>) % <span class="hljs-number">1000000007</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> t = x;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) <br>            res = res * t % <span class="hljs-number">1000000007</span>;<br>        t = t * t % <span class="hljs-number">1000000007</span>;<br>        n /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>三种方法：1、掩码为1，让数子<code>(num &amp; 1)</code> 判断num二进制形式的最后一位是否是1，<code>num &gt;&gt;= 1</code>让num二进制数右移一位，就可以实现逐位判断。</li>
<li>2、方法一通过不断右移num，还可以不断左移掩码1来判断</li>
<li>3、 反转num的最后一位，记录反转次数 反转’n &amp;= n -1’<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) cnt++;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">uint32_t</span> mask = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; mask) cnt++;<br>        mask &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        n &amp;= n - <span class="hljs-number">1</span>;<br>        cnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">leetcode</a><br>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>如果采用whie(exp–)根据指数个数不断求积的方式计算，对于指数很大的数可能会超时，因此使用快速求幂算法</p>
</li>
<li><p>核心就是通过指数的二进制形式，将指数进行的分解，例如（<code>x^9</code> 指数为<code>9</code>，二进制是:1001, 那么<code>9 = 2^3 + 2^0</code>, 所以<code>x^9 = x^8 * x^1</code> )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">bool</span> isPositive = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">long</span> t = n;<br>    <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = -t, isPositive = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">double</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (t) &#123;<br>        <span class="hljs-keyword">if</span> (t &amp; <span class="hljs-number">1</span>) res *= x; <br>        x *= x;<br>        t &gt;&gt;= <span class="hljs-number">1</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> isPositive ? res : (<span class="hljs-number">1</span> / res);<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
<li><p>其中用到了用移位<code>t &gt;&gt;= 1</code>,</p>
</li>
<li><p>注意能够使用的前提是<code>t</code>不能是负数（因为负数用的是补码），因此之前现做绝对化处理,但是力扣的用例中使用了<code>n = -2147483648</code>这个数，int的取值范围是-2147483648到2147483647，但-2147483648取绝对值2147483648超出int范围，所以需要long去接他。</p>
</li>
<li><p>可以用除法 n /= 2来代替，就不会有如上问题,也不同考虑符数问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> t = n;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res *= x;<br>        x *= x;<br>        n /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t &gt; <span class="hljs-number">0</span> ? res : <span class="hljs-number">1</span> / res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>使用递归思想，易理解,因为只有<code>n</code>在递归中发送变化，因此结束条件只考虑n的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / x;<br>    <span class="hljs-keyword">double</span> half = <span class="hljs-built_in">myPow</span>(x, n / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">double</span> mod = <span class="hljs-built_in">myPow</span>(x, n % <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> half * half * mod;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h1><p><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">leetcode</a><br>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: n &#x3D; 1<br>输出: [1,2,3,4,5,6,7,8,9]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>此题相对书上的做了简化，因为已经给出返回值是int型，所以用例中不会有大数，就简单很多</li>
<li>关键在于找到最大值，然后遍历打印即可</li>
<li>可以用pow(10, n)来确定最大边界。</li>
<li>我这里提供另一种算法：例如3位数，那么最大值就是999，4位数最大9999。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span> (n--) &#123;   <br>        cnt = cnt * <span class="hljs-number">10</span> + <span class="hljs-number">9</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; ++i) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h1><p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">leetcode</a>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。</p>
<ul>
<li>删除某个结点的前提一定是找到他的前驱和要删除的结点，因此需要两个指针。</li>
<li>改变链表的操作，有可能会删除第一个结点，因此需要一个头节点作为第一个结点的前驱，来统一化操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode* cur = head;<br>    ListNode* pre = dummy;<br>    <span class="hljs-keyword">while</span> (cur-&gt;val != val) &#123;<br>        cur = cur-&gt;next;<br>        pre = pre-&gt;next;<br>    &#125;<br>    pre-&gt;next = cur-&gt;next;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h1><p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">leetcode</a><br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>思路来自于快排的挖坑法，定义两个头尾指针，把最后一个数挖走，然后left指针遍历直到发现一个偶数，就把这个偶数挖走放到最后的坑里，再用right往前遍历，直到发现一个奇数，挖走放到前面那个坑里，直到俩个指针相遇，把坑不上即可。</p>
</li>
<li><p>注意：如果将第一个数挖走，一开始就要从末尾开始遍历，如果挖走最后一个数，就要从左先开始遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> temp = nums[right];<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">while</span> ((nums[left] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> &amp;&amp; left &lt; right) left++;<br>        nums[right] = nums[left];<br>        <span class="hljs-keyword">while</span> ((nums[right] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; left &lt; right) right--;<br>        nums[left] = nums[right];<br>    &#125;<br>    nums[left] = temp;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>改进版,不需要挖坑了，而且只交换一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span> ,right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; (nums[right] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) right--;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; (nums[left] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) left++;<br>        <span class="hljs-built_in">swap</span>(nums[left++], nums[right--]); <br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h1><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">leetcode</a>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>快慢指针法，让快指针遍历到结尾<code>null</code>时，慢指针正好指向倒数第k个结点。</li>
<li>因为要删出结点必须要前驱，所以添加一个头结点<code>dummy</code>，方便删第一个结点。</li>
<li>注意此题返回的是删除后剩余的链，<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    dummy-&gt;next = head;<br>    ListNode* fast = dummy;<br>    ListNode* slow = dummy;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        fast = fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (fast) &#123;<br>        fast = fast-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">leetcode</a>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>方法1：头插法反转<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* pre = <span class="hljs-literal">NULL</span>;<br>    ListNode* cur = head;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li> 方法2：用栈反转:首先遍历链表，1、把每个结点入栈，2、然后再循环出栈链接到上一个结点，3、更新当前指针。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    stack&lt;ListNode*&gt; sck;<br>    ListNode* cur = head;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        sck.<span class="hljs-built_in">push</span>(cur);<br>        cur = cur-&gt;next;<br>    &#125;<br><br>    ListNode* pre = sck.<span class="hljs-built_in">top</span>();<br>    ListNode* curr = sck.<span class="hljs-built_in">top</span>();<br>    sck.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">while</span> (!sck.<span class="hljs-built_in">empty</span>()) &#123;<br>        curr-&gt;next = sck.<span class="hljs-built_in">top</span>();<br>        sck.<span class="hljs-built_in">pop</span>();<br>        curr = curr-&gt;next;<br>    &#125;<br>    curr-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h1><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">leetcode</a><br>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>合并需要三个指针，一个指向l1的<code>p1</code>,指向l2的<code>p2</code>，遍历合并后链表的<code>cur</code>指针,新链表的头指针<code>pre</code>。</p>
</li>
<li><p>同时遍历两个链表，当有一个链表遍历结束时退出循环，将另一个链表剩下的直接接上新链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    ListNode* p1 = l1;<br>    ListNode* p2 = l2;<br>    ListNode* pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* cur = pre;<br>    <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">NULL</span> &amp;&amp; p2 != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (p1-&gt;val &lt;= p2-&gt;val)&#123;<br>            cur-&gt;next = p1;<br>            p1 = p1-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur-&gt;next = p2;<br>            p2 = p2-&gt;next;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    cur-&gt;next = p1 == <span class="hljs-literal">NULL</span> ? p2 : p1;<br>    <span class="hljs-keyword">return</span> pre-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>一样的思路另一种写法，区别在于while循环大判断是<code>||</code>或.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    ListNode* p1 = l1, p2 = l2;<br>    ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* cur = dummy;<br>    <span class="hljs-keyword">while</span> (p1 || p2) &#123;<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">NULL</span>) &#123; <br>            cur-&gt;next = p2;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">NULL</span>) &#123;<br>            cur-&gt;next = p1;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;   <br>        <span class="hljs-keyword">if</span> (p1-&gt;val &lt;= p2-&gt;val) &#123;<br>            cur-&gt;next = p1;<br>            p1 = p1-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur-&gt;next = p2;<br>            p2 = p2-&gt;next;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>递归思想:先了解函数的意义是合并两个链表并返回合并后的头部节点，其次返回条件，函数的两个参数都会在<br>递归过程中发生变化，因此结束条件有两个，其中一个为<code>null</code>表示其中一条遍历结束，直接返回另一条链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> l2;<br>    <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> l1;<br><br>    <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br>        l1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1-&gt;next, l2);<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        l2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(l1, l2-&gt;next);<br>        <span class="hljs-keyword">return</span> l2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">leetcode</a>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)<br>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">例如:<br>给定的树 A:<br><br>     3<br>    &#x2F; \<br>   4   5<br>  &#x2F; \<br> 1   2<br>给定的树 B：<br><br>   4 <br>  &#x2F;<br> 1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。<br><br></code></pre></td></tr></table></figure>
<h3 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>首先需要遍历整个A树每个结点，来跟跟B进行对比，所以需要两个递归，第一个递归用于遍历整个A树，第二个递归用于对比两个树。</li>
<li>第一个递归结束条件，如果A树的结点遍历到结尾<code>null</code>说明还没发现子树，因此返回false，再根据题意空树<code>B == null</code>不属于任何子树</li>
<li>第二个递归判断两个树是否相等或者B是否属于A，当同时遍历两个树的结点，如果有不相等的结点一定不是，结束条件：当<code>(A == NULL &amp;&amp; B == NULL)</code>即两个树同时遍历结束 ，说明A和B完全相等，<br>如果A先结束，说明A属于B，返回<code>false</code>，B先结束说吧B属于A，B是A的子树，返回<code>true</code><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">NULL</span> || B == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// 空树不算任何子树</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEqual</span>(A, B)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">NULL</span> &amp;&amp; B == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 都刚好遍历完</span><br>    <span class="hljs-keyword">if</span> (B == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <span class="hljs-comment">// B遍历到尾部，A下面还有</span><br>    <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">// B还没有遍历完， A下面就没了</span><br>    <span class="hljs-keyword">if</span> (A-&gt;val != B-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isEqual</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="hljs-built_in">isEqual</span>(A-&gt;right, B-&gt;right); <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">leetcode</a><br>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<h3 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>对于改变树结构的递归，其中一定有<code>root-&gt;left =</code> 和<code>root-&gt;right = </code>左右子树重新赋值的操作。</p>
</li>
<li><p>函数意义是返回反转后的根结点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode* tmp = <span class="hljs-built_in">mirrorTree</span>(root-&gt;left);<br>    root-&gt;left = <span class="hljs-built_in">mirrorTree</span>(root-&gt;right);<br>    root-&gt;right = tmp;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>能用递归就能用迭代法，对于深度递归一般使用栈，又由于翻转操作，我们需要先得到根节点，才能反转他的左右子树，<br>因此采用栈数据结构的前序遍历的迭代法，先右节点入栈。交换操作也可以使用<code>swap()</code>代替。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    stack&lt;TreeNode*&gt; sck;<br>    sck.<span class="hljs-built_in">push</span>(root);<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (!sck.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = sck.<span class="hljs-built_in">top</span>();<br>        sck.<span class="hljs-built_in">pop</span>();       <br>        <span class="hljs-comment">// swap(cur-&gt;left, cur-&gt;right)</span><br>        TreeNode* tmp = cur-&gt;left;<br>        cur-&gt;left = cur-&gt;right;<br>        cur-&gt;right = tmp;<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) sck.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        <span class="hljs-keyword">if</span> (cur-&gt;left) sck.<span class="hljs-built_in">push</span>(cur-&gt;left); <br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h1><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">leetcode</a><br>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。<br>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">    1<br>   &#x2F; \<br>  2   2<br> &#x2F; \ &#x2F; \<br>3  4 4  3<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一定需要两个指针，一个递归遍历左子树，一个遍历右子树，再进行左右子树交叉结点值的对比，当发现结点不相等时返回false</li>
<li>注意遍历到结尾<code>null</code>时的处理，都是null也属于对称。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(root-&gt;left, root-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> || right == <span class="hljs-literal">NULL</span> || left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="hljs-built_in">isSymmetric</span>(left-&gt;right, right-&gt;left) ;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">leetcode</a><br>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<h3 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>定义四个边界，上下左右，每打印一圈四个边界就向里面缩小一个单位，同时为了保证每次打印都是从0下标开始的，所以一行n个元素只打印前n个，一列n个元素也只打印前n个。</li>
<li>循环的结束条件：当上下边界重合，或者左右边界重合时，说明就剩中间一行或者一列或者一个元素三种情况未遍历打印，需要单独考虑。</li>
<li>上下左右边界都重合说明就剩一个元素。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>, bottom = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt; right; ++i) res.<span class="hljs-built_in">push_back</span>(matrix[top][i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top; i &lt; bottom; ++i) res.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = right; i &gt; left; --i) res.<span class="hljs-built_in">push_back</span>(matrix[bottom][i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = bottom; i &gt; top; --i) res.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>        left++, right--;<br>        top++, bottom--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left == right)&#123; <span class="hljs-comment">// 还剩一列 或者一个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top; i &lt;= bottom; ++i) res.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (top == bottom) &#123; <span class="hljs-comment">// 还剩一行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; ++i) res.<span class="hljs-built_in">push_back</span>(matrix[top][i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><p><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">leetcode</a><br>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<h3 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>入栈时比较当前元素与最小栈栈顶元素，更小则加入最小栈中。</li>
<li>出栈时需要考虑当前栈顶的元素是不是最小值，如果是，则最小栈也需要弹出，不是则只弹出数据栈栈顶的元素。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-keyword">int</span>&gt; dataSck;<br>stack&lt;<span class="hljs-keyword">int</span>&gt; minSck;<br><span class="hljs-built_in">MinStack</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    dataSck.<span class="hljs-built_in">push</span>(x);<br>    <span class="hljs-keyword">if</span> (minSck.<span class="hljs-built_in">empty</span>()) &#123;<br>        minSck.<span class="hljs-built_in">push</span>(x);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt;= minSck.<span class="hljs-built_in">top</span>())<br>            minSck.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dataSck.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (dataSck.<span class="hljs-built_in">top</span>() == minSck.<span class="hljs-built_in">top</span>()) &#123;<br>        dataSck.<span class="hljs-built_in">pop</span>();<br>        minSck.<span class="hljs-built_in">pop</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        dataSck.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dataSck.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> minSck.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><p><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">leetcode</a><br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<h3 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>根据弹出数组来模拟整个入栈和出栈的操作。</li>
<li>因为入栈的顺序是固定的，因此根据push数组来遍历入栈，但是出栈可能发生再任意一个结点当中，但是一定按照pop数组进行的。</li>
<li>因此只要当入栈的元素即栈顶与pop数组第一个元素相等时，代表这个刚入栈的元素要出栈了，出栈后pop数组也要往后遍历一位。</li>
<li>用while循环是因为模拟连续出栈的操作，因为有可能一次入栈后，出现连续多次出栈操作。</li>
<li>后面只要入栈的元素即栈顶元素与pop数组相等时，就代表该出栈了。</li>
<li>最后如果栈空代表pop数组满足栈的操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; pushed, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; popped)</span> </span>&#123;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; sck;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : pushed) &#123;<br>        sck.<span class="hljs-built_in">push</span>(num);<br>        <span class="hljs-keyword">while</span> (!sck.<span class="hljs-built_in">empty</span>() &amp;&amp; sck.<span class="hljs-built_in">top</span>() == popped[j]) &#123;<br>            sck.<span class="hljs-built_in">pop</span>();<br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sck.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">leetcode</a>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<h3 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>典型的层序遍历，使用到了队列,遍历一个结点就把他的子结点加入队列即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span> (cur-&gt;left) que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>队列可以实现先进先出，同样用链表也可以代替队列<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    list&lt;TreeNode*&gt; List;<br>    List.<span class="hljs-built_in">push_back</span>(root);<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (!List.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = List.<span class="hljs-built_in">front</span>();<br>        List.<span class="hljs-built_in">pop_front</span>();<br>        res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        <span class="hljs-keyword">if</span> (cur-&gt;left) List.<span class="hljs-built_in">push_back</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) List.<span class="hljs-built_in">push_back</span>(cur-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="从上到下打印二叉树II"><a href="#从上到下打印二叉树II" class="headerlink" title="从上到下打印二叉树II"></a>从上到下打印二叉树II</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">leetcode</a><br>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">    3<br>   &#x2F; \<br>  9  20<br>    &#x2F;  \<br>   15   7<br>输出：<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-26"><a href="#解题思路-26" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>再上题层序遍历的基础上，多了个按层打印的效果，因此每层都需要一个数组level来记录当前层的所以结点。</p>
</li>
<li><p>只需要知道，每次加入队列的所有结点，即为一层的所有结点。队列的长度就是一层的个数。根据这个个数来遍历一层结点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; level;<br>        <span class="hljs-keyword">int</span> len = que.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (len--) &#123;<br>            cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            level.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right) que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(level);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>DFS递归法.前序遍历总体来看是从左到右的遍历，因此遍历到某个节点时将其插入到对应高度的结果数组中。</p>
</li>
<li><p>因为无法提前知道层高，就需要再遍历的过程中，先判断当前层数在结果数组中是否已经开辟了空间。如果没有就再新建一行数组空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> depth)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(depth == res.<span class="hljs-built_in">size</span>()) res.<span class="hljs-built_in">emplace_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;());   <span class="hljs-comment">// 新建一行</span><br>    res[depth].<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, depth + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, depth + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="从上到下打印二叉树III"><a href="#从上到下打印二叉树III" class="headerlink" title="从上到下打印二叉树III"></a>从上到下打印二叉树III</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">leetcode</a><br>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">    3<br>   &#x2F; \<br>  9  20<br>    &#x2F;  \<br>   15   7<br>输出：<br>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-27"><a href="#解题思路-27" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>再上体的基础上又多了一个条件，就是对于奇数层和偶数层，他的结点输出循环不同</p>
</li>
<li><p>因此还需要一个变量cnt来记录当前层数，当前为偶数层时，level数组进行反转操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">int</span> layer = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; level;<br>        <span class="hljs-keyword">int</span> len = que.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (len--) &#123;<br>            cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            level.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right) que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (layer % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">reverse</span>(level.<span class="hljs-built_in">begin</span>(), level.<span class="hljs-built_in">end</span>());<br>        res.<span class="hljs-built_in">push_back</span>(level);<br>        layer++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>dfs递归思想，每层使用list链表的数据结构，这样可以头插法，相当反转一个数组。</p>
</li>
<li><p>最后将链表转为为数组再输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;list&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>    <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>    ans.<span class="hljs-built_in">resize</span>(res.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); ++i) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : res[i]) ans[i].<span class="hljs-built_in">emplace_back</span>(it);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> depth)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (depth == res.<span class="hljs-built_in">size</span>()) res.<span class="hljs-built_in">emplace_back</span>(list&lt;<span class="hljs-keyword">int</span>&gt;());<br>    <span class="hljs-keyword">if</span> (depth &amp; <span class="hljs-number">1</span>) res[depth].<span class="hljs-built_in">emplace_front</span>(root-&gt;val);<br>    <span class="hljs-keyword">else</span> res[depth].<span class="hljs-built_in">emplace_back</span>(root-&gt;val);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, depth + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, depth + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h1><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">leetcode</a><br>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同</p>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">     5<br>    &#x2F; \<br>   2   6<br>  &#x2F; \<br> 1   3<br>输入: [1,6,3,2,5]<br>输出: false<br><br>输入: [1,3,2,6,5]<br>输出: true<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-28"><a href="#解题思路-28" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>只要是根据一个序列来判断是否是某个树得某种遍历,一定都需要两个参数<code>left</code>和<code>right</code>,因为要框出左子树和右子树。</li>
<li>因为后序遍历，所以最后一位即<code>right</code>所指一定是这个树得根结点<code>root</code></li>
<li>找完root结点，还需要找到左子树和右子树得分界点，因为是二叉搜索树，左子树得所有结点值一定小于右子树，利用while遍历序列发现第一个大于root得结点即为右子树得结点，记为mid。</li>
<li>这样一个序列分配完成，right所指为root结点，[left, mid-1] 为左子树结点，[mid, right-1]为右子树 </li>
<li>判断：如果右子树中发现一个小于root结点，就不满足二叉搜索树了。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(postorder, left, right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">int</span> root = postorder[right];<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (postorder[mid] &lt; root) mid++;<br>    <span class="hljs-comment">// mid左为left，&lt; root; mid右为right &gt; root</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mid; i &lt; right; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (postorder[i] &lt; root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(postorder, left , mid - <span class="hljs-number">1</span>) &amp;&amp; <span class="hljs-built_in">dfs</span>(postorder, mid, right - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">leetcode</a><br>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例:"></a>示例:</h3><p>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">              5<br>             &#x2F; \<br>            4   8<br>           &#x2F;   &#x2F; \<br>          11  13  4<br>         &#x2F;  \    &#x2F; \<br>        7    2  5   1<br>返回:<br><br>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-29"><a href="#解题思路-29" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>通过深度递归,每经过一个结点sum就减去当前结点值，数组path记录路径经过得点，并继续往下递归</li>
<li>当sum减至刚好为0时，且当前结点没有后继，属于叶子结点，说明这是一条路径。加入结果数组中即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-keyword">int</span> sum) &#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; path;<br>    <span class="hljs-built_in">dfs</span>(root, sum, path);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> sum, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; path)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    sum -= root-&gt;val;<br>    <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span> &amp;&amp; sum == <span class="hljs-number">0</span>) res.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, sum, path);<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, sum, path);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span>; <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">leetcode</a><br>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<h3 id="解题思路-30"><a href="#解题思路-30" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>因为是深拷贝链表，所以每遍历一个结点就new一个新结点，并赋值</li>
<li>链表得链接，只能链接当前结点与上一个结点，只要遍历过得结点才能链接，不能往后链接，因此需要维护一个last指针，指向当前结点得前驱</li>
<li>由于本题每个结点还有一个随机链接，所以我们需要两个表，第一个表记录原链表得随机指针指向了那个结点得下标。第二表需要记录，新链表每个结点得地址。</li>
<li>链接随机指针时：先查原表当前结点随机指针指得是第几个结点，再根据下标查新表获取新结点地址，再链接。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    unordered_map&lt;Node*, <span class="hljs-keyword">int</span>&gt; idx;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, Node*&gt; addr;<br><br>    Node* cur = head;<br>    Node* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>);<br>    Node* pre = dummy;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        idx[cur] = i;<br>        Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>        addr[i] = node;<br>        pre-&gt;next = node;<br>        pre = pre-&gt;next;<br>        cur = cur-&gt;next;<br>        i++;<br>    &#125;<br>    pre-&gt;next = <span class="hljs-literal">NULL</span>;<br><br>    cur = head;<br>    Node* curr = dummy-&gt;next;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;random)<br>            curr-&gt;random = addr[idx[cur-&gt;random]];<br>        <span class="hljs-keyword">else</span> <br>            curr-&gt;random = <span class="hljs-literal">NULL</span>;<br>        cur = cur-&gt;next;<br>        curr = curr-&gt;next;<br>    &#125; <br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">leetcode</a><br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<h3 id="解题思路-31"><a href="#解题思路-31" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>链表得链接一定是往前链接，所以需要维护一个指向上一个结点得指针<code>pre</code></li>
<li>因为是一个搜索树，所以选择中序遍历,就是从小到大排好序得。</li>
<li>当遍历完后，pre指针正好指向最后一个结点，将其与第一个结点进行链接。</li>
<li>注意：用一个全局变量来记录遍历过程中的上一个节点。</li>
<li>注意：root节点不是第一个链表的第一节点，head-&gt;right才是.<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">Node* pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//上一个结点</span><br><span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    Node* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>);<br>    pre = head;<br>    <span class="hljs-built_in">inorder</span>(root);<br>    pre-&gt;right = head-&gt;right;<br>    head-&gt;right-&gt;left = pre;<br>    <span class="hljs-keyword">return</span> head-&gt;right;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>    pre-&gt;right = root;<br>    root-&gt;left = pre;<br>    pre = root;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">leetcode</a> 请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">你可以将以下二叉树：<br><br>    1<br>   &#x2F; \<br>  2   3<br>     &#x2F; \<br>    4   5<br><br>序列化为 &quot;[1,2,3,null,null,4,5]&quot;<br><br></code></pre></td></tr></table></figure>
<h3 id="解题思路-32"><a href="#解题思路-32" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>对于根据序列来建树得题一般都不简单。本题属于困难</li>
<li>本题涉及得技巧：层序遍历、数字转字符串、字符串转数字</li>
<li>删除字符串最后一位三种方法：<ul>
<li>迭代器：<code>str.erase(str.end() - 1);</code></li>
<li>提取子串：<code>str.substr(0, str.size() - 1);</code></li>
<li>数组：<code>str.pop_back();</code>     </li>
</ul>
</li>
<li>数字转字符串；我用的是从个位开始往前添加每位数字，再<code>reverse()</code>反转字符串。效率很低。</li>
<li>本代码写的不好<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    string res;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        cur = que.<span class="hljs-built_in">front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (cur) &#123;<br>            res += <span class="hljs-built_in">toString</span>(cur-&gt;val);<br>            res += <span class="hljs-string">&#x27;,&#x27;</span>;<br>            que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res += <span class="hljs-string">&quot;null,&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//res.erase(res.end() - 1);         // 迭代器/三种用法</span><br>    <span class="hljs-comment">//res.substr(0, res.size() - 1);    // 子串</span><br>    res.<span class="hljs-built_in">pop_back</span>();                     <br>    <span class="hljs-comment">//cout &lt;&lt; &quot;[&quot; + res + &quot;]&quot;&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[&quot;</span> + res + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">toString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// val &lt; 10</span><br>        res += <span class="hljs-string">&#x27;-&#x27;</span>;<br>        res += <span class="hljs-built_in">abs</span>(val) + <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// val &gt;= 0</span><br>        <span class="hljs-keyword">while</span> (val) &#123;<br>            res += val % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            val /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>    vector&lt;<span class="hljs-keyword">int</span>&gt; data_int;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt; data.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (data[right] != <span class="hljs-string">&#x27;,&#x27;</span> &amp;&amp; data[right] != <span class="hljs-string">&#x27;]&#x27;</span>) right++;<br>        <span class="hljs-keyword">int</span> val = <span class="hljs-built_in">toInt</span>(data, left, right - <span class="hljs-number">1</span>);<br>        data_int.<span class="hljs-built_in">push_back</span>(val);<br>        left = right + <span class="hljs-number">1</span>;<br>        right++;<br>    &#125;       <br><br>    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(data_int[<span class="hljs-number">0</span>]);<br>    queue&lt;TreeNode*&gt; que;<br>    que.<span class="hljs-built_in">push</span>(root);<br><br>    <span class="hljs-keyword">double</span> start = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 子结点起始坐标</span><br>    <span class="hljs-keyword">double</span> end = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> n = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 层数</span><br>    TreeNode* cur = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">double</span> cnt = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, n++);      <br>        start = cnt - <span class="hljs-number">1</span>;             <br>        end = start + cnt - <span class="hljs-number">1</span>;     <br>        <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>            <span class="hljs-keyword">if</span> (start &gt;= data_int.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">break</span>;<br>            cur = que.<span class="hljs-built_in">front</span>();           <br>            que.<span class="hljs-built_in">pop</span>();<br>            <br>            TreeNode* leftNode = <span class="hljs-literal">NULL</span>;<br>            TreeNode* rightNode = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">if</span> (data_int[start] != INT_MIN)<br>                leftNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(data_int[start]);<br>            <br>            <span class="hljs-keyword">if</span> (data_int[start + <span class="hljs-number">1</span>] != INT_MIN) <br>                rightNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(data_int[start + <span class="hljs-number">1</span>]);<br>            <br>            <br>            <span class="hljs-keyword">if</span> (leftNode) que.<span class="hljs-built_in">push</span>(leftNode);<br>            <span class="hljs-keyword">if</span> (rightNode) que.<span class="hljs-built_in">push</span>(rightNode);<br>            <br>            cur-&gt;right = rightNode;<br>            cur-&gt;left = leftNode;<br>            <br>            start += <span class="hljs-number">2</span>;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">toInt</span><span class="hljs-params">(string str, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str[left] == <span class="hljs-string">&#x27;n&#x27;</span>) <span class="hljs-keyword">return</span> INT_MIN;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">bool</span> isNeg = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (str[left] == <span class="hljs-string">&#x27;-&#x27;</span>) left++, isNeg = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        res = res * <span class="hljs-number">10</span> + str[left] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        left++;       <br>    &#125;<br>    <span class="hljs-keyword">return</span> isNeg ? -res : res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">leetcode</a>输入一个字符串，打印出该字符串中字符的所有排列。<br>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;abc&quot;<br>输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-33"><a href="#解题思路-33" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>回溯递归，从第一个字符开始，其他所有字符都属于他的下一结点，<br>所有需要一个for循环遍历全部，为了防止重复遍历需要一个vis数组，同时还需要一个path记录遍历经过的结果</li>
<li>回溯递归结束后还需去重，2种方法：1、使用集合set 2、排序去重unique </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    vector&lt;string&gt; res;<br>    string path;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">isVis</span><span class="hljs-params">(s.size(), <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-built_in">dfs</span>(s, path, isVis, res);<br>    <span class="hljs-comment">//unordered_set&lt;string&gt; set(res.begin(), res.end()); //使用集合去重。</span><br>    <span class="hljs-comment">//res.assign(set.begin(), set.end());</span><br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());                       <span class="hljs-comment">// 排序去重</span><br>    <span class="hljs-keyword">auto</span> end = <span class="hljs-built_in">unique</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());           <span class="hljs-comment">// 返回最后一位</span><br>    res.<span class="hljs-built_in">erase</span>(end, res.<span class="hljs-built_in">end</span>());                          <span class="hljs-comment">// 剪掉</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span> <span class="hljs-params">(string s, string&amp; path, vector&lt;<span class="hljs-keyword">bool</span>&gt;&amp; isVis, vector&lt;string&gt;&amp; res)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == s.<span class="hljs-built_in">size</span>()) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>; <br>    &#125;<br>    <span class="hljs-comment">// 在所有得选择列表中继续选择</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (isVis[i]) <span class="hljs-keyword">continue</span>;<br>        isVis[i] = <span class="hljs-literal">true</span>;<br>        path += s[i];<br>        <span class="hljs-built_in">dfs</span>(s, path, isVis, res);<br>        isVis[i] = <span class="hljs-literal">false</span>;<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>修改版。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">bool</span>&gt; isVis;<br>string s;<br>vector&lt;string&gt; res;<br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;s = s;<br>    isVis.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>    string path;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-built_in">dfs</span>(i, path);<br>    &#125;<br>    <span class="hljs-function">unordered_set <span class="hljs-title">set</span><span class="hljs-params">(res.begin(), res.end())</span></span>;<br>    res.<span class="hljs-built_in">assign</span>(set.<span class="hljs-built_in">begin</span>(), set.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> root, string&amp; path)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (isVis[root]) <span class="hljs-keyword">return</span>;<br>    isVis[root] = <span class="hljs-literal">true</span>;<br>    path += s[root];<br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == s.<span class="hljs-built_in">size</span>()) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(path);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-built_in">dfs</span>(i, path);<br>    &#125;<br>    isVis[root] = <span class="hljs-literal">false</span>;<br>    path.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">leetcode</a>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h3 id="解题思路-34"><a href="#解题思路-34" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>哈希表记录次数<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; num : nums) &#123;<br>        cnt[num]++;<br>        <span class="hljs-keyword">if</span> (cnt[num] &gt; len / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>先排序，因为至少一半都是一个数字，所以中间值一定是他<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>摩尔投票法： 有同意和反对票。多数值当作同意票，其他所有值都当做反对票, 正负票正好抵消，</li>
<li>需要一个<code>last</code>值记录上衣结点的数值，用于比较，vato票数一旦为0就重新更新last值。，由于</li>
<li>因为最后一定都是一个数值，所以last保存的就是那个值。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>, vote = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 记录投票数</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>       <span class="hljs-keyword">if</span> (vote == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 正负票正好抵消，</span><br>           last = nums[i];<br>           vote++;<br>       &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 当前票与上一票进行比较，相同就++，不同就抵消了</span><br>           last == nums[i] ?  vote++ : vote--;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> last; <span class="hljs-comment">// 最后就剩多数票了</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h1><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">leetcode</a>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<h3 id="解题思路-35"><a href="#解题思路-35" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>经典的topK问题</p>
</li>
<li><p>求topK最小就用大顶堆。求topK最大就用小顶堆。</p>
</li>
<li><p>C++用优先队列来实现堆，priority_queue需要三个参数：三个参数：元素类型，容器类型，func类型</p>
</li>
<li><p>小顶堆升序排列，大顶堆降序排列。顶top就是队列第一个元素。</p>
</li>
<li><p>维护大小为k的大顶堆，当堆满时判断，新插入元素只要小于堆顶（即最大值），就入堆，队顶的最大值弹出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, less&lt;<span class="hljs-keyword">int</span>&gt;&gt; que;    <br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; num : arr) &#123;<br>        <span class="hljs-keyword">if</span> (que.<span class="hljs-built_in">size</span>() == k) &#123; <br>            <span class="hljs-keyword">if</span> (num &lt;= que.<span class="hljs-built_in">top</span>())  <br>                que.<span class="hljs-built_in">pop</span>(); <br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">continue</span>;<br>        &#125;  <br>        que.<span class="hljs-built_in">push</span>(num);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">top</span>());<br>        que.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>计数排序解决topK问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt[<span class="hljs-number">10001</span>];<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">10001</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : arr) &#123;<br>        cnt[num]++;<br>    &#125;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10001</span>; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (cnt[i]-- &amp;&amp; res.<span class="hljs-built_in">size</span>() &lt; k)<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>() == k) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><p>{leetcode](<a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B4%E5%9E%8B%E6%95%B0%E7%BB%84%EF%BC%8C%E6%95%B0%E7%BB%84%E9%87%8C%E6%9C%89%E6%AD%A3%E6%95%B0%E4%B9%9F%E6%9C%89%E8%B4%9F%E6%95%B0%E3%80%82%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E6%88%96%E8%BF%9E%E7%BB%AD%E5%A4%9A%E4%B8%AA%E6%95%B4%E6%95%B0%E7%BB%84%E6%88%90%E4%B8%80%E4%B8%AA%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%82%E6%B1%82%E6%89%80%E6%9C%89%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%82">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</a><br>要求时间复杂度为O(n)。</p>
<h3 id="解题思路-36"><a href="#解题思路-36" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>首先想到动态规划</li>
<li>dp[i]代表到当前i位置时，连续的子数组和得最大值。他与dp[i-1]有关，如果dp[i-1]+num[i]更大，那设为dp[i]，但是如果dp[i-1]+nums[i]还没有本身nums[i]大的话说明前面的dp[i-1]还是个负值，产生负影响，所以前面的i-1个子串都该舍弃。</li>
<li>难点在于状态转移方程：因为题意要求必须是连续，所以如果+nums[i]后，还没有本身nums[i]大时，就断开前面得重新开始。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(len)</span></span>;<br>    <span class="hljs-keyword">int</span> maxSum = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>] + nums[i], nums[i]); <br>        maxSum = <span class="hljs-built_in">max</span>(maxSum, dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>如果面试要求空间复杂度O(1)时</li>
<li>该使用一个变量pre来记录dp[i-1]</li>
<li>可以使用技巧：<code>cur += max(pre, 0);</code>来代替if else操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> maxSum = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> pre = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>  (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        cur = nums[i];<br>        cur += <span class="hljs-built_in">max</span>(pre, <span class="hljs-number">0</span>);<br>        pre = cur;<br>        maxSum = <span class="hljs-built_in">max</span>(maxSum, cur);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>正常不用技巧<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> pre = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> MAX = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        cur = nums[i];<br>        cur = <span class="hljs-built_in">max</span>(cur + pre, cur);<br>        MAX = <span class="hljs-built_in">max</span>(MAX, cur);<br>        pre = cur;<br>    &#125;<br>    <span class="hljs-keyword">return</span> MAX;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="1～n整数中1出现的次数"><a href="#1～n整数中1出现的次数" class="headerlink" title="1～n整数中1出现的次数"></a>1～n整数中1出现的次数</h1><p><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">leetcode</a><br>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。<br>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<h3 id="解题思路-37"><a href="#解题思路-37" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>正常思路,对每个数循环取余计算1出现的个数，但是会超时。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <br>        res += <span class="hljs-built_in">count</span>(i);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (num) &#123;<br>        cnt += (num % <span class="hljs-number">10</span> == <span class="hljs-number">1</span>);<br>        num /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>快速的方法是，直接根据n，统计十进制n中每个位出现1的次数，这样这需遍历n的位数次就能求出结果。</li>
<li>需要找到每位出现次数的规律：对于个位只有0<del>9,1只出现1次，十位0</del>99会出现10次，百位0~999会出现100次，因此每位出现1的次数与他的位数<code>digit</code>有关</li>
<li>如果当前位是0的话，例如2304的十位出现1的次数为：因为十位数有<code>0~99</code>,十位会出现<code>10</code>次1，而<code>0~99</code>出现的次数又是<code>23</code>次,因此1出现的总次数为：<code>23 * 10 = 230</code>，公式:<code>high * dight</code></li>
<li>如果当前位是1的话，例如2314，在2304的基础上，在加上 <code>10，11，12，13，14</code> 5 个，即 <code>23 * 10 + 4 + 1</code> 公式:<code>high * digit + low + 1</code></li>
<li>如果当前位是2的话，例如2324, 在2304的基础上，在加上完整的10的是个数<code>10,12,13,14,15,16,17,18,19</code>即<code>23 * 10 + 10</code> 公式：<code>high + digit + dight</code></li>
<li>结束条件：cur遍历完所有的位后。</li>
<li>注意更新low cur high digit的先后顺序不能错<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> high = n / <span class="hljs-number">10</span>, cur = n % <span class="hljs-number">10</span>, low = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> digit = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (high || cur) &#123;   <span class="hljs-comment">// 只有同时为0时才结束</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) cnt += high * digit;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) cnt += high * digit + low + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> cnt += (high + <span class="hljs-number">1</span>) * digit;<br>        low += cur * digit;<br>        cur = high % <span class="hljs-number">10</span>;<br>        high /= <span class="hljs-number">10</span>;<br>        digit *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h1><p><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/submissions/">leetcode</a>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。<br>请写一个函数，求任意第n位对应的数字。</p>
<h3 id="解题思路-38"><a href="#解题思路-38" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>先确定n所指的数字是几位数，通过循环相减确定所在哪个区间。</li>
<li>再确定n所指的数字是什么，通过起始值加偏移量确定数子</li>
<li>最后确定n所指的位于数字的第几位，通过取余确定</li>
<li>最后为了方便取出数字的第几位，先转换为字符串，取出后再转换为整型。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> digit = <span class="hljs-number">1</span>, start = <span class="hljs-number">1</span>, cnt = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; cnt) &#123;<br>        n -= cnt;<br>        digit += <span class="hljs-number">1</span>;<br>        start *= <span class="hljs-number">10</span>;<br>        cnt = digit * start * <span class="hljs-number">9</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num = start + (n - <span class="hljs-number">1</span>) / digit;	<span class="hljs-comment">// 括号不能省 n-1 是因为从0开始不是从1开始，减去0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(num)[(n - <span class="hljs-number">1</span>) % digit] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h1><p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">leetcode</a>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<h3 id="解题思路-39"><a href="#解题思路-39" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>本质是一个排序问题，需要设计一定得规则将字串排序并输出</li>
<li>将所有得数字转换为字符串添加到vector数组中，方便使用sort()函数进行排序</li>
<li><code>[](type parm, type parm)&#123;return ;&#125;</code> 使用lamada表达式建立得匿名函数，作为sort函数得比较cmp函数</li>
<li>比较原则：如意两个数字例如：3和30， 如果拼接得字符串330 &gt; 303，就认为3 &gt; 30 <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">minNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    vector&lt;string&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : nums) res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(it));<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>(), [](string str1, string str2)&#123;<span class="hljs-keyword">return</span> str1 + str2 &lt; str2 + str1;&#125;);<br>    string ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : res) ans += it;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3></li>
<li><code> join()</code>：用一个字符去拼接一个字符列表</li>
<li><code>append()</code>：列表得追加</li>
<li><code>functools.cmp_to_key</code>：将老式得cmp函数转换为关键词函数，（python3取消了cmp函数使用关键字函数）<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs Bash">class Solution:<br>    def minNumber(self, nums: List[int]) -&gt; str:<br>        def sort_rule(x, y):<br>            a, b = x + y, y + x<br>            <span class="hljs-keyword">if</span> a &gt; b: <span class="hljs-built_in">return</span> 1<br>            <span class="hljs-keyword">elif</span> a &lt; b: <span class="hljs-built_in">return</span> -1<br>            <span class="hljs-keyword">else</span>: <span class="hljs-built_in">return</span> 0<br>        strs = []<br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            strs.append(str(num))<br>        strs.sort(key = functools.cmp_to_key(sort_rule))<br>        <span class="hljs-built_in">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(strs)<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h1><p><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">leetcode</a>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-40"><a href="#解题思路-40" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>首先想到用动态规划的思路，想想每新增加一个字符对方法数量改变所做的贡献。例如1，只有一种翻译方式，而2加入后可以分两种情况，2翻译成b时，是一种，12一起翻译又是一种方式，</p>
</li>
<li><p>注意所谓的贡献指，新增2对方法数量的贡献，新增2之前的方法数是n，新增2后还是n，贡献值为0。</p>
</li>
<li><p>状态转移方程：先判断新增的数字与前一个数字合并，是否在1~26之间，如果是则dp[i] = d[i -1] + dp[i - 2],否则还是dp[i-1]</p>
</li>
<li><p>题目中还设置了限制，前导0的情况下不算。即01不属于1~26之间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断与前一个数组能否形成一个字母</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (num1 == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> num1 * <span class="hljs-number">10</span> + num2 &gt;= <span class="hljs-number">0</span> &amp;&amp; num1 * <span class="hljs-number">10</span> + num2 &lt;= <span class="hljs-number">25</span>; <br>&#125;<br><br><span class="hljs-comment">// 将一个数，按位填入数组中</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">toVector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">while</span> (num) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(num % <span class="hljs-number">10</span>);<br>        num /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; nums = <span class="hljs-built_in">toVector</span>(num);<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">helper</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) <br>        dp[i] = <span class="hljs-built_in">helper</span>(nums[i - <span class="hljs-number">1</span>], nums[i]) ? dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>] : dp[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>改进版：用string替换数组数据结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">help</span><span class="hljs-params">(string num, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (num[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> || (num[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp; num[i] &lt; <span class="hljs-string">&#x27;6&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    string n = <span class="hljs-built_in">to_string</span>(num);<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n.size())</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">help</span>(n, <span class="hljs-number">1</span>) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i  = <span class="hljs-number">2</span>; i &lt; n.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        dp[i] = <span class="hljs-built_in">help</span>(n, i) ? dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>] : dp[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h1><p><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">leetcode</a>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<h3 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: <br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-41"><a href="#解题思路-41" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>矩阵的动态规划问题，要求到矩阵中的任意一格的值，都与当前格子上和左格子值有关。因此状态转移方程为：<code>dp[i[j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</code></li>
<li>注意边界问题，在第一行和第一列得状态转移方程稍微有所不同，第一个点可以直接跳过比方便遍历<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(row, vector&lt;<span class="hljs-keyword">int</span>&gt;(col, <span class="hljs-number">0</span>));<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[row<span class="hljs-number">-1</span>][col<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h1><p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">leetcode</a>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<h3 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;abcabcbb&quot;<br>输出: 3 <br>解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br>输入: &quot;pwwkew&quot;<br>输出: 3<br>解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-42"><a href="#解题思路-42" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>子串指连续的，子序列可以不连续</p>
</li>
<li><p>一看到子串问题大部分都是用滑动窗口思想解决</p>
</li>
<li><p>首先移动右指针，当发现有重复的字符出现时，开始移动左指针，直到没有重复字符出现，记录长度个数。</p>
</li>
<li><p>判断有无重复字母可用map记录当前窗口中每个字符出现频率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; cnt;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (cnt[s[right]] == <span class="hljs-number">0</span> &amp;&amp; right &lt; n) &#123;<br>            cnt[s[right]]++; <br>            res = <span class="hljs-built_in">max</span>(res, right - left + <span class="hljs-number">1</span>);<br>            right++;<br>        &#125;<br>        cnt[s[left]]--;<br>        left++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>或者使用set来判断是否出现重复数字，记住set的常用操作，<code>emplace(), erase(), find()</code>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> longest = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    unordered_set&lt;<span class="hljs-keyword">char</span>&gt; ch;<br>    <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>        <span class="hljs-keyword">while</span> (ch.<span class="hljs-built_in">find</span>(s[right])  == ch.<span class="hljs-built_in">end</span>() &amp;&amp; right &lt; n ) &#123;<br>            longest = <span class="hljs-built_in">max</span>(longest, right - left + <span class="hljs-number">1</span>);<br>            ch.<span class="hljs-built_in">emplace</span>(s[right]);<br>            right++;<br>        &#125;<br>        ch.<span class="hljs-built_in">erase</span>(s[left]);  <span class="hljs-comment">// 此处容易写成right 必须在left++前</span><br>        left++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> longest;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><p><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">leetcode</a>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<h3 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: n &#x3D; 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-43"><a href="#解题思路-43" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>此题本质上可以看做是合并三个有序序列，因为丑数序列就是合并后去重而已。</li>
<li>因为丑数是前面的丑数乘以2或3或5形成的，因此最终的丑数序列一定是<code>丑数序列 * 2  丑数序列 * 3  丑数序列 * 5</code>合并去重后得到的。</li>
<li>要无重复的合并三个有序序列，每个序列都需要一个指针，比较三指针所指取最小值加入到丑数序列中，最小值的那个指针后移一位</li>
<li>当2个序列指针所指都是最小的。那么这2个序列指针同时后移<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ugly</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>, p3 = <span class="hljs-number">0</span>;<br>    ugly[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> minVal = <span class="hljs-built_in">min</span>(ugly[p1] * <span class="hljs-number">2</span>, <span class="hljs-built_in">min</span>(ugly[p2] * <span class="hljs-number">3</span>, ugly[p3] * <span class="hljs-number">5</span>));<br>        <span class="hljs-keyword">if</span> (minVal == ugly[p1] * <span class="hljs-number">2</span>) p1++;<br>        <span class="hljs-keyword">if</span> (minVal == ugly[p2] * <span class="hljs-number">3</span>) p2++;<br>        <span class="hljs-keyword">if</span> (minVal == ugly[p3] * <span class="hljs-number">5</span>) p3++;<br>        ugly[i] = minVal;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ugly.<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><p><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">leetcode</a><br>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<h3 id="解题思路-44"><a href="#解题思路-44" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>建立哈希表记录所有字符出现次数，第二次在遍历s字符串找到出现次数为1的字母</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : s) <br>        cnt[ch]++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) <br>        <span class="hljs-keyword">if</span> (cnt[ch] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ch; <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h1><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">leetcode</a>输入两个链表，找出它们的第一个公共节点。</p>
<h3 id="解题思路-45"><a href="#解题思路-45" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>太浪漫了 两个结点不断的去对方的轨迹中寻找对方的身影，只要二人有交集，就终会相遇❤</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>    ListNode* p1 = headA;<br>    ListNode* p2 = headB;<br>    <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>        p1 = p1 == <span class="hljs-literal">NULL</span> ? headB : p1-&gt;next;<br>        p2 = p2 == <span class="hljs-literal">NULL</span> ? headA : p2-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1 == <span class="hljs-literal">NULL</span> ? <span class="hljs-literal">NULL</span>: p1;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="在排序数组中查找数字I"><a href="#在排序数组中查找数字I" class="headerlink" title="在排序数组中查找数字I"></a>在排序数组中查找数字I</h1><p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">leetcode</a>统计一个数字在排序数组中出现的次数。</p>
<h3 id="解题思路-46"><a href="#解题思路-46" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>既然题目中提到了是排序数组就要利用这个条件，主要还是考二分法</li>
<li>因为排好序了，所以目标数字一定都是连续得，只要找到最左边得数字，再往后遍历统计数量即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) right = mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> right = mid;  <br>    &#125;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[left++] == target)<br>        cnt++;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="0～n-1中缺失的数字"><a href="#0～n-1中缺失的数字" class="headerlink" title="0～n-1中缺失的数字"></a>0～n-1中缺失的数字</h1><p><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">leetcode</a>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<h3 id="解题思路-47"><a href="#解题思路-47" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>排序数组找某个数首先想到二分法，其次找缺失数字两头数组得不同点，加以区分，发现他们与下标得关系不同</li>
<li>左边数字与下标相同，而右边数组与下标不同，通过二分法找到缺失的位置</li>
<li>边界的判断，如果left指针指向最后一个元素，且当前元素与下标是相等的，说明数组中间并没有缺，缺的是最后一位的数字。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] != mid) right = mid;<br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left == nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; nums[left] == left ? left + <span class="hljs-number">1</span> : left;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h1><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">leetcode</a>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<h3 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1<br>   3<br>  &#x2F; \<br> 1   4<br>  \<br>   2<br>输出: 4<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-48"><a href="#解题思路-48" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>BST的特点是中序遍历是排好序的，稍作调整，让中序遍历的时候先遍历右子树，最后再遍历左子树，可以实现从大到小的顺序<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">dfs</span>(root, k);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span>&amp; k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs</span>(root-&gt;right, k);<br>    <span class="hljs-keyword">if</span> (--k == <span class="hljs-number">0</span>) &#123;<br>        res = root-&gt;val;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(root-&gt;left, k);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">leetcode</a>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h3 id="解题思路-49"><a href="#解题思路-49" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>因为要求每个节点得高度必须先知道其左右子节点高度信息，所以用后序遍历得到左右子书高度</li>
<li>当前节点得高度为左右子树高度最大值 + 1</li>
<li>为了防止重复计算某个子树节点高度可以使用哈希表对遍历过得节点高度进行储存。计算得时候直接进行取值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">unordered_map&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; height;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) &#123;<br>        height[root] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">maxDepth</span>(root-&gt;left);<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">maxDepth</span>(root-&gt;right);<br>    height[root] = <span class="hljs-built_in">max</span>(height[root-&gt;left], height[root-&gt;right]) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> height[root];<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">leetcode</a>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<h3 id="解题思路-50"><a href="#解题思路-50" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>要判断当前节点是否满足平衡二叉树条件需要先知道左右子树得高度差，因此需要先遍历左右子树，因此使用后序遍历</li>
<li>如果左右子节点有任一不满足，直接返回false</li>
<li>如果当前节点不满足也直接返回false</li>
<li>因为计算节点得高度也是后序遍历，因此可以同时用哈希表记录遍历过得节点高度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">unordered_map&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; height;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) &#123;<br>        height[root]  = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isBalanced</span>(root-&gt;left) || !<span class="hljs-built_in">isBalanced</span>(root-&gt;right)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(height[root-&gt;left] - height[root-&gt;right]) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    height[root] = <span class="hljs-built_in">max</span>(height[root-&gt;left], height[root-&gt;right]) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">leetcode</a>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<h3 id="解题思路-51"><a href="#解题思路-51" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>普通思路使用哈希表，但一定不是面试官想要得答案</li>
<li>主要考点还是位运算：<ul>
<li>^异或：x ^ x = 0; </li>
<li>^异或其他常用用法： i ^ 0 = i; i ^ 1 = ~i; (i表示某一位)</li>
</ul>
</li>
<li>全部数字进行异或后，凡是出现两次得数都会抵消掉，因此最后剩下得数就是只出现一次得两个数异或。</li>
<li>加入A ^ B = C 数组c得二进制形式下，某一个位出现的1一定来自与A或B中的其中一个。通过这一位来区别A和B</li>
<li><code>int mask = A &amp; (-A)</code> 可以得A二进制最右边位的1，用这个数mask来做为掩码。</li>
<li>通过mask掩码与运算，所以数字都区分为两类，一类是有掩码位为1的数，另一类是掩码位为0的数</li>
<li>再次分别异或，最终得到只出现一次的两个数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">singleNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num: nums) <br>        sum ^= num;<br>    <span class="hljs-keyword">int</span> res1 = <span class="hljs-number">0</span>, res2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> mask = sum &amp; (-sum);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (mask &amp; num) <br>            res1 ^= num;<br>        <span class="hljs-keyword">else</span> <br>            res2 ^= num;<br>    &#125; <br>    <span class="hljs-keyword">return</span> &#123;res1, res2&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="数组中数字出现的次数II"><a href="#数组中数字出现的次数II" class="headerlink" title="数组中数字出现的次数II"></a>数组中数字出现的次数II</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">leetcode</a><br>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<h3 id="解题思路-52"><a href="#解题思路-52" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>统计所有数字二进制形式下，各个位1出现的次数和，保存再<code>cnt[32]</code></p>
</li>
<li><p>出现3次数字的位，1的个数一定是3的倍数，因此对cnt[32]各位进行3的取模运算。</p>
</li>
<li><p>最终再将cnt[32]转换为整型数字，即为所求</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt[<span class="hljs-number">32</span>];<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) * <span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 每个数都要重新复位一下, 不用无符号会报错</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (num &amp; mask) cnt[i]++;<br>            mask &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>        res &lt;&lt;= <span class="hljs-number">1</span>;      <span class="hljs-comment">// 必须先左移，否则结果最后会多移一位，变成2倍的值</span><br>        res += cnt[i] % <span class="hljs-number">3</span>;   <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>还有一种更为玄学的操作，了解一下即可  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> once = <span class="hljs-number">0</span>, twice = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>        once = once ^ num &amp; ~twice;<br>        twice = twice ^ num &amp; ~once;<br>    &#125;<br>    <span class="hljs-keyword">return</span> once;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h1><p><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">leetcode</a><br>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<h3 id="解题思路-53"><a href="#解题思路-53" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>既然题目中已经给出了增序数列，一般考的就是二分搜索<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-built_in">qsort</span>(nums, target - num);<br>        <span class="hljs-keyword">if</span> (res &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;num , res&#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">qsort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> target;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) right = mid;<br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>或者两头使用双指针法遍历</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right =nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (nums[left] + nums[right] &gt; target) right--;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] + nums[right] == target) <span class="hljs-keyword">return</span> &#123;nums[left],nums[right]&#125;;<br>        <span class="hljs-keyword">else</span> left++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h1><p><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">leetcode</a><br>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。<br>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<h3 id="解题思路-54"><a href="#解题思路-54" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>类似与找连续字串的问题，都要想到滑动窗口思想</li>
<li>右指针一直往后移动，知道窗口内的和大于等于<code>target</code>,如果等于<code>target</code>就存入结果中，如果大于就移动左指针。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">findContinuousSequence</span>(<span class="hljs-keyword">int</span> target) &#123;<br>     <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = <span class="hljs-number">1</span>;<br>     vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>     <span class="hljs-keyword">while</span> (right &lt; target) &#123;<br>         <span class="hljs-keyword">while</span> ((left + right) * (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt; target) &#123;<br>             right++;<br>         &#125;<br>         <span class="hljs-keyword">if</span> ((left + right) * (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> == target) &#123;<br>             vector&lt;<span class="hljs-keyword">int</span>&gt; ret;<br>             <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right; ++i) &#123;<br>                 ret.<span class="hljs-built_in">push_back</span>(i);<br>             &#125;<br>             res.<span class="hljs-built_in">push_back</span>(ret);<br>         &#125;<br>         left++;<br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h1><p><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">leetcode</a>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<h3 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;the sky is blue&quot;<br>输出: &quot;blue is sky the&quot;<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-55"><a href="#解题思路-55" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>反转类型的题，首先想到用栈</li>
<li>遍历字符串，分割字符串并生成字符串模板，字符串入栈。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;string&gt; sck;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;    <br>        string str;<br>        <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; !<span class="hljs-built_in">isblank</span>(s[i])) &#123;<br>            str += s[i];<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!str.<span class="hljs-built_in">empty</span>()) sck.<span class="hljs-built_in">push</span>(str);    <span class="hljs-comment">// 防止空串入栈</span><br>    &#125;<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">while</span> (!sck.<span class="hljs-built_in">empty</span>()) &#123;<br>        res = res + sck.<span class="hljs-built_in">top</span>() + <span class="hljs-string">&#x27; &#x27;</span>;<br>        sck.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!res.<span class="hljs-built_in">empty</span>()) res.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-comment">// 防止弹出空字符串</span><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><p><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">leetcode</a>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<h3 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2<br>输出: &quot;cdefgab&quot;<br></code></pre></td></tr></table></figure>

<h3 id="解题思路-56"><a href="#解题思路-56" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>因为只是互换位置，字串的长度没有变化，从位置k开始遍历，如果超过len就对<code>len</code>取模，形成从头循环。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        res += s[(n + i) % len];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>偷懒的方式直接使用库函数strstr()提取子串</li>
<li><code>strstr(int begin, int end)</code> 注意end指最后一位字母的后一位索引。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(n, s.<span class="hljs-built_in">size</span>()) + s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">leetcode</a><br>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<h3 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3<br>输出: [3,3,5,5,6,7] <br>解释: <br><br>  滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7<br><br></code></pre></td></tr></table></figure>
<h3 id="解题思路-57"><a href="#解题思路-57" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>维护一个单调队列，队列头部一直保存窗口里的最大值，如果窗口右移时，窗口左边界正好丢弃的是最大值，那么单调队列头部出列。</li>
<li>正常窗口右边界加入的数字都要依次与队列队尾部比较，进加入的数更大，就不断让它往前走，保持队列一直是单调递减的。</li>
<li>注意窗口左右边界的运动范围，<code>1 - k &lt; left &lt; n - k + 1</code> 和  <code>0 &lt; right &lt; n</code> 两个指针同时运动。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt; que;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span> - k, right = <span class="hljs-number">0</span>; right &lt; nums.<span class="hljs-built_in">size</span>(); ++left, ++right) &#123;<br>        <span class="hljs-comment">// 删除得元素等于队首元素时，弹出队首 因为left - 1为弹出的元素，所以left指针不能 = 0.</span><br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span> &amp;&amp; que.<span class="hljs-built_in">front</span>() == nums[left - <span class="hljs-number">1</span>]) que.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-comment">// 保持队列单调递减</span><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[right] &gt; que.<span class="hljs-built_in">back</span>()) que.<span class="hljs-built_in">pop_back</span>();<br>        que.<span class="hljs-built_in">push_back</span>(nums[right]);<br>        <span class="hljs-keyword">if</span> (left &gt;= <span class="hljs-number">0</span>) res.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// left = 0以后才形成窗口，才有最大值出现。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h1><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">leetcode</a><br>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<h3 id="解题思路-58"><a href="#解题思路-58" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>维护两个队列，一个存储正常的数据，一个维护当前最大值的队列</li>
<li>单调队列：新加入的数组必须不断与队尾比较，直到找到他合适的位置，队列一直时单调递减的</li>
<li>删除元素时，相等时同时弹出两个队列头部。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; data;<br>    deque&lt;<span class="hljs-keyword">int</span>&gt; maxque;<br>    <span class="hljs-built_in">MaxQueue</span>() &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!maxque.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> maxque.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!maxque.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; maxque.<span class="hljs-built_in">back</span>()) maxque.<span class="hljs-built_in">pop_back</span>();<br>        data.<span class="hljs-built_in">push</span>(value);<br>        maxque.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> res = data.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-keyword">if</span> (res == maxque.<span class="hljs-built_in">front</span>()) maxque.<span class="hljs-built_in">pop_front</span>();<br>        data.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h1><p><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">leetcode</a><br>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。<br>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<h3 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: 2<br>输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-59"><a href="#解题思路-59" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>二维的动态规划问题</li>
<li>首先了解概率问题都是统计次数，最后除以总次数，所以问题转化为，投掷n个骰子，所有点数出现的总次数是6^n，因为每个骰子点数都有6种可能</li>
<li>我们的目的就是 计算出投掷完 n 枚骰子后每个点数出现的次数。</li>
<li>单单看第 n 枚骰子，它的点数可能为 1~6因此投掷完 n 枚骰子后点数 j 出现的次数，可以由投掷完 n-1枚骰子后，对应点数 j-1, j-2, j-3, … , j-6 出现的次数之和转化过来。</li>
<li>状态转移方程：<code>dp[n][j]= dp[n-1][j-1] + dp[n-1][j-2] + dp[n-1][j-3] + dp[n-1][j-4] + dp[n-1][j-5] + dp[n-1][j-6]</code></li>
<li>边界处理:投掷完 1枚骰子后，它的可能点数分别为 1, 2, 3, … , 6并且每个点数出现的次数都是 1<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">6</span> * n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; ++i) <br>        dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;				<span class="hljs-comment">// i: 投掷i个骰子</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt;= <span class="hljs-number">6</span> * i ; ++j) &#123;     <span class="hljs-comment">// j: 点数和的范围</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">6</span>; ++k) &#123;      <span class="hljs-comment">// k: 1~6点数  </span><br>                <span class="hljs-keyword">if</span> (j &gt; k) dp[i][j] += dp[i - <span class="hljs-number">1</span>][j - k]; <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> total = <span class="hljs-built_in">pow</span>(<span class="hljs-number">6</span>, n);<br>    vector&lt;<span class="hljs-keyword">double</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &lt;= <span class="hljs-number">6</span> * n; ++j) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(dp[n][j] * <span class="hljs-number">1.0</span> / total);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h1><p><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">leetcode</a><br>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<h3 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [0,0,1,2,5]<br>输出: True<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-60"><a href="#解题思路-60" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>因为0代表所有牌，所以只要找到数组中不连续的牌，看他们之间能允许插入几张牌才能使他们连续，最后与0牌的数量进行比较即可</li>
<li>先递增排序，0会出现在前面，统计0出现的次数</li>
<li>因为是递增排序，所以当前数字与后面的数字差大于1说明出现了不连续，如果需要插入0的个数大于已有的0个数，说明不能组成顺子</li>
<li>off等于0说明重复数字，不算顺子</li>
<li>off代表前后的偏差<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> off = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;<br>            cnt++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        off = <span class="hljs-built_in">abs</span>(nums[i] - nums[i + <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (off == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (off == <span class="hljs-number">0</span> || off - <span class="hljs-number">1</span> &gt; cnt ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h1><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">leetcode</a><br>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。<br>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<h3 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: n &#x3D; 5, m &#x3D; 3<br>输出: 3<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-61"><a href="#解题思路-61" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>普通人思路：通过新建一个链表来模拟操作，但是对于大数会出现超时</li>
<li>模拟一个循环链表,n个数字，需要删除<code>n - 1</code>次</li>
<li>注意list的erase删除操作，参数必须是迭代器，返回值也是迭代器，而且是删除元素后一个位置的迭代器。</li>
<li>移动迭代器只能通过++自增操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    list&lt;<span class="hljs-keyword">int</span>&gt; myList;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <br>        myList.<span class="hljs-built_in">push_back</span>(i);<br>    n--;<br>    <span class="hljs-keyword">auto</span> it = myList.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; ++i) &#123;<br>            it++;<br>            <span class="hljs-keyword">if</span> (it == myList.<span class="hljs-built_in">end</span>()) it = myList.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        it = myList.<span class="hljs-built_in">erase</span>(it);<br>        <span class="hljs-keyword">if</span> (it == myList.<span class="hljs-built_in">end</span>()) it = myList.<span class="hljs-built_in">begin</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> myList.<span class="hljs-built_in">front</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h1><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">leetcode</a>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<h3 id="示例-18"><a href="#示例-18" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-62"><a href="#解题思路-62" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>动态规划问题，建立dp数组，则<code>dp[i]</code>代表前<code>i</code>天能获得的最大利润，结果返回<code>dp[n-1]</code></li>
<li><code>dp[i]</code> 的值与前一天的最大利润<code>dp[i-1]</code>有关，如果前一天的利润比当天卖掉股票的最大利润还要大，那就继续用前一天的利润。</li>
<li>如果当天卖股票，就需要知道前面i天当中的最小值，所以可以边遍历边记录最小值。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">int</span> minVal = prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        minVal = <span class="hljs-built_in">min</span>(minVal, prices[i]);<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i <span class="hljs-number">-1</span>], prices[i] - minVal);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a>求1+2+…+n</h1><p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">leetcode</a><br>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h3 id="解题思路-63"><a href="#解题思路-63" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>高斯就和法需要用到四则运算,也可以这样抖个机灵。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(<span class="hljs-built_in">pow</span>(n, <span class="hljs-number">2</span>) + n) &gt;&gt; <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure></li>
<li>迭代法需要用到循环操作<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) <br>     res += i; <br></code></pre></td></tr></table></figure></li>
<li>只能用递归法，不过递归一般需要if()来结束跳出递归，</li>
<li>可以使用逻辑运算符的特性，<code>&amp;&amp;</code>的短路效果来代替跳出操作。也因此<code>&amp;&amp; ||</code>这种运算符无法重载</li>
<li>当<code>n = 1</code>的时候，对于&amp;&amp;运算已经判断为<code>false</code>，就不会执行后面的语句，因此直接<code>return n</code>; 此时<code>n=1</code><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        n &gt; <span class="hljs-number">1</span> &amp;&amp; (n += <span class="hljs-built_in">sumNums</span>(n - <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h1><p><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">leetcode</a><br>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<h3 id="解题思路-64"><a href="#解题思路-64" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>此题主要想考的是二进制形式下的加法运算，一般会用到位运算符</li>
<li>先从一个位考虑<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">不考虑进位时：<br>0 + 0 &#x3D; 0<br>0 + 1 &#x3D; 1<br>1 + 0 &#x3D; 1<br>1 + 1 &#x3D; 0<br>正好是异或运算<br></code></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">只考虑进位c<br>00 + 00 &#x3D; 00  	c &#x3D; 0<br>01 + 00 &#x3D; 01	c &#x3D; 0<br>00 + 01 &#x3D; 01	c &#x3D; 0<br>01 + 01 &#x3D; 10	c &#x3D; 1 <br>正好是&amp;运算，但是需要左移一位<br></code></pre></td></tr></table></figure></li>
<li>所以两个数之和a + b 就转换位二进制形式下的<code>s + c</code> , s代表<code>a ^ b</code>,c代表<code>a &amp; b &lt;&lt; 1</code></li>
<li>但是由于题目要求不能使用加号，所以<code>s + c</code> 通过继续循环的方式相加，把s赋值给a,c赋值给b，继续循环计算<code>a + b</code>,直到第二个加数为0结束。</li>
<li>注意c++里，左移不能作用在负数，因此左移前需要格式转换为无符号类型。 <code>&lt;&lt;</code> 的优先级高于 <code>&amp;</code>记得加括号。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> c = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;<br>        a ^= b;<br>        b = c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h1><p><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">leetcode</a><br>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<h3 id="示例-19"><a href="#示例-19" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [1,2,3,4,5]<br>输出: [120,60,40,30,24]<br></code></pre></td></tr></table></figure>

<h3 id="解题思路-65"><a href="#解题思路-65" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>本质上是一道动态规划，维护两个dp数组</li>
<li>B数组中的每第i数都是由A数组中A[i]左边的所有数之积和A[i]右边的所有数之积相乘得到的。</li>
<li>因此一个dp数组用来记录i以左的乘积，另一个记录i以右的乘积</li>
<li>状态转移方程分别为<code>leftDP[i] = leftDP[i - 1] * a[i - 1]</code>和<code>rightDP[i] = rightDP[i + 1] * a[i + 1]</code></li>
<li>注意边界：左边从第二个数字开始建立dp，右边从倒数第二个数字开始建立dp。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">constructArr</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = a.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">leftDP</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rightDP</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>		<br>    leftDP[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        leftDP[i] = leftDP[i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    rightDP[n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        rightDP[i] = rightDP[i + <span class="hljs-number">1</span>] * a[i + <span class="hljs-number">1</span>];<br>    &#125;<br>   <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        res[i] = leftDP[i] * rightDP[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h1><p><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">leetcode</a><br>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;42&quot;<br>输出: 42<br></code></pre></td></tr></table></figure>

<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;   -42&quot;<br>输出: -42<br>解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。<br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 <br></code></pre></td></tr></table></figure>

<h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;4193 with words&quot;<br>输出: 4193<br>解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。<br></code></pre></td></tr></table></figure>

<h3 id="示例4"><a href="#示例4" class="headerlink" title="示例4:"></a>示例4:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;words and 987&quot;<br>输出: 0<br>解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。<br>     因此无法执行有效的转换。<br></code></pre></td></tr></table></figure>

<p>###示例5:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: &quot;-91283472332&quot;<br>输出: -2147483648<br>解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 <br>     因此返回 INT_MIN (−231) 。<br></code></pre></td></tr></table></figure>

<h3 id="解题思路-66"><a href="#解题思路-66" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>用一个指针i从头到尾遍历</li>
<li>忽略空格，遍历到第一个非空格字符为止，判断<code>+-</code>正负号,</li>
<li>继续往后遍历，如果是数字字符就进行转换，如果不是数字就停止转换将之前的转换的结果输出。</li>
<li>注意1：输出数字之前都要先判断正负，再输出。</li>
<li>注意2：如果不允许使用long只能用int作为转换数字的容器时，<br>需要在 <code>res * 10</code>之前先判断当前<code>res</code>是否已经大于<code>INT_MAX / 10</code>,或者当前res已经等于<code>INT_MAX / 10</code>,但是最右边新加入的位大于<code>7</code>说明这个字符已经超过了32位整数的最大值，需要直接输出INT_MAX。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 跳过空格</span><br>    <span class="hljs-keyword">while</span>(str[i] == <span class="hljs-string">&#x27; &#x27;</span>) i++;<br>    <span class="hljs-comment">// 判断符号</span><br>    <span class="hljs-keyword">bool</span> isNeg = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>        isNeg = <span class="hljs-literal">true</span>;<br>        i++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>        i++;<br>    <span class="hljs-comment">// 转换数字</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; str.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (str[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;      <br>            <span class="hljs-keyword">if</span> (res &gt; INT_MAX / <span class="hljs-number">10</span> || (res == INT_MAX / <span class="hljs-number">10</span> &amp;&amp; str[i] &gt; <span class="hljs-string">&#x27;7&#x27;</span>)) <br>	<span class="hljs-keyword">return</span> isNeg == <span class="hljs-literal">true</span> ? INT_MIN : INT_MAX;    <span class="hljs-comment">// 数字边界处理</span><br>            res = res * <span class="hljs-number">10</span> + (str[i] - <span class="hljs-string">&#x27;0&#x27;</span>); 	<span class="hljs-comment">// 括号不能省，因为可能会溢出</span><br>            <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> isNeg == <span class="hljs-literal">true</span> ? -res : res;       <span class="hljs-comment">// 不是数字直接返回前面转换得数字结果 </span><br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isNeg == <span class="hljs-literal">true</span> ? -res : res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>如果用能用long，比较麻烦，因为res可以超过int的界限，所以再返回答案之前都需要先判断res是否越界。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">....前面都一样<br>       <span class="hljs-keyword">long</span> res  = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>           <span class="hljs-keyword">if</span> (res &gt; INT_MAX || res &lt; INT_MIN) <span class="hljs-keyword">return</span> isNeg ? INT_MIN : INT_MAX;<br>           <span class="hljs-keyword">if</span> (str[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>               res = res * <span class="hljs-number">10</span> + (str[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>               <span class="hljs-keyword">continue</span>;<br>           &#125;<br>           <span class="hljs-keyword">return</span> isNeg ? -res : res;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (res &gt; INT_MAX || res &lt; INT_MIN) <span class="hljs-keyword">return</span> isNeg ? INT_MIN : INT_MAX;<br>       <span class="hljs-keyword">return</span> isNeg ? -res : res;<br>   &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h1><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">leetcode</a><br>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="aa"></p>
<h3 id="示例-20"><a href="#示例-20" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6 <br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br></code></pre></td></tr></table></figure>
<h3 id="示例-21"><a href="#示例-21" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure>

<h3 id="解题思路-67"><a href="#解题思路-67" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>根据BST特性，当前值大于qp，说明p，q都在左子树，就往左子树继续递归，当前值小于qp，说明p，q都在右子树。</li>
<li>p，q各在一边，说明当前的根就是最近共同祖先。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; q-&gt;val &amp;&amp; root-&gt;val &gt; p-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>    <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>    <span class="hljs-keyword">return</span> root; <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">leetcode</a><br>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="aa"></p>
<h3 id="示例-22"><a href="#示例-22" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br></code></pre></td></tr></table></figure>

<h3 id="解题思路-68"><a href="#解题思路-68" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>pq得公共结点就意味着p和q分别出现在当前节点的左右子树。</li>
<li>因此，当递归遍历到pq结点的时候，直接返回该结点，如果没发现就继续往下遍历。</li>
<li>当左右子树返回的不是<code>null</code>就说明这棵树下面发现了qp节点。</li>
<li>如果只有一棵树返回了<code>null</code>说明另一棵树发现了qp节点，就继续往上返回它，告诉上游此也树发现了pq节点。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> root;<br>    TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>    TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>    <span class="hljs-keyword">if</span> (left &amp;&amp; right) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (left) <span class="hljs-keyword">return</span> left;<br>    <span class="hljs-keyword">if</span> (right) <span class="hljs-keyword">return</span> right;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>另一种思路：前序遍历记录从根节点到qp结点的两条路径，然后路径逐个比较，最后一个相同的结点即为最近公共结点。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;TreeNode*&gt;&gt; path;<br><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    vector&lt;TreeNode*&gt; path1;<br>    vector&lt;TreeNode*&gt; path2;<br>    <span class="hljs-built_in">getPath</span>(root, p, path1);<br>    <span class="hljs-built_in">getPath</span>(root, q, path2);<br>    <br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">min</span>(path[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), path[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>());	<span class="hljs-comment">// 按最短的路径长度比较</span><br>    TreeNode* res = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (path[<span class="hljs-number">0</span>][i] == path[<span class="hljs-number">1</span>][i])<br>            res = path[<span class="hljs-number">0</span>][i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getPath</span><span class="hljs-params">(TreeNode* root, TreeNode* tar, vector&lt;TreeNode*&gt;&amp; path)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    path.<span class="hljs-built_in">push_back</span>(root);<br>    <span class="hljs-keyword">if</span> (root == tar) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;path.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">getPath</span>(root-&gt;left, tar, path);<br>    <span class="hljs-built_in">getPath</span>(root-&gt;right, tar, path);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/posts/2633a26.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🍻位运算🍻"><a href="#🍻位运算🍻" class="headerlink" title="🍻位运算🍻"></a>🍻位运算🍻</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p>
<span id="more"></span>

<ul>
<li><a href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97">136.只出现一次的数字</a></li>
<li><a href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II">137.只出现一次的数字II</a></li>
<li><a href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III">260.只出现一次的数字III</a></li>
<li><a href="#%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0">191.位1的个数</a></li>
<li><a href="#%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0">338.比特位计数</a></li>
<li><a href="#%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D">190.颠倒二进制位</a></li>
</ul>
<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p><a href="https://leetcode-cn.com/problems/single-number/">leetcode</a>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一种方法是先排序，因为两个相同的数一定在一起，两个数一起遍历，当发现不同的时候便找到结果</li>
<li>当遍历到结尾时还没有发现则说明那一个数就出现在最后一位。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  i + <span class="hljs-number">2</span> &lt; nums.<span class="hljs-built_in">size</span>(); i+=<span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != nums[i + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>异或的性质：</li>
<li>任何数和 0做异或运算，结果仍然是原来的数</li>
<li>任何数和其自身做异或运算，结果是 0</li>
<li>异或运算满足交换律和结合律，本题就是应用这一性质<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : nums) &#123;<br>        res ^= it;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="只出现一次的数字II"><a href="#只出现一次的数字II" class="headerlink" title="只出现一次的数字II"></a>只出现一次的数字II</h1><p><a href="https://leetcode-cn.com/problems/single-number-ii/">leetcode</a><br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>位运算实在烧脑<a href="https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/">参考题解</a></li>
<li>用哈希表还是香</li>
<li>基本思想是，由于数字都是出现3次，所以这个数它的二进制任意位1的个数和都是3，当把所有的数字全部相加的和的二进制任意位1的个数一定是3的倍数，那么可以设计一种状态转换公式，使所有数字以二进制形式相加，各个位的1当出现第3次时变为0，这样最后剩下仍为1的位，就是只出现1次的数的二进制。</li>
<li>但是二进制只能表达2中状态，所以需要2位二进制<code> 00-&gt; 01-&gt; 10</code> 来表达任意位三种不同的状态。int数字有32位组成，所以需要两个整型变量one和two来状态转换。one表示1出现0次和1次，two表示1出现2次，因为出现第三次会变为0，所以最终的结果就是返回one<blockquote>
<p>异或运算：x ^ 0 = x​ ， x ^ 1 = ~x<br>与运算：x &amp; 0 = 0 ， x &amp; 1 = x</p>
</blockquote>
<h3 id="推导one的计算方式"><a href="#推导one的计算方式" class="headerlink" title="推导one的计算方式"></a>推导one的计算方式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> two == <span class="hljs-number">0</span>:<br>  <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>    one = one<br>  <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>    one = ~one<br><span class="hljs-keyword">if</span> two == <span class="hljs-number">1</span>:<br>    one = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="通过异或运算简化"><a href="#通过异或运算简化" class="headerlink" title="通过异或运算简化"></a>通过异或运算简化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> two == <span class="hljs-number">0</span>:<br>    one = one ^ n<br><span class="hljs-keyword">if</span> two == <span class="hljs-number">1</span>:<br>    one = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h3 id="与运算简化"><a href="#与运算简化" class="headerlink" title="与运算简化"></a>与运算简化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">one = one ^ n &amp; ~two<br></code></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> one = <span class="hljs-number">0</span>, two = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        one = ~two  &amp; one ^ num);<br>        two = ~one  &amp; two ^ num);<br>    &#125;<br>    <span class="hljs-keyword">return</span> one <br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="只出现一次的数字III"><a href="#只出现一次的数字III" class="headerlink" title="只出现一次的数字III"></a>只出现一次的数字III</h1><p><a href="https://leetcode-cn.com/problems/single-number-iii/">leetcode</a>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: [1,2,1,3,2,5]<br>输出: [3,5]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>全部异或就能得到只出现1次的数x和y的异或。然后想办法分离他俩。他俩异或的结果，任意位出现的1，这个1只属于是他俩的其中一个。所以在异或结果中，随便找一个为1的位就能区分他俩。</li>
<li>所以通过 <code>int diff = mask &amp; (-mask);</code>找到最右边的1那个位来区分他俩,</li>
<li>依然对所有数字异或,但加了条件<code>n &amp; diff</code>，这次只有那一位为1的数字才加入异或，通过这样就一定可以剔除掉另一个数字，<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;<br>        mask ^= n;<br>    &#125;<br>    <span class="hljs-keyword">int</span> diff = mask &amp; (-mask);<br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; diff) &#123;<br>            x ^= n;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> y = mask ^ x;<br>    <span class="hljs-keyword">return</span> &#123;x, y&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a>位1的个数</h1><p><a href="https://leetcode-cn.com/problems/number-of-1-bits/">leetcode</a>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>方法一：定义掩码，逐位比较，掩码每次左移一位， <code>mask &lt;&lt;= 1</code>注意掩码必须使用无符号类型。</li>
<li>方法二：或者原码每次右移一位，与1进行比较。</li>
<li>方法三：每次反转原码的最后一位1，<code>n &amp;= (n - 1)</code>，直到原码变为0，最后统计反转的次数 <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">uint32_t</span> mask = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; mask)  cnt++;<br>        mask &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (n) &#123;<br>      <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) cnt++;<br>      n &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        n &amp;= n - <span class="hljs-number">1</span>;<br>        cnt++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h1><p><a href="https://leetcode-cn.com/problems/counting-bits/">leetcode</a>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: 2<br>输出: [0,1,1]<br></code></pre></td></tr></table></figure>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: 5<br>输出: [0,1,1,2,1,2]<br></code></pre></td></tr></table></figure>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>首先理解题意，返回的数组表示每个数字 <code>i</code> 的二进制数1的个数，数组大小一定是num+1,因为包含了数字0。</li>
<li>奇数二进制表示最低位是1，偶数是0。</li>
<li>奇数：二进制表示中，奇数一定比前面那个偶数多一个 1</li>
<li>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多，因为偶数最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。</li>
<li>奇数偶数判断出了用 <code>i % 2 == 0</code> 还可以用<code>i &amp; 1 ==0 </code>来判断偶数。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(num + <span class="hljs-number">1</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;<br>        <span class="hljs-keyword">if</span>((i &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) dp[i] = dp[i / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">else</span> dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="颠倒二进制位"><a href="#颠倒二进制位" class="headerlink" title="颠倒二进制位"></a>颠倒二进制位</h1><p><a href="https://leetcode-cn.com/problems/reverse-bits/">leetcode</a>颠倒给定的 32 位无符号整数的二进制位。</p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>如果做过反转一个十进制数的题，这道题基本与之相似，反转十进制使用的算法是: 类似栈从后往前不断弹出数字，<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> rev = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (n) &#123;<br>    rev = rev * <span class="hljs-number">10</span> + n % <span class="hljs-number">10</span>;<br>    n /=<span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>而对于二进制数，实际上也可以,只是系数变为了2<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> rev = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (n) &#123;<br>    rev = rev * <span class="hljs-number">2</span> + n % <span class="hljs-number">2</span>;<br>    n /=<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>但是需要考虑到整型溢出问题，还有二进制要考虑前导零的问题。所以我们可以替换为位操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">uint32_t</span> rev = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>        rev = (rev &lt;&lt; <span class="hljs-number">1</span>) + (n &amp; <span class="hljs-number">1</span>);<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> rev;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>位运算</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/posts/649c2087.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="🐧二分法🐧"><a href="#🐧二分法🐧" class="headerlink" title="🐧二分法🐧"></a>🐧二分法🐧</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p>
<span id="more"></span>

<p>ps:二分法一定要牢记3个经常用的模板，注意边界检测。</p>
<ul>
<li><a href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE">34.在排序数组中查找元素的第一个和最后一个位置</a></li>
<li><a href="#x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9">69.x的平方根</a></li>
<li><a href="#%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC">153.寻找旋转排序数组中的最小值</a></li>
<li><a href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">167.两数之和II-输入有序数组</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC">278.第一个错误的版本</a></li>
<li><a href="#%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D">744.寻找比目标字母大的最小字母</a></li>
</ul>
<h1 id="二分法的3个模板必须记住"><a href="#二分法的3个模板必须记住" class="headerlink" title="二分法的3个模板必须记住     "></a>二分法的3个模板必须记住     </h1><p>3个模板代码区别很小，主要在于找到target之后指针的处理，建议比较target时的大于小于等于三种情况都写出来进行讨论，不易搞混淆，还要牢记左右指针的越界时的处理。while循环里时&lt;=符号，while循环结束后right指针在前，left指针在后。</p>
<ul>
<li>寻找一个数（基本的二分搜索）   </li>
<li>寻找左侧边界的二分搜索（检查 left 越界的情况）   </li>
<li>寻找右侧边界的二分搜索（检查 right越界的情况)   </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>	<span class="hljs-comment">//直接返回</span><br>            right = mid - <span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;  <span class="hljs-comment">//此处注意区别</span><br>            <span class="hljs-comment">// 别返回，收缩左侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后要检查 left 越界的情况</span><br>    <span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;  <span class="hljs-comment">//此处注意区别</span><br>            <span class="hljs-comment">// 别返回，收缩右侧边界</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后要检查 right 越界的情况</span><br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || nums[right] != target)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">leetcode</a>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>你的算法时间复杂度必须是 O(log n) 级别。<br>如果数组中不存在目标值，返回 [-1, -1]。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>用二分法找左右边界，直接套用上面的模板</li>
<li>找左右边界的函数唯一不同点在于当<code>nums[mid] == target</code>时对指针的操作不同:找左边界就要不断往左压缩即右指针不断往左走<code>right = mid - 1;</code>，函数最后返回左指针，找右边界不断往右压缩即左指针不断往右走<code>left = mid + 1</code>，函数返回右指针</li>
<li>注意:要防止左右指针的溢出，和确定所指的数是否是目标值（可能目标值并不存在于数组中）<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left  = <span class="hljs-built_in">findLeft</span>(nums, target);<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">findRight</span>(nums, target);<br>    <span class="hljs-keyword">return</span> &#123;left, right&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLeft</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;=right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left &gt;= nums.<span class="hljs-built_in">size</span>() || nums[left] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRight</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;=right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || nums[right] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="x的平方根"><a href="#x的平方根" class="headerlink" title="x的平方根"></a>x的平方根</h1><a href="https://leetcode-cn.com/problems/sqrtx/">leetcode</a>实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。<br>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3></li>
<li>二分法，从比x小的数中找平方等于x的值。</li>
<li>注意:结尾返回right而不是left是因为，while循环结束时，<code>right &lt; left</code>，如果x平方根不是整数，那么将会处于(r, l)指针区间内，所以只保留整数意味着返回r所指的数。</li>
<li>因为两数相乘可能涉及到溢出问题，所以可以将乘法转换为除法代替<code>mid * mid == x 改为 mid == x / mid</code>。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = x;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid == x / mid) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid &lt; x / mid)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid &gt; x / mid) &#123;<br>            right = mid <span class="hljs-number">-1</span> ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h1><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">leetcode</a>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。请找出其中最小的元素。你可以假设数组中不存在重复元素。</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>使用二分法解决问题的关键是先发现要查找元素的两边数据的特性，左边的数据一定大于数组的最后一位，右边的数据一定小于数组的最后一位，所以选择最后一位作为target进行比较。  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> target = nums[right];<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[left];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="两数之和II-输入有序数组"><a href="#两数之和II-输入有序数组" class="headerlink" title="两数之和II-输入有序数组"></a>两数之和II-输入有序数组</h1><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">leetcode</a>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<blockquote>
<p>说明:<br>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>本题推荐哈希表解答，但这里提供一个二分法思路，在看到升序排列的有序数组时，要先想到二分法。</li>
<li>基本思路：遍历数组，对于每个数都用二分法来查找第二个数<code>target - nums[i]</code>即可  </li>
<li>注意：不可以重复使用相同的元素，即第二个数不能和第一个数重复，所以函数参数记录了第一个数的下标。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">int</span> num2 = target - numbers[i];<br>        <span class="hljs-keyword">int</span> index2 = <span class="hljs-built_in">binarySearch</span>(numbers, i, num2);<br>        <span class="hljs-keyword">if</span> (index2 != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> &#123;i + <span class="hljs-number">1</span> , index2 + <span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (numbers[mid] == target) &#123;<br>            <span class="hljs-keyword">if</span> (mid != index1)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h1><p><a href="https://leetcode-cn.com/problems/first-bad-version/">leetcode</a>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。<br>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。<br>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>升序数组 且 第一个错误版本之前是好的，之后都是坏的，很容易想到二分搜索查找最左边界的错误版本。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = n;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isBadVersion</span>(mid)) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="寻找比目标字母大的最小字母"><a href="#寻找比目标字母大的最小字母" class="headerlink" title="寻找比目标字母大的最小字母"></a>寻找比目标字母大的最小字母</h1><p><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">leetcode</a>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。<br>在比较时，字母是依序循环出现的。举个例子：</p>
<blockquote>
<p>如果目标字母 target = ‘z’ 并且字符列表为 letters = [‘a’, ‘b’]，则答案返回 ‘a’</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入:<br>letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]<br>target &#x3D; &quot;c&quot;<br>输出: &quot;f&quot;<br><br>输入:<br>letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]<br>target &#x3D; &quot;d&quot;<br>输出: &quot;f&quot;<br><br>输入:<br>letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]<br>target &#x3D; &quot;g&quot;<br>输出: &quot;j&quot;<br><br>输入:<br>letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]<br>target &#x3D; &quot;j&quot;<br>输出: &quot;c&quot;<br><br>输入:<br>letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]<br>target &#x3D; &quot;k&quot;<br>输出: &quot;c&quot;<br><br></code></pre></td></tr></table></figure>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>代码比较简单，主要是理解函数最后应该返回left还是right的问题</li>
<li>题意知，我们要在一个有序数组中找比目标字母大的最小字母，首先需要先找到目标字母的最后一位，也就是右边界，然后再往后一位即为所求。</li>
<li>二分法找右边界，左指针不断往右压缩</li>
<li>while循环结束后，无论有没有找到，目标字母一定在<code>[right, left)</code>区间内，因为是往右压缩，所以如果数组中存在目标字母，那就是right所指的字母，如果不存在，目标字母一定在right和left所指的字母之间。但题目要求找比目标字母稍大的字母，所以left所指正好满足。所以返回值要返回left指针。  </li>
<li>根据上一条分析，函数应该返回left指针，就要考虑left指针的溢出问题，当left超出数组边界时，返回数组首字母。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">nextGreatestLetter</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; letters, <span class="hljs-keyword">char</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = letters.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (letters[mid] == target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (letters[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (letters[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left &gt;= letters.<span class="hljs-built_in">size</span>() ?  letters[<span class="hljs-number">0</span>] : letters[left]<br>&#125; <br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>并发与多线程</title>
    <url>/posts/12e8fad9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="并发与多线程"><a href="#并发与多线程" class="headerlink" title="并发与多线程"></a>并发与多线程</h3><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p>
<span id="more"></span>

<h1 id="1、创建线程"><a href="#1、创建线程" class="headerlink" title="1、创建线程  "></a>1、创建线程  </h1><h2 id="调用线程函数："><a href="#调用线程函数：" class="headerlink" title="调用线程函数： "></a>调用线程函数： </h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">thread myThread(函数名);<br></code></pre></td></tr></table></figure>
<h2 id="可调用对象做参数："><a href="#可调用对象做参数：" class="headerlink" title="可调用对象做参数：  "></a>可调用对象做参数：  </h2><ul>
<li>线程的入口函数在对象的类重载()的函数<code>void operator()()</code>中,对象是值传递所以还必须有拷贝构造函数<code>Obj(const &amp;obj)</code>，这里对象是值传递<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">void operator()()&#123;&#125;;<br>thread myThread(对象);<br>void operator()(int val);<br>thread myThread(对象,val); <br></code></pre></td></tr></table></figure>
lambda表达式： </li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">auto mylamthread &#x3D; [] &#123;  ;&#125;<br>&#96;&#96;&#96;&#96;<br>使用线程：<br>-----------<br>* 实际只使用join()：只有当所有线程运行结束后才运行主线程<br>&#96;&#96;&#96;cpp<br>threadObj.detach();<br>threadObj.join();<br>threadObj.joinable();       &#x2F;&#x2F;判断是否可以使用join()<br></code></pre></td></tr></table></figure>

<h1 id="2、线程传参"><a href="#2、线程传参" class="headerlink" title="2、线程传参"></a>2、线程传参</h1><h2 id="普通类型做线程参数"><a href="#普通类型做线程参数" class="headerlink" title="普通类型做线程参数  "></a>普通类型做线程参数  </h2><ul>
<li>创建线程时，即使线程函数参数是&amp;，主线程传递也依旧是值传递重新拷贝一份给线程函数。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;var,)</span></span>&#123;&#125;    <br><span class="hljs-function">thread <span class="hljs-title">myThread</span><span class="hljs-params">(func,var)</span></span>;          <span class="hljs-comment">//myTread中var和func中的var不同地址</span><br></code></pre></td></tr></table></figure>
类对象做线程参数 </li>
</ul>
<hr>
<ul>
<li>传递类对象，应避免隐式类型转换，全部使用构建临时对象，线程函数必须用const &amp;来接，避免再次构造对象。<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Obj &amp;obj)</span></span>&#123;&#125;     <br><span class="hljs-function">thread <span class="hljs-title">myThread</span><span class="hljs-params">(func,Obj(<span class="hljs-number">0</span>))</span></span>;       <span class="hljs-comment">//先构造临时对象Obj(0)，值传递复制给func函数obj对象</span><br></code></pre></td></tr></table></figure></li>
<li>如果非要用主线程的对象本身做线程参数<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Obj &amp;obj)</span>                 <span class="hljs-comment">//可以不用const</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">Obj obj</span>;           <br><span class="hljs-function">thread <span class="hljs-title">myThread</span><span class="hljs-params">(func,std::ref(obj))</span></span>;                <span class="hljs-comment">//相当于&amp;obj</span><br><br></code></pre></td></tr></table></figure>
用类成员函数指针做线程函数</li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">threadWorkFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;&#125;;<br><span class="hljs-function">thread <span class="hljs-title">myThread</span><span class="hljs-params">(&amp;Obj::threadWorkFunc,&amp;obj,val)</span></span>;     <span class="hljs-comment">//使用&amp;obj也可保证主线程和线程使用同一个对象</span><br></code></pre></td></tr></table></figure>

<h1 id="3、互斥量"><a href="#3、互斥量" class="headerlink" title="3、互斥量"></a>3、互斥量</h1><h2 id="mutex类"><a href="#mutex类" class="headerlink" title="mutex类"></a>mutex类</h2><ul>
<li>相当于一把锁。<code>lock()</code> 与<code>unlock()</code>必须成对使用，先<code>lock</code>，再操作共享数据，然后<code>unlock</code>   </li>
</ul>
<h2 id="lock-guard类模板"><a href="#lock-guard类模板" class="headerlink" title="lock_guard类模板"></a>lock_guard类模板</h2><ul>
<li>为了防止忘记unlock，引入<code>std::lock_guard</code>类模板,在定义时，构造函数中自动调用<code>lock()</code>，在析构函数中自动调用<code> unlock()</code>，直接取代<code>unlock</code> <code>lock</code>函数，不能共用;  </li>
<li>使用：只需要在操作共享数据前加一行将互斥量加入模板即可，不需要考虑解锁</li>
<li>一般项目使用lock_guard就足够了<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">mutexGuard</span><span class="hljs-params">(my_mutex)</span></span>;<br></code></pre></td></tr></table></figure>
死锁</li>
</ul>
<hr>
<ul>
<li>至少有两个互斥量存在，在两个进程中，两个互斥量的<code>lock()</code>次序不同，就会引起死锁只要保持上锁的顺序一致就行</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span>&#123;</span>                                                <span class="hljs-comment">//线程类</span><br><span class="hljs-keyword">private</span>:<br>  std:List&lt;<span class="hljs-keyword">int</span>&gt; MsgRecvQueue;                             <span class="hljs-comment">//共享数据容器</span><br>  mutex my_mutex;                                         <span class="hljs-comment">//互斥锁</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outMsgRecvQueue</span><span class="hljs-params">()</span></span>&#123;                                 <span class="hljs-comment">//读数据线程函数</span><br>       my_mutex.<span class="hljs-built_in">lock</span>();<br>       <span class="hljs-keyword">if</span>(!MsgRecvQueue.<span class="hljs-built_in">empty</span>())&#123;                         <span class="hljs-comment">//判断也是操作共享数据</span><br>           MsgRecvQueue.<span class="hljs-built_in">pop_front</span>();                      <span class="hljs-comment">//if函数的每个分支都要解锁</span><br>           my_mutex.<span class="hljs-built_in">unlock</span>();             <br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           my_mutex.<span class="hljs-built_in">unlock</span>();<br>       &#125;<br>    &#125;;       <br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inMsgRecvQueue</span><span class="hljs-params">()</span></span>&#123;                                   <span class="hljs-comment">//写数据线程函数</span><br>       my_mutex.<span class="hljs-built_in">lock</span>();                                    <span class="hljs-comment">//锁住</span><br>       MsgRecvQueue.<span class="hljs-built_in">push_back</span>();                           <span class="hljs-comment">//写数据</span><br>       my_mutex.<span class="hljs-built_in">unlock</span>();                                  <span class="hljs-comment">//解锁</span><br>    &#125;;        <br>&#125;;<br><br>Obj obj;<br><span class="hljs-function">std::thread <span class="hljs-title">myInMsgThread</span><span class="hljs-params">(&amp;Obj::inMsgRecvQueue,&amp;obj)</span></span>;     <span class="hljs-comment">//写数据线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">myOutMsgThread</span><span class="hljs-params">(&amp;Obj::outMsgRecvQueue,&amp;obj)</span></span>;   <span class="hljs-comment">//读数据线程</span><br>myInMsgThread.<span class="hljs-built_in">join</span>();<br>myOutMsgThread.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure>

<h1 id="4、单例模式与数据共享问题"><a href="#4、单例模式与数据共享问题" class="headerlink" title="4、单例模式与数据共享问题"></a>4、单例模式与数据共享问题</h1><ul>
<li><code>构造函数私有化</code> <code>本类指针类型的静态成员变量</code> <code>返回本类指针得静态成员函数</code></li>
<li>对象只能创建一次</li>
<li>推荐主线程中创建对象（例如初始化配置信息），多线程只读访问，不需要互斥</li>
<li>线程中创建单例对象需要建立互斥<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Obj</span>()&#123;&#125;;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">static</span> Obj* obj;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Obj* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;  <br>        <span class="hljs-keyword">if</span>(obj==null)&#123;                  <span class="hljs-comment">//双重锁定提高效率</span><br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">mutexGuard</span><span class="hljs-params">(myMutex)</span></span>;<br>            <span class="hljs-keyword">if</span>(obj==null)               <span class="hljs-comment">//即if判断两次，因为=null时不一定指对象没有new，可能多个线程争抢权限</span><br>                obj=<span class="hljs-keyword">new</span> Obj;<br>         &#125;<br>         <span class="hljs-keyword">return</span> obj;<br>     &#125;<br>&#125;;<br><br>Obj* Obj::obj=null;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>std::this_thread::get_id()   </p>
<h1 id="5、效率问题"><a href="#5、效率问题" class="headerlink" title="5、效率问题"></a>5、效率问题</h1><h2 id="双重锁定"><a href="#双重锁定" class="headerlink" title="双重锁定"></a>双重锁定</h2><ul>
<li>使用两个判断，第一次提高效率，第二次只有加锁后的判断成立，才是真正的obj==bull<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(obj==null)&#123;                 <br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">mutexGuard</span><span class="hljs-params">(myMutex)</span></span>;<br>    <span class="hljs-keyword">if</span>(obj==null)              <br>        obj=<span class="hljs-keyword">new</span> Obj;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><ul>
<li><code>std::condition_variable</code> 是一个类，函数<code>waite()</code>等待通知<code>notify_noce()</code>，收到通知后，将开启循环尝试拿锁</li>
<li>拿锁成功后，第二参数判断为true：往后执行代码</li>
<li>拿锁成功后，第二参数判断为false:继续休眠，等待<code>notify_noce()</code>通知  <figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">写数据线程<span class="hljs-number">1</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">mutexGuard</span><span class="hljs-params">(myMutex)</span></span><br><span class="hljs-function">dataQueue.<span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>my_condition.<span class="hljs-built_in">notyfy_one</span>();                         <span class="hljs-comment">//my_condition是condition_variable类对象</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">读数据线程<span class="hljs-number">2</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">mutexGuard</span><span class="hljs-params">(myMutex)</span></span><br><span class="hljs-function"><span class="hljs-title">my_condition</span><span class="hljs-params">(mutexGuard,[<span class="hljs-keyword">this</span>]&#123;                    <span class="hljs-comment">//第二参数使用lambda表达式</span></span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">if</span>(!dataQueue.empty())</span></span><br><span class="hljs-function"><span class="hljs-params">          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span></span><br><span class="hljs-function"><span class="hljs-params">   &#125;)</span></span>;<br>dataQueue.<span class="hljs-built_in">pop_front</span>();                             <span class="hljs-comment">//收到通知，持续拿锁，拿到后判断非空，则读数据</span><br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>Liux</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>题解目录</title>
    <url>/posts/fca5c66f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="books-Leetcode题解目录-转载"><a href="#books-Leetcode题解目录-转载" class="headerlink" title=":books: Leetcode题解目录(转载)"></a>:books: Leetcode题解目录(转载)</h1><p>转自：🔥<a href="https://github.com/liuwentao1992">【github】</a> </p>
<ul>
<li>为了进大厂🐛，目前进度<strong>208/300</strong>题，特此记录刷过的所有题，涵盖了基本题型，精简的解题思路，此repo属于 <em><strong>C++</strong></em> 版的题解。</li>
<li>感谢您的观看，希望对您有帮助，欢迎热烈的交流🎉！如果感觉还不错就点个赞 <em><strong>star</strong></em> 吧✨✨✨~</li>
<li>这是我的🔥<a href="https://github.com/liuwentao1992">【github】</a> 里面有适合 <em><strong>C++</strong></em> 萌新的练手项目，热烈欢迎🎉帮助我收集整理题目或者提供解题思路🐳~。<span id="more"></span></li>
</ul>
<h1 id="🚀剑指offer题解"><a href="#🚀剑指offer题解" class="headerlink" title=" 🚀剑指offer题解  "></a> 🚀<a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%89%91%E6%8C%87offer.md">剑指offer题解</a>  </h1><h1 id="🚀程序员面试金典-​"><a href="#🚀程序员面试金典-​" class="headerlink" title=" 🚀程序员面试金典  ​"></a> 🚀<a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8.md">程序员面试金典</a>  ​</h1><h1 id="🎨算法思想"><a href="#🎨算法思想" class="headerlink" title="🎨算法思想"></a>🎨算法思想</h1><ul>
<li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%8F%8C%E6%8C%87%E9%92%88.md">双指针</a></li>
<li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E6%8E%92%E5%BA%8F.md">排序</a></li>
<li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md">贪心思想</a></li>
<li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E4%BA%8C%E5%88%86%E6%B3%95.md">二分查找</a></li>
<li>[分治]</li>
<li>[搜索]</li>
<li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md">动态规划</a></li>
<li>[数学]</li>
</ul>
<h1 id="snowflake-数据结构相关"><a href="#snowflake-数据结构相关" class="headerlink" title=":snowflake:数据结构相关"></a>:snowflake:数据结构相关</h1><ul>
<li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E9%93%BE%E8%A1%A8.md">链表</a></li>
<li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E6%A0%91.md">树</a></li>
<li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.md">栈和队列</a></li>
<li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%93%88%E5%B8%8C%E8%A1%A8.md">哈希表</a></li>
<li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2.md">字符串</a></li>
<li>[数组与矩阵]</li>
<li>[图]</li>
<li><a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E4%BD%8D%E8%BF%90%E7%AE%97.md">位运算</a></li>
</ul>
<h1 id="🎨力扣周赛"><a href="#🎨力扣周赛" class="headerlink" title="🎨力扣周赛"></a>🎨<a href="https://github.com/liuwentao1992/leetcode-note/blob/master/LeetCode/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B.md">力扣周赛</a></h1>]]></content>
      <categories>
        <category>大神们の笔记</category>
        <category>C++</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树🌲</title>
    <url>/posts/5ec0a1e5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="R-B-Tree🌲"><a href="#R-B-Tree🌲" class="headerlink" title="R-B Tree🌲"></a>R-B Tree🌲</h1><blockquote>
<p>R-B Tree,全称Red-Black Tree，又称为”红黑树”，一种特殊的二叉树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红（Red)或黑（black)</p>
<p>转载声明：<a href="https://www.cnblogs.com/skywang12345/p/3245399.html">https://www.cnblogs.com/skywang12345/p/3245399.html</a></p>
</blockquote>
<span id="more"></span>

<h1 id="红黑树的优势"><a href="#红黑树的优势" class="headerlink" title="红黑树的优势"></a>红黑树的优势</h1><p>红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入效率更高！！！</p>
<p>红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如：</p>
<ul>
<li>Java中的java.util.TreeMap,java.util.TreeSet；</li>
<li>C++ STL中的：map,multimap,multiset；</li>
<li>.NET中的：SortedDictionary,SortedSet 等。</li>
</ul>
<h2 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h2><p><font color="green" face="黑体">(1) 每个节点或者是黑色，或者是红色</font></p>
<p><font color="green" face="黑体">(2) 根节点是黑色</font></p>
<p><font color="green" face="黑体">(3) 每个叶子节点（nil)是黑色</font></p>
<p><font color="green" face="黑体">(4) 如果一个节点是红色的，则它的子节点必须是黑色的。</font></p>
<p><font color="green" face="黑体">(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</font></p>
<p><font color="green" face="华文彩云"><strong>注意：</strong></font></p>
<ol>
<li><p>特性(3)中的叶子节点，是指为空（NIL或null）的节点。</p>
</li>
<li><p>特性(5)，确保没有一条路径会比其他路径长处两倍。因而，红黑树是相对接近平衡的二叉树。</p>
</li>
</ol>
<p>红黑树示意图</p>
<img src="http://qgqz63fje.hb-bkt.clouddn.com/img/20200920232316.jpg">

<h2 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h2><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。<br>例如，Java集合中的<a href="http://www.cnblogs.com/skywang12345/p/3311268.html">TreeSet</a>和<a href="http://www.cnblogs.com/skywang12345/p/3310928.html">TreeMap</a>，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p>
<h2 id="红黑树的基本操作（1）-左旋和右旋"><a href="#红黑树的基本操作（1）-左旋和右旋" class="headerlink" title="红黑树的基本操作（1） 左旋和右旋"></a>红黑树的基本操作（1） 左旋和右旋</h2><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p>红黑树的基本操作是<strong>添加</strong>、<strong>删除</strong>。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的节点之后，红黑树就发生了变化，可能不满足红黑树的5条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转，可以使这颗树重新成为红黑树。简单点说，旋转的目的是让树保持红黑树的特性。<br>旋转包括两种：<strong>左旋</strong> 和 <strong>右旋</strong>。下面分别对它们进行介绍。</p>
<img src="http://qgqz63fje.hb-bkt.clouddn.com/20200921094915.jpeg">

<p>左旋的伪代码《算法导论》，参考上示意图和如下伪代码，理解“红黑树T的节点x进行左旋”是如何进行的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">LEFT-<span class="hljs-built_in">ROTATE</span>(T, x)  <br><span class="hljs-number">01</span>  y ← right[x]            <span class="hljs-comment">// 前提：这里假设x的右孩子为y。下面开始正式操作</span><br><span class="hljs-number">02</span>  right[x] ← left[y]      <span class="hljs-comment">// 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子</span><br><span class="hljs-number">03</span>  p[left[y]] ← x          <span class="hljs-comment">// 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x</span><br><span class="hljs-number">04</span>  p[y] ← p[x]             <span class="hljs-comment">// 将 “x的父亲” 设为 “y的父亲”</span><br><span class="hljs-number">05</span>  <span class="hljs-keyword">if</span> p[x] = nil[T]       <br><span class="hljs-number">06</span>  then root[T] ← y                 <span class="hljs-comment">// 情况1：如果 “x的父亲” 是空节点，则将y设为根节点</span><br><span class="hljs-number">07</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x = left[p[x]]  <br><span class="hljs-number">08</span>            then left[p[x]] ← y    <span class="hljs-comment">// 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span><br><span class="hljs-number">09</span>            <span class="hljs-keyword">else</span> right[p[x]] ← y   <span class="hljs-comment">// 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”</span><br><span class="hljs-number">10</span>  left[y] ← x             <span class="hljs-comment">// 将 “x” 设为 “y的左孩子”</span><br><span class="hljs-number">11</span>  p[x] ← y                <span class="hljs-comment">// 将 “x的父节点” 设为 “y”</span><br></code></pre></td></tr></table></figure>

<p>理解左旋之后，再看一下鲜明的例子。你可以先行尝试一下：</p>
<p><img src="https://images0.cnblogs.com/i/497634/201403/251734577643655.jpg"></p>
<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p><img src="https://images0.cnblogs.com/i/497634/201403/251735527958942.jpg"></p>
<p>对x进行左旋，意味着”将x变成一个左节点”。</p>
<p>右旋的伪代码《算法导论》：参考上面的示意图和下面的伪代码，理解“红黑树T的节点y进行右旋”是如何进行的。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">RIGHT-<span class="hljs-built_in">ROTATE</span>(T, y)  <br><span class="hljs-number">01</span>  x ← left[y]             <span class="hljs-comment">// 前提：这里假设y的左孩子为x。下面开始正式操作</span><br><span class="hljs-number">02</span>  left[y] ← right[x]      <span class="hljs-comment">// 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子</span><br><span class="hljs-number">03</span>  p[right[x]] ← y         <span class="hljs-comment">// 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y</span><br><span class="hljs-number">04</span>  p[x] ← p[y]             <span class="hljs-comment">// 将 “y的父亲” 设为 “x的父亲”</span><br><span class="hljs-number">05</span>  <span class="hljs-keyword">if</span> p[y] = nil[T]       <br><span class="hljs-number">06</span>  then root[T] ← x                 <span class="hljs-comment">// 情况1：如果 “y的父亲” 是空节点，则将x设为根节点</span><br><span class="hljs-number">07</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> y = right[p[y]]  <br><span class="hljs-number">08</span>            then right[p[y]] ← x   <span class="hljs-comment">// 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”</span><br><span class="hljs-number">09</span>            <span class="hljs-keyword">else</span> left[p[y]] ← x    <span class="hljs-comment">// 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”</span><br><span class="hljs-number">10</span>  right[x] ← y            <span class="hljs-comment">// 将 “y” 设为 “x的右孩子”</span><br><span class="hljs-number">11</span>  p[y] ← x                <span class="hljs-comment">// 将 “y的父节点” 设为 “x”</span><br></code></pre></td></tr></table></figure>

<p>理解右旋之后，看看下面一个更鲜明的例子。你可以先不看右边的结果，自己尝试一下。</p>
<p><img src="https://images0.cnblogs.com/i/497634/201403/251737465769614.jpg"></p>
<p><strong>3. 区分 左旋 和 右旋</strong></p>
<p>仔细观察上面”左旋”和”右旋”的示意图。我们能清晰的发现，它们是对称的。无论是左旋还是右旋，被旋转的树，在旋转前是二叉查找树，并且旋转之后仍然是一颗二叉查找树。</p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251739385617803.jpg"><img src="https://images0.cnblogs.com/i/497634/201403/251739385617803.jpg" alt="img"></a></p>
<h1 id="红黑树的基本操作（二）添加"><a href="#红黑树的基本操作（二）添加" class="headerlink" title="红黑树的基本操作（二）添加"></a>红黑树的基本操作（二）添加</h1><p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。详细描述如下：</p>
<p><strong>第一步: 将红黑树当作一颗二叉查找树，将节点插入。</strong><br>    红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。<br>    好吧？那接下来，我们就来想方设法的旋转以及重新着色，使这颗树重新成为红黑树！</p>
<p><strong>第二步：将插入的节点着色为”红色”。</strong><br>    为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。<br>    将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。o(∩∩)o…哈哈</p>
<p><strong>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。</strong><br>    第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>    对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>    对于”特性(2)”，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。<br>    对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>    对于”特性(4)”，是有可能违背的！<br>    那接下来，想办法使之”满足特性(4)”，就可以将树重新构造成红黑树了。</p>
<p><strong>伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">RB-<span class="hljs-built_in">INSERT</span>(T, z)  <br><span class="hljs-number">01</span>  y ← nil[T]                        <span class="hljs-comment">// 新建节点“y”，将y设为空节点。</span><br><span class="hljs-number">02</span>  x ← root[T]                       <span class="hljs-comment">// 设“红黑树T”的根节点为“x”</span><br><span class="hljs-number">03</span>  <span class="hljs-keyword">while</span> x ≠ nil[T]                  <span class="hljs-comment">// 找出要插入的节点“z”在二叉树T中的位置“y”</span><br><span class="hljs-number">04</span>      <span class="hljs-keyword">do</span> y ← x                      <br><span class="hljs-number">05</span>         <span class="hljs-keyword">if</span> key[z] &lt; key[x]  <br><span class="hljs-number">06</span>            then x ← left[x]  <br><span class="hljs-number">07</span>            <span class="hljs-keyword">else</span> x ← right[x]  <br><span class="hljs-number">08</span>  p[z] ← y                          <span class="hljs-comment">// 设置 “z的父亲” 为 “y”</span><br><span class="hljs-number">09</span>  <span class="hljs-keyword">if</span> y = nil[T]                     <br><span class="hljs-number">10</span>     then root[T] ← z               <span class="hljs-comment">// 情况1：若y是空节点，则将z设为根</span><br><span class="hljs-number">11</span>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> key[z] &lt; key[y]        <br><span class="hljs-number">12</span>             then left[y] ← z       <span class="hljs-comment">// 情况2：若“z所包含的值” &lt; “y所包含的值”，则将z设为“y的左孩子”</span><br><span class="hljs-number">13</span>             <span class="hljs-keyword">else</span> right[y] ← z      <span class="hljs-comment">// 情况3：(“z所包含的值” &gt;= “y所包含的值”)将z设为“y的右孩子” </span><br><span class="hljs-number">14</span>  left[z] ← nil[T]                  <span class="hljs-comment">// z的左孩子设为空</span><br><span class="hljs-number">15</span>  right[z] ← nil[T]                 <span class="hljs-comment">// z的右孩子设为空。至此，已经完成将“节点z插入到二叉树”中了。</span><br><span class="hljs-number">16</span>  color[z] ← RED                    <span class="hljs-comment">// 将z着色为“红色”</span><br><span class="hljs-number">17</span>  RB-INSERT-<span class="hljs-built_in">FIXUP</span>(T, z)             <span class="hljs-comment">// 通过RB-INSERT-FIXUP对红黑树的节点进行颜色修改以及旋转，让树T仍然是一颗红黑树</span><br></code></pre></td></tr></table></figure>

<p>结合伪代码以及为代码上面的说明，先理解RB-INSERT。理解了RB-INSERT之后，我们接着对 RB-INSERT-FIXUP的伪代码进行说明。</p>
<p>添加修正操作的伪代码《算法导论》</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">RB-INSERT-<span class="hljs-built_in">FIXUP</span>(T, z)<br><span class="hljs-number">01</span> <span class="hljs-keyword">while</span> color[p[z]] = RED                                                  <span class="hljs-comment">// 若“当前节点(z)的父节点是红色”，则进行以下处理。</span><br><span class="hljs-number">02</span>     <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> p[z] = left[p[p[z]]]                                           <span class="hljs-comment">// 若“z的父节点”是“z的祖父节点的左孩子”，则进行以下处理。</span><br><span class="hljs-number">03</span>           then y ← right[p[p[z]]]                                        <span class="hljs-comment">// 将y设置为“z的叔叔节点(z的祖父节点的右孩子)”</span><br><span class="hljs-number">04</span>                <span class="hljs-keyword">if</span> color[y] = RED                                         <span class="hljs-comment">// Case 1条件：叔叔是红色</span><br><span class="hljs-number">05</span>                   then color[p[z]] ← BLACK                    ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (01) 将“父节点”设为黑色。</span><br><span class="hljs-number">06</span>                        color[y] ← BLACK                       ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (02) 将“叔叔节点”设为黑色。</span><br><span class="hljs-number">07</span>                        color[p[p[z]]] ← RED                   ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (03) 将“祖父节点”设为“红色”。</span><br><span class="hljs-number">08</span>                        z ← p[p[z]]                            ▹ Case <span class="hljs-number">1</span>   <span class="hljs-comment">//  (04) 将“祖父节点”设为“当前节点”(红色节点)</span><br><span class="hljs-number">09</span>                   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> z = right[p[z]]                                <span class="hljs-comment">// Case 2条件：叔叔是黑色，且当前节点是右孩子</span><br><span class="hljs-number">10</span>                           then z ← p[z]                       ▹ Case <span class="hljs-number">2</span>   <span class="hljs-comment">//  (01) 将“父节点”作为“新的当前节点”。</span><br><span class="hljs-number">11</span>                                LEFT-<span class="hljs-built_in">ROTATE</span>(T, z)              ▹ Case <span class="hljs-number">2</span>   <span class="hljs-comment">//  (02) 以“新的当前节点”为支点进行左旋。</span><br><span class="hljs-number">12</span>                           color[p[z]] ← BLACK                 ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">// Case 3条件：叔叔是黑色，且当前节点是左孩子。(01) 将“父节点”设为“黑色”。</span><br><span class="hljs-number">13</span>                           color[p[p[z]]] ← RED                ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">//  (02) 将“祖父节点”设为“红色”。</span><br><span class="hljs-number">14</span>                           RIGHT-<span class="hljs-built_in">ROTATE</span>(T, p[p[z]])            ▹ Case <span class="hljs-number">3</span>   <span class="hljs-comment">//  (03) 以“祖父节点”为支点进行右旋。</span><br><span class="hljs-number">15</span>        <span class="hljs-built_in"><span class="hljs-keyword">else</span></span> (same as then clause with <span class="hljs-string">&quot;right&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;left&quot;</span> exchanged)      <span class="hljs-comment">// 若“z的父节点”是“z的祖父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。</span><br><span class="hljs-number">16</span> color[root[T]] ← BLACK<br></code></pre></td></tr></table></figure>

<p>根据被插入节点的父节点的情况，可以将”当节点z被着色为红色节点，并插入二叉树”划分为三种情况来处理。<br>① 情况说明：被插入的节点是根节点。<br>  处理方法：直接把此节点涂为黑色。<br>② 情况说明：被插入的节点的父节点是黑色。<br>  处理方法：什么也不需要做。节点被插入后，仍然是红黑树。<br>③ 情况说明：被插入的节点的父节点是红色。<br>  处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为3种情况(Case)。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>现象说明</strong></th>
<th><strong>处理策略</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Case 1</td>
<td>当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</td>
<td>(01) 将“父节点”设为黑色。 (02) 将“叔叔节点”设为黑色。 (03) 将“祖父节点”设为“红色”。 (04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</td>
</tr>
<tr>
<td>Case 2</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</td>
<td>(01) 将“父节点”作为“新的当前节点”。 (02) 以“新的当前节点”为支点进行左旋。</td>
</tr>
<tr>
<td>Case 3</td>
<td>当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</td>
<td>(01) 将“父节点”设为“黑色”。 (02) 将“祖父节点”设为“红色”。 (03) 以“祖父节点”为支点进行右旋。</td>
</tr>
</tbody></table>
<p>上面三种情况(Case)处理问题的核心思路都是：将红色的节点移到根节点；然后，将根节点设为黑色。下面对它们详细进行介绍。</p>
<p><strong>1. (Case 1)叔叔是红色</strong></p>
<p><strong>1.1 现象说明</strong><br>当前节点(即，被插入节点)的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。</p>
<p><strong>1.2 处理策略</strong><br>(01) 将“父节点”设为黑色。<br>(02) 将“叔叔节点”设为黑色。<br>(03) 将“祖父节点”设为“红色”。<br>(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。</p>
<p>  <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>  “当前节点”和“父节点”都是红色，违背“特性(4)”。所以，将“父节点”设置“黑色”以解决这个问题。<br>  但是，将“父节点”由“红色”变成“黑色”之后，违背了“特性(5)”：因为，包含“父节点”的分支的黑色节点的总数增加了1。  解决这个问题的办法是：将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”。关于这里，说明几点：第一，为什么“祖父节点”之前是黑色？这个应该很容易想明白，因为在变换操作之前，该树是红黑树，“父节点”是红色，那么“祖父节点”一定是黑色。 第二，为什么将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；能解决“包含‘父节点’的分支的黑色节点的总数增加了1”的问题。这个道理也很简单。“包含‘父节点’的分支的黑色节点的总数增加了1” 同时也意味着 “包含‘祖父节点’的分支的黑色节点的总数增加了1”，既然这样，我们通过将“祖父节点”由“黑色”变成“红色”以解决“包含‘祖父节点’的分支的黑色节点的总数增加了1”的问题； 但是，这样处理之后又会引起另一个问题“包含‘叔叔’节点的分支的黑色节点的总数减少了1”，现在我们已知“叔叔节点”是“红色”，将“叔叔节点”设为“黑色”就能解决这个问题。 所以，将“祖父节点”由“黑色”变成红色，同时，将“叔叔节点”由“红色”变成“黑色”；就解决了该问题。<br>  按照上面的步骤处理之后：当前节点、父节点、叔叔节点之间都不会违背红黑树特性，但祖父节点却不一定。若此时，祖父节点是根节点，直接将祖父节点设为“黑色”，那就完全解决这个问题了；若祖父节点不是根节点，那我们需要将“祖父节点”设为“新的当前节点”，接着对“新的当前节点”进行分析。</p>
<p><strong>1.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg"><strong><img src="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg" alt="img"></strong></a></p>
<p><strong>2. (Case 2)叔叔是黑色，且当前节点是右孩子</strong></p>
<p><strong>2.1 现象说明</strong><br>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子</p>
<p><strong>2.2 处理策略</strong><br>(01) 将“父节点”作为“新的当前节点”。<br>(02) 以“新的当前节点”为支点进行左旋。</p>
<p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   首先，将“父节点”作为“新的当前节点”；接着，以“新的当前节点”为支点进行左旋。 为了便于理解，我们先说明第(02)步，再说明第(01)步；为了便于说明，我们设置“父节点”的代号为F(Father)，“当前节点”的代号为S(Son)。<br>为什么要“以F为支点进行左旋”呢？根据已知条件可知：S是F的右孩子。而之前我们说过，我们处理红黑树的核心思想：将红色的节点移到根节点；然后，将根节点设为黑色。既然是“将红色的节点移到根节点”，那就是说要不断的将破坏红黑树特性的红色节点上移(即向根方向移动)。 而S又是一个右孩子，因此，我们可以通过“左旋”来将S上移！<br>   按照上面的步骤(以F为支点进行左旋)处理之后：若S变成了根节点，那么直接将其设为“黑色”，就完全解决问题了；若S不是根节点，那我们需要执行步骤(01)，即“将F设为‘新的当前节点’”。那为什么不继续以S为新的当前节点继续处理，而需要以F为新的当前节点来进行处理呢？这是因为“左旋”之后，F变成了S的“子节点”，即S变成了F的父节点；而我们处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决“孩子”的问题，再解决“父亲”的问题；所以，我们执行步骤(01)：将“父节点”作为“新的当前节点”。</p>
<p><strong>2.2 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg"><strong><img src="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg" alt="img"></strong></a></p>
<p><strong>3. (Case 3)叔叔是黑色，且当前节点是左孩子</strong></p>
<p><strong>3.1 现象说明</strong><br>当前节点(即，被插入节点)的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子</p>
<p><strong>3.2 处理策略</strong><br>(01) 将“父节点”设为“黑色”。<br>(02) 将“祖父节点”设为“红色”。<br>(03) 以“祖父节点”为支点进行右旋。</p>
<p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“叔叔节点”为U(Uncle)，“父节点”为F(Father)，祖父节点为G(Grand-Father)。<br>   S和F都是红色，违背了红黑树的“特性(4)”，我们可以将F由“红色”变为“黑色”，就解决了“违背‘特性(4)’”的问题；但却引起了其它问题：违背特性(5)，因为将F由红色改为黑色之后，所有经过F的分支的黑色节点的个数增加了1。那我们如何解决“所有经过F的分支的黑色节点的个数增加了1”的问题呢？ 我们可以通过“将G由黑色变成红色”，同时“以G为支点进行右旋”来解决。</p>
<p><strong>2.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg"><img src="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg" alt="img"></a></p>
<p>提示：上面的进行Case 3处理之后，再将节点”120”当作当前节点，就变成了Case 2的情况。</p>
<h3 id="红黑树的基本操作-三-删除"><a href="#红黑树的基本操作-三-删除" class="headerlink" title="红黑树的基本操作(三) 删除"></a><strong>红黑树的基本操作(三) 删除</strong></h3><p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：</p>
<p><strong>第一步：将红黑树当作一颗二叉查找树，将节点删除。</strong><br>    这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：<br>    ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。<br>    ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。<br>    ③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。</p>
<p><strong>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</strong><br>    因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p>
<p>删除操作的伪代码《算法导论》</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">RB-DELETE(T, z)<br>01 if left[z] &#x3D; nil[T] or right[z] &#x3D; nil[T]         <br>02    then y ← z                                  &#x2F;&#x2F; 若“z的左孩子” 或 “z的右孩子”为空，则将“z”赋值给 “y”；<br>03    else y ← TREE-SUCCESSOR(z)                  &#x2F;&#x2F; 否则，将“z的后继节点”赋值给 “y”。<br>04 if left[y] ≠ nil[T]<br>05    then x ← left[y]                            &#x2F;&#x2F; 若“y的左孩子” 不为空，则将“y的左孩子” 赋值给 “x”；<br>06    else x ← right[y]                           &#x2F;&#x2F; 否则，“y的右孩子” 赋值给 “x”。<br>07 p[x] ← p[y]                                    &#x2F;&#x2F; 将“y的父节点” 设置为 “x的父节点”<br>08 if p[y] &#x3D; nil[T]                               <br>09    then root[T] ← x                            &#x2F;&#x2F; 情况1：若“y的父节点” 为空，则设置“x” 为 “根节点”。<br>10    else if y &#x3D; left[p[y]]                    <br>11            then left[p[y]] ← x                 &#x2F;&#x2F; 情况2：若“y是它父节点的左孩子”，则设置“x” 为 “y的父节点的左孩子”<br>12            else right[p[y]] ← x                &#x2F;&#x2F; 情况3：若“y是它父节点的右孩子”，则设置“x” 为 “y的父节点的右孩子”<br>13 if y ≠ z                                    <br>14    then key[z] ← key[y]                        &#x2F;&#x2F; 若“y的值” 赋值给 “z”。注意：这里只拷贝z的值给y，而没有拷贝z的颜色！！！<br>15         copy y&#39;s satellite data into z         <br>16 if color[y] &#x3D; BLACK                            <br>17    then RB-DELETE-FIXUP(T, x)                  &#x2F;&#x2F; 若“y为黑节点”，则调用<br>18 return y <br></code></pre></td></tr></table></figure>

<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>结合伪代码以及为代码上面的说明，先理解RB-DELETE。理解了RB-DELETE之后，接着对 RB-DELETE-FIXUP的伪代码进行说明</p>
<p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">RB-DELETE-FIXUP(T, x)<br>01 while x ≠ root[T] and color[x] &#x3D; BLACK  <br>02     do if x &#x3D; left[p[x]]      <br>03           then w ← right[p[x]]                                             &#x2F;&#x2F; 若 “x”是“它父节点的左孩子”，则设置 “w”为“x的叔叔”(即x为它父节点的右孩子)                                          <br>04                if color[w] &#x3D; RED                                           &#x2F;&#x2F; Case 1: x是“黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。<br>05                   then color[w] ← BLACK                        ▹  Case 1   &#x2F;&#x2F;   (01) 将x的兄弟节点设为“黑色”。<br>06                        color[p[x]] ← RED                       ▹  Case 1   &#x2F;&#x2F;   (02) 将x的父节点设为“红色”。<br>07                        LEFT-ROTATE(T, p[x])                    ▹  Case 1   &#x2F;&#x2F;   (03) 对x的父节点进行左旋。<br>08                        w ← right[p[x]]                         ▹  Case 1   &#x2F;&#x2F;   (04) 左旋后，重新设置x的兄弟节点。<br>09                if color[left[w]] &#x3D; BLACK and color[right[w]] &#x3D; BLACK       &#x2F;&#x2F; Case 2: x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。<br>10                   then color[w] ← RED                          ▹  Case 2   &#x2F;&#x2F;   (01) 将x的兄弟节点设为“红色”。<br>11                        x ←  p[x]                               ▹  Case 2   &#x2F;&#x2F;   (02) 设置“x的父节点”为“新的x节点”。<br>12                   else if color[right[w]] &#x3D; BLACK                          &#x2F;&#x2F; Case 3: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。<br>13                           then color[left[w]] ← BLACK          ▹  Case 3   &#x2F;&#x2F;   (01) 将x兄弟节点的左孩子设为“黑色”。<br>14                                color[w] ← RED                  ▹  Case 3   &#x2F;&#x2F;   (02) 将x兄弟节点设为“红色”。<br>15                                RIGHT-ROTATE(T, w)              ▹  Case 3   &#x2F;&#x2F;   (03) 对x的兄弟节点进行右旋。<br>16                                w ← right[p[x]]                 ▹  Case 3   &#x2F;&#x2F;   (04) 右旋后，重新设置x的兄弟节点。<br>17                         color[w] ← color[p[x]]                 ▹  Case 4   &#x2F;&#x2F; Case 4: x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的。(01) 将x父节点颜色 赋值给 x的兄弟节点。<br>18                         color[p[x]] ← BLACK                    ▹  Case 4   &#x2F;&#x2F;   (02) 将x父节点设为“黑色”。<br>19                         color[right[w]] ← BLACK                ▹  Case 4   &#x2F;&#x2F;   (03) 将x兄弟节点的右子节设为“黑色”。<br>20                         LEFT-ROTATE(T, p[x])                   ▹  Case 4   &#x2F;&#x2F;   (04) 对x的父节点进行左旋。<br>21                         x ← root[T]                            ▹  Case 4   &#x2F;&#x2F;   (05) 设置“x”为“根节点”。<br>22        else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)        &#x2F;&#x2F; 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和“left”交换位置，然后依次执行。<br>23 color[x] ← BLACK   <br></code></pre></td></tr></table></figure>

<p>下面对删除函数进行分析。在分析之前，我们再次温习一下红黑树的几个特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>   前面我们将”删除红黑树中的节点”大致分为两步，在第一步中”将红黑树当作一颗二叉查找树，将节点删除”后，可能违反”特性(2)、(4)、(5)”三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。<br>   为了便于分析，我们假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。为什么呢？<br>   通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设”x包含一个额外的黑色”，就正好弥补了”删除y所丢失的黑色节点”，也就不会违反”特性(5)”。 因此，假设”x包含一个额外的黑色”(x原本的颜色还存在)，这样就不会违反”特性(5)”。<br>   现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是”红+黑”或”黑+黑”，它违反了”特性(1)”。</p>
<p>   现在，我们面临的问题，由解决”违反了特性(2)、(4)、(5)三个特性”转换成了”解决违反特性(1)、(2)、(4)三个特性”。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：<br>a) x指向一个”红+黑”节点。此时，将x设为一个”黑”节点即可。<br>b) x指向根。此时，将x设为一个”黑”节点即可。<br>c) 非前面两种姿态。</p>
<p>将上面的姿态，可以概括为3种情况。<br>① 情况说明：x是“红+黑”节点。<br>  处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。<br>② 情况说明：x是“黑+黑”节点，且x是根。<br>  处理方法：什么都不做，结束。此时红黑树性质全部恢复。<br>③ 情况说明：x是“黑+黑”节点，且x不是根。<br>  处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>现象说明</strong></th>
<th><strong>处理策略</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Case 1</strong></td>
<td>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</td>
<td>(01) 将x的兄弟节点设为“黑色”。 (02) 将x的父节点设为“红色”。 (03) 对x的父节点进行左旋。 (04) 左旋后，重新设置x的兄弟节点。</td>
</tr>
<tr>
<td><strong>Case 2</strong></td>
<td>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</td>
<td>(01) 将x的兄弟节点设为“红色”。 (02) 设置“x的父节点”为“新的x节点”。</td>
</tr>
<tr>
<td><strong>Case 3</strong></td>
<td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</td>
<td>(01) 将x兄弟节点的左孩子设为“黑色”。 (02) 将x兄弟节点设为“红色”。 (03) 对x的兄弟节点进行右旋。 (04) 右旋后，重新设置x的兄弟节点。</td>
</tr>
<tr>
<td><strong>Case 4</strong></td>
<td>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</td>
<td>(01) 将x父节点颜色 赋值给 x的兄弟节点。 (02) 将x父节点设为“黑色”。 (03) 将x兄弟节点的右子节设为“黑色”。 (04) 对x的父节点进行左旋。 (05) 设置“x”为“根节点”。</td>
</tr>
</tbody></table>
<p><strong>1. (Case 1)x是”黑+黑”节点，x的兄弟节点是红色</strong></p>
<p><strong>1.1 现象说明</strong><br>x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。</p>
<p><strong>1.2 处理策略</strong><br>(01) 将x的兄弟节点设为“黑色”。<br>(02) 将x的父节点设为“红色”。<br>(03) 对x的父节点进行左旋。<br>(04) 左旋后，重新设置x的兄弟节点。</p>
<p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，同时“将x的父节点设为红色”；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p>
<p><strong>1.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251813539515702.jpg"><img src="https://images0.cnblogs.com/i/497634/201403/251813539515702.jpg" alt="img"></a></p>
<p><strong>2. (Case 2) x是”黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色</strong></p>
<p><strong>2.1 现象说明</strong><br>x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。</p>
<p><strong>2.2 处理策略</strong><br>(01) 将x的兄弟节点设为“红色”。<br>(02) 设置“x的父节点”为“新的x节点”。</p>
<p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   这个情况的处理思想：是将“x中多余的一个黑色属性上移(往根方向移动)”。 x是“黑+黑”节点，我们将x由“黑+黑”节点 变成 “黑”节点，多余的一个“黑”属性移到x的父节点中，即x的父节点多出了一个黑属性(若x的父节点原先是“黑”，则此时变成了“黑+黑”；若x的父节点原先时“红”，则此时变成了“红+黑”)。 此时，需要注意的是：所有经过x的分支中黑节点个数没变化；但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属性)！为了解决这个问题，我们需要将“所有经过x的兄弟节点的分支中黑色节点的个数减1”即可，那么就可以通过“将x的兄弟节点由黑色变成红色”来实现。<br>   经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。我们需要将x的父节点设为“新的x节点”进行处理。若“新的x节点”是“黑+红”，直接将“新的x节点”设为黑色，即可完全解决该问题；若“新的x节点”是“黑+黑”，则需要对“新的x节点”进行进一步处理。</p>
<p><strong>2.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251814572322069.jpg"><strong><img src="https://images0.cnblogs.com/i/497634/201403/251814572322069.jpg" alt="img"></strong></a></p>
<p><strong>3. (Case 3)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的</strong></p>
<p><strong>3.1 现象说明</strong><br>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。</p>
<p><strong>3.2 处理策略</strong><br>(01) 将x兄弟节点的左孩子设为“黑色”。<br>(02) 将x兄弟节点设为“红色”。<br>(03) 对x的兄弟节点进行右旋。<br>(04) 右旋后，重新设置x的兄弟节点。</p>
<p>​    <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>​    我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑色”，同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。</p>
<p><strong>3.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251815496235531.jpg"><strong><img src="https://images0.cnblogs.com/i/497634/201403/251815496235531.jpg" alt="img"></strong></a></p>
<p><strong>4. (Case 4)x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色</strong></p>
<p><strong>4.1 现象说明</strong><br>x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。</p>
<p><strong>4.2 处理策略</strong><br>(01) 将x父节点颜色 赋值给 x的兄弟节点。<br>(02) 将x父节点设为“黑色”。<br>(03) 将x兄弟节点的右子节设为“黑色”。<br>(04) 对x的父节点进行左旋。<br>(05) 设置“x”为“根节点”。</p>
<p>   <strong>下面谈谈为什么要这样处理。</strong>(建议理解的时候，通过下面的图进行对比)<br>   我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是“：进行颜色修改，然后对x的父节点进行左旋。下面，我们来分析是如何实现的。<br>   为了便于说明，我们设置“当前节点”为S(Original Son)，“兄弟节点”为B(Brother)，“兄弟节点的左孩子”为BLS(Brother’s Left Son)，“兄弟节点的右孩子”为BRS(Brother’s Right Son)，“父节点”为F(Father)。<br>   我们要对F进行左旋。但在左旋前，我们需要调换F和B的颜色，并设置BRS为黑色。为什么需要这里处理呢？因为左旋后，F和BLS是父子关系，而我们已知BL是红色，如果F是红色，则违背了“特性(4)”；为了解决这一问题，我们将“F设置为黑色”。 但是，F设置为黑色之后，为了保证满足“特性(5)”，即为了保证左旋之后：<br>   第一，“同时经过根节点和S的分支的黑色节点个数不变”。<br>       若满足“第一”，只需要S丢弃它多余的颜色即可。因为S的颜色是“黑+黑”，而左旋后“同时经过根节点和S的分支的黑色节点个数”增加了1；现在，只需将S由“黑+黑”变成单独的“黑”节点，即可满足“第一”。<br>   第二，“同时经过根节点和BLS的分支的黑色节点数不变”。<br>       若满足“第二”，只需要将“F的原始颜色”赋值给B即可。之前，我们已经将“F设置为黑色”(即，将B的颜色”黑色”，赋值给了F)。至此，我们算是调换了F和B的颜色。<br>   第三，“同时经过根节点和BRS的分支的黑色节点数不变”。<br>       在“第二”已经满足的情况下，若要满足“第三”，只需要将BRS设置为“黑色”即可。<br>经过，上面的处理之后。红黑树的特性全部得到的满足！接着，我们将x设为根节点，就可以跳出while循环(参考伪代码)；即完成了全部处理。</p>
<p>至此，我们就完成了Case 4的处理。理解Case 4的核心，是了解如何“去掉当前节点额外的黑色”。</p>
<p><strong>4.3 示意图</strong></p>
<p><a href="https://images0.cnblogs.com/i/497634/201403/251817189983393.jpg"><img src="https://images0.cnblogs.com/i/497634/201403/251817189983393.jpg" alt="img"></a></p>
<p>OK！至此，红黑树的理论知识差不多讲完了。后续再更新红黑树的实现代码！</p>
<h1 id="变换规则"><a href="#变换规则" class="headerlink" title="变换规则"></a>变换规则</h1><h2 id="变颜色的情况："><a href="#变颜色的情况：" class="headerlink" title="变颜色的情况："></a>变颜色的情况：</h2><p>当前节点的父亲是红色，且它的祖父节点的另一个子节点也是红色(叔叔节点)：</p>
<ol>
<li>把父节点设为黑色</li>
<li>把叔叔也设为黑色</li>
<li>把祖父节点也就是父亲的父亲设为红色（爷爷）</li>
<li>把指针定义到祖父节点设为当前要操作的。（爷爷）分析的点变换的的规则。</li>
</ol>
<h2 id="左旋-1"><a href="#左旋-1" class="headerlink" title="左旋"></a>左旋</h2><p>当前父节点是红色，叔叔是黑色的时候，且当前的节点是右子树。左旋以父节点作为左旋。</p>
<h2 id="右旋-1"><a href="#右旋-1" class="headerlink" title="右旋"></a>右旋</h2><ol>
<li>把父节点变为黑色</li>
<li>把祖父节点变为红色（爷爷）</li>
<li>以祖父节点旋转(爷爷)</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>1, 《算法导论》</p>
<p>2,  <a href="http://blog.csdn.net/v_JULY_v/article/details/6105630">教你透彻了解红黑树</a></p>
]]></content>
      <categories>
        <category>程序员内功</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试知识点（牛客）</title>
    <url>/posts/2c47887.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-面试宝典📖"><a href="#C-面试宝典📖" class="headerlink" title="C++面试宝典📖"></a>C++面试宝典📖</h1><blockquote>
<p>转载自：<a href="https://www.nowcoder.com/tutorial/93/a88b64c6d7b14a59aad2061b9fd15ac2">牛客网C++面试技巧</a></p>
</blockquote>
<p>博客仅用于记录面试经验与技巧~~给自己<strong>加油</strong></p>
<span id="more"></span>

<p><img src="https://uploadfiles.nowcoder.com/images/20190415/826546_1555311086357_F6592A0E70C1D517863BD1E4559E7C29" alt="面试知识点分布"></p>
<p><strong>需要注意的是：</strong>此图不绝对，因为实际面试中面试官会根据你的简历去问，比如你的项目多可能就问的项目多一些，或者你说哪里精通可能面试官就多去问你这些。而且此图是根据题库数据整理出来，并不是根据实际单场面试整理，比如基础部分不会考那么多，会从中抽着考</p>
<p><font color="red">但是面试中必考的点且占比非常大的有c基础和<strong>算法</strong>。</font></p>
<p><font color="red">决定你是否能拿sp offer（高薪offer）以及是否进名企的是项目和<strong>算法</strong>。</font></p>
<h2 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h2><p>面试一般分为==技术面==和==hr面==，形式的话很少有群面，少部分企业可能会有一个交叉面，不过总的来说，技术面基本就是考察你的专业技术水平的，hr面的话主要是看这个人的综合素质以及家庭情况符不符合公司要求，一般来讲，技术的话只要通过了技术面hr面基本上是没有问题（也有少数企业hr面会刷很多人）</p>
<p>那我们主要来说技术面，技术面的话主要是<strong>考察专业技术知识和水平</strong>，我们是可以有一定的技巧的，但是一定是基于有一定的能力水平的。</p>
<p>所以也慎重的告诉大家，技巧不是投机取巧，是起到辅助效果的，技术面最主要的还是要有实力，这里是基于实力水平之上的技巧。</p>
<blockquote>
<p>整个过程都去主动引导聊天内容的方向</p>
<ol>
<li>简历上做一个引导</li>
</ol>
<p>​    在词汇上做好区分，比如熟悉java，了解python，精通c语言等</p>
<ol start="2">
<li><p> 在面试的过程中做一个引导</p>
</li>
<li><p>在自我介绍中做一个引导</p>
</li>
<li><p>面试过程中展示出自信</p>
</li>
</ol>
</blockquote>
<h2 id="面试前的准备："><a href="#面试前的准备：" class="headerlink" title="面试前的准备："></a><strong>面试前的准备：</strong></h2><p>最重要的肯定是系统的学习了，有一个<strong>知识的框架，基础知识的牢靠程度</strong>等。</p>
<p>其中算法尤其重要，越来越多公司还会让你现场或者视频面试中手写代码；</p>
<p>另一大重要的和加分项就是项目，在面试前，一定要练习回答自己项目的三个问题：</p>
<ul>
<li> 这是一个怎样的项目</li>
<li>用到了什么技术，为什么用这项技术（以及每项技术很细的点以及扩展）</li>
<li>过程中遇到了什么问题，怎么解决的。</li>
</ul>
<h2 id="面试后需要做的："><a href="#面试后需要做的：" class="headerlink" title="面试后需要做的："></a><strong>面试后需要做的：</strong></h2><p>面试完了的话就不用太在意结果了，有限的时间就应该做事半功倍的事情，当然，要保持电话邮箱畅通，不然别给你发offer你都不知道。</p>
<p>抛开这些，我们需要做的是及时将面试中的问题记录下来，尤其是自己回答的不够好的问题，一定要花时间去研究，并解决这些问题，下次面试再遇到相同的问题就能很好的解决，当然，即使不遇到，你这个习惯坚持住，后面也可以作为一个经历去跟面试官说，能表现出你对技术的喜爱和钻研的一个态度，同时，每次面试后你会发现自己的不足，查缺补漏的好机会，及时调整，在不断的调整和查缺补漏的过程中，你会越来越好。</p>
<h2 id="C-知识图谱"><a href="#C-知识图谱" class="headerlink" title="C++知识图谱"></a>C++知识图谱</h2><p><img src="https://uploadfiles.nowcoder.com/images/20190318/826546_1552892534596_2906E0A7B909700014399EE95544E4AA" alt="C++知识图"></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/posts/850f2080.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p><a href="##%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84">哈希映射</a></p>
<p><a href="#%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84">面试题10.02变位词组</a></p>
<p><a href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2">最长回文串</a></p>
<span id="more"></span>

<h2 id="哈希映射"><a href="#哈希映射" class="headerlink" title="哈希映射"></a>哈希映射</h2><p>不使用任何内建的哈希表库设计一个哈希映射</p>
<p>具体地说，你的设计应该包含以下的功能</p>
<p>put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。<br>get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。<br>remove(key)：如果映射中存在这个键，删除这个数值对。</p>
<p>示例：</p>
<p>MyHashMap hashMap = new MyHashMap();<br>hashMap.put(1, 1);<br>hashMap.put(2, 2);<br>hashMap.get(1);            // 返回 1<br>hashMap.get(3);            // 返回 -1 (未找到)<br>hashMap.put(2, 1);         // 更新已有的值<br>hashMap.get(2);            // 返回 1<br>hashMap.remove(2);         // 删除键为2的数据<br>hashMap.get(2);            // 返回 -1 (未找到) </p>
<h3 id="实现一个hash类"><a href="#实现一个hash类" class="headerlink" title="实现一个hash类"></a>实现一个hash类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> nkey;<br>    <span class="hljs-keyword">int</span> nval;<br>    Node* next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val): <span class="hljs-built_in">nkey</span>(key), <span class="hljs-built_in">nval</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">int</span> len = <span class="hljs-number">1000</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector &lt;Node*&gt; arr;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyHashMap</span>() &#123;<br>        arr = vector&lt;Node*&gt; (len, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>));<br>    &#125;<br>    <br>    <span class="hljs-comment">/** value will always be non-negative. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = key % len;<br>        Node* h = arr[temp];<br>        Node* prev;<br>        <span class="hljs-keyword">while</span>(h)&#123;<br>            <span class="hljs-keyword">if</span>(h -&gt; nkey == key)&#123;<br>                h -&gt; nval = value;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            prev = h;<br>            h = h -&gt; next;<br>        &#125;<br>        Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key,value);<br>        prev -&gt; next = node;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = key % len;<br>        Node* h = arr[temp];<br>        <span class="hljs-keyword">while</span>(h)&#123;<br>            <span class="hljs-keyword">if</span>(h -&gt; nkey == key)    <span class="hljs-keyword">return</span> h -&gt; nval;<br>            h = h -&gt; next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = key % len;<br>        Node* h = arr[temp];<br>        <span class="hljs-keyword">while</span>(h)&#123;<br>            <span class="hljs-keyword">if</span>(h -&gt; nkey == key)&#123;<br>                h -&gt; nval = <span class="hljs-number">-1</span>;<br>            &#125;<br>            h = h -&gt; next;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<p>C++链地址法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> key;<br>    <span class="hljs-keyword">int</span> value;<br>    Node * next;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> key_, <span class="hljs-keyword">int</span> value_):<span class="hljs-built_in">key</span>(key_),<span class="hljs-built_in">value</span>(value_),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;;<br>    ~<span class="hljs-built_in">Node</span>();<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> len = <span class="hljs-number">100</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> &#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;Node*&gt; arr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyHashMap</span>():<span class="hljs-built_in">arr</span>(vector&lt;Node*&gt;(len, <span class="hljs-literal">nullptr</span>))&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)<br>            arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">/** value will always be non-negative. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> index = key % len;<br>        Node *tmp = arr[index];<br>        <span class="hljs-keyword">while</span> (tmp)<br>        &#123;<br>             <span class="hljs-keyword">if</span> (tmp-&gt;key == <span class="hljs-number">-1</span>)<br>            &#123;<br>                tmp-&gt;key = key;<br>                tmp-&gt;value = value;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tmp-&gt;key == key)<br>            &#123;<br>                tmp-&gt;value = value;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tmp-&gt;next == <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                tmp-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            tmp = tmp-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> index = key % len;<br>        Node *tmp = arr[index];<br>        <span class="hljs-keyword">while</span> (tmp)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (tmp-&gt;key == key)<br>                <span class="hljs-keyword">return</span> tmp-&gt;value;<br>            tmp = tmp-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> index = key % len;<br>        Node *tmp = arr[index];<br>        <span class="hljs-keyword">while</span> (tmp)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (tmp-&gt;key == key)<br>            &#123;<br>                tmp-&gt;value = <span class="hljs-number">0</span>;<br>                tmp-&gt;key = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            tmp = tmp-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyHashMap* obj = new MyHashMap();</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;remove(key);</span><br><span class="hljs-comment"> */</span><br>作者：lie-wen-hu-ke-de-xian-wei-jing<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/design-hashmap/solution/c-lian-di-zhi-fa-by-lie-wen-hu-ke-de-xian-wei-jing/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>



<h1 id="变位词组"><a href="#变位词组" class="headerlink" title="变位词组"></a>变位词组</h1><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p>
<p>注意：本题相对原题稍作修改</p>
<p>示例:</p>
<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>说明：</p>
<p>所有输入均为小写字母。<br>不考虑答案输出的顺序。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote>
<p>变位词利用sort后和相同。哈希表添加次下标即可，之后便利哈希表根据下标添加变位词</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>    unordered_map&lt;string,vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; map;<br>    vector&lt;vector&lt;string&gt; &gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; strs.<span class="hljs-built_in">size</span>() ; i++)<br>    &#123;<br>        string str = strs[i];<br>        <span class="hljs-built_in">sort</span>(str.<span class="hljs-built_in">begin</span>(),str.<span class="hljs-built_in">end</span>());<br>        map[str].<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : map )<br>    &#123;<br>        <span class="hljs-keyword">auto</span> index = i.second; <span class="hljs-comment">//vector&lt;int&gt; index</span><br>        vector&lt;string&gt; tmp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : index)<br>        &#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(strs[it]);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h1><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p>
<p>注意:<br>假设字符串的长度不会超过 1010。</p>
<p>示例 1:</p>
<p>输入:<br>“abccccdd”</p>
<p>输出:<br>7</p>
<p>解释:<br>我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>先用哈希统计出现的每一个字母个数</li>
</ul>
<p><code>for(auto it : s) hash[it]++;</code></p>
<ul>
<li>统计字母个数为偶数的和，字母个数为奇数时，减一也能满足回文串要求</li>
</ul>
<p><code>length += it.second % 2 ? it.second : it.second - 1</code></p>
<ul>
<li> 此时<code>res % 2 = 0</code>，如果 <code>res &lt; size</code>,则回文串中间还可以加一个</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : s)<br>            hash[it]++;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : hash)<br>            res += it.second % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? it.second : it.second<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//res % 2 = 0 如果res = size,则原字符串出现的字母均是偶数个</span><br>        <span class="hljs-keyword">return</span> res = res &lt; s.<span class="hljs-built_in">size</span>() ? res + <span class="hljs-number">1</span> : res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="独一无二的出现次数"><a href="#独一无二的出现次数" class="headerlink" title="独一无二的出现次数"></a>独一无二的出现次数</h1><h4 id="1207-独一无二的出现次数"><a href="#1207-独一无二的出现次数" class="headerlink" title="1207. 独一无二的出现次数"></a><a href="https://leetcode-cn.com/problems/unique-number-of-occurrences/">1207. 独一无二的出现次数</a></h4><p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。</p>
<p>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：arr &#x3D; [1,2,2,1,1,3]<br>输出：true<br>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：arr &#x3D; [1,2]<br>输出：false<br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]<br>输出：true<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">uniqueOccurrences</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            hash[arr[i]]++;<br>        &#125;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; times;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; x: hash) &#123;<br>            times.<span class="hljs-built_in">insert</span>(x.second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> times.<span class="hljs-built_in">size</span>() == hash.<span class="hljs-built_in">size</span>();<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="前-K-个高频元素（哈希排序）"><a href="#前-K-个高频元素（哈希排序）" class="headerlink" title="前 K 个高频元素（哈希排序）"></a>前 K 个高频元素（哈希排序）</h1><h4 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h4><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br></code></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1]<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;v1,pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;v2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> v1.second &gt; v2.second;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>            unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; hash;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>            &#123;<br>                hash[nums[i]]++;<br>            &#125;<br>            vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">arr</span>(hash.<span class="hljs-built_in">begin</span>(),hash.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>(),cmp);<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(arr[i].first);<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="二倍数对数组"><a href="#二倍数对数组" class="headerlink" title="二倍数对数组"></a>二倍数对数组</h1><h3 id="954-二倍数对数组"><a href="#954-二倍数对数组" class="headerlink" title="954. 二倍数对数组"></a><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/">954. 二倍数对数组</a></h3><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E4%B8%AD%E7%AD%89-red"> </p>
<p>给定一个长度为偶数的整数数组 A，只有对 A 进行重组后可以满足 “对于每个 0 &lt;= i &lt; len(A) / 2，都有 A[2 * i + 1] = 2 * A[2 * i]” 时，返回 true；否则，返回 false。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：[3,1,3,6]<br>输出：false<br></code></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：[2,1,2,6]<br>输出：false<br></code></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：[4,-2,2,-4]<br>输出：true<br>解释：我们可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]<br></code></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：[1,2,4,16,8,4]<br>输出：false<br></code></pre></td></tr></table></figure>

<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><img src="https://img.shields.io/badge/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-n-information"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canReorderDoubled</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;<br>        map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; hash;<br>        <span class="hljs-keyword">int</span> match;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : A)<br>            hash[i]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = hash.<span class="hljs-built_in">begin</span>(); it != hash.<span class="hljs-built_in">end</span>(); ++it)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(it-&gt;second &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(it-&gt;first &gt; <span class="hljs-number">0</span>)<br>                    match = it-&gt;first *<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(it-&gt;first % <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    match = it-&gt;first / <span class="hljs-number">2</span>;<br>                &#125;<br>                hash[match] -= it-&gt;second;<br>                <span class="hljs-keyword">if</span>(hash[match] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序员内功</category>
        <category>刷题笔记</category>
        <category>C++</category>
        <category>算法数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>力扣</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>就业实录-信息系统与信息管理专业</title>
    <url>/posts/undefined.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="https://source.unsplash.com/user/fole_del/likes" width="50%">

<h1 id="面试日记📚"><a href="#面试日记📚" class="headerlink" title="面试日记📚"></a>面试日记📚</h1><div class="note blue no-icon flat"><p>没想到的是，offer是有了。虽然是格力的，但是体检不合格。从小到大都没犯过什么毛病，却在入职体检查出来预激综合征。来年春招再战了！</p>
</div>

<p>博客仅用于记录20年下半年的面试记录与学习记录~~给自己<strong>加油</strong></p>
<span id="more"></span>

<h2 id="一、天马面试记录🐴"><a href="#一、天马面试记录🐴" class="headerlink" title="一、天马面试记录🐴"></a>一、天马面试记录🐴</h2><p><u>Data：20年9月23日</u></p>
<p>先说一下没能成功签的因素，在无领导小组讨论环节，也不知道是怎么想的，就想表达自己认为的观点，但我对别人的也是认同的，只是纠结于目标，期间说了这么一句“只要我们给考官一个满意的答案就行！”。我觉得这句话对考官来说比较刺耳，同时也有限制别的组员发挥的意思，尤其不好，不过我是想从事于C++开发岗位的工作，但是此次面试的经验还是记录下来比较好，吸取一点教训！希望下次还能有这样碰壁的机会~</p>
<p>先是准备自我介绍，室友比我早一点时间，所以在室友那取经后，还是稍稍准备了一下自我介绍：</p>
<p>以下贴上准备的稿子，实际对话的时候可能会为了场合和地点以及面试官的问题稍作修改，<strong>首先表明</strong>在校期间表现不是特别优异，但也不是差的那批，处于中上游的水平，参加过几次比赛，但是名次都一般。</p>
<blockquote>
<h1 id="天马面试自我介绍"><a href="#天马面试自我介绍" class="headerlink" title="天马面试自我介绍"></a>天马面试自我介绍</h1><p>您好！ 😃😃我是经济管理学院信息系统与信息管理专业的XXX，学习期间担任班长和学生会网络媒体部副部长一职。在校活动中多次荣获优秀志愿者称号。竞赛方面，参加过两次三创赛，一次互联网＋，申请并独自完成了一个大创项目。18年末开始学习并使用Qt进行项目开发，其中大创项目就是基于Qt平台开发的一款PC端应用程序。现在主要期望能参与到C/C++方面的开发工作当中。</p>
</blockquote>
<blockquote>
<p>您好！ 😃😃我是经济管理学院信息系统与信息管理专业的XXX,课程内容以管理与计算机为主，18年末开始学习并使用Qt进行项目开发，其中大创项目就是基于Qt平台开发的一款PC端应用程序。现在主要期望能参与到C/C++方面的开发工作当中。</p>
</blockquote>
<h2 id="1️⃣天马一面"><a href="#1️⃣天马一面" class="headerlink" title="1️⃣天马一面"></a>1️⃣天马一面</h2><p><strong>一面主要是<code>自我介绍</code>的环节与面试官的一些<code>问答</code>环节</strong>：问一下大学期间的学习情况以及参加的项目，面试官可能会细致的问一下你对某一课程的学习情况，除此之外，会着重问一下你大学期间参加的项目、担任的角色、负责的任务。</p>
<p>一面的同时，面试官也会思考你是适合哪一岗位，所以你要尽可能的把<code>自己说明白</code>，这一点不管是在哪个面试上，我觉得都是个人最重要的一点。</p>
<h2 id="珠海格力面试"><a href="#珠海格力面试" class="headerlink" title="珠海格力面试"></a>珠海格力面试</h2><h2 id="IBM面试"><a href="#IBM面试" class="headerlink" title="IBM面试"></a>IBM面试</h2><h1 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h1><div class="note orange icon flat"><i class="note-icon fa fa-battery-quarter"></i><p>这篇文章还在编辑中······</p>
</div>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C++成“神”之路—浮点数</title>
    <url>/posts/1bbee39e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇为基础浮点数用法学习记录</p>
<span id="more"></span>

<h2 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
<th align="center">表示范围</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">4字节</td>
<td align="center">-128~127</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">signed char</td>
<td align="center">4字节</td>
<td align="center">-128~127</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">unsiged char</td>
<td align="center">4字节</td>
<td align="center">0~255</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">wchar_t(整数类型、宽字符类型)</td>
<td align="center">8字节</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>wcahr_t：可以拜师扩展字符集，<code>iostream</code>头文件的最新版提供了作用相似的工具——wcin和wcout，可用于处理wchar_t流，==可以通过加上前缀L来指示宽字符常量和宽字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">wcahr_t</span> bob = <span class="hljs-string">L&#x27;P&#x27;</span>;<br>wcout &lt;&lt; <span class="hljs-string">L&quot;tall&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>C++11新增的类型char16_t和char32_t（两者均是无符号的）</p>
<table>
<thead>
<tr>
<th>char16_t</th>
<th>使用前缀u表示</th>
<th>char16_t ch1 =u’q’;</th>
</tr>
</thead>
<tbody><tr>
<td>char32_t</td>
<td>使用前缀U表示</td>
<td>char32_t ch2 = U’\U000022B’;</td>
</tr>
</tbody></table>
<h2 id="原始（raw）字符串"><a href="#原始（raw）字符串" class="headerlink" title="原始（raw）字符串"></a>原始（raw）字符串</h2><blockquote>
<p> 使用前缀R来标识原值字符串</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">R&quot;(Jim &quot;Kingt Tutt uses·&quot;\n&quot; inatead of endl)&quot;</span> &lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-comment">//也可以使用</span><br>cout &lt;&lt; <span class="hljs-string">R&quot;+*(此处输入原始字符串)+*&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//输出：</span><br>Jim <span class="hljs-string">&quot;Kingt Tutt uses·&quot;</span>\n<span class="hljs-string">&quot; inatead of endl</span><br></code></pre></td></tr></table></figure>



<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><blockquote>
<p>如果程序在多个地方使用同一个常量，则需要修改该常量时，只需修改一个符号定义即可(const)。</p>
<p>g++将指出程序试图给一个只读变量赋值。 关键字 const 叫做限定符，因为它限定了声明的含义。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//creat &#x27;const&#x27;</span><br><span class="hljs-comment">//const type name = value;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Months = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure>

<p>​    即：在声明中对const进行初始化。</p>
<p>​        一种常见的做法是将名称的首字母大写，以提醒您 Months是个常量。这决不是一种通用约定，但在阅读程序时有助于区分常量和变量。另一种约定是将整个名称大写，使用Wdefime 创建常量时通常使用这种约定。还有一种约定是以字母k打头，如kmonths。当然，还有其他约定。许多组织都有特殊的编码约定，要求其程序员遵守。</p>
<h2 id="C-浮点数"><a href="#C-浮点数" class="headerlink" title="C++ 浮点数"></a>C++ 浮点数</h2><blockquote>
<p>计算机将(2.5、3.64564)这样的值分成两部分存储。一部分表示值，另一部分（缩放因子）用于对值进行放大或缩小。</p>
</blockquote>
<h3 id="浮点数的两种表示方法"><a href="#浮点数的两种表示方法" class="headerlink" title="浮点数的两种表示方法"></a>浮点数的两种表示方法</h3><pre><code>    #### 1. 使用常用的标准小数点表示法（如3.1415926）
</code></pre>
<h4 id="2-E表示法（如2-52e-8-252-000-000）"><a href="#2-E表示法（如2-52e-8-252-000-000）" class="headerlink" title="2. E表示法（如2.52e+8==252 000 000）"></a>2. E表示法（如2.52e+8==252 000 000）</h4><p>​    需要注意的是:</p>
<pre><code>1. 既可以使用E，也可以使用e
2. 指数可以是正数，也可以是负数
3. 数字中间不能有空格（7.2 E6是错误的）
</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">float</span> f1 = <span class="hljs-number">3834e-10</span>;<br>    <span class="hljs-keyword">float</span> f2 = <span class="hljs-number">3834</span>/<span class="hljs-number">1e10</span>,f3 = f1;	<br>	<span class="hljs-comment">//输出f1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;当前输出为f1：&quot;</span> &lt;&lt; f1 &lt;&lt; std::endl;<br>	<span class="hljs-comment">//输出f2</span><br>    std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前输出为f2：%.10f\n&quot;</span>,f2);<br>	<span class="hljs-comment">//输出f3</span><br>    std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前输出为f3：%.10f\n&quot;</span>, f3);<br>    <br>    <span class="hljs-comment">//int 隐式转换</span><br>    <span class="hljs-keyword">float</span> f4 = <span class="hljs-number">10</span> / <span class="hljs-number">3</span>; <span class="hljs-comment">//10和3 被默认为两个int型变量  赋值操作向下取整</span><br>    std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前输出为f4：%.10f\n&quot;</span>, f4);  <span class="hljs-comment">//f4=3.0</span><br>    <span class="hljs-keyword">float</span> f5 = <span class="hljs-number">10.0</span> / <span class="hljs-number">3.0</span>;<br>    std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前输出为f5：%.10f\n&quot;</span>, f5);	 <span class="hljs-comment">// 10.0/3 = 10/3.0 = 3.33</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下所示：</p>
<img alt="image-20200808150951505.png" src="../../../../../images/image-20200808150951505.png">

<h3 id="浮点数优缺点"><a href="#浮点数优缺点" class="headerlink" title="浮点数优缺点"></a>浮点数优缺点</h3><blockquote>
<ul>
<li>优势</li>
</ul>
<ol>
<li>可以表示整数之间的值</li>
<li>由于有缩放因此，表示范围较大</li>
</ol>
<ul>
<li>不足<ol>
<li>浮点运算的速度比整数运算慢</li>
<li>精度降低（如下所示）</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//该程序将f6加1，然后减去1</span><br>	<span class="hljs-keyword">float</span> f6 = <span class="hljs-number">2.34E+22</span>f;<br>	<span class="hljs-keyword">float</span> f7 = f6 + <span class="hljs-number">1.0f</span>;<br><br>	std::cout &lt;&lt; <span class="hljs-string">&quot;f6:&quot;</span> &lt;&lt; f6 &lt;&lt; std::endl &lt;&lt; <span class="hljs-string">&quot;f7-f6:&quot;</span> &lt;&lt; f7 - f6 &lt;&lt; std::endl;<br>	std::<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前输出为f6：%.1f\n当前输出为f7-f6：%.1f\n&quot;</span>, f6, f7-f6);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<img src="../../../../../images/image-20200808163114284.png">



<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2>]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
        <category>第四章、数据类型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>浮点型</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数与纯虚函数</title>
    <url>/posts/5dd98e7e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇讲述虚函数与纯虚函数的区别与用法</p>
<span id="more"></span>
<p><font color="red" size="4px"><strong>对于抽象类来说，它无法实例化对象，而对于抽象类的子类来说，只有把抽象类中的纯虚函数全部实现之后，那么这个子类才可以实例化对象</strong></font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">bool</span> gender;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span></span>; <br>&#125;;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>简单理解就是父类定义了一个群体将会有的动作以及行为：如Worker类，我们仅知道工人们会工作，但是我们不知道具体是什么工人以及从事于什么样的工作，因此，可以把worker类定义为抽象类，用以规定可能会有的行为以及操作。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">worker</span>：<span class="hljs-title">public</span> <span class="hljs-title">person</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">bool</span> gender;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义为抽象基类是避免实例化造成的编译报错，并且基类的定义时1为了规定大致的行为操作，具体的内容实现是基于继承类</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同时，<strong>对于抽象类的子类也可以是抽象类</strong>，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dustMan</span>：<span class="hljs-title">public</span> <span class="hljs-title">worker</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">bool</span> gender;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义为抽象基类是避免实例化造成的编译报错，并且基类的定义时1为了规定大致的行为操作，具体的内容实现是基于继承类</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;扫地&quot;</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;我是清洁工&quot;</span>;&#125; <br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，如果基类中有纯虚函数（该类为抽象类，不能实例化对象），那么子类实现过程中必须重新定义纯虚函数，编译器才不会报错。</p>
</blockquote>
<ol>
<li><p><strong>虚函数是动态绑定的</strong>，也就是说。使用虚函数的指针和引用能够正确找到实际类的相应函数，而不是运行定义类的函数。</p>
<p>这是虚函数的基本功能，就不再解释了。</p>
</li>
<li><p><strong>构造函数不能是虚函数</strong>。并且，在构造函数中调用虚函数，实际运行的是父类的相应函数。由于自己还没有构造好, 多态是被<code>disable</code>的。</p>
</li>
<li><p><strong>析构函数能够是虚函数。并且，在一个复杂类结构中。这往往是必须的</strong>。</p>
</li>
<li><p><strong>将一个函数定义为纯虚函数。实际上是将这个类定义为抽象类，不能实例化对象</strong>。</p>
</li>
<li><p><strong>纯虚函数通常未定义体，但也全然能够拥有</strong>, 甚至能够显示调用。</p>
</li>
<li><p>**析构函数能够是纯虚的，但纯虚析构函数必须有定义体，*由于析构函数的调用是在子类中隐含的***。</p>
</li>
<li><p>非纯的虚函数必须有定义体，不然是一个错误。</p>
</li>
<li><p>派生类的<code>override</code>虚函数定义必须和父类全然一致(<code>c++11</code>中使用<code>override</code>进行编译器检查)。除了一个特例，假设父类中返回值是一个指针或引用。子类<code>override</code>时能够返回这个指针（或引用）的派生。</p>
<p>比如，在上面的样例中，在<code>Base</code>中定义了 <code>virtual Base* clone()</code>; 在<code>Derived</code>中能够定义为 <code>virtual Derived* clone()</code>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>浮点型</tag>
      </tags>
  </entry>
  <entry>
    <title>class与struct的区别与用法</title>
    <url>/posts/79effa92.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇讲述class与struct的区别与用法</p>
<span id="more"></span>
<h3 id="命名常识"><a href="#命名常识" class="headerlink" title="命名常识"></a>命名常识</h3><img src="../../../../images/3-struct%E4%B8%8Eclass%E7%9A%84%E5%8C%BA%E5%88%AB/image-20200808135010677.png" style="zoom:60%">



<h1 id="struct与class的区别"><a href="#struct与class的区别" class="headerlink" title="struct与class的区别"></a>struct与class的区别</h1><blockquote>
<p>C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。</p>
<p>struct能包含成员函数吗？ 能！</p>
<p>struct能继承吗？ 能！！</p>
<p>struct能实现多态吗？ 能！！！</p>
</blockquote>
<h2 id="1）默认的继承访问权限。struct是public的，class是private的。"><a href="#1）默认的继承访问权限。struct是public的，class是private的。" class="headerlink" title="1）默认的继承访问权限。struct是public的，class是private的。"></a>1）默认的继承访问权限。struct是public的，class是private的。</h2><h2 id="2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。"><a href="#2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。" class="headerlink" title="2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。"></a>2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</h2><blockquote>
<p>coutpu（）函数，该函数显示一个字符</p>
</blockquote>
<p>decltype类似于typedef，但是typedef加类型，decltype加变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">decltype</span>(n) n2;<span class="hljs-comment">//n2是int类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> INT;<br>INT n3;<span class="hljs-comment">//n3也是int类型</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*pfun)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//类外声明</span><br><span class="hljs-keyword">auto</span> add（<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b）<br>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-built_in">itn</span> (*p)(<span class="hljs-keyword">int</span> ,<span class="hljs-keyword">int</span>) = add;<br><span class="hljs-keyword">using</span> PFUN = <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*)();<br><br></code></pre></td></tr></table></figure>

<p><img src="../../../../images/3-struct%E4%B8%8Eclass%E7%9A%84%E5%8C%BA%E5%88%AB/image-20200907213340088.png"></p>
<p>typedef 重定义类型时不能用于vector</p>
<p>此时就需要using</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> vector&lt;<span class="hljs-keyword">int</span>&gt; int_vec;<span class="hljs-comment">//此时就会报错</span><br><br><span class="hljs-keyword">using</span> int_vec = vector&lt;<span class="hljs-keyword">int</span>&gt;;<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>class</tag>
        <tag>struct</tag>
      </tags>
  </entry>
  <entry>
    <title>string函数的用法</title>
    <url>/posts/17269114.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本篇教程为基础string用法</p>
<span id="more"></span>
<h1 id="1、sizeof（）与strlen（）get（）与getline（）的区别"><a href="#1、sizeof（）与strlen（）get（）与getline（）的区别" class="headerlink" title="1、sizeof（）与strlen（）get（）与getline（）的区别"></a>1、sizeof（）与strlen（）get（）与getline（）的区别</h1><blockquote>
<p>两者都能读取一行输入，知道到达换行符，但是getline()将丢弃换行符，而get()会将换行符保留在输入序列中</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">long</span> totals[<span class="hljs-number">500</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//只要显式地将第一个元素初始化为0，然后让编译器将其他元素都初始化为0；如果初始化为1）而不是&#123;0&#125;，则第一个元素被设置为1.其他元素都被设置为</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>再确定存储字符串所需的最短数组时，别忘了将结尾的空字符串计算在内</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;S&quot;</span> = <span class="hljs-string">&#x27;S&#x27;</span> + <span class="hljs-string">&#x27;\0&#x27;</span><br></code></pre></td></tr></table></figure>

<p>==sizeof==运算符指出整个数组的长度，但==strlen()==函数返回的是当前存储在数组中的字符串长度，而不是数组本身的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Arsize = <span class="hljs-number">15</span>;<br><span class="hljs-keyword">char</span> name2[Arsize] = <span class="hljs-string">&quot;C++OWboy&quot;</span>;<br><span class="hljs-comment">//通过设置符号常量的地址即可对数组长度进行修改</span><br>name2[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p><code>strlen()</code>对于未被初始化的数据， 第一个空字符的出现位置是随机的，因此您在运行该程序时，得到的数据长度很可能与此不同</p>
<h2 id="面向行的输入：getline"><a href="#面向行的输入：getline" class="headerlink" title="面向行的输入：getline()"></a>面向行的输入：getline()</h2><p>getline是istream类的一个类方法</p>
<p>getline（）函数每次读取一行。它通过==换行符==来确定行尾，但不保存==换行符==。相反，在存储字符串时，它用空字符来替换换行符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;istream&gt;</span></span><br><span class="hljs-comment">//设要使用gtline（（）将姓名读入到一个包含20个元素的nme数组中</span><br><span class="hljs-comment">//第一个参数是目标数组;第二个参数数组长度</span><br><span class="hljs-comment">//长度‘20’包含\0</span><br>cin.<span class="hljs-built_in">getling</span>(name,<span class="hljs-number">20</span>); <br></code></pre></td></tr></table></figure>

<h2 id="面向行的输入：get"><a href="#面向行的输入：get" class="headerlink" title="面向行的输入：get()"></a>面向行的输入：get()</h2><p>get()会读取换行符（==所输入的[<strong>enter</strong>]需要一个get()消化==）；用不带任何参数的cin.get（）调用可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。</p>
<img src="https://tva4.sinaimg.cn/large/0072YHp3ly1gjvu25gt0rj30uu0a2gv1.jpg" alt="String函数用法1" width="1110" data-width="1110" data-height="362">

<h2 id="如何消化换行符"><a href="#如何消化换行符" class="headerlink" title="如何消化换行符"></a>如何消化换行符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<br><br>	<span class="hljs-keyword">char</span> charr[<span class="hljs-number">20</span>];<br>	string str;<br>	<span class="hljs-keyword">int</span> year;<br>	cout &lt;&lt; <span class="hljs-string">&quot;请输入年份：&quot;</span>;<br>	cin &gt;&gt; year;<br>	cout &lt;&lt; <span class="hljs-string">&quot;获取char字符串：&quot;</span>;<br>	cin.<span class="hljs-built_in">getline</span>(charr, <span class="hljs-number">20</span>);<br>	cout &lt;&lt; <span class="hljs-string">&quot;获取string字符串：&quot;</span>;<br>	<span class="hljs-built_in">getline</span>(cin, str);<br>	cout &lt;&lt; <span class="hljs-string">&quot;第一次输入为：&quot;</span> &lt;&lt; charr &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; <span class="hljs-string">&quot;第二次输入为：&quot;</span> &lt;&lt; str;<br><br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://tvax3.sinaimg.cn/large/0072YHp3ly1gjvu364erfj30fl01rdfp.jpg" alt="String函数用法2" width="561" data-width="561" data-height="63">

<p>运行上述代码可以发现：在输入1997以及<code>回车</code>确定之后，第一个字符串，也就是代码中的<code>cin.getline(charr,20)</code>将回车键吸收并保留，导致第一次getline()直接被调用。所以可以使用get()函数吸收<code>1997</code>之后的换行符；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//以下两种方式均可以</span><br><span class="hljs-comment">//---1---</span><br>cin &gt;&gt; year;<br>cin.<span class="hljs-built_in">get</span>();<span class="hljs-comment">//句点表示法</span><br><br><span class="hljs-comment">//---2---</span><br>(cin&gt;&gt;yeat).<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure>

<p>在添加上述语句之后：便可以正常输入<code>charr</code>与<code>str</code>两个字符串。</p>
<img src="https://tva1.sinaimg.cn/large/0072YHp3ly1gjvu4239ktj30ff02vq2y.jpg" alt="String函数用法3" width="555" data-width="555" data-height="103">

<h1 id="2、string类"><a href="#2、string类" class="headerlink" title="2、string类"></a>2、string类</h1><h3 id="1-注意点"><a href="#1-注意点" class="headerlink" title="1.注意点"></a>1.注意点</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//string类位于命名空间std中</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure>

<ul>
<li>可以使用C-风格字符串来初始化sring 对象。</li>
<li>可以使用cin来将键盘输入存储到sring对象中。</li>
<li>可以使用cout 来显示 string对象。</li>
<li>可以使用数组表示法来访问存储在string对象中的字符。</li>
</ul>
<ol>
<li><p>在未输入之前，string对象的长度被自动设置为0</p>
</li>
<li><p>~~~ C++<br>//使用以下方法获取string对象的输入<br>char charr[20];<br>int length = strlen(charr);<br>cout &lt;&lt; “strlen（charr）：” &lt;&lt; length &lt;&lt; endl;<br>getline(cin,str);//此时getline()不是istream中的类方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>3. 上述代码中的charr由于定义时未初始化，第一个空字符的出现位置是随机的吗，因此在运行上述strlen(charr)时，会得到一个不确定的数值&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;tvax1.sinaimg.cn&#x2F;large&#x2F;0072YHp3ly1gjvu4tpiw6j3083011we9.jpg&quot; alt&#x3D;&quot;String函数用法4&quot; width&#x3D;&quot;291&quot; data-width&#x3D;&quot;291&quot; data-height&#x3D;&quot;37&quot;&gt;<br><br>### 2.string类的赋值、拼接和附加<br><br>~~~ C++<br>string str1&#x3D;&quot;hello &quot;;<br>string str2&#x3D;&quot;world!&quot;;<br><br>string str3 &#x3D; str1+str2;&#x2F;&#x2F;str3 &#x3D; &quot;hello world!&quot;<br><br>str1 +&#x3D; str2; &#x2F;&#x2F;str1 &#x3D; &quot;hello world!&quot;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-其他形式的字符串字面值"><a href="#3-其他形式的字符串字面值" class="headerlink" title="3.其他形式的字符串字面值"></a>3.其他形式的字符串字面值</h3><p>除了char类型，C++还有wchar_t；并且C++11新增了char16_t和char32_t 可以创建这些类型的数组和这些类型的字符串面值。<code>C++11分别使用前缀L、u和U表示上述三种字符</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">wchar_t</span> c1[] = <span class="hljs-string">L&quot;first&quot;</span>;<br><span class="hljs-keyword">char16_t</span> c2[] = <span class="hljs-string">u&quot;second&quot;</span>;<br><span class="hljs-keyword">char32_t</span> c3[] = <span class="hljs-string">U&quot;third&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>==除了上述之外，C++11还支持Unicode编码，使用前缀<code>u8</code>表示这种类型的字符串面值==</p>
<p>在不使用转移字符时，即保留<code>\n</code>的原样输出是，常规的做法就是<code>“\\\n”</code>输出\n到序列中，但原始字符串将”（和）”用作定界符，并使用前缀 R来标识原始字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">R&quot;(i am a &quot;big&quot;one .)&quot;</span><br></code></pre></td></tr></table></figure>

<p>上述代码输出为:</p>
<p> i am “big” one.</p>
<p>就不必使用\来表示转义序列。</p>
<p>同时也可以使用自定义定界符控制开始和结尾R”+*(输出内容)+*“</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-string">R&quot;+*(&quot;(how are you?)&quot;,i&#x27;m fine. )+*&quot;</span><br></code></pre></td></tr></table></figure>

<p>上述代码输出为：</p>
<p>“(how are you?)”,i’m fine.</p>
<p><code>需要注意的是，在默认定界符之间可以添加任意数量额基本的字符，但是不包括(空格、左括号、右括号、斜杠和控制字符（如制表符和换行符）)</code>，还可以结合着字符串前缀使用，如Ru、UR等</p>
<h3 id="substr-size-type-pos-size-type-n-npos-函数"><a href="#substr-size-type-pos-size-type-n-npos-函数" class="headerlink" title="substr(size_type pos,size_type n = npos)函数"></a>substr(size_type pos,size_type n = npos)函数</h3><p>返回一个字符串——这是从pos开始，复制n个字符（或到字符串尾部）得到的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">messgae</span> <span class="hljs-params">(<span class="hljs-string">&quot;this is a test string!&quot;</span>)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">firstWord</span><span class="hljs-params">(message.substr(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>))</span></span><br></code></pre></td></tr></table></figure>



<h1 id="3、结构体"><a href="#3、结构体" class="headerlink" title="3、结构体"></a>3、结构体</h1><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//创建结构体</span><br><span class="hljs-comment">//定义一个student结构体，包括三种类型的变量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>	<span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>	<span class="hljs-keyword">int</span> age;<br>	<span class="hljs-keyword">bool</span> gender;<br>&#125;;<br><span class="hljs-comment">//还可以在创建的结构体的时候就创建结构变量，同时也可以对变量初始化</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>	<span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>	<span class="hljs-keyword">int</span> age;<br>	<span class="hljs-keyword">bool</span> gender;<br>&#125;ming_xiao,hua_li=<br>&#123;<br>  <span class="hljs-string">&quot;lihua&quot;</span>,<br>    <span class="hljs-number">18</span>,<br>    <span class="hljs-number">0</span><br>&#125;;<br><span class="hljs-comment">//还可以声明没有名称的结构体，省略名称就行</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>	<span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];<br>	<span class="hljs-keyword">int</span> age;<br>	<span class="hljs-keyword">bool</span> gender;<br>&#125; Danny; <span class="hljs-comment">//这样就创建了一个Danny的结构体变量，可以使用Danny.name调用成员变量</span><br></code></pre></td></tr></table></figure>

<h3 id="2-结构数组"><a href="#2-结构数组" class="headerlink" title="2.结构数组"></a>2.结构数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//创建结构体</span><br>student stu[<span class="hljs-number">100</span>];<br><br><span class="hljs-comment">//stu中的每个元素都是stu对象，可以与成员运算符一起使用</span><br>cin &gt;&gt; stu[<span class="hljs-number">0</span>].name;<br>cout &lt;&lt; stu[<span class="hljs-number">99</span>].age;<br><br><span class="hljs-comment">//结构数组在定义的时候也可以初始化</span><br><br>student stu[<span class="hljs-number">2</span>] =&#123;<br>    &#123;<span class="hljs-string">&quot;LiMing&quot;</span>，<span class="hljs-number">19</span>,<span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;Danny&quot;</span>,<span class="hljs-number">21</span>,<span class="hljs-number">0</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
        <category>第四章、数据类型</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>STL实现—迭代器</title>
    <url>/posts/f8b7acae.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>迭代器</p>
<span id="more"></span>

<h1 id="一、实验内容"><a href="#一、实验内容" class="headerlink" title="一、实验内容"></a>一、实验内容</h1><p>本节实验我们将为大家讲解迭代器，主要介绍 5 种常见迭代器：输入、输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。主要内容包括各自的构造方法和操作方法。</p>
<!--more-->

<h2 id="1-1-知识点"><a href="#1-1-知识点" class="headerlink" title="1.1 知识点"></a>1.1 知识点</h2><ul>
<li>输出迭代器</li>
<li>输入迭代器</li>
<li>前向迭代器</li>
<li>双向迭代器</li>
<li>随机迭代器</li>
<li>迭代器辅助函数</li>
</ul>
<h2 id="1-2-实验环境"><a href="#1-2-实验环境" class="headerlink" title="1.2 实验环境"></a>1.2 实验环境</h2><ul>
<li>g++</li>
<li>ubuntu 16.04</li>
</ul>
<h2 id="1-3-代码获取"><a href="#1-3-代码获取" class="headerlink" title="1.3 代码获取"></a>1.3 代码获取</h2><p>可以通过以下链接获取本课程的源码内容，本次实验内容主要包含在文件<code>Iterator.h</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;获取代码<br>wget https:&#x2F;&#x2F;labfile.oss.aliyuncs.com&#x2F;courses&#x2F;1166&#x2F;mySTL.zip<br>unzip -q mySTL.zip -d .&#x2F;Code&#x2F;<br></code></pre></td></tr></table></figure>

<h1 id="二、迭代器详述"><a href="#二、迭代器详述" class="headerlink" title="二、迭代器详述"></a>二、迭代器详述</h1><p>迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。迭代器基本分为五种，输入输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。</p>
<p><strong>简单概括</strong>：迭代器是一种检查容器内元素并遍历元素的可带泛型数据类型。</p>
<p>下面，我们新建头文件<code>Iterator.h</code>是头文件，用来实现我们的迭代器，这里的代码需要引用到系统头文件<code>#include &lt;cstddef&gt;</code>，它主要用于定义一些类型。接下来我们定义 5 种迭代器的类型，将其写入<code>Iterator.h</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">struct input_iterator_tag&#123;&#125;;&#x2F;&#x2F;返回输入迭代器<br>struct output_iterator_tag&#123;&#125;;&#x2F;&#x2F;返回输出迭代器<br>struct forward_iterator_tag :public input_iterator_tag &#123;&#125;;&#x2F;&#x2F;返回前向迭代器<br>struct bidirectional_iterator_tag :public forward_iterator_tag &#123;&#125;;&#x2F;&#x2F;返回双向迭代器<br>struct random_access_iterator_tag :public bidirectional_iterator_tag &#123;&#125;;&#x2F;&#x2F;返回随机迭代器<br></code></pre></td></tr></table></figure>

<h2 id="2-1-输入迭代器"><a href="#2-1-输入迭代器" class="headerlink" title="2.1 输入迭代器"></a>2.1 输入迭代器</h2><p>通过对输入迭代器解除引用，它将引用对象，而对象可能位于集合中。通常用于传递地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Distance</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">input_iterator</span> &#123;</span><br>    <span class="hljs-keyword">typedef</span> input_iterator_tag iterator_category;<span class="hljs-comment">//返回类型</span><br>    <span class="hljs-keyword">typedef</span> T                  value_type;<span class="hljs-comment">//所指对象类型</span><br>    <span class="hljs-keyword">typedef</span> Distance           difference_type;<span class="hljs-comment">//迭代器间距离类型</span><br>    <span class="hljs-keyword">typedef</span> T*                 pointer;<span class="hljs-comment">//操作结果类型</span><br>    <span class="hljs-keyword">typedef</span> T&amp;                 reference;<span class="hljs-comment">//解引用操作结果类型</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2-2-输出迭代器"><a href="#2-2-输出迭代器" class="headerlink" title="2.2 输出迭代器"></a>2.2 输出迭代器</h2><p>该类迭代器和输入迭代器极其相似，也只能单步向前迭代元素，不同的是该类迭代器对元素只有写的权力。通常用于返回地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">output_iterator</span>&#123;</span><br>    <span class="hljs-keyword">typedef</span> output_iterator_tag iterator_category;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                value_type;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                difference_type;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                pointer;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>                reference;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2-3-前向迭代器"><a href="#2-3-前向迭代器" class="headerlink" title="2.3 前向迭代器"></a>2.3 前向迭代器</h2><p>前向迭代器可以在一个正确的区间中进行读写操作，它拥有输入迭代器的所有特性，和输出迭代器的部分特性，以及单步向前迭代元素的能力。通常用于遍历。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Distance</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">forward_iterator</span>&#123;</span><br>    <span class="hljs-keyword">typedef</span> forward_iterator_tag    iterator_category;<br>    <span class="hljs-keyword">typedef</span> T                        value_type;<br>    <span class="hljs-keyword">typedef</span> Distance                difference_type;<br>    <span class="hljs-keyword">typedef</span> T*                        pointer;<br>    <span class="hljs-keyword">typedef</span> T&amp;                        reference;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="2-4-双向迭代器"><a href="#2-4-双向迭代器" class="headerlink" title="2.4 双向迭代器"></a>2.4 双向迭代器</h1><p>该类迭代器是在前向迭代器的基础上提供了单步向后迭代元素的能力，前向迭代器的高级版。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Distance</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bidirectional_iterator</span>&#123;</span><br>    <span class="hljs-keyword">typedef</span> bidirectional_iterator_tag    iterator_category;<br>    <span class="hljs-keyword">typedef</span> T                        value_type;<br>    <span class="hljs-keyword">typedef</span> Distance                difference_type;<br>    <span class="hljs-keyword">typedef</span> T*                        pointer;<br>    <span class="hljs-keyword">typedef</span> T&amp;                        reference;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="2-5-随机迭代器"><a href="#2-5-随机迭代器" class="headerlink" title="2.5 随机迭代器"></a>2.5 随机迭代器</h2><p>该类迭代器能完成上面所有迭代器的工作，它自己独有的特性就是可以像指针那样进行算术计算，而不是仅仅只有单步向前或向后迭代。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">Distance</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">random_access_iterator</span>&#123;</span><br>    <span class="hljs-keyword">typedef</span> random_access_iterator_tag    iterator_category;<br>    <span class="hljs-keyword">typedef</span> T                        value_type;<br>    <span class="hljs-keyword">typedef</span> Distance                difference_type;<br>    <span class="hljs-keyword">typedef</span> T*                        pointer;<br>    <span class="hljs-keyword">typedef</span> T&amp;                        reference;<br>&#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实验楼</category>
        <category>实现STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/posts/2f57a694.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>正则表达式扩展应用</p>
<h1 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h1><p>事实上，基础的正则表达式已经足以满足大部分情况下的使用需求。不过有时候为了进一步简化命令操作，了解一些使用范围更广的扩展表达式会更加方便。本节实验将介绍扩展正则表达式的基本知识。</p>
<h2 id="实验知识点"><a href="#实验知识点" class="headerlink" title="实验知识点"></a>实验知识点</h2><ul>
<li>egrep 命令</li>
<li>扩展正则表达式</li>
</ul>
<h1 id="1、使用扩展正则表达式-egrep"><a href="#1、使用扩展正则表达式-egrep" class="headerlink" title="1、使用扩展正则表达式 egrep"></a>1、使用扩展正则表达式 egrep</h1><p>首先来看一条前面章节学习过的用来去除空白行和注释行的指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -v <span class="hljs-string">&#x27;^$&#x27;</span> regular_express.txt |grep -v <span class="hljs-string">&#x27;^#&#x27;</span><br></code></pre></td></tr></table></figure>

<p>可见，通常的 grep 指令需要使用两次管线命令。 那么如果使用扩展正则表达式，则可以简化为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">egrep -v <span class="hljs-string">&#x27;^$|^#&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>利用支持扩展正则表达式的 egrep 与特殊字符 “|” 的组功能来间隔两组字符串，如此一来，可以极大地化简指令。</p>
<p>此外，也可以使用 grep - E 来使用扩展正则表达式，不过一般更建议直接使用 egrep，grep -E 与 egrep 之间类似命令别名的关系。</p>
<h1 id="2、扩展规则（一）"><a href="#2、扩展规则（一）" class="headerlink" title="2、扩展规则（一）"></a>2、扩展规则（一）</h1><p>回忆一下，在非扩展正则表达式中，我们使用 * 来表示任意个重复字符（零至无穷多个）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;goo*d&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>在扩展正则表达式中，则可以进一步细分为”一个或一个以上“和”零个或一个“字符：</p>
<h2 id="：表示重复一个或一个以上的前一个字符"><a href="#：表示重复一个或一个以上的前一个字符" class="headerlink" title="+ ：表示重复一个或一个以上的前一个字符"></a>+ ：表示重复一个或一个以上的前一个字符</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">egrep -n <span class="hljs-string">&#x27;go+d&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<h2 id="：-表示重复零个或一个的前一个字符"><a href="#：-表示重复零个或一个的前一个字符" class="headerlink" title="? ： 表示重复零个或一个的前一个字符"></a>? ： 表示重复零个或一个的前一个字符</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">egrep -n <span class="hljs-string">&#x27;go?d&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>执行上述三条指令，比较三者的不同。</p>
<p><img src="https://doc.shiyanlou.com/courses/2645/484222/8257533d9214ce18f0c46e4dcc15ae24-0" alt="4-3-0"></p>
<h1 id="3、扩展规则（二）"><a href="#3、扩展规则（二）" class="headerlink" title="3、扩展规则（二）"></a>3、扩展规则（二）</h1><h4 id="：表示用或（or）的方式找出数个字符串"><a href="#：表示用或（or）的方式找出数个字符串" class="headerlink" title="|：表示用或（or）的方式找出数个字符串"></a>|：表示用或（or）的方式找出数个字符串</h4><p>查找 gd 或 good：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">egrep -n <span class="hljs-string">&#x27;gd|good&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<h4 id="表示找出组字符串"><a href="#表示找出组字符串" class="headerlink" title="() : 表示找出组字符串"></a>() : 表示找出组字符串</h4><p>查找 glad 或 good，注意到由于二者存在重复字母，所以可以将其合并：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">egrep -n <span class="hljs-string">&#x27;g(la|oo)d&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/81e75b954572c96f7b3920823bd83fab-0" alt="4-4-0"></p>
<h4 id="2-2-5-多个重复群组判别"><a href="#2-2-5-多个重复群组判别" class="headerlink" title="2.2.5 ()+ : 多个重复群组判别"></a>2.2.5 ()+ : 多个重复群组判别</h4><p>查找开头是 A 结尾是 C 中间有一个以上的’xyz’或’‘xz’字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;AxyzxyzxyzxyzC&#x27;</span>|egrep <span class="hljs-string">&#x27;A(xyz)+C&#x27;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;AxyzxyzxyzxyzC&#x27;</span>|egrep <span class="hljs-string">&#x27;A(xz)+C&#x27;</span><br></code></pre></td></tr></table></figure>

<p>结果显示 <code>A(xyz)+C</code> 可以匹配，<code>A(xz)+C</code> 没有匹配项。</p>
<p><img src="https://doc.shiyanlou.com/courses/2645/484222/b1477754080b8b69d4fa6c1c113db53b-0" alt="4-4-1"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h1><p>本节实验通过使用正则表达式和 sed 工具简单便捷地完成文件查询、修改等功能。</p>
<h2 id="实验知识点"><a href="#实验知识点" class="headerlink" title="实验知识点"></a>实验知识点</h2><ul>
<li>sed 工具</li>
<li>文件副本编辑</li>
</ul>
<h1 id="1、sed-简介"><a href="#1、sed-简介" class="headerlink" title="1、sed 简介"></a>1、sed 简介</h1><p>sed 是非交互式的编辑器。它不会修改文件，除非使用 shell 重定向来保存结果。默认情况下，所有的输出行都会被打印到屏幕上。</p>
<p>sed 编辑器逐行处理文件（或输入），并将结果打印到屏幕上。</p>
<p>具体过程如下：首先 sed 把当前正在处理的行保存在一个临时缓存区中（也称为模式空间），然后处理临时缓冲区中的行，完成后把该行发送到屏幕上。</p>
<p>sed 每处理完一行就将其从临时缓冲区删除，然后将下一行读入，进行处理和显示。处理完输入文件的最后一行后，sed 便结束运行。sed 把每一行都存在临时缓冲区中，对这个副本进行编辑，所以**不会修改原文件。 **</p>
<p>如果要修改原文件，可使用-i 选项。</p>
<h1 id="2、输出文件内容"><a href="#2、输出文件内容" class="headerlink" title="2、输出文件内容"></a>2、输出文件内容</h1><p>将 regular_express.txt 的内容列出并打印行号，并将 2-5 行删除显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nl regular_express.txt | sed <span class="hljs-string">&#x27;2,5d&#x27;</span><br></code></pre></td></tr></table></figure>

<p>‘2,5d’ 表示删除 2~5 行，d 即为 delete。</p>
<p><img src="https://doc.shiyanlou.com/courses/2645/484222/12e6d541fb40ce03818dcdefa9bb8a98-0" alt="3-3-0"></p>
<p>同理，删除第 2 行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nl regular_express.txt | sed <span class="hljs-string">&#x27;2d&#x27;</span><br></code></pre></td></tr></table></figure>

<p>删除第三行到最后一行, $表示定位到最后一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nl regular_express.txt | sed <span class="hljs-string">&#x27;3,$d&#x27;</span><br></code></pre></td></tr></table></figure>

<p>使用-i 在原文件中删除第 1 行：（注意：该指令会修改原文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&#x27;1d&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<h1 id="3、使用a和i新增输出"><a href="#3、使用a和i新增输出" class="headerlink" title="3、使用a和i新增输出"></a>3、使用a和i新增输出</h1><p>在第二行后添加字符串 test：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nl regular_express.txt | sed <span class="hljs-string">&#x27;2a test&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/9d9a30c17134de206471f46848cdb521-0" alt="3-4-0"></p>
<p>在第二行前添加字符串 test：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nl regular_express.txt | sed <span class="hljs-string">&#x27;2i test&#x27;</span><br></code></pre></td></tr></table></figure>

<p>在第二行后添加两行 test，“\n”表示换行符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nl regular_express.txt | sed <span class="hljs-string">&#x27;2a    test\ntest&#x27;</span><br></code></pre></td></tr></table></figure>

<h1 id="4、行内容替换"><a href="#4、行内容替换" class="headerlink" title="4、行内容替换"></a>4、行内容替换</h1><p>将 2-5 行的内容替换为 No 2-5 number，c 为替换内容选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nl regular_express.txt | sed <span class="hljs-string">&#x27;2,5c No 2-5 number&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/0f4cf032bf85c3132cd9eef8010209bc-0" alt="3-5-0"></p>
<h1 id="5、输出指定行"><a href="#5、输出指定行" class="headerlink" title="5、输出指定行"></a>5、输出指定行</h1><p>输出 regular_express.txt 的第 5-7 行，其中-n 为安静模式选项，我们在前面的章节中已经介绍过。</p>
<p>执行以下两条命令可以明显看出区别：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nl regular_express.txt |sed -n <span class="hljs-string">&#x27;5,7p&#x27;</span><br><br>nl regular_express.txt |sed  <span class="hljs-string">&#x27;5,7p&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/c08e483588e2a018a3a527f65ff8e952-0" alt="3-6-0"></p>
<h1 id="6、字符串替换"><a href="#6、字符串替换" class="headerlink" title="6、字符串替换"></a>6、字符串替换</h1><p>格式为：<code>sed &#39;s/被替换字符串/新字符串/g&#39;</code></p>
<p>来看一个实例。首先查看本机 IP 地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/sbin/ifconfig eth0<br></code></pre></td></tr></table></figure>

<p>字段 <code>inet 地址：192.168.x.x</code> 即为本机的 IP 地址，这是经由 NAT 转换后分配的内网 IP 地址，在此不做展开。若想进一步学习计算机网络的相关知识可以参阅 <a href="https://www.lanqiao.cn/courses/98">TCP/IP 网络协议基础入门</a>。</p>
<p>之后使用 grep 指令在/sbin/ifconfig eth0 的结果中查找‘inet’，并打印至终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/sbin/ifconfig eth0 |grep <span class="hljs-string">&#x27;inet &#x27;</span><br></code></pre></td></tr></table></figure>

<p>可以使用字符串替换功能将 IP 前面的部分予以删除，按照思路，也就是将 <code>inet 地址:</code> 替换为空字符串，可以简单写成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/sbin/ifconfig eth0 |grep <span class="hljs-string">&#x27;inet &#x27;</span>|sed <span class="hljs-string">&#x27;s/inet 地址://g&#x27;</span><br></code></pre></td></tr></table></figure>

<p>（注意中文字符不能直接复制，需要自己在终端输入）</p>
<p>但正则表达式在实际应用中可以非常灵活，回想一下我们在前两节所学的关于正则表达式的知识（忘了也不要紧，可以随时返回查看）。</p>
<p>. 表示任意一个字符，* 表示重复字符，{ } 表示限定连续字符范围，则表达式可以写成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/sbin/ifconfig eth0 |grep <span class="hljs-string">&#x27;inet &#x27;</span>| sed <span class="hljs-string">&#x27;s/.inet...://g&#x27;</span><br>或者<br>/sbin/ifconfig eth0 |grep <span class="hljs-string">&#x27;inet &#x27;</span>| sed <span class="hljs-string">&#x27;s/.\&#123;0,9\&#125;://&#x27;</span><br></code></pre></td></tr></table></figure>

<p>表达式的写法并不唯一，在此也并未全部列出，大家亦可自行尝试使用其他写法，欢迎在评论区中讨论。</p>
<p>将 IP 后面的部分删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/sbin/ifconfig eth0 |grep <span class="hljs-string">&#x27;inet &#x27;</span>| sed <span class="hljs-string">&#x27;s/.inet...://g&#x27;</span>| sed <span class="hljs-string">&#x27;s/..:.*$//g&#x27;</span><br><br>/sbin/ifconfig eth0 |grep <span class="hljs-string">&#x27;inet &#x27;</span>| sed <span class="hljs-string">&#x27;s/.inet...://g&#x27;</span>| sed <span class="hljs-string">&#x27;s/.\&#123;0,3\&#125;:.*$//g&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/086dfb0ba5bc4c1c6fc9016d5ec75508-0" alt="3-7-0"></p>
<p>上述指令是比较复杂的正则表达式运用，熟悉正则表达式后可以明显地简化指令，简单便捷地完成文件的查询、修改等任务。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h1><p>本节实验将介绍通过 grep 命令使用正则表达式。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>grep 命令</li>
<li>字符组匹配</li>
<li>行首行尾符</li>
<li>任意和重复字符</li>
<li>限定连续字符范围</li>
</ul>
<h1 id="1、查找特定字符串"><a href="#1、查找特定字符串" class="headerlink" title="1、查找特定字符串"></a>1、查找特定字符串</h1><p><strong>参数说明：</strong></p>
<ul>
<li>-a ：以 text 档案的方式搜寻 binary 档案数据</li>
<li>-c ：计算找到 ‘搜寻字符串’ 的次数</li>
<li>-i ：忽略大小写的不同，所以大小写视为相同</li>
<li>-n ：顺便输出行号</li>
<li>-v ：反向选择，亦即显示没有 ‘搜寻字符串’ 内容的行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;the&#x27;</span> regular_express.txt<br><br>grep -<span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;the&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/3e68cd05b043d405869a7317b565ef5e-0" alt="2-1-0"></p>
<p>反向查找，当该行没有字符串’the’时才显示在屏幕上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -vn <span class="hljs-string">&#x27;the&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/10c0bc8b908bf88885c903ac44d74883-0" alt="2-1-1"></p>
<h1 id="2、字符组匹配"><a href="#2、字符组匹配" class="headerlink" title="2、字符组匹配"></a>2、字符组匹配</h1><p>[ ]可以用来查找字符组。 值得注意的是，无论[ ]中包含多少个字符，它都只代表一个字符。比如说，我们想要查找”tast”或者”test”这两个字符串，注意到二者的拼写大部分相同，都是 t?st 的形式，故此时可以使用[ ]进行查找：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;t[ae]st&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/c3e6f9986267e65e6936f2e4adf7e2f4-0" alt="2-2-0"></p>
<p>字符组支持使用连字符“ - ”来表示一个范围。当“ - ”前后构成范围时，要求前面字符的码位小于后面字符的码位。</p>
<p>[^] 为反向选择字符组，用于排除后面的字符，使用方式为[^需要反向选择的字符]。</p>
<p>需要注意 [^] 与参数 -v 的区别，尽管二者都表示反向选择，但是如果包含有反向选择的字符的行含有其他字符的话， [^] 仍会输出该行，而 -v 则只会输出不含有反向选择的字符的行。</p>
<p>下面给出一些应用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[abc]           ：表示“a”或“b”或“c”<br>[0-9]           ：表示 0~9 中任意一个数字，等价于[0123456789]<br>[\u4e00-\u9fa5] :表示任意一个汉字<br>[^a1&lt;]          :表示除“a”、“1”、“&lt;”外的其它任意一个字符<br>[^a-z]          :表示除小写字母外的任意一个字符<br></code></pre></td></tr></table></figure>

<p>使用 - 和 [^] 查找“Xoo”形式的字符串，要求“oo”之前不能包含小写字母：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;[^a-z]oo&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>回忆前一节所提到的正则表达式特殊符号，[:lower:]表示小写字母，因此也可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;[^[:lower:]]oo&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/388c1a04e780c1eba339a1c7697626b4-0" alt="2-2-1"></p>
<p>这两者是等价的，但是可以看出，使用[a-z]来表示小写字母明显更加便捷，也更加灵活。</p>
<p>查找字符”oog”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;oog&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>如果我不想要“oog”字符前面有 g，则使用“[^g]oog”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;[^g]oog&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>同理，若不想让字符“oog”前面为 g 或者 o，则使用“[^go]oog”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;[^go]oog&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/34662d9e5e1f8efa74f0c8e424a7866b-0" alt="2-2-2"></p>
<p>其中，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;[^go]oog&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>返回结果为空，表示没有匹配到符合要求的字符串。</p>
<h1 id="3、行首符-与行尾符"><a href="#3、行首符-与行尾符" class="headerlink" title="3、行首符 ^ 与行尾符 $"></a>3、行首符 ^ 与行尾符 $</h1><p>在第一个实验中，我们使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;the&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>查找含有“the”的字符串，如果你只想查找行首为“the”的字符行，则使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;^the&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>查找行首为大写字母的所有行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;^[A-Z]&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>注意行首符 ^ 和反向选择 [^] 的区别，’^[A-Z]’ 表示以大写字母开头。’[^a-z]’ 表示除了大写字母 A-Z 的所有字符。</p>
<p>行尾符 $ 的用法与行首符类似。</p>
<p>查找以字母 d 结尾的行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;d$&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>这里有一个小技巧，将行首符与行尾符连用，可以用来查找空行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;^$&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<h2 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h2><p>查看/etc/insserv.conf 文档</p>
<p>‘^$’ : 过滤掉空白行</p>
<p>‘^#’ ：过滤掉注释行（以#号开头）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cat -n /etc/insserv.conf<br><br>grep -v <span class="hljs-string">&#x27;^$&#x27;</span> /etc/insserv.conf | grep -v <span class="hljs-string">&#x27;^#&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/8900443b487ed3282ef97ef8e1e5eb81-0" alt="2-2-3"></p>
<h1 id="4、任意一个字符-与重复字符"><a href="#4、任意一个字符-与重复字符" class="headerlink" title="4、任意一个字符 . 与重复字符 *"></a>4、任意一个字符 . 与重复字符 *</h1><p>查找 a?ou? 类型的字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;a.ou.&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>其中小数点表示任意一个字符，一个小数点只能表示一个未知字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">*（星号）：代表重复前面 0 个或者多个字符。<br>e*： 表示具有空字符或者一个以上 e 字符。<br>ee*，表示前面的第一个 e 字符必须存在。第二个 e 则可以是 0 个或者多个 e 字符。<br>eee*，表示前面两个 e 字符必须存在。第三个 e 则可以是 0 个或者多个 e 字符。<br>ee*e ：表示前面的第一个与第三个 e 字符必须存在。第二个 e 则可以是 0 个或者多个 e 字符。<br></code></pre></td></tr></table></figure>

<p>下面的第一条命令与第二条命令由于允许存在空字符，所以会打印所有文本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;e*&#x27;</span> regular_express.txt<br><br>grep -n <span class="hljs-string">&#x27;@*&#x27;</span> regular_express.txt<br><br>grep -n <span class="hljs-string">&#x27;eee*&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<h1 id="5、限定连续字符范围"><a href="#5、限定连续字符范围" class="headerlink" title="5、限定连续字符范围 { }"></a>5、限定连续字符范围 { }</h1><p>{ }可限制一个范围区间内的重复字符数。如果现在要求找出存在连续的两个 o 字符的字符串，根据前面所学的知识，我们可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;ooo*&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>另一种方式是使用 { }。由于 { 与 } 在 shell 中有特殊意义，故在使用时需要用到转义字符\。</p>
<p>查找连续的两个 o 字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;o\&#123;2\&#125;&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p>查找 g 后面接 2 到 5 个 o，然后再接 g 的字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;go\&#123;2,5\&#125;g&#x27;</span> regular_express.txt<br>总结：<br>^word    表示带搜寻的字符串(word)在行首<br>word$    表示带搜寻的字符串(word)在行尾<br>.(小数点) 表示 1 个任意字符<br>\        表示转义字符，在特殊字符前加\会将特殊字符意义去除<br>*        表示重复 0 到无穷多个前一个 RE(正则表达式)字符<br>[list]   表示搜索含有 l,i,s,t 任意字符的字符串<br>[n1-n2]  表示搜索指定的字符串范围,例如[0-9] [a-z] [A-Z]等<br>[^list]  表示反向字符串的范围,例如[^0-9]表示非数字字符，[^A-Z]表示非大写字符范围<br>\&#123;n,m\&#125;  表示找出 n 到 m 个前一个 RE 字符<br>\&#123;n,\&#125;   表示 n 个以上的前一个 RE 字符<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#生成运行文件</span><br>g++ helloworld.cpp -o helloworld<br><br><span class="hljs-comment">#执行生成的文件（helloworld）</span><br>./helloworld<br></code></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>窗口显示在顶层</title>
    <url>/posts/79fd161.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="窗口显示在顶层"><a href="#窗口显示在顶层" class="headerlink" title="窗口显示在顶层"></a>窗口显示在顶层</h1><span id="more"></span>

<p>代码比较简单:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//保持在最前</span><br>w.<span class="hljs-built_in">setWindowFlags</span>(w.<span class="hljs-built_in">windowFlags</span>() | Qt::WindowStaysOnTopHint);<br>w.<span class="hljs-built_in">show</span>();<br><span class="hljs-comment">//仅仅显示在最前1次(点击主窗体时主窗体回到最前)</span><br>w.<span class="hljs-built_in">raise</span>();<br></code></pre></td></tr></table></figure>

<p>效果:</p>
<img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gjvtv30yzgj30ho06hq2x.jpg" alt="Qt窗口布局1" width="636" data-width="636" data-height="233">

<h1 id="任意拖动窗口位置"><a href="#任意拖动窗口位置" class="headerlink" title="任意拖动窗口位置"></a>任意拖动窗口位置</h1><blockquote>
<p>重写mouseEvent事件</p>
</blockquote>
<p>在Qt程序中，当==<code>隐藏掉窗体的标题栏</code>==之后，如果不重写鼠标移动事件，我们是无法通过鼠标任意拖拽窗体的。<br>下面收藏了两个重写的方法，只要在程序里添加鼠标事件，并重写即可。<br>方法一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">void Widget::mousePressEvent(QMouseEvent *event)<br>&#123;<br>    bPressFlag &#x3D; true;<br>    beginDrag &#x3D; event-&gt;pos();<br>    QWidget::mousePressEvent(event);<br>&#125;<br><br>void Widget::mouseReleaseEvent(QMouseEvent *event)<br>&#123;<br>    bPressFlag &#x3D; false;<br>    QWidget::mouseReleaseEvent(event);<br>&#125;<br><br>void Widget::mouseMoveEvent(QMouseEvent *event)<br>&#123;<br>    if(bPressFlag)<br>    &#123;<br>        QPoint relaPos(QCursor::pos() - beginDrag);<br>        move(relaPos);<br>    &#125;<br>    QWidget::mouseMoveEvent(event);<br>&#125;<br>其中，bPressFlag是布尔型成员变量,beginDrag是QPoint型成员变量.1234567891011121314151617181920212223<br></code></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">void Widget::mousePressEvent(QMouseEvent *e)<br>&#123;<br>    if(e-&gt;button() &#x3D;&#x3D; Qt::LeftButton)<br>    &#123;<br>        isDrag &#x3D; true;<br>        m_position &#x3D; e-&gt;globalPos() - this-&gt;pos();<br>        e-&gt;accept();<br>    &#125;<br>&#125;<br><br>void Widget::mouseMoveEvent(QMouseEvent *e)<br>&#123;<br>    if(isDrag &amp;&amp; (e-&gt;buttons() &amp;&amp; Qt::LeftButton))<br>    &#123;<br>        move(e-&gt;globalPos() - m_position);<br>        e-&gt;accept();<br>    &#125;<br>&#125;<br><br>void Widget::mouseReleaseEvent(QMouseEvent *)<br>&#123;<br>    isDrag &#x3D; false;<br>&#125;<br><br>其中，isDrag 是布尔型成员变量,m_position是QPoint型成员变量.12345678910111213141516171819202122232425<br></code></pre></td></tr></table></figure>

<p>我们知道设置无标题栏窗体的代码是:<br>setWindowFlags(Qt::FramelessWindowHint);<br>但是这样会出现一个问题，当我们在电脑的状态栏点击程序图标时，如果它原本在最前端那么隐藏掉，如果隐藏了则显示出来，大部分的程序都是这样的。但是，按照上面的那代码是有时候有效果，有时候没有。所以这条代码应该是这样:<br>setWindowFlags(Qt::FramelessWindowHint|Qt::WindowMinimizeButtonHint);</p>
<h1 id="QLcdNumber显示时间"><a href="#QLcdNumber显示时间" class="headerlink" title="QLcdNumber显示时间"></a>QLcdNumber显示时间</h1><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">	<span class="hljs-comment">//设置定时器并绑定，然后启动</span><br>	QTimer *timer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QTimer</span>(<span class="hljs-keyword">this</span>);       <span class="hljs-comment">//新建一个定时器对象</span><br>    <span class="hljs-built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="hljs-keyword">this</span>, &amp;Dialog::showTime);   <span class="hljs-comment">//(d)</span><br>	timer-&gt;<span class="hljs-built_in">start</span>(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	QTime time = QTime::currentTime();</span><br><span class="hljs-comment">	QString text=time.toString(&quot;hh:mm:ss&quot;);</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dialog::showTime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QTime time=QTime::<span class="hljs-built_in">currentTime</span>();<br>    QString text=time.<span class="hljs-built_in">toString</span>(<span class="hljs-string">&quot;hh:mm:ss&quot;</span>);<br>    <span class="hljs-built_in">display</span>(text);<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h1 id="Qt鼠标事件"><a href="#Qt鼠标事件" class="headerlink" title="Qt鼠标事件"></a>Qt鼠标事件</h1><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PushButton::leaveEvent</span><span class="hljs-params">(QEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>	nStart = btnNomal;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PushButton::enterEvent</span><span class="hljs-params">(QEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>	nStart = btnHover;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PushButton::onClicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	nStart = btnPressed;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>本文结束~</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>窗口布局</tag>
      </tags>
  </entry>
  <entry>
    <title>算法——查找算法</title>
    <url>/posts/f43b98cb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哈希、红黑树、B+树、二叉树、平衡算法</p>
<span id="more"></span>

<h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><p><img src="../../../../images/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/image-20200813082005539-16381534443523.png"></p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找一定是有序的：target ? (left+right)/2</p>
<p>如果说二分查找转换成数据结构展示—-&gt;==二叉树—&gt;二叉查找树、二叉搜索树==</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h5 id="1-时间复杂度："><a href="#1-时间复杂度：" class="headerlink" title="1. 时间复杂度："></a>1. 时间复杂度：</h5><p>二分：log(n)</p>
<h2 id="AVL树：平衡二叉树"><a href="#AVL树：平衡二叉树" class="headerlink" title="AVL树：平衡二叉树"></a>AVL树：平衡二叉树</h2><h2 id="红黑树（特殊的二叉查找树）"><a href="#红黑树（特殊的二叉查找树）" class="headerlink" title="红黑树（特殊的二叉查找树）"></a><a href="E:\hexo\source_drafts\数据结构\红黑树.md">红黑树（特殊的二叉查找树）</a></h2><div class="note orange icon flat"><i class="note-icon fa fa-battery-quarter"></i><p>这篇文章还在编辑中······</p>
</div>

<p>本文结束！</p>
]]></content>
      <categories>
        <category>程序员内功</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据架构层"><a href="#数据架构层" class="headerlink" title="数据架构层"></a><strong>数据架构层</strong></h1><p>==如果你未来是一个架构师，没有什么是加一层解决不了的！==</p>
<blockquote>
<h1 id="1-商品的基本信息"><a href="#1-商品的基本信息" class="headerlink" title="1.商品的基本信息"></a>1.商品的基本信息</h1><p>​    王坚：推荐文章：==阿里云的这群疯子==-40分钟重要！</p>
<h1 id="2-商品的描述、评论"><a href="#2-商品的描述、评论" class="headerlink" title="2.商品的描述、评论"></a>2.商品的描述、评论</h1><p>​    文档型数据库，mongoDB</p>
<h1 id="3-图片"><a href="#3-图片" class="headerlink" title="3. 图片"></a>3. 图片</h1><p>​    分布式文件系统 FastDFS</p>
<ul>
<li>淘宝自己的 TFS</li>
<li>Google 的 GFS</li>
<li>Hadoop HDFS</li>
<li>阿里云的 oss</li>
</ul>
<h1 id="4-商品的关键字（搜索）"><a href="#4-商品的关键字（搜索）" class="headerlink" title="4.商品的关键字（搜索）"></a>4.商品的关键字（搜索）</h1><ul>
<li>搜索引擎 solr elasticsearch</li>
<li>ISerach：多隆</li>
</ul>
<p>所有牛逼的人都有一段苦逼的岁月！</p>
<h1 id="5-热门的波段信息"><a href="#5-热门的波段信息" class="headerlink" title="5.热门的波段信息"></a>5.热门的波段信息</h1><ul>
<li>内存数据库</li>
<li>redis   tair   、Memache</li>
</ul>
<h1 id="6-商品的交易，外部的支付借口"><a href="#6-商品的交易，外部的支付借口" class="headerlink" title="6. 商品的交易，外部的支付借口"></a>6. 商品的交易，外部的支付借口</h1><ul>
<li>三方应用</li>
</ul>
</blockquote>
<h2 id="大型互联网应用问题："><a href="#大型互联网应用问题：" class="headerlink" title="大型互联网应用问题："></a>大型互联网应用问题：</h2><ul>
<li>数据类型太多了</li>
<li>数据源繁多，经常重构</li>
<li>数据要改造，大面积改革</li>
</ul>
<p><img src="../../../../images/%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E5%B1%82/image-20200725191300403.png" alt="image-20200725191300403"></p>
<p>$\ LaTeX$</p>
<p><code>f = \frac&#123;2 \pi&#125;&#123;T&#125;$</code>.</p>
<p>算大</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs Markdown">$\ce&#123;CH4 + 2 $\left( \ce&#123;O2 + 79/21 N2&#125; \right)$&#125;$<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><blockquote>
<p>3V+3高</p>
</blockquote>
<h4 id="大数据时代的3V：主是描述问题的"><a href="#大数据时代的3V：主是描述问题的" class="headerlink" title="大数据时代的3V：主是描述问题的"></a>大数据时代的3V：主是描述问题的</h4><ol>
<li>海量volume</li>
<li>多样variety</li>
<li>实时velocity</li>
</ol>
<h4 id="大数据时代的3高：主要是面向程序的"><a href="#大数据时代的3高：主要是面向程序的" class="headerlink" title="大数据时代的3高：主要是面向程序的"></a>大数据时代的3高：主要是面向程序的</h4><ol>
<li><p>高并发</p>
<ol start="2">
<li>高扩展</li>
<li>高性能</li>
</ol>
</li>
</ol>
<p>de1</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NoSQL的四大分类"><a href="#NoSQL的四大分类" class="headerlink" title="NoSQL的四大分类"></a>NoSQL的四大分类</h1><h2 id="KV键值对："><a href="#KV键值对：" class="headerlink" title="KV键值对："></a>KV键值对：</h2><pre><code>- 新浪：Redis
- 美团：Redis + Tair
- 阿里、百度：Redis + memecache
</code></pre>
<h2 id="文档型数据库（bson格式和json一样）："><a href="#文档型数据库（bson格式和json一样）：" class="headerlink" title="文档型数据库（bson格式和json一样）："></a>文档型数据库（bson格式和json一样）：</h2><ul>
<li>MongoDB（一般必须要掌握）<ul>
<li>MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档！</li>
<li>MongoDB是一个介于关系型数据库和非关系型数据库中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的</li>
<li>ConthDB</li>
</ul>
</li>
<li>列存数据库<ul>
<li>HBase</li>
<li>分布式文件系统</li>
</ul>
</li>
<li>图关系数据库</li>
</ul>
<p><img src="../../../../images/NoSQL%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%88%86%E7%B1%BB/image-20200725192835745.png" alt="image-20200725192835745"></p>
]]></content>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/posts/2f57a694.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><font colo="rgb(0,255,0)" face="华文彩云">正则表达式</font></h1><h2 id="正则表达式特殊符号"><a href="#正则表达式特殊符号" class="headerlink" title="正则表达式特殊符号"></a>正则表达式特殊符号</h2><p>首先是正则表达式的特殊符号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[:alnum:]代表英文大小写字母及数字<br>[:alpha:]代表英文大小写字母<br>[:blank:]代表空格和 tab 键<br>[:cntrl:]键盘上的控制按键，如 CR,LF,TAB,DEL<br>[:digit:]代表数字<br>[:graph:]代表空白字符以外的其他<br>[:lower:]小写字母<br>[:print:]可以被打印出来的任何字符<br>[:punct:]代表标点符号<br>[:upper:]代表大写字母<br>[:space:]任何会产生空白的字符如空格，tab,CR 等<br>[:xdigit:]代表 16 进位的数字类型<br></code></pre></td></tr></table></figure>

<h4 id="特殊符号实例"><a href="#特殊符号实例" class="headerlink" title="特殊符号实例"></a>特殊符号实例</h4><p>在 WebIDE 中使用 touch 命令或图形界面新建一个 .txt 文件并将下文中的文本内容复制进去。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">touch regular_express.txt<br></code></pre></td></tr></table></figure>

<p>也可以使用 wget 指令从本节开头的实验环境说明处下载，这两种方式取得的文件是一样的。</p>
<p>文本内容为：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><code class="hljs md">&quot;Open Source&quot; is a good mechanism to develop programs.<br>apple is my favorite food.<br>Football game is not use feet only.<br>this dress doesn&#x27;t fit me.<br>However, this dress is about \$ 3183 dollars.<br>GNU is free air not free beer.<br>Her hair is very beauty.<br>I can&#x27;t finish the test.<br>Oh! The soup taste good.<br>motorcycle is cheap than car.<br>This window is clear.<br>the symbol &#x27;\<span class="hljs-emphasis">*&#x27; is represented as start.</span><br><span class="hljs-emphasis">Oh!My god!</span><br><span class="hljs-emphasis">The gd software is a library for drafting programs.</span><br><span class="hljs-emphasis">You are the best is mean you are the no. 1.</span><br><span class="hljs-emphasis">The world <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Happy</span>&gt;</span></span> is the same with &quot;glad&quot;.</span><br><span class="hljs-emphasis">I like dog.</span><br><span class="hljs-emphasis">google is the best tools for search keyword.</span><br><span class="hljs-emphasis">goooooogle yes!</span><br><span class="hljs-emphasis">go! go! Let&#x27;s go.</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"># I am VBird</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/e79dc5fe8e3eb3bc8aca398276fa171a-0" alt="1-2-0"></p>
<p>使用特殊符号查找小写字母：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;[[:lower:]]&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p><strong>红色为匹配成功的字符</strong></p>
<p><img src="https://doc.shiyanlou.com/courses/2645/484222/7bc47bed26ed64b39ec88829508263a3-0" alt="1-2-1"></p>
<p>使用特殊符号查找数字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&#x27;[[:digit:]]&#x27;</span> regular_express.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/2645/484222/60895d8256708d16d14f360965740324-0" alt="1-2-2"></p>
<h2 id="语系对正则表达式的影响"><a href="#语系对正则表达式的影响" class="headerlink" title="语系对正则表达式的影响"></a>语系对正则表达式的影响</h2><p>我们知道，计算机可以直接处理的文件中只有 0 和 1，我们看到的字符文字和数字都是通过编码表转换而来的。不同语系的编码不同会导致不同语系的数据选取结果有所差异。 以英文大小写为例，zh_CN.big5 及 C 这两种语系差异如下：</p>
<ul>
<li>LANG=C 时： 0 1 2 3 4….A B C D E…Z a b c d e…z</li>
<li>LANG=zh_CN.big5 时：0 1 2 3 4…a A b B c C d D…..z Z</li>
</ul>
<p>在使用正则表达式[A-Z]时， LANG=C 的情况下，找到的是大写字符 A B C D…Z。而在 LANG=zh_CN.big5 的情况下，会选取到 A b B c C d D…z Z。所以在使用正则表达式时要特别留意语系。</p>
<p>由于我们一般使用的是兼容于 POSIX 的标准，因此建议使用 C 语系。</p>
<p>需要说明的是，我们实验环境使用的 WebIDE 的默认语系 zh_CN.UTF-8 并没有该编码问题，可以直接使用。</p>
<p>可以使用 <code>echo $LANG</code> 指令查看当前语系。</p>
]]></content>
      <tags>
        <tag>拓展知识</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习记录-Vim</title>
    <url>/posts/6d2dfa59.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vim常规命令</p>
<span id="more"></span>

<h6 id><a href="#" class="headerlink" title></a><img src="../../../images/Vim/vim.png"></h6><h2 id="二-删除-移动"><a href="#二-删除-移动" class="headerlink" title="二 删除|移动"></a>二 删除|移动</h2><p><img src="../../../images/Vim/20200812140608611.png"></p>
<ol>
<li>撤销 u</li>
<li>粘贴 p</li>
<li>重做 CRTL+R</li>
<li>插入文本 A</li>
<li>插入 i</li>
<li>删除 d</li>
<li>替换 r</li>
<li>替换插入 cw</li>
<li>删除后半部分插入 c$</li>
<li>括号匹配  % （移动到括号上再输入%）</li>
<li> 查找字符串 /： 向前查 ？：向后查</li>
<li></li>
</ol>
<h2 id="三-更改类操作符"><a href="#三-更改类操作符" class="headerlink" title="三 更改类操作符"></a>三 更改类操作符</h2><p><img src="../../../images/Vim/20200812144221541.png" alt="更改类操作总结"></p>
<h2 id="四-查找-替换-匹配"><a href="#四-查找-替换-匹配" class="headerlink" title="四 查找|替换|匹配"></a>四 查找|替换|匹配</h2><p><img src="../../../images/Vim/20200812144023800.png"></p>
<h2 id="五-外部命令"><a href="#五-外部命令" class="headerlink" title="五 外部命令"></a>五 外部命令</h2><p><img src="../../../images/Vim/20200812145646832.png"></p>
<h2 id="六-查找-插入-复制-粘贴-替换"><a href="#六-查找-插入-复制-粘贴-替换" class="headerlink" title="六 查找|插入|复制|粘贴|替换"></a>六 查找|插入|复制|粘贴|替换</h2><p><img src="../../../images/Vim/20200812151045457.png"></p>
<h2 id="七-帮助-自动补全"><a href="#七-帮助-自动补全" class="headerlink" title="七 帮助|自动补全"></a>七 帮助|自动补全</h2><p><img src="../../../images/Vim/20200812161242116.png"></p>
]]></content>
      <categories>
        <category>Linux学习笔记</category>
        <category>Linux</category>
        <category>实验楼</category>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Bash</title>
    <url>/posts/dae6345.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="bash学习记录——实验楼"><a href="#bash学习记录——实验楼" class="headerlink" title="bash学习记录——实验楼"></a>bash学习记录——实验楼</h1><span id="more"></span>

<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Bash(GNU Bourne-Again Shell )是一个为GNU计划编写的Unix shell，它是许多Linux平台默认使用的shell。</p>
<p>shell是一个命令解释器，是一个介于操作系统内核与用户之间的绝缘层。准确地说，他也是能力很强的计算机语言，被称为解释性语言或脚本语言。它可以通过将系统调用、公共程序、工具和编译过的二进制程序“粘合”在一起来建立应用，这是大多数脚本语言的共同特征，所以有时候脚本语言又称为“胶水语言”。</p>
<p>事实上，所有的UNIX命令和工具再加上公共程序，对于shell脚本来说，都是可调用的。Shell脚本对于管理系统任务和其他的重复工作的例程来说，表现得非常好，根本不需要那些华而不实的成熟紧凑的编译型程序语言。</p>
<h2 id="2-初步练习"><a href="#2-初步练习" class="headerlink" title="2. 初步练习"></a>2. 初步练习</h2><h3 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1.Hello World"></a>1.Hello World</h3><p>行首以 <code>#</code> 开头(除#!之外)的是注释。<code>#!</code>是用于指定当前脚本的解释器，我们这里为bash，且应该指明完整路径，所以为<code>/bin/bash</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vim hello.sh <span class="hljs-comment">#使用vim编辑hello.sh</span><br><span class="hljs-built_in">echo</span> Hello World <span class="hljs-comment">#向文件中输入以下内容</span><br><span class="hljs-comment"># 运行Bash脚本的方式</span><br><span class="hljs-comment"># 1 使用shell来执行</span><br>$ sh hello.sh<br><span class="hljs-comment"># 2 使用bash来执行</span><br>$ bash hello.sh<br><span class="hljs-comment"># 3 使用.来执行</span><br>$ . ./hello.sh<br><span class="hljs-comment"># 4 使用source来执行</span><br>$ <span class="hljs-built_in">source</span> hello.sh<br><span class="hljs-comment"># 5 还可以赋予脚本所有者执行权限，允许用户执行该脚本</span><br>$ chmod u+rx hello.sh <br>$ ./hello.sh<br></code></pre></td></tr></table></figure>

<h3 id="2-使用重定向"><a href="#2-使用重定向" class="headerlink" title="2. 使用重定向"></a>2. 使用重定向</h3><p>比如我们想要<strong>保存</strong>刚刚的hello world为一个文本，那么该怎么办呢？</p>
<p>==&gt;==是重定向，会在当前目录下生成一个my.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span> &gt; my.txt<br>$ cat my.txt<br><span class="hljs-comment"># 输出Hello World</span><br></code></pre></td></tr></table></figure>

<h3 id="3-使用脚本清除-var-log-wtmp-里边的东西"><a href="#3-使用脚本清除-var-log-wtmp-里边的东西" class="headerlink" title="3. 使用脚本清除**/var/log/wtmp**里边的东西"></a>3. 使用脚本清除**/var/log/wtmp**里边的东西</h3><blockquote>
<p>说白了就是在脚本文件中写入命令，然后在外部使用bash命令调用sh文件（实验内容为编写cleanlogs.sh文件，然后使用命令调用该文件）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先查看wtmp文件中是否有东西</span><br>cat /var/<span class="hljs-built_in">log</span>/wtmp<br><br><span class="hljs-comment"># 使用vim编辑 cleanlogs.sh</span><br><br><span class="hljs-comment">######################################</span><br><span class="hljs-comment">####以下内容为cleanlogs.sh文件内容####</span><br><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 初始化一个变量</span><br>LOG_DIR=/var/<span class="hljs-built_in">log</span><br><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$LOG_DIR</span><br><br>cat /dev/null &gt; wtmp<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Logs cleaned up.&quot;</span><br><br><span class="hljs-built_in">exit</span><br><span class="hljs-comment">######################################</span><br><br><br>sudo ./cleanlogs.sh<br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>由于脚本中含有对系统日志文件的清楚操作，这要求要有管理员权限.不然会报**<code>permission denied</code>**错误</li>
</ul>
<p> 使用sudo命令调用<code>管理员权限</code>才能执行成功：</p>
<p> <strong>$ sudo ./cleanlogs.sh</strong></p>
<ul>
<li><p><strong>#!/bin/bash</strong><code>这一行是表示使用</code><strong>/bin/bash</strong><code>作为脚本的解释器，这行要放在脚本的行首并且不要省略</code></p>
</li>
<li><p>脚本正文中以**<code>#</code>**号开头的行都是注释语句，这些行在脚本的实际执行过程中不会被执行。这些注释语句能方便我们在脚本中做一些注释或标记，让脚本更具可读性。</p>
</li>
</ul>
</blockquote>
<blockquote>
<h4 id="1-遇到权限不够的提示，为什么，如何解决？"><a href="#1-遇到权限不够的提示，为什么，如何解决？" class="headerlink" title="1. 遇到权限不够的提示，为什么，如何解决？"></a>1. 遇到权限不够的提示，为什么，如何解决？</h4><p>权限不够加sudo啊，可是你会发现</p>
<p><code>sudo cat /dev/null &gt; /var/log/wtmp</code> 一样会提示权限不够，为什么呢？因为sudo只能让cat命令以sudo的权限执行，而对于<code>&gt;</code>这个符号并没有<code>sudo</code>的权限，我们可以使用</p>
<p><code>sudo sh -c &quot;cat /dev/null &gt; /var/log/wtmp &quot;</code> 让整个命令都具有sudo的权限执行</p>
<h4 id="2-为什么cleanlogs-sh可以将log文件清除？"><a href="#2-为什么cleanlogs-sh可以将log文件清除？" class="headerlink" title="2. 为什么cleanlogs.sh可以将log文件清除？"></a>2. 为什么cleanlogs.sh可以将log文件清除？</h4><p>因为<code>/dev/null</code> ，里面是空的，重定向到 /var/log/wtmp 文件后，就清空了 wtmp 文件的内容。</p>
</blockquote>
<h2 id="3-简单热身——新建-复制-修改-清楚"><a href="#3-简单热身——新建-复制-修改-清楚" class="headerlink" title="3. 简单热身——新建|复制|修改|清楚"></a>3. 简单热身——新建|复制|修改|清楚</h2><h3 id="1-步骤一-新建一个test-sh-输出Hello-Shiyanlou"><a href="#1-步骤一-新建一个test-sh-输出Hello-Shiyanlou" class="headerlink" title="1. 步骤一 新建一个test.sh 输出Hello Shiyanlou!"></a>1. <em><code>步骤一</code></em> 新建一个test.sh 输出Hello Shiyanlou!</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#题目未要求文件路劲 直接新建并输出</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello Shiyanlou!&quot;</span> &gt; test.sh<br><span class="hljs-comment">#或者</span><br>touch /home/shiyanlou/test.sh<br>cat &gt; /home/shiyanlou/test.sh &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">#!/bin/bash</span><br><span class="hljs-string">echo &quot;Hello Shiyanlou!&quot;</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure>

<h3 id="2-步骤二复制test-sh为test2-sh-修改test2-sh实验将Hello-Shiyanlou-保存为my-txt文本"><a href="#2-步骤二复制test-sh为test2-sh-修改test2-sh实验将Hello-Shiyanlou-保存为my-txt文本" class="headerlink" title="2. 步骤二复制test.sh为test2.sh,修改test2.sh实验将Hello Shiyanlou 保存为my.txt文本"></a>2. <code>步骤二</code>复制test.sh为test2.sh,修改test2.sh实验将Hello Shiyanlou 保存为my.txt文本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#复制语句</span><br>cp /home/shiyanlou/<span class="hljs-built_in">test</span>&#123;,2&#125;.sh<br><br><span class="hljs-comment">#修改test2.sh的代码为：</span><br><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello Shiyanlou!&quot;</span> &gt; my.txt<br></code></pre></td></tr></table></figure>

<h3 id="3-步骤三新建一个cleantest-sh脚本运行实现清空test-sh里的内容"><a href="#3-步骤三新建一个cleantest-sh脚本运行实现清空test-sh里的内容" class="headerlink" title="3. 步骤三新建一个cleantest.sh脚本运行实现清空test.sh里的内容"></a>3. <code>步骤三</code>新建一个cleantest.sh脚本运行实现清空test.sh里的内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ touch /home/shiyanlou/cleantest.sh<br>$ cat &gt; /home/shiyanlou/cleantest.sh &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">###cleantest.sh文件内容####</span><br><span class="hljs-string">#!/bin/bash</span><br><span class="hljs-string">cat /dev/null &gt; test.sh</span><br><span class="hljs-string">EOF</span><br><span class="hljs-comment">##########################</span><br></code></pre></td></tr></table></figure>

<h2 id="4-特殊字符"><a href="#4-特殊字符" class="headerlink" title="4. 特殊字符"></a>4. 特殊字符</h2><h3 id="1-注释（-）"><a href="#1-注释（-）" class="headerlink" title="1. 注释（#）"></a>1. 注释（#）</h3><p>行首以 <code>#</code> 开头(除#!之外)的是注释。<code>#!</code>是用于指定当前脚本的解释器，我们这里为bash，且应该指明完整路径，所以为<code>/bin/bash</code></p>
<p>当然，在echo中转义的 # 是不能作为注释的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个test.sh文件</span><br>$ vim test.sh<br><br><span class="hljs-comment">########test.sh##########</span><br><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The # here does not begin a comment.&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;The # here does not begin a comment.&#x27;</span><br><span class="hljs-built_in">echo</span> The \<span class="hljs-comment"># here does not begin a comment.</span><br><span class="hljs-built_in">echo</span> The <span class="hljs-comment"># 这里开始一个注释</span><br><span class="hljs-built_in">echo</span> $(( <span class="hljs-number">2#101011</span> ))     <span class="hljs-comment"># 数制转换（使用二进制表示），不是一个注释，双括号表示对于数字的处理</span><br><br><span class="hljs-comment"># 欢迎来到实验楼参观学习</span><br><span class="hljs-comment">#########################</span><br></code></pre></td></tr></table></figure>

<img src="http://qgqlbe4fd.hb-bkt.clouddn.com/image-20200815001059711.png" style="zoom:80%;">

<h3 id="2-分号（；）"><a href="#2-分号（；）" class="headerlink" title="2. 分号（；）"></a>2. 分号（；）</h3><h4 id="1-命令分隔符"><a href="#1-命令分隔符" class="headerlink" title="1. 命令分隔符"></a>1. 命令分隔符</h4><p>使用分号（;）可以在同一行上写两个或两个以上的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$vim</span> test2.sh<br><br><br><span class="hljs-comment">#  test2.sh   #</span><br><span class="hljs-meta">#!/bin/bash</span><br> <span class="hljs-built_in">echo</span> hello; <span class="hljs-built_in">echo</span> there<br> filename=ttt.sh<br> <span class="hljs-keyword">if</span> [ -e <span class="hljs-string">&quot;<span class="hljs-variable">$filename</span>&quot;</span> ]; <span class="hljs-keyword">then</span>    <span class="hljs-comment"># 注意: &quot;if&quot;和&quot;then&quot;需要分隔，-e用于判断文件是否存在</span><br>     <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File <span class="hljs-variable">$filename</span> exists.&quot;</span>; cp <span class="hljs-variable">$filename</span> <span class="hljs-variable">$filename</span>.bak<br> <span class="hljs-keyword">else</span><br>     <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File <span class="hljs-variable">$filename</span> not found.&quot;</span>; touch <span class="hljs-variable">$filename</span><br> <span class="hljs-keyword">fi</span>; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File test complete.&quot;</span><br> <br> <span class="hljs-comment">###############</span><br> <br> <br> <span class="hljs-comment">#执行文件</span><br> bash test2.sh  <span class="hljs-comment">#结果如下如所示↓</span><br></code></pre></td></tr></table></figure>

<p><img src="http://qgqlbe4fd.hb-bkt.clouddn.com/image-20200815001913808.png" alt="image-20200815001913808"></p>
<p>解释说明</p>
<p>上面脚本使用了一个if分支判断一个文件是否存在，如果文件存在打印相关信息并将该文件备份；如果不存在打印相关信息并创建一个新的文件。最后将输出”测试完成”。</p>
<h4 id="2-终止case选项（双分号）"><a href="#2-终止case选项（双分号）" class="headerlink" title="2. 终止case选项（双分号）"></a>2. 终止case选项（双分号）</h4><p>使用双分号（;;）可以终止case选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vim test3.sh<br><br><span class="hljs-comment">#  test3.sh  #</span><br>varnaem = b<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$varname</span>&quot;</span> <span class="hljs-keyword">in</span> <br>	[a-z]) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;abc&quot;</span>;;<br>	[0-9]) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;123&quot;</span>;;<br><span class="hljs-keyword">esac</span><br><span class="hljs-comment">#################</span><br><br><span class="hljs-comment">#执行脚本</span><br>bash test3.sh<br><span class="hljs-comment">#输出abc</span><br></code></pre></td></tr></table></figure>

<h3 id="3-点号（-）"><a href="#3-点号（-）" class="headerlink" title="3. 点号（.）"></a>3. 点号（.）</h3><p><strong>==等价于source命令==</strong></p>
<h3 id="4-引号"><a href="#4-引号" class="headerlink" title="4. 引号"></a>4. 引号</h3><h4 id="1-双引号"><a href="#1-双引号" class="headerlink" title="1. 双引号"></a>1. 双引号</h4><p>“STRING”将会阻止（解释）STRING中大部分特殊的字符</p>
<h4 id="2-单引号"><a href="#2-单引号" class="headerlink" title="2. 单引号"></a>2. 单引号</h4><p>‘STRING’将会阻止STRING中所有特殊字符的解释，这是一种比使用“更强烈的形式。</p>
<img src="https://dn-simplecloud.shiyanlou.com/87971506680766895" alt="2-4-1" style="zoom:50%;">

<p>同样是$HOME，单引号会直接认为是字符，而双引号会认为是一个变量</p>
<h3 id="5-斜线和反斜线"><a href="#5-斜线和反斜线" class="headerlink" title="5. 斜线和反斜线"></a>5. 斜线和反斜线</h3><h4 id="1-斜线（-——文件路径分隔符"><a href="#1-斜线（-——文件路径分隔符" class="headerlink" title="1. 斜线（/)——文件路径分隔符"></a>1. 斜线（/)——文件路径分隔符</h4><h4 id="2-反斜线（-）——转义符"><a href="#2-反斜线（-）——转义符" class="headerlink" title="2. 反斜线（\）——转义符"></a>2. 反斜线（\）——转义符</h4><ul>
<li>符号 说明</li>
<li>\n 表示新的一行</li>
<li>\r 表示回车</li>
<li>\t 表示水平制表符</li>
<li>\v 表示垂直制表符</li>
<li>\b 表示后退符</li>
<li>\a 表示”alert”(蜂鸣或者闪烁)</li>
<li>\0xx 转换为八进制的ASCII码, 等价于0xx</li>
<li>“ 表示引号字面的意思</li>
</ul>
<h3 id="6-反引号（-）"><a href="#6-反引号（-）" class="headerlink" title="6. 反引号（`）"></a>6. 反引号（`）</h3><p><strong>命令替换</strong></p>
<p>反引号中的命令会优先执行，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ cp `mkdir back` test.sh back<br>$ ls<br></code></pre></td></tr></table></figure>

<h3 id="7-冒号（：）"><a href="#7-冒号（：）" class="headerlink" title="7. 冒号（：）"></a>7. 冒号（：）</h3><h4 id="1-空命令"><a href="#1-空命令" class="headerlink" title="1. 空命令"></a>1. 空命令</h4><p>等价于“NOP”（no op ,一个什么也不干的命令）。也可以被认为与shell的内建命令==true==作用相同</p>
<h4 id="2-变量扩展-子串替换"><a href="#2-变量扩展-子串替换" class="headerlink" title="2. 变量扩展/子串替换"></a>2. 变量扩展/子串替换</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ : &gt; test.sh   <span class="hljs-comment"># 文件“test.sh”现在被清空了</span><br><span class="hljs-comment"># 与 cat /dev/null &gt; test.sh 的作用相同</span><br><span class="hljs-comment"># 然而,这并不会产生一个新的进程, 因为“:”是一个内建命令</span><br></code></pre></td></tr></table></figure>

<p>“:”还用来在 <code>/etc/passwd</code> 和 <code>$PATH</code> 变量中做分隔符，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ echo $PATH<br>&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;X11R6&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;games<br></code></pre></td></tr></table></figure>

<h3 id="8-问号（-）——三元操作符"><a href="#8-问号（-）——三元操作符" class="headerlink" title="8. 问号（?）——三元操作符"></a>8. 问号（?）——三元操作符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=10<br>(( t=a&lt;50?8:9 ))<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$t</span><br></code></pre></td></tr></table></figure>

<h3 id="9-美元符号"><a href="#9-美元符号" class="headerlink" title="9. 美元符号"></a>9. 美元符号</h3><p>变量替换</p>
<h3 id="10-小括号"><a href="#10-小括号" class="headerlink" title="10. 小括号"></a>10. 小括号</h3><h4 id="1-命令组"><a href="#1-命令组" class="headerlink" title="1. 命令组"></a>1. 命令组</h4><p>在括号中的变量，由于是在子shell中，所以对于脚本剩下的部分是不可用的。父进程，也就是脚本本身，将不能够读取在子进程中创建的变量，也就是在子shell 中创建的变量。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ vim test20.sh<br></code></pre></td></tr></table></figure>

<p>输入代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=123<br>( a=321; )<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span> <span class="hljs-comment">#a的值为123而不是321，因为括号将判断为局部变量</span><br></code></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ bash test20.sh<br>a = 123<br></code></pre></td></tr></table></figure>

<p>在圆括号中 a 变量，更像是一个局部变量。</p>
<h4 id="2-初始化数组"><a href="#2-初始化数组" class="headerlink" title="2.初始化数组"></a>2.初始化数组</h4><p>创建数组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vim test21.sh<br></code></pre></td></tr></table></figure>

<p>输入代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>arr=(1 4 5 7 9 21)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[3]&#125;</span> <span class="hljs-comment"># get a value of arr</span><br></code></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ bash test21.sh<br>7<br></code></pre></td></tr></table></figure>

<h3 id="11-大括号"><a href="#11-大括号" class="headerlink" title="11. 大括号"></a>11. 大括号</h3><h4 id="1-文件名扩展"><a href="#1-文件名扩展" class="headerlink" title="1.文件名扩展"></a>1.文件名扩展</h4><p>复制 t.txt 的内容到 t.back 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vim test22.sh<br></code></pre></td></tr></table></figure>

<p>输入代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-keyword">if</span> [ ! -w <span class="hljs-string">&#x27;t.txt&#x27;</span> ];<br><span class="hljs-keyword">then</span><br>    touch t.txt<br><span class="hljs-keyword">fi</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;test text&#x27;</span> &gt;&gt; t.txt<br>cp t.&#123;txt,back&#125;<br></code></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ bash test22.sh<br></code></pre></td></tr></table></figure>

<p>查看运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ ls<br>$ cat t.txt<br>$ cat t.back<br></code></pre></td></tr></table></figure>

<p>注意： 在大括号中，不允许有空白，除非这个空白被引用或转义。</p>
<h4 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2.代码块"></a>2.代码块</h4><p>代码块，又被称为内部组，这个结构事实上创建了一个匿名函数（一个没有名字的函数）。然而，与“标准”函数不同的是，在其中声明的变量，对于脚本其他部分的代码来说还是可见的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vim test23.sh<br></code></pre></td></tr></table></figure>

<p>输入代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=123<br>&#123; a=321; &#125;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a = <span class="hljs-variable">$a</span>&quot;</span><br></code></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ bash test23.sh<br>a = 321<br></code></pre></td></tr></table></figure>

<p>变量 a 的值被更改了。</p>
<h3 id="12-中括号"><a href="#12-中括号" class="headerlink" title="12. 中括号"></a>12. 中括号</h3><h4 id="1-条件测试"><a href="#1-条件测试" class="headerlink" title="1.条件测试"></a>1.条件测试</h4><p>条件测试表达式放在[ ]中。下列练习中的-lt (less than)表示小于号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vim test24.sh<br></code></pre></td></tr></table></figure>

<p>输入代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=5<br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> -lt 10 ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a: <span class="hljs-variable">$a</span>&quot;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;a&gt;=10&#x27;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ bash test24.sh<br>a: 5<br></code></pre></td></tr></table></figure>

<p>双中括号（[[ ]]）也用作条件测试（判断），后面的实验会详细讲解。</p>
<h4 id="2-数组元素"><a href="#2-数组元素" class="headerlink" title="2.数组元素"></a>2.数组元素</h4><p>在一个array结构的上下文中，中括号用来引用数组中每个元素的编号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vim test25.sh<br></code></pre></td></tr></table></figure>

<p>输入代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>arr=(12 22 32)<br>arr[0]=10<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;arr[0]&#125;</span><br></code></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ bash test25.sh<br>10<br></code></pre></td></tr></table></figure>

<h3 id="13-尖括号"><a href="#13-尖括号" class="headerlink" title="13. 尖括号"></a>13. 尖括号</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>test.sh &gt; filename：重定向test.sh的输出到文件 filename 中。如果 filename 存在的话，那么将会被==覆盖==。</p>
<p>test.sh &amp;&gt; filename：重定向 test.sh 的 stdout（标准输出）和 stderr（标准错误）到 filename 中。</p>
<p>test.sh &gt;&amp;2：重定向 test.sh 的 stdout 到 stderr 中。</p>
<p>test.sh &gt;&gt; filename：把 test.sh 的输出==追加==到文件 filename 中。如果filename 不存在的话，将会被创建。</p>
<h3 id="14-竖线（-）"><a href="#14-竖线（-）" class="headerlink" title="14. 竖线（|）"></a>14. 竖线（|）</h3><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>分析前边命令的输出，并将输出作为后边命令的输入。这是一种产生命令链的好方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vim test26.sh<br></code></pre></td></tr></table></figure>

<p>输入代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>tr <span class="hljs-string">&#x27;a-z&#x27;</span> <span class="hljs-string">&#x27;A-Z&#x27;</span><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>

<p>现在让我们输送ls -l的输出到一个脚本中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ chmod 755 test26.sh<br>$ ls -l | ./test26.sh<br></code></pre></td></tr></table></figure>

<p>输出的内容均变为了大写字母。</p>
<h3 id="15-破折号（-）"><a href="#15-破折号（-）" class="headerlink" title="15. 破折号（-）"></a>15. 破折号（-）</h3><h4 id="1-选项，前缀"><a href="#1-选项，前缀" class="headerlink" title="1.选项，前缀"></a>1.选项，前缀</h4><p>在所有的命令内如果想使用选项参数的话,前边都要加上“-”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vim test27.sh<br></code></pre></td></tr></table></figure>

<p>输入代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>a=5<br>b=5<br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span> -eq <span class="hljs-string">&quot;<span class="hljs-variable">$b</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a is equal to b.&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ bash test27.sh<br>a is equal to b.<br></code></pre></td></tr></table></figure>

<h4 id="2-用于重定向stdin或stdout"><a href="#2-用于重定向stdin或stdout" class="headerlink" title="2.用于重定向stdin或stdout"></a>2.用于重定向stdin或stdout</h4><p>下面脚本用于备份最后24小时当前目录下所有修改的文件.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vim test28.sh<br></code></pre></td></tr></table></figure>

<p>输入代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>BACKUPFILE=backup-$(date +%m-%d-%Y)<br><span class="hljs-comment"># 在备份文件中嵌入时间.</span><br>archive=<span class="hljs-variable">$&#123;1:-<span class="hljs-variable">$BACKUPFILE</span>&#125;</span><br><span class="hljs-comment">#  如果在命令行中没有指定备份文件的文件名,</span><br><span class="hljs-comment">#  那么将默认使用&quot;backup-MM-DD-YYYY.tar.gz&quot;.</span><br><br>tar cvf - `find . -mtime -1 -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">print</span>` &gt; <span class="hljs-variable">$archive</span>.tar<br>gzip <span class="hljs-variable">$archive</span>.tar<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Directory <span class="hljs-variable">$PWD</span> backed up in archive file \&quot;<span class="hljs-variable">$archive</span>.tar.gz\&quot;.&quot;</span><br><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ bash test28.sh<br>$ ls<br></code></pre></td></tr></table></figure>

<h3 id="16-波浪号（-）——表示home目录"><a href="#16-波浪号（-）——表示home目录" class="headerlink" title="16. 波浪号（~）——表示home目录"></a>16. 波浪号（~）——表示home目录</h3><h2 id="5-变量和参数"><a href="#5-变量和参数" class="headerlink" title="5. 变量和参数"></a>5. 变量和参数</h2><h4 id="1-变量定义"><a href="#1-变量定义" class="headerlink" title="1. 变量定义"></a>1. 变量定义</h4><h5 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h5><p>变量的名字就是变量保存值的地方。引用变量的值就叫做变量替换。</p>
<p>如果 variable 是一个变量的名字，那么 $variable 就是引用这个变量的值，即这变量所包含的数据。</p>
<p>$variable 事实上只是 ${variable} 的简写形式。在某些上下文中 $variable 可能会引起错误，这时候你就需要用 ${variable} 了。</p>
<h5 id="2-定义变量"><a href="#2-定义变量" class="headerlink" title="2.定义变量"></a>2.定义变量</h5><p>定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如： myname=”shiyanlou”</p>
<p><strong>注意</strong></p>
<p><strong>变量名和等号之间不能有空格</strong>。同时，变量名的命名须遵循如下规则：</p>
<ul>
<li>首个字符必须为字母（a-z，A-Z）。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
<p>除了直接赋值，还可以用语句给变量赋值，如：for file in <code>ls /etc</code></p>
<h4 id="2-使用变量"><a href="#2-使用变量" class="headerlink" title="2. 使用变量"></a>2. 使用变量</h4><p>变量名前加<strong>美元符号</strong>，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">myname=<span class="hljs-string">&quot;shiyanlou&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$myname</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;myname&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;myname&#125;</span>Good<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$mynameGood</span><br><br>myname=<span class="hljs-string">&quot;miao&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;myname&#125;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>加<strong>花括号</strong>帮助解释器识别变量的<strong>边界</strong>，若不加，解释器会把mynameGood当成一个变量（值为空）</p>
<p>推荐给所有变量加花括号</p>
<p>已定义的变量可以重新被定义</p>
</blockquote>
<h4 id="3-只读变量"><a href="#3-只读变量" class="headerlink" title="3. 只读变量"></a>3. 只读变量</h4><p>使用 <code>readonly</code> 命令可以将变量定义为只读变量，只读变量的值不能被改变。 下面的例子尝试更改只读变量，结果报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>myUrl=<span class="hljs-string">&quot;http://www.shiyanlou.com&quot;</span><br><span class="hljs-built_in">readonly</span> myUrl<br>myUrl=<span class="hljs-string">&quot;http://www.shiyanlou.com&quot;</span><br></code></pre></td></tr></table></figure>

<p>运行脚本，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/bin/sh: NAME: This variable is <span class="hljs-built_in">read</span> only.<br></code></pre></td></tr></table></figure>

<h4 id="4-特殊变量"><a href="#4-特殊变量" class="headerlink" title="4. 特殊变量"></a>4. 特殊变量</h4><h5 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1.局部变量"></a>1.局部变量</h5><p>这种变量只有在代码块或者函数中才可见。后面的实验会详细讲解。</p>
<h5 id="2-环境变量"><a href="#2-环境变量" class="headerlink" title="2.环境变量"></a>2.环境变量</h5><p>这种变量将影响用户接口和 shell 的行为。</p>
<p>在通常情况下，每个进程都有自己的“环境”，这个环境是由一组变量组成的，这些变量中存有进程可能需要引用的信息。在这种情况下，shell 与一个一般的进程没什么区别。</p>
<h5 id="3-位置参数"><a href="#3-位置参数" class="headerlink" title="3.位置参数"></a>3.位置参数</h5><p>从命令行传递到脚本的参数：0，0，1，2，2，3…</p>
<p>0就是脚本文件自身的名字，0就是脚本文件自身的名字，1 是第一个参数，2 是第二个参数，2是第二个参数，3 是第三个参数，然后是第四个。9 之后的位置参数就必须用大括号括起来了，比如，9之后的位置参数就必须用大括号括起来了，比如，{10}，{11}，11，{12}。</p>
<ul>
<li><code>$#</code> ： 传递到脚本的参数个数</li>
<li><code>$*</code> ： 以一个单字符串显示所有向脚本传递的参数。与位置变量不同,此选项参数可超过 9个</li>
<li><code>$$</code> ： 脚本运行的当前进程 ID号</li>
<li><code>$!</code> ： 后台运行的最后一个进程的进程 ID号</li>
<li><code>$@</code> ： 与$*相同,但是使用时加引号,并在引号中返回每个参数</li>
<li><code>$</code>： 显示shell使用的当前选项,与 set命令功能相同</li>
<li><code>$?</code> ： 显示最后命令的退出状态。 0表示没有错误,其他任何值表明有错误。</li>
</ul>
<h5 id="4-位置参数实例"><a href="#4-位置参数实例" class="headerlink" title="4.位置参数实例"></a>4.位置参数实例</h5><p>这个十分重要，在我们运行一套脚本的时候，有时候是需要参数的，这里我们教大家如何获取参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vim test30.sh<br></code></pre></td></tr></table></figure>

<p>输入代码（中文皆为注释，不用输入）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 作为用例, 调用这个脚本至少需要10个参数, 比如:</span><br><span class="hljs-comment"># bash test.sh 1 2 3 4 5 6 7 8 9 10</span><br>MINPARAMS=10<br><br><span class="hljs-built_in">echo</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The name of this script is \&quot;<span class="hljs-variable">$0</span>\&quot;.&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The name of this script is \&quot;`basename <span class="hljs-variable">$0</span>`\&quot;.&quot;</span><br><br><br><span class="hljs-built_in">echo</span><br><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]              <span class="hljs-comment"># 测试变量被引用.</span><br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Parameter #1 is <span class="hljs-variable">$1</span>&quot;</span>  <span class="hljs-comment"># 需要引用才能够转义&quot;#&quot;</span><br><span class="hljs-keyword">fi</span> <br><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Parameter #2 is <span class="hljs-variable">$2</span>&quot;</span><br><span class="hljs-keyword">fi</span> <br><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;10&#125;</span>&quot;</span> ]  <span class="hljs-comment"># 大于$9的参数必须用&#123;&#125;括起来.</span><br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Parameter #10 is <span class="hljs-variable">$&#123;10&#125;</span>&quot;</span><br><span class="hljs-keyword">fi</span> <br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----------------------------------&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;All the command-line parameters are: &quot;</span>$*<span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -lt <span class="hljs-string">&quot;<span class="hljs-variable">$MINPARAMS</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br> <span class="hljs-built_in">echo</span><br> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This script needs at least <span class="hljs-variable">$MINPARAMS</span> command-line arguments!&quot;</span><br><span class="hljs-keyword">fi</span>  <br><br><span class="hljs-built_in">echo</span><br><br><span class="hljs-built_in">exit</span> 0<br></code></pre></td></tr></table></figure>

<p>运行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ bash test30.sh 1 2 10<br><br><br>The name of this script is <span class="hljs-string">&quot;test.sh&quot;</span>.<br>The name of this script is <span class="hljs-string">&quot;test.sh&quot;</span>.<br><br>Parameter <span class="hljs-comment">#1 is 1</span><br>Parameter <span class="hljs-comment">#2 is 2</span><br>-----------------------------------<br>All the command-line parameters are: 1 2 10<br><br>This script needs at least 10 command-line arguments!<br></code></pre></td></tr></table></figure>

<h2 id="6-基本运算符"><a href="#6-基本运算符" class="headerlink" title="6. 基本运算符"></a>6. 基本运算符</h2><h3 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1. 算数运算符"></a>1. 算数运算符</h3><img src="https://doc.shiyanlou.com/document-uid8797labid3895timestamp1554172034738.png" alt="5-1-1" style="zoom:80%;">

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$vim</span> test.sh<br><span class="hljs-meta">#!/bin/bash</span><br><br>a=10<br>b=20<br><br>val=`expr <span class="hljs-variable">$a</span> + <span class="hljs-variable">$b</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a + b : <span class="hljs-variable">$val</span>&quot;</span><br><br>val=`expr <span class="hljs-variable">$a</span> - <span class="hljs-variable">$b</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a - b : <span class="hljs-variable">$val</span>&quot;</span><br><br>val=`expr <span class="hljs-variable">$a</span> \* <span class="hljs-variable">$b</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a * b : <span class="hljs-variable">$val</span>&quot;</span><br><br>val=`expr <span class="hljs-variable">$b</span> / <span class="hljs-variable">$a</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;b / a : <span class="hljs-variable">$val</span>&quot;</span><br><br>val=`expr <span class="hljs-variable">$b</span> % <span class="hljs-variable">$a</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;b % a : <span class="hljs-variable">$val</span>&quot;</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> == <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a == b&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a != b&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$bash</span> test.sh<br>a + b : 30<br>a - b : -10<br>a * b : 200<br>b / a : 2<br>b % a : 0<br>a != b<br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 <code>awk</code> 和 <code>expr</code>，<code>expr</code> 最常用。</li>
<li><code>expr</code> 是一款表达式计算工具，使用它能完成表达式的求值操作。</li>
<li>注意使用的反引号（esc键下边）</li>
<li>表达式和运算符之间要有空格<code>$a + $b</code>写成<code>$a+$b</code>不行</li>
<li>条件表达式要放在方括号之间，并且要有空格<code>[ $a == $b ]</code>写成<code>[$a==$b]</code>不行</li>
<li>乘号（<code>*</code>）前边必须加反斜杠（<code>\</code>)才能实现乘法运算</li>
</ul>
</blockquote>
<h3 id="2-关系运算符-大于、小于、等于"><a href="#2-关系运算符-大于、小于、等于" class="headerlink" title="2. 关系运算符(大于、小于、等于)"></a>2. 关系运算符(大于、小于、等于)</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>检测两个数是否相等，相等返回true.</td>
</tr>
<tr>
<td>-ne</td>
<td>检测两个数是都相等，不相等返回true</td>
</tr>
<tr>
<td>-gt</td>
<td>检测左边的数是否大于右边的，如果是，则返回true</td>
</tr>
<tr>
<td>-lt</td>
<td>检测左边的数是否小于右边的，如果是，则返回true</td>
</tr>
<tr>
<td>-ge</td>
<td>检测左边的数是否大于右边的，如果是，则返回true</td>
</tr>
<tr>
<td>-le</td>
<td>检测左边的数是否小于右边的，如果是，则返回true</td>
</tr>
</tbody></table>
<h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑的AND</td>
</tr>
<tr>
<td>||</td>
<td>逻辑的OR</td>
</tr>
</tbody></table>
<h3 id="4-字符运算符"><a href="#4-字符运算符" class="headerlink" title="4. 字符运算符"></a>4. 字符运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>检测两个字符串是否相等，相等则返回true</td>
</tr>
<tr>
<td>！=</td>
<td>检测两个字符串是否相等，不相等则返回true</td>
</tr>
<tr>
<td>-z</td>
<td>检测两个字符串长度是否为0，为0则返回true</td>
</tr>
<tr>
<td>-n</td>
<td>检测两个字符串长度是否为0，不为0则返回true</td>
</tr>
<tr>
<td>str</td>
<td>检测字符串是否为空，不为空返回true</td>
</tr>
</tbody></table>
<h3 id="5-文件测试运算符"><a href="#5-文件测试运算符" class="headerlink" title="5. 文件测试运算符"></a>5. 文件测试运算符</h3><p><img src="https://doc.shiyanlou.com/document-uid8797labid3895timestamp1554172035089.png" alt="5-5-1"></p>
<h3 id="6-浮点运算（小数运算）"><a href="#6-浮点运算（小数运算）" class="headerlink" title="6. 浮点运算（小数运算）"></a>6. 浮点运算（小数运算）</h3><p>浮点运算，比如实现求圆的面积和周长。</p>
<blockquote>
<p><code>expr</code> 只能用于整数计算，可以使用 <code>bc</code> 或者 <code>awk</code> 进行浮点数运算。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>raduis=2.4<br><br>pi=3.14159<br><br>girth=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=4; 3.14 * 2 * <span class="hljs-variable">$raduis</span>&quot;</span> | bc)<br><br>area=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=4; 3.14 * <span class="hljs-variable">$raduis</span> * <span class="hljs-variable">$raduis</span>&quot;</span> | bc)<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;girth=<span class="hljs-variable">$girth</span>&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;area=<span class="hljs-variable">$area</span>&quot;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>以上代码如果想在环境中运行，需要先安装 <code>bc</code>。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt-get update<br>$ sudo apt-get install bc<br></code></pre></td></tr></table></figure>

<h2 id="7-流程控制（if-else"><a href="#7-流程控制（if-else" class="headerlink" title="7. 流程控制（if-else)"></a>7. 流程控制（if-else)</h2><h3 id="1-if-else"><a href="#1-if-else" class="headerlink" title="1. if else"></a>1. if else</h3><p>和Java、PHP等语言不一样，sh的流程控制不可为空</p>
<p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p>
<h4 id="1-if"><a href="#1-if" class="headerlink" title="1.if"></a>1.if</h4><p>if 语句语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> condition<br><span class="hljs-keyword">then</span><br>    command1 <br>    command2<br>    ...<br>    commandN <br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<h4 id="2-if-else"><a href="#2-if-else" class="headerlink" title="2.if else"></a>2.if else</h4><p>if else 语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> condition<br><span class="hljs-keyword">then</span><br>    command1 <br>    command2<br>    ...<br>    commandN<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<p>if-elif-else 语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> condition1<br><span class="hljs-keyword">then</span><br>    command1<br><span class="hljs-keyword">elif</span> condition2 <br><span class="hljs-keyword">then</span> <br>    command2<br><span class="hljs-keyword">else</span><br>    commandN<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<p>以下实例判断两个变量是否相等：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">a=10<br>b=20<br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$a</span> == <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a == b&quot;</span><br><span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$a</span> -gt <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a &gt; b&quot;</span><br><span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$a</span> -lt <span class="hljs-variable">$b</span> ]<br><span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a &lt; b&quot;</span><br><span class="hljs-keyword">else</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Ineligible&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">a &lt; b<br></code></pre></td></tr></table></figure>

<p>if else语句经常与test命令结合使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">num1=$[2*3]<br>num2=$[1+5]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> $[num1] -eq $[num2]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Two numbers are equal!&#x27;</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;The two numbers are not equal!&#x27;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Two numbers are equal!<br></code></pre></td></tr></table></figure>

<h3 id="2-for循环"><a href="#2-for循环" class="headerlink" title="2. for循环"></a>2. for循环</h3><p>for循环一般格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> item1 item2 ... itemN<br><span class="hljs-keyword">do</span><br>    command1<br>    command2<br>    ...<br>    commandN<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>

<p>例如，顺序输出当前列表中的数字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> loop <span class="hljs-keyword">in</span> 1 2 3 4 5<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The value is: <span class="hljs-variable">$loop</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">The value is: 1<br>The value is: 2<br>The value is: 3<br>The value is: 4<br>The value is: 5<br></code></pre></td></tr></table></figure>

<p>顺序输出字符串中的字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> str <span class="hljs-keyword">in</span> This is a string<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$str</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">This<br>is<br>a<br>string<br></code></pre></td></tr></table></figure>

<h4 id="for循环高级用法"><a href="#for循环高级用法" class="headerlink" title="for循环高级用法"></a>for循环高级用法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>PREFIX=192.168.1.<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `seq 100 110`<br><span class="hljs-keyword">do</span><br>　　<span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PREFIX&#125;</span><span class="hljs-variable">$i</span> &quot;</span><br>　　ping -c5 <span class="hljs-variable">$&#123;PREFIX&#125;</span><span class="hljs-variable">$&#123;i&#125;</span> &gt;/dev/null 2&gt;&amp;1<br>　　<span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;$?&quot;</span> -eq 0 ];<span class="hljs-keyword">then</span><br>　　　　<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;OK&quot;</span><br>　　<span class="hljs-keyword">else</span><br>　　　　<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Failed&quot;</span><br>　　<span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>



<h3 id="3-while语句"><a href="#3-while语句" class="headerlink" title="3. while语句"></a>3. while语句</h3><p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> condition<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br><span class="hljs-meta">#!/bin/bash</span><br>int=1<br><span class="hljs-keyword">while</span>(( <span class="hljs-variable">$int</span>&lt;=5 ))<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$int</span><br>    <span class="hljs-built_in">let</span> <span class="hljs-string">&quot;int++&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>

<p>运行脚本，输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">1<br>2<br>3<br>4<br>5<br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果int小于等于5，那么条件返回真。int从1开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。</li>
<li>使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量</li>
</ul>
</blockquote>
<p>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量MAN，按结束循环。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;press &lt;CTRL-D&gt; exit&#x27;</span><br><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&#x27;Who do you think is the most handsome: &#x27;</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> MAN<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Yes！<span class="hljs-variable">$MAN</span> is really handsome&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>

<h3 id="4-无限循环"><a href="#4-无限循环" class="headerlink" title="4. 无限循环"></a>4. 无限循环</h3><p>无限循环语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br>或者<br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> (( ; ; ))<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>until循环</li>
</ol>
<p>until循环执行一系列命令直至条件为真时停止。 until循环与while循环在处理方式上刚好相反。 一般while循环优于until循环，但在某些时候—也只是极少数情况下，until循环更加有用。 until 语法格式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">until condition<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">command</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>

<p>条件可为任意测试条件，测试发生在循环末尾，因此循环至少执行一次—请注意这一点。</p>
<ol start="6">
<li>case</li>
</ol>
<p>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">case</span> 值 <span class="hljs-keyword">in</span><br>模式1)<br>    command1<br>    command2<br>    ...<br>    commandN<br>    ;;<br>模式2）<br>    command1<br>    command2<br>    ...<br>    commandN<br>    ;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 <code>;;</code>。</li>
<li>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 <code>*</code> 捕获该值，再执行后面的命令。</li>
</ul>
</blockquote>
<p>下面的脚本提示输入1到4，与每一种模式进行匹配：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Enter a number between 1 and 4:&#x27;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;The number you entered is:&#x27;</span><br><span class="hljs-built_in">read</span> aNum<br><span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span><br>    1)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;You have chosen 1&#x27;</span><br>    ;;<br>    2)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;You have chosen 2&#x27;</span><br>    ;;<br>    3)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;You have chosen 3&#x27;</span><br>    ;;<br>    4)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;You have chosen 4&#x27;</span><br>    ;;<br>    *)  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;You did not enter a number between 1 and 4&#x27;</span><br>    ;;<br><span class="hljs-keyword">esac</span><br></code></pre></td></tr></table></figure>

<p>输入不同的内容，会有不同的结果，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Enter a number between 1 and 4:<br>The number you entered is:<br>3<br>You have chosen 3<br></code></pre></td></tr></table></figure>

<h3 id="7-跳出循环"><a href="#7-跳出循环" class="headerlink" title="7. 跳出循环"></a>7. 跳出循环</h3><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。</p>
<p>==<strong>break命令</strong>==</p>
<p>break命令允许跳出所有循环（终止执行后面的所有循环）。 下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Enter a number between 1 and 5:&quot;</span><br>    <span class="hljs-built_in">read</span> aNum<br>    <span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span><br>        1|2|3|4|5) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The number you entered is <span class="hljs-variable">$aNum</span>!&quot;</span><br>        ;;<br>        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The number you entered is not between 1 and 5! game over!&quot;</span><br>            <span class="hljs-built_in">break</span><br>        ;;<br>    <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Enter a number between 1 and 5:3<br>The number you entered is 3!<br>Enter a number between 1 and 5:7<br>The number you entered is not between 1 and 5! game over!<br></code></pre></td></tr></table></figure>

<h3 id="8-continue"><a href="#8-continue" class="headerlink" title="8. continue"></a>8. continue</h3><p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。 对上面的例子进行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;Enter a number between 1 and 5: &quot;</span><br>    <span class="hljs-built_in">read</span> aNum<br>    <span class="hljs-keyword">case</span> <span class="hljs-variable">$aNum</span> <span class="hljs-keyword">in</span><br>        1|2|3|4|5) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The number you entered is <span class="hljs-variable">$aNum</span>!&quot;</span><br>        ;;<br>        *) <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The number you entered is not between 1 and 5!&quot;</span><br>            <span class="hljs-built_in">continue</span><br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;game over&quot;</span><br>        ;;<br>    <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>

<p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 <code>echo &quot;Game is over!&quot;</code> 永远不会被执行。</p>
<h3 id="9-esac"><a href="#9-esac" class="headerlink" title="9. esac"></a>9. esac</h3><p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。</p>
<h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h2><h3 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="1. 函数定义"></a>1. 函数定义</h3><p>shell中函数的定义格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[ <span class="hljs-keyword">function</span> ] funname [()]<br><br>&#123;<br><br>    action;<br><br>    [<span class="hljs-built_in">return</span> int;]<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<ul>
<li>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)</li>
</ul>
</blockquote>
<p>下面的例子定义了一个函数并进行调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-function"><span class="hljs-title">demoFun</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is my first shell function!&quot;</span><br>&#125;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----Execution-----&quot;</span><br>demoFun<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-----Finished-----&quot;</span><br><br><br>Output the result：<br>-----Execution-----<br>This is my first shell <span class="hljs-keyword">function</span>!<br>-----Finished-----<br></code></pre></td></tr></table></figure>

<p>下面定义一个带有return语句的函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-function"><span class="hljs-title">funWithReturn</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This function will add the two numbers of the input...&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Enter the first number: &quot;</span><br>    <span class="hljs-built_in">read</span> aNum<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Enter the second number: &quot;</span><br>    <span class="hljs-built_in">read</span> anotherNum<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The two numbers are <span class="hljs-variable">$aNum</span> and <span class="hljs-variable">$anotherNum</span> !&quot;</span><br>    <span class="hljs-built_in">return</span> $((<span class="hljs-variable">$aNum</span>+<span class="hljs-variable">$anotherNum</span>))<br>&#125;<br>funWithReturn<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The sum of the two numbers entered is $? !&quot;</span><br></code></pre></td></tr></table></figure>

<p>输出类似下面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">This function will add the two numbers of the input...<br>Enter the first number: <br>1<br>Enter the second number: <br>2<br>The two numbers are 1 and  2 !<br>The sum of the two numbers entered is 3 !<br></code></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>函数返回值在调用该函数后通过 $? 来获得</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>所有函数在使用前必须定义。</li>
</ul>
</blockquote>
<h3 id="2-函数参数"><a href="#2-函数参数" class="headerlink" title="2. 函数参数"></a>2. 函数参数</h3><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 n 的形式来获取参数的值，例如，<em>n</em>的形式来获取参数的值，例如，1表示第一个参数，$2表示第二个参数… 带参数的函数示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-function"><span class="hljs-title">funWithParam</span></span>()&#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The first parameter is <span class="hljs-variable">$1</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The second parameter is <span class="hljs-variable">$2</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The tenth parameter is <span class="hljs-variable">$10</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The tenth parameter is <span class="hljs-variable">$&#123;10&#125;</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The eleventh parameter is <span class="hljs-variable">$&#123;11&#125;</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The total number of parameters is <span class="hljs-variable">$#</span> !&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Outputs all parameters as a string $* !&quot;</span><br>&#125;<br>funWithParam 1 2 3 4 5 6 7 8 9 34 73<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">The first parameter is 1 !<br>The second parameter is 2 !<br>The tenth parameter is 10 !<br>The tenth parameter is 34 !<br>The eleventh parameter is 73 !<br>The total number of parameters is 11 !<br>Outputs all parameters as a string 1 2 3 4 5 6 7 8 9 34 73 !<br></code></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<blockquote>
<p>10 不能获取第十个参数，获取第十个参数需要10不能获取第十个参数，获取第十个参数需要{10}。当n&gt;=10时，需要使用${n}来获取参数。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Bash</category>
        <category>Bash</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>bash</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>N、Linux轻松一刻</title>
    <url>/posts/3ac4cd3c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、火焰"><a href="#一、火焰" class="headerlink" title="一、火焰"></a>一、火焰</h1><p>天冷的时候，要是有个火炉就好了。这里有个有趣的程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ sudo apt-get install libaa-bin<br># 提示 command not found ，请自行解决<br>$ aafire<br></code></pre></td></tr></table></figure>

<p><img src="http://qgqz63fje.hb-bkt.clouddn.com/20201002110427.gif" alt="img"></p>
<h1 id="二、屏幕特效（cmatrix）"><a href="#二、屏幕特效（cmatrix）" class="headerlink" title="二、屏幕特效（cmatrix）"></a>二、屏幕特效（cmatrix）</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt-get update<br>$ sudo apt-get install cmatrix<br>$ camtris<br></code></pre></td></tr></table></figure>

<h1 id="三、图画"><a href="#三、图画" class="headerlink" title="三、图画"></a>三、图画</h1><h4 id="轻松一下"><a href="#轻松一下" class="headerlink" title="轻松一下"></a>轻松一下</h4><p><code>cowsay</code>命令，可以让你在终端里以一种动物说话的形式打印出一段话。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 更新软件包</span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt update</span><br><br><span class="hljs-meta">#</span><span class="bash"> 安装</span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt install -y cowsay</span><br><br><span class="hljs-meta">#</span><span class="bash"> 默认是一只牛</span><br><span class="hljs-meta">$</span><span class="bash"> cowsay hello shiyanlou</span><br><br><span class="hljs-meta">#</span><span class="bash"> 加上<span class="hljs-string">&#x27;-l&#x27;</span>参数打印所有支持的动物（其实不只是动物）种类</span><br><span class="hljs-meta">$</span><span class="bash"> cowsay -l</span><br><br><span class="hljs-meta">#</span><span class="bash"> 使用<span class="hljs-string">&#x27;-f&#x27;</span>参数选择动物种类</span><br><span class="hljs-meta">$</span><span class="bash"> cowsay -f elephant hello shiyanlou</span><br><br><span class="hljs-meta">#</span><span class="bash"> 安装 fortune-zh</span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install fortune-zh</span><br><br><span class="hljs-meta">#</span><span class="bash"> 此外它还可以结合我们之前的作业讲过的 fortune 命令一起使用</span><br><span class="hljs-meta">$</span><span class="bash"> /usr/games/fortune | cowsay -f daemon</span><br></code></pre></td></tr></table></figure>

<p><img src="http://qgqz63fje.hb-bkt.clouddn.com/20201002110432.png" alt="此处输入图片的描述"></p>
<h1 id="四、显示图片"><a href="#四、显示图片" class="headerlink" title="四、显示图片"></a>四、显示图片</h1><p>使用以前介绍过的方法，安装<code>aview</code>和<code>imagemagick</code>，然后用<code>asciiview</code>命令显示图片，使用方法可以用 man 命令查看。</p>
<p>Linus 大神的照片地址 <a href="https://labfile.oss.aliyuncs.com/courses/1/Linus.png">https://labfile.oss.aliyuncs.com/courses/1/Linus.png</a></p>
<img src="http://qgqz63fje.hb-bkt.clouddn.com/20201002110437.png" alt="img" style="zoom: 33%;">

<p>执行以下命令安装工具包并下载图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">shiyanlou:~&#x2F; $ sudo apt update<br><br>shiyanlou:~&#x2F; $ sudo apt install -y aview imagemagick<br><br>shiyanlou:~&#x2F; $ wget https:&#x2F;&#x2F;labfile.oss.aliyuncs.com&#x2F;courses&#x2F;1&#x2F;Linus.png<br></code></pre></td></tr></table></figure>

<p>执行 <code>asciiview [图片文件名]</code> 即可打开图片：</p>
<img src="https://dn-simplecloud.shiyanlou.com/uid/dcb2ea4c3df440da669e05ba35dbe75d/1550043520959.png" alt="图片描述" style="zoom: 67%;">

<p><a href="https://b287.photo.store.qq.com/psb?/V141y5OQ39HXnh/Ze5q9eV9O7czDkzvDkjVWgUOJSx38g9dbb1ENFsRTMQ!/b/dB8BAAAAAAAA&amp;bo=AQPQAwAAAAARB.E!&amp;rf=viewer_4">https://b287.photo.store.qq.com/psb?/V141y5OQ39HXnh/Ze5q9eV9O7czDkzvDkjVWgUOJSx38g9dbb1ENFsRTMQ!/b/dB8BAAAAAAAA&amp;bo=AQPQAwAAAAARB.E!&amp;rf=viewer_4</a></p>
<h1 id="五、蜜蜂大战"><a href="#五、蜜蜂大战" class="headerlink" title="五、蜜蜂大战"></a>五、蜜蜂大战</h1><h4 id="轻松一下-1"><a href="#轻松一下-1" class="headerlink" title="轻松一下"></a>轻松一下</h4><p>还记得小时候在小霸王上面玩的小蜜蜂游戏么？它的正统名字应该是<a href="http://en.wikipedia.org/wiki/Space_Invaders">Space Invaders:太空侵略者</a>。</p>
<p>使用下面这个命令可以安装，之所以叫 ninvaders 是因为这款游戏是基于 ncurses 命令行图形库做的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ sudo apt-get install ninvaders<br>$ &#x2F;usr&#x2F;games&#x2F;ninvaders<br></code></pre></td></tr></table></figure>

<p><img src="http://qgqz63fje.hb-bkt.clouddn.com/20201002110442.gif" alt="img"></p>
<h1 id="六、彩色火焰"><a href="#六、彩色火焰" class="headerlink" title="六、彩色火焰"></a>六、彩色火焰</h1><h4 id="轻松一下-2"><a href="#轻松一下-2" class="headerlink" title="轻松一下"></a>轻松一下</h4><p>之前介绍过一个在命令行将图片转换为 ascii 字符查看的工具 aview/asciiview，不过它是黑白的。现在，这里是个彩色的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ sudo apt-get install caca-utils<br>$ cacaview &lt;pic_file&gt;<br>$ cacademo<br>$ cacafire<br></code></pre></td></tr></table></figure>

<p><img src="http://qgqz63fje.hb-bkt.clouddn.com/20201002110448.gif" alt="img"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>九、数据流重定向</title>
    <url>/posts/3083aeb6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="九、数据流重定向"><a href="#九、数据流重定向" class="headerlink" title="九、数据流重定向"></a>九、数据流重定向</h1><h2 id="一、实验介绍"><a href="#一、实验介绍" class="headerlink" title="一、实验介绍"></a>一、实验介绍</h2><h3 id="1-1-实验内容"><a href="#1-1-实验内容" class="headerlink" title="1.1 实验内容"></a>1.1 实验内容</h3><p>你可能对重定向这个概念感到些许陌生，但你应该在前面的课程中多次见过<code>&gt;</code>或<code>&gt;&gt;</code>操作了，并知道他们分别是将标准输出导向一个文件或追加到一个文件中。这其实就是重定向，将原本输出到标准输出的数据重定向到一个文件中，因为标准输出(<code>/dev/stdout</code>)本身也是一个文件，我们将命令输出导向另一个文件自然也是没有任何问题的。</p>
<h3 id="1-2-实验知识点"><a href="#1-2-实验知识点" class="headerlink" title="1.2 实验知识点"></a>1.2 实验知识点</h3><ul>
<li>重定向怎么用</li>
<li>文件描述符(0,1,2)</li>
</ul>
<h2 id="二、数据流重定向"><a href="#二、数据流重定向" class="headerlink" title="二、数据流重定向"></a>二、数据流重定向</h2><p>下面我们简单的回顾一下我们前面经常用到的两个重定向操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello shiyanlou&#x27;</span> &gt; redirect<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;www.shiyanlou.com&#x27;</span> &gt;&gt; redirect<br>$ cat redirect<br></code></pre></td></tr></table></figure>

<blockquote>
<p>当然前面没有用到的<code>&lt;</code>和<code>&lt;&lt;</code>操作也是没有问题的，如你理解的一样，它们的区别在于重定向的方向不一致而已，<code>&gt;</code>表示是从左到右，<code>&lt;</code>右到左。</p>
</blockquote>
<h3 id="2-1-简单的重定向"><a href="#2-1-简单的重定向" class="headerlink" title="2.1 简单的重定向"></a>2.1 简单的重定向</h3><p>在更多了解 Linux 的重定向之前，我们需要先知道一些基本的东西，前面我们已经提到过 Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为<code>stdin</code>（标准输入,对应于你在终端的输入），<code>stdout</code>（标准输出，对应于终端的输出），<code>stderr</code>（标准错误输出，对应于终端的输出）。</p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>设备文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td><code>/dev/stdin</code></td>
<td>标准输入</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>/dev/stdout</code></td>
<td>标准输出</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>/dev/stderr</code></td>
<td>标准错误</td>
</tr>
</tbody></table>
<blockquote>
<p>文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p>
</blockquote>
<p>我们可以这样使用这些文件描述符：</p>
<p>默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ cat<br>（按Ctrl+C退出）<br></code></pre></td></tr></table></figure>

<p>将 cat 的连续输出（heredoc 方式）重定向到一个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ mkdir Documents<br>$ cat &gt; Documents/test.c &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">#include &lt;stdio.h&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int main()</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    printf(&quot;hello world\n&quot;);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure>

<p>将一个文件作为命令的输入，标准输出作为命令的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ cat Documents/test.c<br></code></pre></td></tr></table></figure>

<p>将 echo 命令通过管道传过来的数据作为 cat 命令的输入，将标准输出作为命令的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hi&#x27;</span> | cat<br></code></pre></td></tr></table></figure>

<p>将 echo 命令的输出从默认的标准输出重定向到一个普通文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello shiyanlou&#x27;</span> &gt; redirect<br>$ cat redirect<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid346timestamp1532415296335.png" alt="此处输入图片的描述"></p>
<p>初学者这里要注意不要将管道和重定向混淆，<strong>管道默认是连接前一个命令的输出到下一个命令的输入</strong>，而重定向通常是需要一个文件来建立两个命令的连接，你可以仔细体会一下上述第三个操作和最后两个操作的异同点。</p>
<h3 id="2-2-标准错误重定向"><a href="#2-2-标准错误重定向" class="headerlink" title="2.2 标准错误重定向"></a>2.2 标准错误重定向</h3><p>重定向标准输出到文件，这是一个很实用的操作，另一个很实用的操作是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到的一个命令的输出通常是同时包含了标准输出和标准错误的结果的。比如下面的操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用cat 命令同时读取两个文件，其中一个存在，另一个不存在</span><br>$ cat Documents/test.c hello.c<br><span class="hljs-comment"># 你可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息</span><br><span class="hljs-comment"># 下面我们将输出重定向到一个文件</span><br>$ cat Documents/test.c hello.c &gt; somefile<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6127timestamp1523951670892.png" alt="此处输入图片的描述"></p>
<p>遗憾的是，这里依然出现了那条错误信息，这正是因为如我上面说的那样，标准输出和标准错误虽然都指向终端屏幕，实际它们并不一样。那有的时候我们就是要隐藏某些错误或者警告，那又该怎么做呢。这就需要用到我们前面讲的文件描述符了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将重定向到文件写到前面</span><br>$ cat Documents/test.c hello.c &gt;somefile  2&gt;&amp;1<br><span class="hljs-comment"># 或者只用bash提供的特殊的重定向符号&quot;&amp;&quot;将标准错误和标准输出同时重定向到文件</span><br>$ cat Documents/test.c hello.c &amp;&gt;somefilehell<br></code></pre></td></tr></table></figure>

<p><strong>注意你应该在输出重定向文件描述符前加上<code>&amp;</code>,否则 shell 会当做重定向到一个文件名为 1 的文件中</strong></p>
<p><img src="https://doc.shiyanlou.com/document-uid600404labid6127timestamp1523951876075.png" alt="此处输入图片的描述"></p>
<h3 id="2-3-使用tee命令同时重定向到多个文件"><a href="#2-3-使用tee命令同时重定向到多个文件" class="headerlink" title="2.3 使用tee命令同时重定向到多个文件"></a>2.3 使用tee命令同时重定向到多个文件</h3><p>你可能还有这样的需求，除了需要将输出重定向到文件,也需要将信息打印在终端。那么你可以使用<code>tee</code>命令来实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello shiyanlou&#x27;</span> | tee hello<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid346timestamp1532415315324.png" alt="此处输入图片的描述"></p>
<h3 id="2-4-永久重定向"><a href="#2-4-永久重定向" class="headerlink" title="2.4 永久重定向"></a>2.4 永久重定向</h3><p>你应该可以看出我们前面的重定向操作都只是临时性的，即只对当前命令有效，那如何做到“永久”有效呢，比如在一个脚本中，你需要某一部分的命令的输出全部进行重定向，难道要让你在每个命令上面加上临时重定向的操作嘛，当然不需要，我们可以使用<code>exec</code>命令实现“永久”重定向。<code>exec</code>命令的作用是使用指定的命令替换当前的 Shell，即使用一个进程替换当前进程，或者指定新的重定向：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先开启一个子 Shell</span><br>$ zsh<br><span class="hljs-comment"># 使用exec替换当前进程的重定向，将标准输出重定向到一个文件</span><br>$ <span class="hljs-built_in">exec</span> 1&gt;somefile<br><span class="hljs-comment"># 后面你执行的命令的输出都将被重定向到文件中,直到你退出当前子shell，或取消exec的重定向（后面将告诉你怎么做）</span><br>$ ls<br>$ <span class="hljs-built_in">exit</span><br>$ cat somefile<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6127timestamp1523952144929.png" alt="此处输入图片的描述"></p>
<h3 id="2-5-创建输出文件描述符"><a href="#2-5-创建输出文件描述符" class="headerlink" title="2.5 创建输出文件描述符"></a>2.5 创建输出文件描述符</h3><p>在 Shell 中有 9 个文件描述符。上面我们使用了也是它默认提供的 0,1,2 号文件描述符。另外我们还可以使用 3-8 的文件描述符，只是它们默认没有打开而已。你可以使用下面命令查看当前 Shell 进程中打开的文件描述符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /dev/fd/;ls -Al<br></code></pre></td></tr></table></figure>

<p>同样使用<code>exec</code>命令可以创建新的文件描述符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ zsh<br>$ <span class="hljs-built_in">exec</span> 3&gt;somefile<br><span class="hljs-comment"># 先进入目录，再查看，否则你可能不能得到正确的结果，然后再回到上一次的目录</span><br>$ <span class="hljs-built_in">cd</span> /dev/fd/;ls -Al;<span class="hljs-built_in">cd</span> -<br><span class="hljs-comment"># 注意下面的命令&gt;与&amp;之间不应该有空格，如果有空格则会出错</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;this is test&quot;</span> &gt;&amp;3<br>$ cat somefile<br>$ <span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid346timestamp1532415336263.png" alt="此处输入图片的描述"></p>
<h3 id="2-6-关闭文件描述符"><a href="#2-6-关闭文件描述符" class="headerlink" title="2.6 关闭文件描述符"></a>2.6 关闭文件描述符</h3><p>如上面我们打开的 3 号文件描述符，可以使用如下操作将它关闭：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">exec</span> 3&gt;&amp;-<br>$ <span class="hljs-built_in">cd</span> /dev/fd;ls -Al;<span class="hljs-built_in">cd</span> -<br></code></pre></td></tr></table></figure>

<h3 id="2-7-完全屏蔽命令的输出"><a href="#2-7-完全屏蔽命令的输出" class="headerlink" title="2.7 完全屏蔽命令的输出"></a>2.7 完全屏蔽命令的输出</h3><p>在 Linux 中有一个被称为“黑洞”的设备文件,所有导入它的数据都将被“吞噬”。</p>
<blockquote>
<p>在类 UNIX 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个 EOF。</p>
</blockquote>
<p>我们可以利用<code>/dev/null</code>屏蔽命令的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ cat Documents/test.c 1&gt;/dev/null 2&gt;&amp;1<br></code></pre></td></tr></table></figure>

<p>上面这样的操作将使你得不到任何输出结果。</p>
<h3 id="2-8-使用-xargs-分割参数列表"><a href="#2-8-使用-xargs-分割参数列表" class="headerlink" title="2.8 使用 xargs 分割参数列表"></a>2.8 使用 xargs 分割参数列表</h3><blockquote>
<p>xargs 是一条 UNIX 和类 UNIX 操作系统的常用命令。它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。</p>
</blockquote>
<p>这个命令在有些时候十分有用，特别是当用来处理产生大量输出结果的命令如 find，locate 和 grep 的结果，详细用法请参看 man 文档。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ cut -d: -f1 &lt; /etc/passwd | sort | xargs <span class="hljs-built_in">echo</span><br></code></pre></td></tr></table></figure>

<p>上面这个命令用于将<code>/etc/passwd</code>文件按<code>:</code>分割取第一个字段排序后，使用<code>echo</code>命令生成一个列表。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>八、简单的文本处理</title>
    <url>/posts/48fd063.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="八、简单的文本处理"><a href="#八、简单的文本处理" class="headerlink" title="八、简单的文本处理"></a>八、简单的文本处理</h1><h2 id="一、实验介绍"><a href="#一、实验介绍" class="headerlink" title="一、实验介绍"></a>一、实验介绍</h2><h3 id="1-1-实验内容"><a href="#1-1-实验内容" class="headerlink" title="1.1 实验内容"></a>1.1 实验内容</h3><p>这一节我们将介绍这几个命令<code>tr</code>（注意不是 tar），<code>col</code>，<code>join</code>，<code>paste</code>。实际这一节是上一节关于能实现管道操作的命令的延续，所以我们依然将结合管道来熟悉这些命令的使用。</p>
<h3 id="1-2-实验知识点"><a href="#1-2-实验知识点" class="headerlink" title="1.2 实验知识点"></a>1.2 实验知识点</h3><ul>
<li>常见文本处理命令</li>
<li>如何简单处理文本</li>
</ul>
<h2 id="二、文本处理命令"><a href="#二、文本处理命令" class="headerlink" title="二、文本处理命令"></a>二、文本处理命令</h2><h3 id="2-1-tr-命令"><a href="#2-1-tr-命令" class="headerlink" title="2.1 tr 命令"></a>2.1 tr 命令</h3><p>tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。</p>
<h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">tr [option]...SET1 [SET2]<br></code></pre></td></tr></table></figure>

<h4 id="常用的选项有："><a href="#常用的选项有：" class="headerlink" title="常用的选项有："></a>常用的选项有：</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-d</code></td>
<td>删除和 set1 匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>去除 set1 指定的在输入文本中连续并重复的字符</td>
</tr>
</tbody></table>
<h4 id="操作举例："><a href="#操作举例：" class="headerlink" title="操作举例："></a>操作举例：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除 &quot;hello shiyanlou&quot; 中所有的&#x27;o&#x27;,&#x27;l&#x27;,&#x27;h&#x27;</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello shiyanlou&#x27;</span> | tr -d <span class="hljs-string">&#x27;olh&#x27;</span><br><span class="hljs-comment"># 将&quot;hello&quot; 中的ll,去重为一个l</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;hello&#x27;</span> | tr -s <span class="hljs-string">&#x27;l&#x27;</span><br><span class="hljs-comment"># 将输入文本，全部转换为大写或小写输出</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;input some text here&#x27;</span> | tr <span class="hljs-string">&#x27;[:lower:]&#x27;</span> <span class="hljs-string">&#x27;[:upper:]&#x27;</span><br><span class="hljs-comment"># 上面的&#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;你也可以简单的写作&#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;,当然反过来将大写变小写也是可以的</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid337timestamp1532414877239.png" alt="此处输入图片的描述"></p>
<p>更多 tr 的使用，你可以使用<code>--help</code>或者<code>man tr</code>获得。</p>
<h3 id="2-2-col-命令"><a href="#2-2-col-命令" class="headerlink" title="2.2 col 命令"></a>2.2 col 命令</h3><p>col 命令可以将<code>Tab</code>换成对等数量的空格键，或反转这个操作。</p>
<h4 id="使用方式：-1"><a href="#使用方式：-1" class="headerlink" title="使用方式："></a>使用方式：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">col [option]<br></code></pre></td></tr></table></figure>

<h4 id="常用的选项有：-1"><a href="#常用的选项有：-1" class="headerlink" title="常用的选项有："></a>常用的选项有：</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-x</code></td>
<td>将<code>Tab</code>转换为空格</td>
</tr>
<tr>
<td><code>-h</code></td>
<td>将空格转换为<code>Tab</code>（默认选项）</td>
</tr>
</tbody></table>
<h4 id="操作举例：-1"><a href="#操作举例：-1" class="headerlink" title="操作举例："></a>操作举例：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 /etc/protocols 中的不可见字符，可以看到很多 ^I ，这其实就是 Tab 转义成可见字符的符号</span><br>$ cat -A /etc/protocols<br><span class="hljs-comment"># 使用 col -x 将 /etc/protocols 中的 Tab 转换为空格,然后再使用 cat 查看，你发现 ^I 不见了</span><br>$ cat /etc/protocols | col -x | cat -A<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid337timestamp1532414886554.png" alt="此处输入图片的描述"></p>
<h3 id="2-3-join-命令"><a href="#2-3-join-命令" class="headerlink" title="2.3 join 命令"></a>2.3 join 命令</h3><p>学过数据库的用户对这个应该不会陌生，这个命令就是用于将两个文件中包含相同内容的那一行合并在一起。</p>
<h4 id="使用方式：-2"><a href="#使用方式：-2" class="headerlink" title="使用方式："></a>使用方式：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">join [option]... file1 file2<br></code></pre></td></tr></table></figure>

<h4 id="常用的选项有：-2"><a href="#常用的选项有：-2" class="headerlink" title="常用的选项有："></a>常用的选项有：</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-t</code></td>
<td>指定分隔符，默认为空格</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>忽略大小写的差异</td>
</tr>
<tr>
<td><code>-1</code></td>
<td>指明第一个文件要用哪个字段来对比，默认对比第一个字段</td>
</tr>
<tr>
<td><code>-2</code></td>
<td>指明第二个文件要用哪个字段来对比，默认对比第一个字段</td>
</tr>
</tbody></table>
<h4 id="操作举例：-2"><a href="#操作举例：-2" class="headerlink" title="操作举例："></a>操作举例：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /home/shiyanlou<br><span class="hljs-comment"># 创建两个文件</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1 hello&#x27;</span> &gt; file1<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1 shiyanlou&#x27;</span> &gt; file2<br>$ join file1 file2<br><span class="hljs-comment"># 将/etc/passwd与/etc/shadow两个文件合并，指定以&#x27;:&#x27;作为分隔符</span><br>$ sudo join -t<span class="hljs-string">&#x27;:&#x27;</span> /etc/passwd /etc/shadow<br><span class="hljs-comment"># 将/etc/passwd与/etc/group两个文件合并，指定以&#x27;:&#x27;作为分隔符, 分别比对第4和第3个字段</span><br>$ sudo join -t<span class="hljs-string">&#x27;:&#x27;</span> -1 4 /etc/passwd -2 3 /etc/group<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid337timestamp1532414902443.png" alt="此处输入图片的描述" style="zoom: 80%;"> <img src="https://doc.shiyanlou.com/document-uid735639labid337timestamp1532414948354.png" alt="此处输入图片的描述" style="zoom: 80%;"></p>
<h3 id="2-4-paste-命令"><a href="#2-4-paste-命令" class="headerlink" title="2.4 paste 命令"></a>2.4 paste 命令</h3><p><code>paste</code>这个命令与<code>join</code> 命令类似，它是在不对比数据的情况下，简单地将多个文件合并一起，以<code>Tab</code>隔开。</p>
<h4 id="使用方式：-3"><a href="#使用方式：-3" class="headerlink" title="使用方式："></a>使用方式：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">paste [option] file...<br></code></pre></td></tr></table></figure>

<h4 id="常用的选项有：-3"><a href="#常用的选项有：-3" class="headerlink" title="常用的选项有："></a>常用的选项有：</h4><table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-d</code></td>
<td>指定合并的分隔符，默认为 Tab</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>不合并到一行，每个文件为一行</td>
</tr>
</tbody></table>
<h4 id="操作举例：-3"><a href="#操作举例：-3" class="headerlink" title="操作举例："></a>操作举例：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> hello &gt; file1<br>$ <span class="hljs-built_in">echo</span> shiyanlou &gt; file2<br>$ <span class="hljs-built_in">echo</span> www.lanqiao.cn &gt; file3<br>$ paste -d <span class="hljs-string">&#x27;:&#x27;</span> file1 file2 file3<br>$ paste -s file1 file2 file3<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid337timestamp1532414967936.png" alt="此处输入图片的描述"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>七、命令顺序控制与管道</title>
    <url>/posts/5499ad08.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="七、命令顺序控制与管道"><a href="#七、命令顺序控制与管道" class="headerlink" title="七、命令顺序控制与管道"></a>七、命令顺序控制与管道</h1><h2 id="1-1-实验内容"><a href="#1-1-实验内容" class="headerlink" title="1.1 实验内容"></a>1.1 实验内容</h2><p>顺序执行、选择执行、管道、cut 命令、grep 命令、wc 命令、sort 命令等，高效率使用 Linux 的技巧。</p>
<h2 id="1-2-实验知识点"><a href="#1-2-实验知识点" class="headerlink" title="1.2 实验知识点"></a>1.2 实验知识点</h2><ul>
<li><code>cut</code>，<code>grep</code>，<code>wc</code>，<code>sort</code>命令的使用</li>
<li>管道的理解</li>
</ul>
<h1 id="二、命令执行顺序的控制"><a href="#二、命令执行顺序的控制" class="headerlink" title="二、命令执行顺序的控制"></a>二、命令执行顺序的控制</h1><p>通常情况下，我们每次只能在终端输入一条命令，按下回车执行，执行完成后，我们再输入第二条命令，然后再按回车执行……,当有时候我们会一次输入多条命令，这个时候的执行过程又是如何的呢？下面我们将为大家详细讲解下命令的执行顺序的控制问题。</p>
<h2 id="2-1-顺序执行多条命令"><a href="#2-1-顺序执行多条命令" class="headerlink" title="2.1 顺序执行多条命令"></a>2.1 顺序执行多条命令</h2><p>当我们需要使用<code>apt-get</code>安装一个软件，然后安装完成后立即运行安装的软件（或命令工具），又恰巧你的主机才更换的软件源还没有更新软件列表（比如之前我们的环境中，每次重新开始实验就得 sudo apt-get update，现在已经没有这个问题了）,那么你可能会有如下一系列操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt-get update<br><span class="hljs-comment"># 等待——————————然后输入下面的命令</span><br>$ sudo apt-get install some-tool //这里some-tool是指具体的软件包<br><span class="hljs-comment"># 等待——————————然后输入下面的命令</span><br>$ some-tool<br></code></pre></td></tr></table></figure>

<p>这时你可能就会想：要是我可以一次性输入完，让它自己去依次执行各命令就好了，这就是我们这一小节要解决的问题。</p>
<p>简单的顺序执行你可以使用<code>;</code>来完成，比如上述操作你可以：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt-get update;sudo apt-get install some-tool;some-tool<br><span class="hljs-comment"># 让它自己运行</span><br></code></pre></td></tr></table></figure>

<h2 id="2-2-有选择的执行命令"><a href="#2-2-有选择的执行命令" class="headerlink" title="2.2 有选择的执行命令"></a>2.2 有选择的执行命令</h2><p>关于上面的操作，不知你有没有思考过一个问题，如果我们在让它自动顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖于上一条命令的结果，那么就会造成花了时间，最终却得到一个错误的结果，而且有时候直观的看你还无法判断结果是否正确。那么我们需要能够有选择性的来执行命令，比如上一条命令执行成功才继续下一条，或者不成功又该做出其它什么处理,比如我们使用<code>which</code>来查找是否安装某个命令，如果找到就执行该命令，否则什么也不做（虽然这个操作没有什么实际意义，但可帮你更好的理解一些概念）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">which</span> cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~<br></code></pre></td></tr></table></figure>

<p>你如果没有安装<code>cowsay</code>，你可以先执行一次上述命令，你会发现什么也没发生，你再安装好之后你再执行一次上述命令，你也会发现一些惊喜。</p>
<p>上面的<code>&amp;&amp;</code>就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回 0 则执行后面的，否则不执行，你可以从<code>$?</code>环境变量获取上一次命令的返回结果：</p>
<img src="https://doc.shiyanlou.com/document-uid1labid63timestamp1544148440172.png" alt="此处输入图片的描述" style="zoom:80%;">

<p>学习过 C 语言的用户应该知道在 C 语言里面<code>&amp;&amp;</code>表示逻辑与，而且还有一个<code>||</code>表示逻辑或，同样 Shell 也有一个<code>||</code>，它们的区别就在于，shell 中的这两个符号除了也可用于表示逻辑与和或之外，就是可以实现这里的命令执行顺序的简单控制。<code>||</code>在这里就是与<code>&amp;&amp;</code>相反的控制效果，当上一条命令执行结果为 ≠0($?≠0)时则执行它后面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">which</span> cowsay&gt;/dev/null || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;cowsay has not been install, please run &#x27;sudo apt-get install cowsay&#x27; to install&quot;</span><br></code></pre></td></tr></table></figure>

<p>除了上述基本的使用之外，我们还可以结合着<code>&amp;&amp;</code>和<code>||</code>来实现一些操作，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">which</span> cowsay&gt;/dev/null &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;exist&quot;</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;not exist&quot;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid63timestamp1532414664955.png" alt="此处输入图片的描述"></p>
<p>我画个流程图来解释一下上面的流程：</p>
<p><img src="https://doc.shiyanlou.com/linux_base/8-3.png" alt="img"></p>
<h1 id="三、管道"><a href="#三、管道" class="headerlink" title="三、管道"></a>三、管道</h1><p>管道是什么？管道是一种==通信机制==，通常用于进程间的通信（也可通过 socket 进行网络通信），它表现出来的形式就是==将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)==。</p>
<p>管道又分为==匿名管道==和==具名管道==（这里将不会讨论在源程序中使用系统调用创建并使用管道的情况，它与命令行的管道在内核中实际都是采用相同的机制）。我们在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由<code>|</code>分隔符表示，<code>|</code>在前面的内容中我们已经多次使用到了。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。下面我们就将通过一些常用的可以使用管道的”过滤程序”来帮助你熟练管道的使用。</p>
<h2 id="3-1-试用"><a href="#3-1-试用" class="headerlink" title="3.1 试用"></a>3.1 试用</h2><p>先试用一下管道，比如查看<code>/etc</code>目录下有哪些文件和目录，使用<code>ls</code>命令来查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ ls -al /etc<br></code></pre></td></tr></table></figure>

<p>有太多内容，屏幕不能完全显示，这时候可以使用滚动条或快捷键滚动窗口来查看。不过这时候可以使用管道：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ ls -al /etc | less<br></code></pre></td></tr></table></figure>

<p>通过管道将前一个命令(<code>ls</code>)的输出作为下一个命令(<code>less</code>)的输入，然后就可以一行一行地看。</p>
<h2 id="3-2-cut-命令，打印每一行的某一字段"><a href="#3-2-cut-命令，打印每一行的某一字段" class="headerlink" title="3.2 cut 命令，打印每一行的某一字段"></a>3.2 cut 命令，打印每一行的某一字段</h2><p>打印<code>/etc/passwd</code>文件中以<code>:</code>为分隔符的第 1 个字段和第 6 个字段分别表示用户名和其家目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ cut &#x2F;etc&#x2F;passwd -d &#39;:&#39; -f 1,6<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid63timestamp1532414685006.png" alt="此处输入图片的描述"></p>
<p>打印<code>/etc/passwd</code>文件中每一行的前 N 个字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前五个（包含第五个）</span><br>$ cut /etc/passwd -c -5<br><span class="hljs-comment"># 前五个之后的（包含第五个）</span><br>$ cut /etc/passwd -c 5-<br><span class="hljs-comment"># 第五个</span><br>$ cut /etc/passwd -c 5<br><span class="hljs-comment"># 2到5之间的（包含第五个）</span><br>$ cut /etc/passwd -c 2-5<br></code></pre></td></tr></table></figure>

<h2 id="3-3-grep-命令，在文本中或-stdin-中查找匹配字符串"><a href="#3-3-grep-命令，在文本中或-stdin-中查找匹配字符串" class="headerlink" title="3.3 grep 命令，在文本中或 stdin 中查找匹配字符串"></a>3.3 grep 命令，在文本中或 stdin 中查找匹配字符串</h2><p><code>grep</code>命令是很强大的，也是相当常用的一个命令，它结合正则表达式可以实现很复杂却很高效的匹配和查找，不过在学习正则表达式之前，这里介绍它简单的使用，而关于正则表达式后面将会有单独一小节介绍到时会再继续学习<code>grep</code>命令和其他一些命令。</p>
<p><code>grep</code>命令的一般形式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep [命令选项]... 用于匹配的表达式 [文件]...<br></code></pre></td></tr></table></figure>

<p>还是先体验一下，我们搜索<code>/home/shiyanlou</code>目录下所有包含”shiyanlou”的文本文件，并显示出现在文本中的行号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ grep -rnI <span class="hljs-string">&quot;shiyanlou&quot;</span> ~<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid63timestamp1532414709836.png" alt="此处输入图片的描述"></p>
<p><code>-r</code> 参数表示递归搜索子目录中的文件,<code>-n</code>表示打印匹配项行号，<code>-I</code>表示忽略二进制文件。这个操作实际没有多大意义，但可以感受到<code>grep</code>命令的强大与实用。</p>
<p>当然也可以在匹配字段中使用正则表达式，下面简单的演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看环境变量中以&quot;yanlou&quot;结尾的字符串</span><br>$ <span class="hljs-built_in">export</span> | grep <span class="hljs-string">&quot;.*yanlou$&quot;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid63timestamp1532414725827.png" alt="此处输入图片的描述"></p>
<p>其中<code>$</code>就表示一行的末尾。</p>
<h2 id="3-4-wc-命令，简单小巧的计数工具"><a href="#3-4-wc-命令，简单小巧的计数工具" class="headerlink" title="3.4 wc 命令，简单小巧的计数工具"></a>3.4 wc 命令，简单小巧的计数工具</h2><p>wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出<code>/etc/passwd</code>文件的统计信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ wc /etc/passwd<br></code></pre></td></tr></table></figure>

<p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 行数</span><br>$ wc -l /etc/passwd<br><span class="hljs-comment"># 单词数</span><br>$ wc -w /etc/passwd<br><span class="hljs-comment"># 字节数</span><br>$ wc -c /etc/passwd<br><span class="hljs-comment"># 字符数</span><br>$ wc -m /etc/passwd<br><span class="hljs-comment"># 最长行字节数</span><br>$ wc -L /etc/passwd<br></code></pre></td></tr></table></figure>

<p><strong>注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于 2 个字节的，具体数目是由字符编码决定的</strong></p>
<p><img src="https://doc.shiyanlou.com/document-uid735639labid63timestamp1532414808838.png" alt="此处输入图片的描述"></p>
<p>再来结合管道来操作一下，下面统计 /etc 下面所有目录数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ ls -dl &#x2F;etc&#x2F;*&#x2F; | wc -l<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6125timestamp1523946094712.png" alt="此处输入图片的描述"></p>
<h2 id="3-5-sort-排序命令"><a href="#3-5-sort-排序命令" class="headerlink" title="3.5 sort 排序命令"></a>3.5 sort 排序命令</h2><p>这个命令前面我们也是用过多次，功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。</p>
<p>默认为字典排序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ cat /etc/passwd | sort<br></code></pre></td></tr></table></figure>

<p>反转排序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ cat /etc/passwd | sort -r<br></code></pre></td></tr></table></figure>

<p>按特定字段排序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ cat /etc/passwd | sort -t<span class="hljs-string">&#x27;:&#x27;</span> -k 3<br></code></pre></td></tr></table></figure>

<p>上面的<code>-t</code>参数用于指定字段的分隔符，这里是以”:”作为分隔符；<code>-k 字段号</code>用于指定对哪一个字段进行排序。这里<code>/etc/passwd</code>文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上<code>-n</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ cat /etc/passwd | sort -t<span class="hljs-string">&#x27;:&#x27;</span> -k 3 -n<br></code></pre></td></tr></table></figure>

<p>注意观察第二个冒号后的数字： </p>
<center><img src="https://doc.shiyanlou.com/document-uid735639labid63timestamp1532414849333.png" alt="此处输入图片的描述" style="zoom:50%;"></center>

<h2 id="3-6-uniq-去重命令"><a href="#3-6-uniq-去重命令" class="headerlink" title="3.6 uniq 去重命令"></a>3.6 uniq 去重命令</h2><p><code>uniq</code>命令可以用于过滤或者输出重复行。</p>
<ul>
<li>过滤重复行</li>
</ul>
<p>我们可以使用<code>history</code>命令查看最近执行过的命令（实际为读取${SHELL}_history 文件,如我们环境中的~/.zsh_history 文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">history</span> | cut -c 8- | cut -d <span class="hljs-string">&#x27; &#x27;</span> -f 1 | uniq<br></code></pre></td></tr></table></figure>

<p>然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是<strong>因为<code>uniq</code>命令只能去连续重复的行，不是全文去重</strong>，所以要达到预期效果，我们先排序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">history</span> | cut -c 8- | cut -d <span class="hljs-string">&#x27; &#x27;</span> -f 1 | sort | uniq<br><span class="hljs-comment"># 或者$ history | cut -c 8- | cut -d &#x27; &#x27; -f 1 | sort -u</span><br></code></pre></td></tr></table></figure>

<p>这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。</p>
<ul>
<li>输出重复行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出重复过的行（重复的只输出一个）及重复次数</span><br>$ <span class="hljs-built_in">history</span> | cut -c 8- | cut -d <span class="hljs-string">&#x27; &#x27;</span> -f 1 | sort | uniq -dc<br><span class="hljs-comment"># 输出所有重复的行</span><br>$ <span class="hljs-built_in">history</span> | cut -c 8- | cut -d <span class="hljs-string">&#x27; &#x27;</span> -f 1 | sort | uniq -D<br></code></pre></td></tr></table></figure>

<p>文本处理命令还有很多，下一节将继续介绍一些常用的文本处理的命令。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>六、Linux任务计划crontab</title>
    <url>/posts/433d7c09.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux任务计划crontab"><a href="#Linux任务计划crontab" class="headerlink" title="Linux任务计划crontab"></a>Linux任务计划crontab</h1><h2 id="一、实验介绍"><a href="#一、实验介绍" class="headerlink" title="一、实验介绍"></a>一、实验介绍</h2><h3 id="1-1-实验内容"><a href="#1-1-实验内容" class="headerlink" title="1.1 实验内容"></a>1.1 实验内容</h3><p>我们时常会有一些定期定时的任务，如周期性的清理一下／tmp，周期性的去备份一次数据库，周期性的分析日志等等。而且有时候因为某些因素的限制，执行该任务的时间会很尴尬。本课程将带你很好的利用 Linux 系统的计划工具</p>
<h3 id="1-2-实验知识点"><a href="#1-2-实验知识点" class="headerlink" title="1.2 实验知识点"></a>1.2 实验知识点</h3><ul>
<li>crontab 语法</li>
</ul>
<h3 id="1-3-参考资料"><a href="#1-3-参考资料" class="headerlink" title="1.3 参考资料"></a>1.3 参考资料</h3><p>本节部分内容参考以下文档制作：</p>
<ul>
<li><a href="http://linux.vbird.org/linux_basic/0430cron.php">例行性工作排程(crontab) - 鸟哥私房菜</a></li>
<li><a href="http://baike.baidu.com/link?url=h_n27RWno87VR4N0xoTGQfcnhoWXH_5JtLNEjuTqisXIasgLiUbWWjJwIkc3vnEIJrCrlZ1oQ4q3xrTz8VRtd_">Linux Crontab 百度百科</a></li>
</ul>
<h2 id="二、crontab-的使用"><a href="#二、crontab-的使用" class="headerlink" title="二、crontab 的使用"></a>二、crontab 的使用</h2><blockquote>
<p>crontab 命令常见于 Unix 和类 Unix 的操作系统之中（Linux 就属于类 Unix 操作系统），用于设置周期性被执行的指令。</p>
</blockquote>
<h3 id="2-1-crontab简介"><a href="#2-1-crontab简介" class="headerlink" title="2.1 crontab简介"></a>2.1 crontab简介</h3><p>crontab 命令从输入设备读取指令，并将其存放于 crontab 文件中，以供之后读取和执行。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。</p>
<p>通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell 　 script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。</p>
<p>这里我们看一看 crontab 的格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Example of job definition:</span><br><span class="hljs-comment"># .---------------- minute (0 - 59)</span><br><span class="hljs-comment"># |  .------------- hour (0 - 23)</span><br><span class="hljs-comment"># |  |  .---------- day of month (1 - 31)</span><br><span class="hljs-comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="hljs-comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="hljs-comment"># |  |  |  |  |</span><br><span class="hljs-comment"># *  *  *  *  * user-name command to be executed</span><br></code></pre></td></tr></table></figure>

<h3 id="2-2-crontab准备"><a href="#2-2-crontab准备" class="headerlink" title="2.2 crontab准备"></a>2.2 crontab准备</h3><p>crontab 在本实验环境中需要做一些特殊的准备，首先我们会启动 rsyslog，以便我们可以通过日志中的信息来了解我们的任务是否真正的被执行了（在本实验环境中需要手动启动，而在自己本地中 Ubuntu 会默认自行启动不需要手动启动）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install -y rsyslog<br>sudo service rsyslog start<br></code></pre></td></tr></table></figure>

<img src="https://dn-simplecloud.shiyanlou.com/1135081468201394787" alt="service-rsyslog-start" style="zoom:67%;">

<p>在本实验环境中 crontab 也是不被默认启动的，同时不能在后台由 upstart 来管理，所以需要我们来启动它:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo cron －f &amp;<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523941816405.png" alt="此处输入图片的描述"></p>
<h3 id="2-3-crontab使用"><a href="#2-3-crontab使用" class="headerlink" title="2.3 crontab使用"></a>2.3 crontab使用</h3><p>下面将开始 crontab 的使用了，我们通过下面一个命令来添加一个计划任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">crontab -e<br></code></pre></td></tr></table></figure>

<p>第一次启动会出现这样一个画面，这是让我们选择编辑的工具，选择第二个基本的 vim 就可以了</p>
<img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523941985569.png" alt="此处输入图片的描述" style="zoom:67%;">

<p>而选择后我们会进入这样一个画面，这就是添加计划的地方了，与一般的配置文档相同，以#号开头的都是注释，通过文档的最后一排我们可以猜猜 crontab 的格式是什么样的呢？</p>
<img src="https://dn-simplecloud.shiyanlou.com/1135081468202029108" alt="实验楼" style="zoom:67%;">

<p>详细的格式可以使用上一节中学习到的 man 命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">man crontab<br></code></pre></td></tr></table></figure>

<p>在了解命令格式之后，我们通过这样的一个例子来完成一个任务的添加，在文档的最后一排加上这样一排命令,该任务是每分钟我们会在/home/shiyanlou 目录下创建一个以当前的年月日时分秒为名字的空白文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">*&#x2F;1 * * * * touch &#x2F;home&#x2F;shiyanlou&#x2F;$(date +\%Y\%m\%d\%H\%M\%S)<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> “ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。</p>
</blockquote>
<p>添加成功后我们会得到最后一排 installing new crontab 的一个提示</p>
<img src="https://dn-simplecloud.shiyanlou.com/1135081468203483143" alt="实验楼" style="zoom:67%;">

<p>当然我们也可以通过这样的一个指令来查看我们添加了哪些任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">crontab -l<br></code></pre></td></tr></table></figure>

<p>通过图中的显示，我们也可以看出，我们正确的保存并且添加成功了该任务的</p>
<img src="https://dn-simplecloud.shiyanlou.com/1135081468204230683" alt="实验楼" style="zoom:67%;">

<p>虽然我们添加了任务，但是如果 cron 的守护进程并没有启动，它根本都不会监测到有任务，当然也就不会帮我们执行，我们可以通过以下 2 种方式来确定我们的 cron 是否成功的在后台启动，默默的帮我们做事，若是没有就得执行上文准备中的第二步了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps aux | grep cron<br><br>or<br><br>pgrep cron<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523942683532.png" alt="此处输入图片的描述"></p>
<p>通过下图可以看到任务在创建之后，执行了几次，生成了一些文件，且每分钟生成一个：</p>
<p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523943532369.png" alt="此处输入图片的描述"></p>
<p>我们通过这样一个命令可以查看到执行任务命令之后在日志中的信息反馈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">sudo tail -f &#x2F;var&#x2F;log&#x2F;syslog<br></code></pre></td></tr></table></figure>

<p>从图中我们可以看到分别在 13 点 28、29、30 分的 01 秒为我们在 shiyanlou 用户的家目录下创建了文件</p>
<img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523943327065.png" alt="此处输入图片的描述" style="zoom:80%;">

<p>当我们并不需要这个任务的时候我们可以使用这么一个命令去删除任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">crontab -r<br></code></pre></td></tr></table></figure>

<p>通过图中我们可以看出我们删除之后再查看任务列表，系统已经显示该用户并没有任务哦</p>
<p><img src="https://doc.shiyanlou.com/document-uid600404labid6124timestamp1523943647348.png" alt="此处输入图片的描述"></p>
<h2 id="三、crontab的深入"><a href="#三、crontab的深入" class="headerlink" title="三、crontab的深入"></a>三、crontab的深入</h2><p>每个用户使用 <code>crontab -e</code> 添加计划任务，都会在 <code>/var/spool/cron/crontabs</code> 中添加一个该用户自己的任务文档，这样目的是为了隔离。</p>
<img src="https://dn-simplecloud.shiyanlou.com/1135081468206283987" alt="实验楼" style="zoom:80%;">

<p>如果是系统级别的定时任务，应该如何处理？只需要以 sudo 权限编辑 <code>/etc/crontab</code> 文件就可以。</p>
<p>cron 服务监测时间最小单位是分钟，所以 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron/crontabs 里面的內容。</p>
<p>在 /etc 目录下，cron 相关的目录有下面几个：</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081468206856712" alt="实验楼"></p>
<p>每个目录的作用：</p>
<ol>
<li>/etc/cron.daily，目录下的脚本会每天执行一次，在每天的 6 点 25 分时运行；</li>
<li>/etc/cron.hourly，目录下的脚本会每个小时执行一次，在每小时的 17 分钟时运行；</li>
<li>/etc/cron.monthly，目录下的脚本会每月执行一次，在每月 1 号的 6 点 52 分时运行；</li>
<li>/etc/cron.weekly，目录下的脚本会每周执行一次，在每周第七天的 6 点 47 分时运行；</li>
</ol>
<p>系统默认执行时间可以根据需求进行修改。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>五、Linux下的帮助命令</title>
    <url>/posts/31620285.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux下的帮助命令"><a href="#Linux下的帮助命令" class="headerlink" title="Linux下的帮助命令"></a>Linux下的帮助命令</h1><h2 id="一、实验介绍"><a href="#一、实验介绍" class="headerlink" title="一、实验介绍"></a>一、实验介绍</h2><h3 id="1-实验内容"><a href="#1-实验内容" class="headerlink" title="1 实验内容"></a>1 实验内容</h3><p>我们时常使用 Linux 的命令，一些常用的命令即使不背我们也能记住，而一些较长的命令或是一些不常用的参数甚至是不常用的命令需要用时怎么也想不出来。本课程将带你好好利用 Linux 系统自带的帮助工具与文档。</p>
<span id="more"></span>

<h3 id="1-实验知识点"><a href="#1-实验知识点" class="headerlink" title="1 实验知识点"></a>1 实验知识点</h3><ul>
<li>内建命令与外部命令之分</li>
<li>help , man , info 命令的使用以及区别</li>
</ul>
<h2 id="二、内建命令与外部命令"><a href="#二、内建命令与外部命令" class="headerlink" title="二、内建命令与外部命令"></a>二、内建命令与外部命令</h2><p>什么是内建命令，什么是外部命令呢？这和帮助命令又有什么关系呢？</p>
<p>因为有一些查看帮助的工具在内建命令与外建命令上是有区别对待的。</p>
<blockquote>
<p><strong>内建命令</strong>实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在 bash 源码的 builtins 里面的，由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。</p>
</blockquote>
<blockquote>
<p><strong>外部命令</strong>是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调入内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin 等等。比如：ls、vi 等。</p>
</blockquote>
<p>简单来说就是：一个是天生自带的天赋技能，一个是后天得来的附加技能。我们可以使用　 type 命令来区分命令是内建的还是外部的。例如这两个得出的结果是不同的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">type</span> <span class="hljs-built_in">exit</span><br><br><span class="hljs-built_in">type</span> vim<br></code></pre></td></tr></table></figure>

<p>得到的是两种结果，若是对 ls 你还能得到第三种结果</p>
<p><img src="https://doc.shiyanlou.com/document-uid600404labid6123timestamp1523930371175.png" alt="此处输入图片的描述"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#得到这样的结果说明是内建命令，正如上文所说内建命令都是在 bash 源码中的 builtins 的.def中</span><br>xxx is a shell <span class="hljs-built_in">builtin</span><br><span class="hljs-comment">#得到这样的结果说明是外部命令，正如上文所说，外部命令在/usr/bin or /usr/sbin等等中</span><br>xxx is /usr/bin/xxx<br><span class="hljs-comment">#若是得到alias的结果，说明该指令为命令别名所设定的名称；</span><br>xxx is an <span class="hljs-built_in">alias</span> <span class="hljs-keyword">for</span> xx --xxx<br></code></pre></td></tr></table></figure>

<h2 id="三、帮助命令的使用"><a href="#三、帮助命令的使用" class="headerlink" title="三、帮助命令的使用"></a>三、帮助命令的使用</h2><h3 id="1-help命令"><a href="#1-help命令" class="headerlink" title="1. help命令"></a>1. help命令</h3><p>本实验环境是 zsh，而 zsh 中内置并没有 help 命令，我们可以进入 bash 中，在 bash 中内置有该命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">bash<br></code></pre></td></tr></table></figure>

<p>做好了以上的准备，我们就可以愉快的使用 help 命令了，我们可以尝试下这个命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">help</span> ls<br></code></pre></td></tr></table></figure>

<p>得到的结果如图所示，为什么是这样的结果？</p>
<p><img src="https://doc.shiyanlou.com/document-uid600404labid6123timestamp1523930924973.png" alt="此处输入图片的描述"></p>
<p>因为 help 命令是用于显示 shell 内建命令的简要帮助信息。帮助信息中显示有该命令的简要说明以及一些参数的使用以及说明，一定记住 help 命令只能用于显示内建命令的帮助信息，不然就会得到你刚刚得到的结果。</p>
<p>那如果是外部命令怎么办，不能就这么抛弃它呀。其实外部命令基本上都有一个参数–help,这样就可以得到相应的帮助，看到你想要的东西了。试试下面这个命令是不是能看到你想要的东西了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ls --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6123timestamp1523931303648.png" alt="此处输入图片的描述"></p>
<h3 id="3-man命令"><a href="#3-man命令" class="headerlink" title="3. man命令"></a>3. man命令</h3><p>你可以尝试下这个命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">man ls<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081467871829217" alt="实验楼"></p>
<p>得到的内容比用 help 更多更详细，而且　 man 　没有内建与外部命令的区分，因为 man 工具是显示系统手册页中的内容，也就是一本电子版的字典，这些内容大多数都是对命令的解释信息，还有一些相关的描述。通过查看系统文档中的 man 也可以得到程序的更多相关信息和 Linux 的更多特性。</p>
<p>是不是好用许多，当然也不代表 help 就没有存在的必要，当你非常紧急只是忘记该用哪个参数的时候，help 这种显示简单扼要的信息就特别实用，若是不太紧急的时候就可以用 man 这种详细描述的查询方式</p>
<p>在尝试上面这个命令时我们会发现最左上角显示“ LS （1）”，在这里，“ LS ”表示手册名称，而“（1）”表示该手册位于第一章节。这个章节又是什么？在 man 手册中一共有这么几个章节</p>
<table>
<thead>
<tr>
<th>章节数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>1</code></td>
<td>Standard commands （标准命令）</td>
</tr>
<tr>
<td><code>2</code></td>
<td>System calls （系统调用）</td>
</tr>
<tr>
<td><code>3</code></td>
<td>Library functions （库函数）</td>
</tr>
<tr>
<td><code>4</code></td>
<td>Special devices （设备说明）</td>
</tr>
<tr>
<td><code>5</code></td>
<td>File formats （文件格式）</td>
</tr>
<tr>
<td><code>6</code></td>
<td>Games and toys （游戏和娱乐）</td>
</tr>
<tr>
<td><code>7</code></td>
<td>Miscellaneous （杂项）</td>
</tr>
<tr>
<td><code>8</code></td>
<td>Administrative Commands （管理员命令）</td>
</tr>
<tr>
<td><code>9</code></td>
<td>其他（Linux 特定的）， 用来存放内核例行程序的文档。</td>
</tr>
</tbody></table>
<p>打开手册之后我们可以通过 pgup 与 pgdn 或者上下键来上下翻看，可以按 q 退出当前页面</p>
<h3 id="3-info命令"><a href="#3-info命令" class="headerlink" title="3. info命令"></a>3. info命令</h3><p>要是你觉得 man 显示的信息都还不够，满足不了你的需求，那试试 info 命令，注意实验楼的环境中没有安装 info，可以手动安装，安装和操作步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 info</span><br>$ sudo apt-get update<br>$ sudo apt-get install info<br><span class="hljs-comment"># 查看 ls 命令的 info</span><br>$ info ls<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081468210358613" alt="Info_for_ls"></p>
<p>得到的信息是不是比 man 还要多了，info 来自自由软件基金会的 GNU 项目，是 GNU 的超文本帮助系统，能够更完整的显示出 GNU 信息。所以得到的信息当然更多</p>
<p>man 和 info 就像两个集合，它们有一个交集部分，但与 man 相比，info 工具可显示更完整的　 GNU 　工具信息。若 man 页包含的某个工具的概要信息在 info 中也有介绍，那么 man 页中会有“请参考 info 页更详细内容”的字样。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>十四、Linux 日志系统</title>
    <url>/posts/de6197c0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux-日志系统"><a href="#Linux-日志系统" class="headerlink" title="Linux 日志系统"></a>Linux 日志系统</h1><h2 id="一、实验介绍"><a href="#一、实验介绍" class="headerlink" title="一、实验介绍"></a>一、实验介绍</h2><h3 id="1-1-实验内容"><a href="#1-1-实验内容" class="headerlink" title="1.1 实验内容"></a>1.1 实验内容</h3><p>日志数据可以是有价值的信息宝库，也可以是毫无价值的数据泥潭。它可以记录下系统产生的所有行为，并按照某种规范表达出来。我们可以使用日志系统所记录的信息为系统进行排错，优化系统的性能，或者根据这些信息调整系统的行为。收集你想要的数据，分析出有价值的信息，可以提高系统、产品的安全性，还可以帮助开发完善代码，优化产品。日志会成为在事故发生后查明“发生了什么”的一个很好的“取证”信息来源。日志可以为审计进行审计跟踪。</p>
<h3 id="1-2-实验知识点"><a href="#1-2-实验知识点" class="headerlink" title="1.2 实验知识点"></a>1.2 实验知识点</h3><ul>
<li>常见的日志</li>
<li>配置的日志</li>
<li>轮替的日志</li>
</ul>
<h2 id="二、常见的日志"><a href="#二、常见的日志" class="headerlink" title="二、常见的日志"></a>二、常见的日志</h2><p>日志是一个系统管理员，一个运维人员，甚至是开发人员不可或缺的东西，系统用久了偶尔也会出现一些错误，我们需要日志来给系统排错，在一些网络应用服务不能正常工作的时候，我们需要用日志来做问题定位，日志还是过往时间的记录本，我们可以通过它知道我们是否被不明用户登录过等等。</p>
<p>在 Linux 中大部分的发行版都内置使用 syslog 系统日志，那么通过前期的课程我们了解到常见的日志一般存放在 <code>/var/log</code> 中，我们来看看其中有哪些日志</p>
<p><img src="http://qgqz63fje.hb-bkt.clouddn.com/20201002110533" alt="实验楼"></p>
<p>根据图中所显示的日志，我们可以根据服务对象粗略的将日志分为两类</p>
<ul>
<li>系统日志</li>
<li>应用日志</li>
</ul>
<p>系统日志主要是存放系统内置程序或系统内核之类的日志信息如 <code>alternatives.log</code> 、<code>btmp</code> 等等，应用日志主要是我们装的第三方应用所产生的日志如 <code>tomcat7</code> 、<code>apache2</code> 等等。</p>
<p>接下来我们来看看常见的系统日志有哪些，他们都记录了怎样的信息</p>
<table>
<thead>
<tr>
<th>日志名称</th>
<th>记录信息</th>
</tr>
</thead>
<tbody><tr>
<td>alternatives.log</td>
<td>系统的一些更新替代信息记录</td>
</tr>
<tr>
<td>apport.log</td>
<td>应用程序崩溃信息记录</td>
</tr>
<tr>
<td>apt/history.log</td>
<td>使用 apt-get 安装卸载软件的信息记录</td>
</tr>
<tr>
<td>apt/term.log</td>
<td>使用 apt-get 时的具体操作，如 package 的下载、打开等</td>
</tr>
<tr>
<td>auth.log</td>
<td>登录认证的信息记录</td>
</tr>
<tr>
<td>boot.log</td>
<td>系统启动时的程序服务的日志信息</td>
</tr>
<tr>
<td>btmp</td>
<td>错误的信息记录</td>
</tr>
<tr>
<td>Consolekit/history</td>
<td>控制台的信息记录</td>
</tr>
<tr>
<td>dist-upgrade</td>
<td>dist-upgrade 这种更新方式的信息记录</td>
</tr>
<tr>
<td>dmesg</td>
<td>启动时，显示屏幕上内核缓冲信息，与硬件有关的信息</td>
</tr>
<tr>
<td>dpkg.log</td>
<td>dpkg 命令管理包的日志。</td>
</tr>
<tr>
<td>faillog</td>
<td>用户登录失败详细信息记录</td>
</tr>
<tr>
<td>fontconfig.log</td>
<td>与字体配置有关的信息记录</td>
</tr>
<tr>
<td>kern.log</td>
<td>内核产生的信息记录，在自己修改内核时有很大帮助</td>
</tr>
<tr>
<td>lastlog</td>
<td>用户的最近信息记录</td>
</tr>
<tr>
<td>wtmp</td>
<td>登录信息的记录。wtmp 可以找出谁正在进入系统，谁使用命令显示这个文件或信息等</td>
</tr>
<tr>
<td>syslog</td>
<td>系统信息记录</td>
</tr>
</tbody></table>
<p>而在本实验环境中没有 apport.log 是因为 apport 这个应用程序需要读取一些内核的信息来收集判断其他应用程序的信息，从而记录应用程序的崩溃信息。而在本实验环境中我们没有这个权限，所以将 apport 从内置应用值剔除，自然而然就没有它的日志信息了。</p>
<p>只闻其名，不见其人，我们并不能明白这些日志记录的内容。首先我们来看 <code>alternatives.log</code> 中的信息，在本实验环境中没有任何日志输出是因为刚刚启动的系统中并没有任何的更新迭代。我可以看看从其他地方截取过来的内容</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/x-www-browser x-www-browser /usr/bin/google-chrome-stable 200<br>update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/gnome-www-browser gnome-www-browser /usr/bin/google-chrome-stable 200<br>update-alternatives 2016-07-02 13:36:16: run with --install /usr/bin/google-chrome google-chrome /usr/bin/google-chrome-stable 200<br></code></pre></td></tr></table></figure>

<p>我们可以从中得到的信息有程序作用，日期，命令，成功与否的返回码。</p>
<p>我们用这样的命令来看看 <code>auth.log</code> 中的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo less /var/<span class="hljs-built_in">log</span>/auth.log<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469409885670" alt="实验楼"></p>
<p>我们可以从中得到的信息有日期与 ip 地址的来源以及的用户与工具。</p>
<p>在 <code>/var/log/apt</code> 文件夹中有两个日志文件 <code>history.log</code> 与 <code>term.log</code>，两个日志文件的区别在于 <code>history.log</code> 主要记录了进行了哪个操作，相关的依赖有哪些，而 <code>term.log</code> 则是较为具体的一些操作，主要就是下载包，打开包，安装包等等的细节操作。</p>
<p>如果是刚刚开启的新系统，那么按理说这些日志应该都是空的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo cat /var/<span class="hljs-built_in">log</span>/apt/history.log<br>sudo cat /var/<span class="hljs-built_in">log</span>/apt/term.log<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/1379/871732/7bc699b28ff48cefee31fa859af518d9-0" alt="图片描述"></p>
<p>但是在实验环境中因为是启动的我们定制后的环境，所以两个日志中还残留了配置镜像的记录。可以先删除这两个文件然后再执行新的安装命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo rm /var/<span class="hljs-built_in">log</span>/apt/history.log<br>sudo rm /var/<span class="hljs-built_in">log</span>/apt/term.log<br></code></pre></td></tr></table></figure>

<p>我们来安装 git 这个程序，因为实验环境里已经预装了 git，所以这里真正执行的操作是一个更新的操作，但这并不影响。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install git<br></code></pre></td></tr></table></figure>

<p><img src="http://qgqz63fje.hb-bkt.clouddn.com/20201002110540.png" alt="图片描述"></p>
<p>成功的执行之后我们再来查看两个日志的内容变化：</p>
<p><img src="https://doc.shiyanlou.com/courses/1379/871732/dc97b5ebc3c1054d4e5a6070fa36773b-0" alt="图片描述"></p>
<p>其他的日志格式也都类似于之前我们所查看的日志，主要便是时间，操作。而这其中有两个比较特殊的日志，其查看的方式比较与众不同，因为这两个日志并不是 ASCII 文件而是被编码成了二进制文件，所以我们并不能直接使用 less、cat、more 这样的工具来查看，这两个日志文件是 wtmp，lastlog</p>
<p><img src="http://qgqz63fje.hb-bkt.clouddn.com/20201002110543.png" alt="实验楼"></p>
<p>我们查看的方法是使用 last 与 lastlog 工具来提取其中的信息</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469412472830" alt="实验楼"></p>
<p>关于这两个工具的更深入使用我们可以使用前面的学习过的 man 来查看</p>
<h2 id="三、配置的日志"><a href="#三、配置的日志" class="headerlink" title="三、配置的日志"></a>三、配置的日志</h2><p>这些日志是如何产生的？通过上面的例子我们可以看出大部分的日志信息似乎格式都很类似，并且都出现在这个文件夹中。</p>
<p>这样的实现可以通过两种方式：</p>
<ul>
<li>一种是由软件开发商自己来自定义日志格式然后指定输出日志位置；</li>
<li>一种方式就是 Linux 提供的日志服务程序，而我们这里系统日志是通过 syslog 来实现，提供日志管理服务。</li>
</ul>
<p>syslog 是一个系统日志记录程序，在早期的大部分 Linux 发行版都是内置 syslog，让其作为系统的默认日志收集工具，虽然随着时代的进步与发展，syslog 已经年老体衰跟不上时代的需求，所以他被 rsyslog 所代替了，较新的 Ubuntu、Fedora 等等都是默认使用 rsyslog 作为系统的日志收集工具</p>
<p>rsyslog 的全称是 rocket-fast system for log，它提供了高性能，高安全功能和模块化设计。rsyslog 能够接受各种各样的来源，将其输入，输出的结果到不同的目的地。rsyslog 可以提供超过每秒一百万条消息给目标文件。</p>
<p>这样能实时收集日志信息的程序是有其守护进程的，如 rsyslog 的守护进程便是 rsyslogd</p>
<p>因为一些原因本实验环境中默认并没有打开这个服务，我们可以手动开启这项服务，然后来查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install -y rsyslog<br>sudo service rsyslog start<br>ps aux | grep syslog<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469414492628" alt="实验楼"></p>
<p>既然它是一个服务，那么它便是可以配置，为我们提供一些我们自定义的服务</p>
<p>首先我们来看 rsyslog 的配置文件是什么样子的，而 rsyslog 的配置文件有两个，</p>
<ul>
<li>一个是 <code>/etc/rsyslog.conf</code></li>
<li>一个是 <code>/etc/rsyslog.d/50-default.conf</code>。</li>
</ul>
<p>第一个主要是配置的环境，也就是 rsyslog 加载什么模块，文件的所属者等；而第二个主要是配置的 Filter Conditions</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim /etc/rsyslog.conf<br><br>vim /etc/rsyslog.d/50-default.conf<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469414801715" alt="实验楼"></p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469433052645" alt="实验楼"></p>
<p>也不知道他在写什么，我们还是来看看 rsyslog 的结构框架，数据流的走向吧。</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469416361678" alt="实验楼"></p>
<p>通过这个简单的流程图我们可以知道 rsyslog 主要是由 Input、Output、Parser 这样三个模块构成的，并且了解到数据的简单走向，首先通过 Input module 来收集消息，然后将得到的消息传给 Parser module，通过分析模块的层层处理，将真正需要的消息传给 Output module，然后便输出至日志文件中。</p>
<p>上文提到过 rsyslog 号称可以提供超过每秒一百万条消息给目标文件，怎么只是这样简单的结构。我们可以通过下图来做更深入的了解</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469415269198" alt="实验楼"></p>
<p>（图片来源于<a href="http://www.rsyslog.com/doc/queues_analogy.html%EF%BC%89">http://www.rsyslog.com/doc/queues_analogy.html）</a></p>
<p>Rsyslog 架构如图中所示，从图中我们可以很清楚的看见，rsyslog 还有一个核心的功能模块便是 Queue，也正是因为它才能做到如此高的并发。</p>
<p>第一个模块便是 Input，该模块的主要功能就是从各种各样的来源收集 messages，通过这些接口实现：</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>im3195</td>
<td>RFC3195 Input Module</td>
</tr>
<tr>
<td>imfile</td>
<td>Text File Input Module</td>
</tr>
<tr>
<td>imgssapi</td>
<td>GSSAPI Syslog Input Module</td>
</tr>
<tr>
<td>imjournal</td>
<td>Systemd Journal Input Module</td>
</tr>
<tr>
<td>imklog</td>
<td>Kernel Log Input Module</td>
</tr>
<tr>
<td>imkmsg</td>
<td>/dev/kmsg Log Input Module</td>
</tr>
<tr>
<td>impstats</td>
<td>Generate Periodic Statistics of Internal Counters</td>
</tr>
<tr>
<td>imptcp</td>
<td>Plain TCP Syslog</td>
</tr>
<tr>
<td>imrelp</td>
<td>RELP Input Module</td>
</tr>
<tr>
<td>imsolaris</td>
<td>Solaris Input Module</td>
</tr>
<tr>
<td>imtcp</td>
<td>TCP Syslog Input Module</td>
</tr>
<tr>
<td>imudp</td>
<td>UDP Syslog Input Module</td>
</tr>
<tr>
<td>imuxsock</td>
<td>Unix Socket Input</td>
</tr>
</tbody></table>
<p>而 Output 中也有许多可用的接口，可以通过 man 或者官方的文档查看</p>
<p>而这些模块接口的使用需要通过 $ModLoad 指令来加载，那么返回上文的图中，配置生效的头两行可以看懂了，默认加载了 imklog、imuxsock 这两个模块</p>
<p>在配置中 rsyslog 支持三种配置语法格式：</p>
<ul>
<li>sysklogd</li>
<li>legacy rsyslog</li>
<li>RainerScript</li>
</ul>
<p>sysklogd 是老的简单格式，一些新的语法特性不支持。而 legacy rsyslog 是以 dollar 符($)开头的语法，在 v6 及以上的版本还在支持，就如上文所说的 <code>$ModLoad</code> 还有一些插件和特性只在此语法下支持。而以 <code>$</code> 开头的指令是全局指令，全局指令是 rsyslogd 守护进程的配置指令，每行只能有一个指令。 RainnerScript 是最新的语法。在官网上 rsyslog 大多推荐这个语法格式来配置</p>
<p>老的语法格式（sysklogd &amp; legacy rsyslog）是以行为单位。新的语法格式（RainnerScript）可以分割多行。</p>
<p>注释有两种语法:</p>
<ul>
<li>井号 #</li>
<li>C-style <code>/* .. */</code></li>
</ul>
<p>执行顺序: 指令在 rsyslog.conf 文件中是从上到下的顺序执行的。</p>
<p>模板是 rsyslog 一个重要的属性，它可以控制日志的格式，支持类似 template() 语句的基于 string 或 plugin 的模板，通过它我们可以自定义日志格式。</p>
<p>legacy 格式使用 $template 的语法，不过这个在以后要移除，所以最好使用新格式 template():，以免未来突然不工作了也不知道为什么</p>
<p>模板定义的形式有四种，适用于不同的输出模块，一般简单的格式，可以使用 string 的形式，复杂的格式，建议使用 list 的形式，使用 list 的形式，可以使用一些额外的属性字段（property statement）</p>
<p>如果不指定输出模板，rsyslog 会默认使用 RSYSLOG_DEFAULT。若想更深入的学习可以查看<a href="http://www.rsyslog.com/doc/v8-stable/configuration/index.html">官方文档</a></p>
<p>了解了 rsyslog 环境的配置文件之后，我们看向 <code>/etc/rsyslog.d/50-default.conf</code> 这个配置文件，这个文件中主要是配置的 Filter Conditions，也就是我们在流程图中所看见的 <code>Parser &amp; Filter Engine</code>，它的名字叫 Selectors 是过滤 syslog 的传统方法，他主要由两部分组成，<code>facility</code> 与 <code>priority</code>，其配置格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">facility.priority　　　　　log_location<br></code></pre></td></tr></table></figure>

<p>其中一个 priority 可以指定多个 facility，多个 facility 之间使用逗号 <code>,</code> 分割开</p>
<p>rsyslog 通过 Facility 的概念来定义日志消息的来源，以便对日志进行分类，Facility 的种类有：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>kern</td>
<td>内核消息</td>
</tr>
<tr>
<td>user</td>
<td>用户信息</td>
</tr>
<tr>
<td>mail</td>
<td>邮件系统消息</td>
</tr>
<tr>
<td>daemon</td>
<td>系统服务消息</td>
</tr>
<tr>
<td>auth</td>
<td>认证系统</td>
</tr>
<tr>
<td>authpriv</td>
<td>权限系统</td>
</tr>
<tr>
<td>syslog</td>
<td>日志系统自身消息</td>
</tr>
<tr>
<td>cron</td>
<td>计划安排</td>
</tr>
<tr>
<td>news</td>
<td>新闻信息</td>
</tr>
<tr>
<td>local0~7</td>
<td>由自定义程序使用</td>
</tr>
</tbody></table>
<p>而另外一部分 priority 也称之为 serverity level，除了日志的来源以外，对统一源产生日志消息还需要进行优先级的划分，而优先级的类别有以下几种：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>emergency</td>
<td>系统已经无法使用了</td>
</tr>
<tr>
<td>alert</td>
<td>必须立即处理的问题</td>
</tr>
<tr>
<td>critical</td>
<td>很严重了</td>
</tr>
<tr>
<td>error</td>
<td>错误</td>
</tr>
<tr>
<td>warning</td>
<td>警告信息</td>
</tr>
<tr>
<td>notice</td>
<td>系统正常，但是比较重要</td>
</tr>
<tr>
<td>informational</td>
<td>正常</td>
</tr>
<tr>
<td>debug</td>
<td>debug 的调试信息</td>
</tr>
<tr>
<td>panic</td>
<td>很严重但是已淘汰不常用</td>
</tr>
<tr>
<td>none</td>
<td>没有优先级，不记录任何日志消息</td>
</tr>
</tbody></table>
<p>我们来看看系统中的配置</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469433052645" alt="实验楼"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">auth,authpriv.*       /var/<span class="hljs-built_in">log</span>/auth.log<br></code></pre></td></tr></table></figure>

<p>这里的意思是 auth 与 authpriv 的所有优先级的信息全都输出于 <code>/var/log/auth.log</code> 日志中</p>
<p>而其中有类似于这样的配置信息意思有细微的差别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kern.*      -/var/<span class="hljs-built_in">log</span>/kern.log<br></code></pre></td></tr></table></figure>

<p><code>-</code> 代表异步写入，也就是日志写入时不需要等待系统缓存的同步，也就是日志还在内存中缓存也可以继续写入无需等待完全写入硬盘后再写入。通常用于写入数据比较大时使用。</p>
<p>到此我们对 rsyslog 的配置就有了一定的了解，若想更深入学习模板，队列的高级应用，大家可去查看<a href="http://www.rsyslog.com/doc/v8-stable/index.html">官网的文档</a>，需要注意的是 rsyslog 每个版本之间差异化比较大，学习之前先查看自己所使用的版本，再去查看相关的文档</p>
<p>与日志相关的还有一个还有常用的命令 <code>logger</code>，<code>logger</code> 是一个 shell 命令接口，可以通过该接口使用 Syslog 的系统日志模块，还可以从命令行直接向系统日志文件写入信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#首先将syslog启动起来</span><br>sudo service rsyslog start<br><br><span class="hljs-comment">#向 syslog 写入数据</span><br>ping 127.0.0.1 | logger -it logger_test -p local3.notice &amp;<br><br><span class="hljs-comment">#查看是否有数据写入</span><br>sudo tail -f /var/<span class="hljs-built_in">log</span>/syslog<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469474419356" alt="实验楼"></p>
<p>从图中我们可以看到我们成功的将 ping 的信息写入了 syslog 中，格式也就是使用的 rsyslog 的默认模板</p>
<p>我们可以通过 man 来查看 logger 的其他用法，</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>在每行都记录进程 ID</td>
</tr>
<tr>
<td>-t</td>
<td>添加 tag 标签</td>
</tr>
<tr>
<td>-p</td>
<td>设置日志的 facility 与 priority</td>
</tr>
</tbody></table>
<h3 id="四、转储的日志"><a href="#四、转储的日志" class="headerlink" title="四、转储的日志"></a>四、转储的日志</h3><p>在本地的机器中每天都有成百上千条日志被写入文件中，更别说是我们的服务器，每天都会有数十兆甚至更多的日志信息被写入文件中，如果是这样的话，每天看着我们的日志文件不断的膨胀，那岂不是要占用许多的空间，所以有个叫 logrotate 的东西诞生了。</p>
<p>logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件。我们可以根据日志文件的大小，也可以根据其天数来切割日志、管理日志，这个过程又叫做“转储”。</p>
<p>大多数 Linux 发行版使用 logrotate 或 newsyslog 对日志进行管理。logrotate 程序不但可以压缩日志文件，减少存储空间，还可以将日志发送到指定 E-mail，方便管理员及时查看日志。</p>
<p>显而易见，logrotate 是基于 CRON 来运行的，其脚本是 /etc/cron.daily/logrotate；同时我们可以在 <code>/etc/logrotate</code> 中找到其配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cat /etc/logrotate.conf<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469476364695" alt="实验楼"></p>
<p>这其中的具体意思是什么呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># see &quot;man logrotate&quot; for details  //可以查看帮助文档</span><br><span class="hljs-comment"># rotate log files weekly</span><br>weekly                             //设置每周转储一次(daily、weekly、monthly当然可以使用这些参数每天、星期，月 )<br><span class="hljs-comment"># keep 4 weeks worth of backlogs</span><br>rotate 4                           //最多转储4次<br><span class="hljs-comment"># create new (empty) log files after rotating old ones</span><br>create                             //当转储后文件不存在时创建它<br><span class="hljs-comment"># uncomment this if you want your log files compressed</span><br>compress                          //通过gzip压缩方式转储（nocompress可以不压缩）<br><span class="hljs-comment"># RPM packages drop log rotation information into this directory</span><br>include /etc/logrotate.d           //其他日志文件的转储方式配置文件，包含在该目录下<br><span class="hljs-comment"># no packages own wtmp -- we&#x27;ll rotate them here</span><br>/var/<span class="hljs-built_in">log</span>/wtmp &#123;                    //设置/var/<span class="hljs-built_in">log</span>/wtmp日志文件的转储参数<br>    monthly                        //每月转储<br>    create 0664 root utmp          //转储后文件不存在时创建它，文件所有者为root，所属组为utmp，对应的权限为0664<br>    rotate 1                       //最多转储一次<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然在 /etc/logrotate.d/ 中有各项应用的 logrotate 配置，还有更多的配置参数，大家可以使用 man 查看，如按文件大小转储，按当前时间格式命名等等参数配置。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>十三、Linux 进程管理</title>
    <url>/posts/428e1ceb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux-进程管理"><a href="#Linux-进程管理" class="headerlink" title="Linux 进程管理"></a>Linux 进程管理</h1><h2 id="一、实验介绍"><a href="#一、实验介绍" class="headerlink" title="一、实验介绍"></a>一、实验介绍</h2><h3 id="1-1-实验内容"><a href="#1-1-实验内容" class="headerlink" title="1.1 实验内容"></a>1.1 实验内容</h3><p>通过本实验我们将掌握一些 Linux 所提供的工具来进行进程的查看与控制，掌握这些工具让我们能在某些进程出现异常的时候及时查看相关的指标，从而解决问题。</p>
<h3 id="1-2-实验知识点"><a href="#1-2-实验知识点" class="headerlink" title="1.2 实验知识点"></a>1.2 实验知识点</h3><ul>
<li>查看进程的运行状态</li>
<li>进程的结束控制</li>
<li>进程的执行顺序</li>
</ul>
<h2 id="二、-进程的查看"><a href="#二、-进程的查看" class="headerlink" title="二、 进程的查看"></a>二、 进程的查看</h2><p>不管在测试的时候、在实际的生产环境中，还是自己的使用过程中，难免会遇到一些进程异常的情况，所以 Linux 为我们提供了一些工具来查看进程的状态信息。我们可以通过 <code>top</code> 实时的查看进程的状态，以及系统的一些信息（如 CPU、内存信息等），我们还可以通过 <code>ps</code> 来静态查看当前的进程信息，同时我们还可以使用 <code>pstree</code> 来查看当前活跃进程的树形结构。</p>
<h3 id="2-1-top-工具的使用"><a href="#2-1-top-工具的使用" class="headerlink" title="2.1 top 工具的使用"></a>2.1 top 工具的使用</h3><p><code>top</code> 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">top<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469070319324" alt="实验楼"></p>
<p>top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。</p>
<p>我们看到 top 显示的第一排，</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>top</td>
<td>表示当前程序的名称</td>
</tr>
<tr>
<td>11:05:18</td>
<td>表示当前的系统的时间</td>
</tr>
<tr>
<td>up 8 days,17:12</td>
<td>表示该机器已经启动了多长时间</td>
</tr>
<tr>
<td>1 user</td>
<td>表示当前系统中只有一个用户</td>
</tr>
<tr>
<td>load average: 0.29,0.20,0.25</td>
<td>分别对应 1、5、15 分钟内 cpu 的平均负载</td>
</tr>
</tbody></table>
<p>load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。</p>
<p>我们该如何看待这个 load average 数据呢？</p>
<p>假设我们的系统是单 CPU、单内核的，把它比喻成是一条单向的桥，把 CPU 任务比作汽车。</p>
<ul>
<li>load = 0 的时候意味着这个桥上并没有车，cpu 没有任何任务；</li>
<li>load &lt; 1 的时候意味着桥上的车并不多，一切都还是很流畅的，cpu 的任务并不多，资源还很充足；</li>
<li>load = 1 的时候就意味着桥已经被车给占满了，没有一点空隙，cpu 已经在全力工作了，所有的资源都被用完了，当然还好，这还在能力范围之内，只是有点慢而已；</li>
<li>load &gt; 1 的时候就意味着不仅仅是桥上已经被车占满了，就连桥外都被占满了，cpu 已经在全力工作，系统资源的用完了，但是还是有大量的进程在请求，在等待。若是这个值大于 2 表示进程请求超过 CPU 工作能力的 2 倍。而若是这个值大于 5 说明系统已经在超负荷运作了。</li>
</ul>
<p>这是单个 CPU 单核的情况，而实际生活中我们需要将得到的这个值除以我们的核数来看。我们可以通过以下的命令来查看 CPU 的个数与核心数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看物理 CPU 的个数</span><br>cat /proc/cpuinfo | grep <span class="hljs-string">&quot;physical id&quot;</span> | sort | uniq |wc -l<br><br><span class="hljs-comment">#每个 cpu 的核心数</span><br>cat /proc/cpuinfo | grep <span class="hljs-string">&quot;physical id&quot;</span> | grep <span class="hljs-string">&quot;0&quot;</span> | wc -l<br></code></pre></td></tr></table></figure>

<p>通过上面的指数我们可以得知 load 的临界值为 1 ，但是在实际生活中，比较有经验的运维或者系统管理员会将临界值定为 0.7。这里的指数都是除以核心数以后的值，不要混淆了</p>
<ul>
<li>若是 load &lt; 0.7 并不会去关注他；</li>
<li>若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；</li>
<li>若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；</li>
<li>若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了</li>
</ul>
<p>通常我们都会先看 15 分钟的值来看这个大体的趋势，然后再看 5 分钟的值对比来看是否有下降的趋势。</p>
<p>查看 busybox 的代码可以知道，数据是每 5 秒钟就检查一次活跃的进程数，然后计算出该值，然后 load 从 <code>/proc/loadavg</code> 中读取的。而这个 load 的值是如何计算的呢，这是 load 的计算的源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FSHIFT      11          <span class="hljs-comment">/* nr of bits of precision */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FIXED_1     (1&lt;&lt;FSHIFT) <span class="hljs-comment">/* 1.0 as fixed-point(定点) */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOAD_FREQ   (5*HZ)      <span class="hljs-comment">/* 5 sec intervals，每隔5秒计算一次平均负载值 */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CALC_LOAD(load, exp, n)     \</span><br>         load *= <span class="hljs-built_in">exp</span>;               \<br>         load += n*(FIXED_1 - <span class="hljs-built_in">exp</span>); \<br>         load &gt;&gt;= FSHIFT;<br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> avenrun[<span class="hljs-number">3</span>];<br><br>EXPORT_SYMBOL(avenrun);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* calc_load - given tick count, update the avenrun load estimates.</span><br><span class="hljs-comment">* This is called while holding a write_lock on xtime_lock.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calc_load</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> ticks)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> active_tasks; <span class="hljs-comment">/* fixed-point */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = LOAD_FREQ;<br>        count -= ticks;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>                count += LOAD_FREQ;<br>                active_tasks = count_active_tasks();<br>                CALC_LOAD(avenrun[<span class="hljs-number">0</span>], EXP_1, active_tasks);<br>                CALC_LOAD(avenrun[<span class="hljs-number">1</span>], EXP_5, active_tasks);<br>                CALC_LOAD(avenrun[<span class="hljs-number">2</span>], EXP_15, active_tasks);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>有兴趣的朋友可以研究一下，是如何计算的。代码中的后面这部分相当于它的计算公式</p>
</blockquote>
<p>我们回归正题，来看 top 的第二行数据，基本上第二行是进程的一个情况统计</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Tasks: 26 total</td>
<td>进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>1 个正在运行的进程数</td>
</tr>
<tr>
<td>25 sleeping</td>
<td>25 个睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>没有停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>没有僵尸进程数</td>
</tr>
</tbody></table>
<p>来看 top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Cpu(s): 1.0%us</td>
<td>用户空间进程占用 CPU 百分比</td>
</tr>
<tr>
<td>1.0% sy</td>
<td>内核空间运行占用 CPU 百分比</td>
</tr>
<tr>
<td>0.0%ni</td>
<td>用户进程空间内改变过优先级的进程占用 CPU 百分比</td>
</tr>
<tr>
<td>97.9%id</td>
<td>空闲 CPU 百分比</td>
</tr>
<tr>
<td>0.0%wa</td>
<td>等待输入输出的 CPU 时间百分比</td>
</tr>
<tr>
<td>0.1%hi</td>
<td>硬中断(Hardware IRQ)占用 CPU 的百分比</td>
</tr>
<tr>
<td>0.0%si</td>
<td>软中断(Software IRQ)占用 CPU 的百分比</td>
</tr>
<tr>
<td>0.0%st</td>
<td>(Steal time) 是 hypervisor 等虚拟服务中，虚拟 CPU 等待实际 CPU 的时间的百分比</td>
</tr>
</tbody></table>
<p>CPU 利用率是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，而 Load Average 是 CPU 的 Load，它所包含的信息不是 CPU 的使用率状况，而是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数情况统计信息，这两个指标并不一样。</p>
<p>来看 top 的第四行数据，这一行基本上是内存的一个使用情况的统计了：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>8176740 total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>8032104 used</td>
<td>使用的物理内存总量</td>
</tr>
<tr>
<td>144636 free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>313088 buffers</td>
<td>用作内核缓存的内存量</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<blockquote>
<p>系统中可用的物理内存最大值并不是 free 这个单一的值，而是 free + buffers + swap 中的 cached 的和。</p>
</blockquote>
<p>来看 top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了：</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>used</td>
<td>使用的交换区总量</td>
</tr>
<tr>
<td>free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>cached</td>
<td>缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖</td>
</tr>
</tbody></table>
<p>再下面就是进程的一个情况了</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>进程 id</td>
</tr>
<tr>
<td>USER</td>
<td>该进程的所属用户</td>
</tr>
<tr>
<td>PR</td>
<td>该进程执行的优先级 priority 值</td>
</tr>
<tr>
<td>NI</td>
<td>该进程的 nice 值</td>
</tr>
<tr>
<td>VIRT</td>
<td>该进程任务所使用的虚拟内存的总数</td>
</tr>
<tr>
<td>RES</td>
<td>该进程所使用的物理内存数，也称之为驻留内存数</td>
</tr>
<tr>
<td>SHR</td>
<td>该进程共享内存的大小</td>
</tr>
<tr>
<td>S</td>
<td>该进程进程的状态: S=sleep R=running Z=zombie</td>
</tr>
<tr>
<td>%CPU</td>
<td>该进程 CPU 的利用率</td>
</tr>
<tr>
<td>%MEM</td>
<td>该进程内存的利用率</td>
</tr>
<tr>
<td>TIME+</td>
<td>该进程活跃的总时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>该进程运行的名字</td>
</tr>
</tbody></table>
<p><strong>注意:</strong></p>
<p><strong>NICE 值</strong>叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20 至 19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice 值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低。</p>
<p><strong>PR 值</strong>表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 <code>MAX_PRIO</code>，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 <code>0-139</code>，这个值越小，优先级越高。而这其中的 <code>0-99</code> 是实时进程的值，而 <code>100-139</code> 是给用户的。</p>
<p>其中 PR 中的 <code>100 to 139</code> 值部分有这么一个对应 <code>PR = 20 + (-20 to +19)</code>，这里的 <code>-20 to +19</code> 便是 nice 值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同。</p>
<p><strong>VIRT</strong> 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap 空间的页面等所占据空间的总数。</p>
<p>在上文我们曾经说过 top 是一个前台程序，所以是一个可以交互的：</p>
<table>
<thead>
<tr>
<th>常用交互命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>q</td>
<td>退出程序</td>
</tr>
<tr>
<td>I</td>
<td>切换显示平均负载和启动时间的信息</td>
</tr>
<tr>
<td>P</td>
<td>根据 CPU 使用百分比大小进行排序</td>
</tr>
<tr>
<td>M</td>
<td>根据驻留内存大小进行排序</td>
</tr>
<tr>
<td>i</td>
<td>忽略闲置和僵死的进程，这是一个开关式命令</td>
</tr>
<tr>
<td>k</td>
<td>终止一个进程，系统提示输入 PID 及发送的信号值。一般终止进程用 15 信号，不能正常结束则使用 9 信号。安全模式下该命令被屏蔽。</td>
</tr>
</tbody></table>
<p>好好的利用 top 能够很有效的帮助我们观察到系统的瓶颈所在，或者是系统的问题所在。</p>
<h3 id="2-2-ps-工具的使用"><a href="#2-2-ps-工具的使用" class="headerlink" title="2.2 ps 工具的使用"></a>2.2 ps 工具的使用</h3><p>ps 也是我们最常用的查看进程的工具之一，我们通过这样的一个命令来了解一下，他能给我带来哪些信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps aux<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469086224826" alt="实验楼"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps axjf<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469086474033" alt="实验楼"></p>
<p>我们来总体了解下会出现哪些信息给我们，这些信息又代表着什么（更多的 keywords 大家可以通过 <code>man ps</code> 了解）。</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>F</td>
<td>进程的标志（process flags），当 flags 值为 1 则表示此子程序只是 fork 但没有执行 exec，为 4 表示此程序使用超级管理员 root 权限</td>
</tr>
<tr>
<td>USER</td>
<td>进程的拥有用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程的 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>其父进程的 PID</td>
</tr>
<tr>
<td>SID</td>
<td>session 的 ID</td>
</tr>
<tr>
<td>TPGID</td>
<td>前台进程组的 ID</td>
</tr>
<tr>
<td>%CPU</td>
<td>进程占用的 CPU 百分比</td>
</tr>
<tr>
<td>%MEM</td>
<td>占用内存的百分比</td>
</tr>
<tr>
<td>NI</td>
<td>进程的 NICE 值</td>
</tr>
<tr>
<td>VSZ</td>
<td>进程使用虚拟内存大小</td>
</tr>
<tr>
<td>RSS</td>
<td>驻留内存中页的大小</td>
</tr>
<tr>
<td>TTY</td>
<td>终端 ID</td>
</tr>
<tr>
<td>S or STAT</td>
<td>进程状态</td>
</tr>
<tr>
<td>WCHAN</td>
<td>正在等待的进程资源</td>
</tr>
<tr>
<td>START</td>
<td>启动进程的时间</td>
</tr>
<tr>
<td>TIME</td>
<td>进程消耗 CPU 的时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>命令的名称和参数</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>TPGID</strong>栏写着-1 的都是没有控制终端的进程，也就是守护进程</p>
</blockquote>
<blockquote>
<p><strong>STAT</strong>表示进程的状态，而进程的状态有很多，如下表所示</p>
</blockquote>
<table>
<thead>
<tr>
<th>状态</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>Running.运行中</td>
</tr>
<tr>
<td>S</td>
<td>Interruptible Sleep.等待调用</td>
</tr>
<tr>
<td>D</td>
<td>Uninterruptible Sleep.不可中断睡眠</td>
</tr>
<tr>
<td>T</td>
<td>Stoped.暂停或者跟踪状态</td>
</tr>
<tr>
<td>X</td>
<td>Dead.即将被撤销</td>
</tr>
<tr>
<td>Z</td>
<td>Zombie.僵尸进程</td>
</tr>
<tr>
<td>W</td>
<td>Paging.内存交换</td>
</tr>
<tr>
<td>N</td>
<td>优先级低的进程</td>
</tr>
<tr>
<td>&lt;</td>
<td>优先级高的进程</td>
</tr>
<tr>
<td>s</td>
<td>进程的领导者</td>
</tr>
<tr>
<td>L</td>
<td>锁定状态</td>
</tr>
<tr>
<td>l</td>
<td>多线程状态</td>
</tr>
<tr>
<td>+</td>
<td>前台进程</td>
</tr>
</tbody></table>
<blockquote>
<p>其中的 D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于 D 状态的进程，无论是 <code>kill</code>，<code>kill -9</code> 还是 <code>kill -15</code>，一般处于这种状态可能是进程 I/O 的时候出问题了。</p>
</blockquote>
<p>ps 工具有许多的参数，下面给大家解释部分常用的参数。</p>
<p>使用 <code>-l</code> 参数可以显示自己这次登录的 bash 相关的进程信息罗列出来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps -l<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469088103140" alt="实验楼"></p>
<p>相对来说我们更加常用下面这个命令，他将会罗列出所有的进程信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps aux<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469089342412" alt="实验楼"></p>
<p>若是查找其中的某个进程的话，我们还可以配合着 grep 和正则表达式一起使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps aux | grep zsh<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469089837027" alt="实验楼"></p>
<p>此外我们还可以查看时，将连同部分的进程呈树状显示出来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps axjf<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469090040956" alt="实验楼"></p>
<p>当然如果你觉得使用这样的此时没有把你想要的信息放在一起，我们也可以是用这样的命令，来自定义我们所需要的参数显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps -afxo user,ppid,pid,pgid,<span class="hljs-built_in">command</span><br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469004994601" alt="实验楼"></p>
<p>这是一个简单而又实用的工具，想要更灵活的使用，想要知道更多的参数我们可以使用 man 来获取更多相关的信息。</p>
<h3 id="2-3-pstree-工具的使用"><a href="#2-3-pstree-工具的使用" class="headerlink" title="2.3 pstree 工具的使用"></a>2.3 pstree 工具的使用</h3><p>通过 pstree 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程之间的相关性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pstree<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469090893467" alt="实验楼"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pstree -up<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数选择</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-A</td>
<td>程序树之间以 ASCII 字符连接</td>
</tr>
<tr>
<td>-p</td>
<td>同时列出每个 process 的 PID</td>
</tr>
<tr>
<td>-u</td>
<td>同时列出每个 process 的所属账户名称</td>
</tr>
</tbody></table>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469091089249" alt="实验楼"></p>
<h2 id="三、进程的管理"><a href="#三、进程的管理" class="headerlink" title="三、进程的管理"></a>三、进程的管理</h2><h3 id="3-1-kill-命令的掌握"><a href="#3-1-kill-命令的掌握" class="headerlink" title="3.1 kill 命令的掌握"></a>3.1 kill 命令的掌握</h3><p>上个实验中我们讲诉了进程之间是如何衍生，之间又有什么相关性，我们来回顾一下，当一个进程结束的时候或者要异常结束的时候，会向其父进程返回一个或者接收一个 SIGHUP 信号而做出的结束进程或者其他的操作，这个 SIGHUP 信号不仅可以由系统发送，我们可以使用 kill 来发送这个信号来操作进程的结束或者重启等等。</p>
<p>上节课程我们使用 kill 命令来管理我们的一些 job，这节课我们将尝试用 kill 来操作下一些不属于 job 范畴的进程，直接对 pid 下手。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先我们使用图形界面打开了 gedit、gvim，用 ps 可以查看到</span><br>ps aux<br><br><span class="hljs-comment"># 使用 9 这个信号强制结束 gedit 进程</span><br><span class="hljs-built_in">kill</span> -9 1608<br><br><span class="hljs-comment"># 我们再查找这个进程的时候就找不到了</span><br>ps aux | grep gedit<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469092567061" alt="实验楼"></p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469092779938" alt="实验楼"></p>
<h3 id="3-2-进程的执行顺序"><a href="#3-2-进程的执行顺序" class="headerlink" title="3.2 进程的执行顺序"></a>3.2 进程的执行顺序</h3><p>我们在使用 ps 命令的时候可以看到大部分的进程都是处于休眠的状态，如果这些进程都被唤醒，那么该谁最先享受 CPU 的服务，后面的进程又该是一个什么样的顺序呢？进程调度的队列又该如何去排列呢？</p>
<p>当然就是靠该进程的优先级值来判定进程调度的优先级，而优先级的值就是上文所提到的 PR 与 nice 来控制与体现了</p>
<p>而 nice 的值我们是可以通过 nice 命令来修改的，而需要注意的是 nice 值可以调整的范围是 <code>-20 ~ 19</code>，其中 root 有着至高无上的权力，既可以调整自己的进程也可以调整其他用户的程序，并且是所有的值都可以用，而普通用户只可以调制属于自己的进程，并且其使用的范围只能是 <code>0 ~ 19</code>，因为系统为了避免一般用户抢占系统资源而设置的一个限制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这个实验在环境中无法做，因为权限不够，可以自己在本地尝试</span><br><br><span class="hljs-comment"># 打开一个程序放在后台，或者用图形界面打开</span><br>nice -n -5 vim &amp;<br><br><span class="hljs-comment"># 用 ps 查看其优先级</span><br>ps -afxo user,ppid,pid,<span class="hljs-built_in">stat</span>,pri,ni,time,<span class="hljs-built_in">command</span> | grep vim<br></code></pre></td></tr></table></figure>

<p>我们还可以用 renice 来修改已经存在的进程的优先级，同样因为权限的原因在实验环境中无法尝试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">renice -5 pid<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>十二、Linux进程概念</title>
    <url>/posts/bc91e4b2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux-进程概念"><a href="#Linux-进程概念" class="headerlink" title="Linux 进程概念"></a>Linux 进程概念</h1><h2 id="一、实验介绍"><a href="#一、实验介绍" class="headerlink" title="一、实验介绍"></a>一、实验介绍</h2><h3 id="1-1-实验内容"><a href="#1-1-实验内容" class="headerlink" title="1.1 实验内容"></a>1.1 实验内容</h3><p>Linux 中也难免遇到某个程序无响应的情况，可以通过一些命令来帮助我们让系统能够更流畅的运行。 而在此之前，我们需要对进程的基础知识有一定的了解，才能更好、更有效率的使用 Linux 提供的工具。</p>
<h3 id="1-2-实验知识点"><a href="#1-2-实验知识点" class="headerlink" title="1.2 实验知识点"></a>1.2 实验知识点</h3><ul>
<li>进程与程序</li>
<li>进程的衍生</li>
<li>工作管理</li>
</ul>
<h2 id="二、概念的理解"><a href="#二、概念的理解" class="headerlink" title="二、概念的理解"></a>二、概念的理解</h2><p>首先程序与进程是什么？程序与进程又有什么区别？</p>
<blockquote>
<p><strong>程序</strong>（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。</p>
</blockquote>
<blockquote>
<p><strong>进程</strong>（process）：进程是程序在一个数据集合上的一次执行过程，在早期的 UNIX、Linux 2.4 及更早的版本中，它是系统进行资源分配和调度的独立基本单位。同上一个例子，就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。</p>
</blockquote>
<p>简单来说，程序是为了完成某种任务而设计的软件，比如 vim 是程序。什么是进程呢？进程就是运行中的程序。</p>
<p>程序只是一些列指令的集合，是一个静止的实体，而进程不同，进程有以下的特性：</p>
<ul>
<li>动态性：进程的实质是一次程序执行的过程，有创建、撤销等状态的变化。而程序是一个静态的实体。</li>
<li>并发性：进程可以做到在一个时间段内，有多个程序在运行中。程序只是静态的实体，所以不存在并发性。</li>
<li>独立性：进程可以独立分配资源，独立接受调度，独立地运行。</li>
<li>异步性：进程以不可预知的速度向前推进。</li>
<li>结构性：进程拥有代码段、数据段、PCB（进程控制块，进程存在的唯一标志）。也正是因为有结构性，进程才可以做到独立地运行。</li>
</ul>
<blockquote>
<p><strong>并发：</strong>在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过）</p>
</blockquote>
<blockquote>
<p><strong>并行：</strong>在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行</p>
</blockquote>
<p>引入进程是因为传统意义上的程序已经不足以描述 OS 中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。</p>
<p>而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6 及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。</p>
<blockquote>
<p><strong>线程</strong>（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p>
</blockquote>
<p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。就如下图所示：</p>
<h2 id="三、进程的属性"><a href="#三、进程的属性" class="headerlink" title="三、进程的属性"></a><img src="https://dn-simplecloud.shiyanlou.com/1135081469062947147" alt="实验楼">三、进程的属性</h2><p>了解基础概念后，下面我们将详细的讲解进程的属性。</p>
<h3 id="3-1-进程的分类"><a href="#3-1-进程的分类" class="headerlink" title="3.1 进程的分类"></a>3.1 进程的分类</h3><p>大概明白进程是个什么样的存在后，我们需要进一步了解的就是进程分类。可以从两个角度来分：</p>
<ul>
<li>以进程的功能与服务的对象来分；</li>
<li>以应用程序的服务类型来分；</li>
</ul>
<p>第一个角度来看，我们可以分为==用户进程与系统进程==：</p>
<ul>
<li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li>
<li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。</li>
</ul>
<p>第二角度来看，我们可以将进程分为==交互进程==、==批处理进程==、==守护进程==</p>
<ul>
<li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li>
<li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li>
<li>守护进程：守护进程是一直运行的一种进程，在 Linux 系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd 进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab 的守护进程，可以周期性的执行用户设定的某些任务。</li>
</ul>
<h3 id="3-2-进程的衍生"><a href="#3-2-进程的衍生" class="headerlink" title="3.2 进程的衍生"></a>3.2 进程的衍生</h3><p>进程有这么多的种类，那么进程之间定是有相关性的，而这些有关联性的进程又是如何产生的，如何衍生的？</p>
<p>就比如我们启动了终端，就是启动了一个 bash 进程，我们可以在 bash 中再输入 bash 则会再启动一个 bash 的进程，此时第二个 bash 进程就是由第一个 bash 进程创建出来的，他们之间又是个什么关系？</p>
<p>我们一般称呼第一个 bash 进程是第二 bash 进程的父进程，第二 bash 进程是第一个 bash 进程的子进程，这层关系是如何得来的呢？</p>
<p>关于父进程与子进程便会提及这两个系统调用 <code>fork()</code> 与 <code>exec()</code></p>
<blockquote>
<p><strong>fork-exec</strong>是由 Dennis M. Ritchie 创造的</p>
</blockquote>
<blockquote>
<p><strong>fork()</strong> 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等</p>
</blockquote>
<blockquote>
<p><strong>exec()</strong> 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段</p>
</blockquote>
<p>子进程就是父进程通过系统调用 <code>fork()</code> 而产生的复制品，<code>fork()</code> 就是把父进程的 PCB 等进程的数据结构信息直接复制过来，只是修改了 PID，所以一模一样，只有在执行 <code>exec()</code> 之后才会不同，而早先的 <code>fork()</code> 比较消耗资源后来进化成 <code>vfork()</code>,效率高了不少，感兴趣的同学可以查查为什么。</p>
<p>这就是子进程产生的由来。简单的实现逻辑就如下方所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">pid_t</span> p;<br><br>p = fork();<br><span class="hljs-keyword">if</span> (p == (<span class="hljs-keyword">pid_t</span>) <span class="hljs-number">-1</span>)<br>        <span class="hljs-comment">/* ERROR */</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">/* CHILD */</span><br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">/* PARENT */</span><br></code></pre></td></tr></table></figure>

<p>既然子进程是通过父进程而衍生出来的，那么子进程的退出与资源的回收定然与父进程有很大的相关性。当一个子进程要正常的终止运行时，或者该进程结束时它的主函数 <code>main()</code> 会执行 <code>exit(n);</code> 或者 <code>return n</code>，这里的返回值 n 是一个信号，系统会把这个 SIGCHLD 信号传给其父进程，当然若是异常终止也往往是因为这个信号。</p>
<p>在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。</p>
<p>如图中第四列标题是 S，S 表示的是进程的状态，而在下属的第三行的 Z 表示的是 Zombie 的意思。（ ps 命令将在后续详解）</p>
<img src="https://dn-simplecloud.shiyanlou.com/1135081469027998669" alt="实验楼" style="zoom:67%;">

<p>正常情况下，父进程会收到两个返回值：exit code（SIGCHLD 信号）与 <code>reason for termination</code> 。之后，父进程会使用 <code>wait(&amp;status)</code> 系统调用以获取子进程的退出状态，然后内核就可以从内存中释放已结束的子进程的 PCB；而如若父进程没有这么做的话，子进程的 PCB 就会一直驻留在内存中，一直留在系统中成为僵尸进程（Zombie）。</p>
<p>虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是 Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。</p>
<p>另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在 Linux 系统中，<code>孤儿进程一般会被 init 进程所“收养”</code>，成为 init 的子进程。由 init 来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。</p>
<p>进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 <code>fork()</code> 创建出一个子进程运行 <code>/sbin/init</code> 可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init 进程）是第一个用户态的进程，再由它不断调用 fork() 来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。</p>
<p>通过以下的命令我们可以很明显的看到这样的结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pstree<br></code></pre></td></tr></table></figure>

<img src="https://dn-simplecloud.shiyanlou.com/1135081468836854017" alt="实验楼" style="zoom: 67%;">

<p>或者从此图我们可以更加形象的看清子父进程的关系</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469030455439" alt="实验楼"></p>
<p>通过以上的显示结果我们可以看的很清楚，init 为所有进程的父进程或者说是祖先进程</p>
<p>我们还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps －fxo user,ppid,pid,pgid,<span class="hljs-built_in">command</span><br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469004994601" alt="实验楼"></p>
<p>可以在图中看见我们执行的 ps 就是由 zsh 通过 fork-exec 创建的子进程而执行的</p>
<p>使用这样的一个命令我们也能清楚的看见 init 如上文所说是由进程 0 这个初始化进程来创建出来的子进程,而其他的进程基本是由 init 创建的子进程，或者是由它的子进程创建出来的子进程。所以 init 是用户进程的第一个进程也是所有用户进程的父进程或者祖先进程。（ps 命令将在后续课程详解）</p>
<p>就像一个树状图，而 init 进程就是这棵树的根，其他进程由根不断的发散，开枝散叶</p>
<h3 id="3-3-进程组与-Sessions"><a href="#3-3-进程组与-Sessions" class="headerlink" title="3.3 进程组与 Sessions"></a>3.3 进程组与 Sessions</h3><p>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。</p>
<p>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 <code>getpgrp()</code> 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的 PGID，直到进程组中最后一个进程终结。</p>
<p>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，</p>
<p>Session 主要是针对一个 tty 建立    ，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。</p>
<blockquote>
<p><strong>前台</strong>（foreground）就是在终端中运行，能与你有交互的</p>
</blockquote>
<blockquote>
<p><strong>后台</strong>（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程</p>
</blockquote>
<h3 id="3-4-工作原理"><a href="#3-4-工作原理" class="headerlink" title="3.4 工作原理"></a>3.4 工作原理</h3><p>bash(Bourne-Again shell)支持工作控制（job control）,而 sh（Bourne shell）并不支持。</p>
<p>并且每个终端或者说 bash 只能管理当前终端中的 job，不能管理其他终端中的 job。比如我当前存在两个 bash 分别为 bash1、bash2，bash1 只能管理其自己里面的 job 并不能管理 bash2 里面的 job</p>
<p>我们都知道当一个进程在前台运作时我们可以用 <code>ctrl + c</code> 来终止它，但是若是在后台的话就不行了。</p>
<p>我们可以通过 <code>&amp;</code> 这个符号，让我们的命令在后台中运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ls &amp;<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469036077882" alt="实验楼"></p>
<p>图中所显示的 <code>[1] 236</code>分别是该 job 的 job number 与该进程的 PID，而最后一行的 Done 表示该命令已经在后台执行完毕。</p>
<p>我们还可以通过 <code>ctrl + z</code> 使我们的当前工作停止并丢到后台中去</p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469036715105" alt="实验楼"></p>
<p>被停止并放置在后台的工作我们可以使用这个命令来查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">jobs</span><br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469037134869" alt="实验楼"></p>
<p>其中第一列显示的为被放置后台 job 的编号，而第二列的 <code>＋</code> 表示最近(刚刚、最后)被放置后台的 job，同时也表示预设的工作，也就是若是有什么针对后台 job 的操作，首先对预设的 job，<code>-</code> 表示倒数第二（也就是在预设之前的一个）被放置后台的工作，倒数第三个（再之前的）以后都不会有这样的符号修饰，第三列表示它们的状态，而最后一列表示该进程执行的命令</p>
<p>我们可以通过这样的一个命令将后台的工作拿到前台来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 后面不加参数提取预设工作，加参数提取指定工作的编号</span><br><span class="hljs-comment"># ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</span><br><span class="hljs-built_in">fg</span> [%jobnumber]<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469037555070" alt="实验楼"></p>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469037666320" alt="实验楼"></p>
<p>之前我们通过 <code>ctrl + z</code> 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#与fg类似，加参则指定，不加参则取预设</span><br><span class="hljs-built_in">bg</span> [%jobnumber]<br></code></pre></td></tr></table></figure>

<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469037983282" alt="实验楼"></p>
<p>既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># kill的使用格式如下</span><br><span class="hljs-built_in">kill</span> -signal %jobnumber<br><br><span class="hljs-comment"># signal从1-64个信号值可以选择，可以这样查看</span><br><span class="hljs-built_in">kill</span> －l<br></code></pre></td></tr></table></figure>

<p>其中常用的有这些信号值</p>
<table>
<thead>
<tr>
<th>信号值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-1</td>
<td>重新读取参数运行，类似与 restart</td>
</tr>
<tr>
<td>-2</td>
<td>如同 ctrl+c 的操作退出</td>
</tr>
<tr>
<td>-9</td>
<td>强制终止该任务</td>
</tr>
<tr>
<td>-15</td>
<td>正常的方式终止该任务</td>
</tr>
</tbody></table>
<p><img src="https://dn-simplecloud.shiyanlou.com/1135081469038840624" alt="实验楼"></p>
<p><strong>注意</strong></p>
<blockquote>
<p>若是在使用 kill ＋信号值然后直接加 pid，你将会对 pid 对应的进程进行操作</p>
</blockquote>
<blockquote>
<p>若是在使用 kill+信号值然后 <code>％jobnumber</code>，这时所操作的对象是 job，这个数字就是就当前 bash 中后台的运行的 job 的 ID</p>
</blockquote>
<p>下一步</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>十一、Linux下的软件安装</title>
    <url>/posts/3f5a894e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux下的软件安装"><a href="#Linux下的软件安装" class="headerlink" title="Linux下的软件安装"></a>Linux下的软件安装</h1><h2 id="一、实验介绍"><a href="#一、实验介绍" class="headerlink" title="一、实验介绍"></a>一、实验介绍</h2><h3 id="1-1-实验内容"><a href="#1-1-实验内容" class="headerlink" title="1.1 实验内容"></a>1.1 实验内容</h3><p>介绍 Ubuntu 下软件安装的几种方式，及 apt，dpkg 工具的使用。</p>
<h3 id="1-2-实验知识点"><a href="#1-2-实验知识点" class="headerlink" title="1.2 实验知识点"></a>1.2 实验知识点</h3><p>通常 Linux 上的软件安装主要有四种方式：</p>
<ul>
<li>在线安装</li>
<li>从磁盘安装 deb 软件包</li>
<li>从二进制软件包安装</li>
<li>从源代码编译安装</li>
</ul>
<p>这几种安装方式各有优劣，而大多数软件包会采用多种方式发布软件，所以我们常常需要全部掌握这几种软件安装方式，以便适应各种环境。下面将介绍前三种安装方式，从源码编译安装你将在 Linux 程序设计中学习到。</p>
<h2 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h2><p>试想一下，平时我们在使用 Windows 的时候，想要安装一个软件，我们需要在网上去下载对应软件的安装包，接着安装的时候就是不断的去点击下一步，这些流程想必大家已经经历无数回了，但是在 Linux 下，一个命令加回车，等待一下，软件就安装好了，这就是方便的在线安装软件的方式。在学习这种安装方式之前有一点需要说明的是，**在不同的 linux 发行版上面在线安装方式会有一些差异包括使用的命令及它们的包管理工具，因为我们的开发环境是基于 ubuntu 的，所以这里我们涉及的在线安装方式将只适用于 ubuntu 发行版，或其它基于 ubuntu 的发行版如国内的 ubuntukylin(优麒麟)，ubuntu 又是基于 debian 的发行版，它使用的是 debian 的包管理工具 dpkg，所以一些操作也适用于 debian。而在一些采用其它包管理工具的发行版如 redhat，centos,fedora 等将不适用(redhat 和 centos 使用 rpm)**。</p>
<h3 id="2-1-先体验一下"><a href="#2-1-先体验一下" class="headerlink" title="2.1 先体验一下"></a>2.1 先体验一下</h3><p>比如我们想安装一个软件，名字叫做 <code>w3m</code>(w3m 是一个命令行的简易网页浏览器)，那么输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get install w3m<br></code></pre></td></tr></table></figure>

<p>这样的操作你应该在前面的章节中看到过很多次了，它就表示将会安装一个软件包名为<code>w3m</code>的软件</p>
<p>我们来看看命令执行后的效果：</p>
<img src="https://doc.shiyanlou.com/document-uid735639labid356timestamp1532415882720.png" alt="此处输入图片的描述" style="zoom: 50%;">

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">w3m https://www.lanqiao.cn/faq<br></code></pre></td></tr></table></figure>

<p><strong>注意</strong>:如果你在安装一个软件之后，无法立即使用<code>Tab</code>键补全这个命令，你可以尝试先执行<code>source ~/.zshrc</code>，然后你就可以使用补全操作。</p>
<img src="https://doc.shiyanlou.com/courses/1/1347963/e6610089a8f1decc8e20da121675c7db-0" alt="图片描述" style="zoom:50%;">

<h3 id="2-2-apt-包管理工具介绍"><a href="#2-2-apt-包管理工具介绍" class="headerlink" title="2.2 apt 包管理工具介绍"></a>2.2 apt 包管理工具介绍</h3><blockquote>
<p>APT 是 Advance Packaging Tool（高级包装工具）的缩写，是 Debian 及其派生发行版的软件包管理器，APT 可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了 Unix 系统上管理软件的过程。APT 最早被设计成 dpkg 的前端，用来处理 deb 格式的软件包。现在经过 APT-RPM 组织修改，APT 已经可以安装在支持 RPM 的系统管理 RPM 包。这个包管理器包含以 <code>apt-</code> 开头的多个工具，如 <code>apt-get</code> <code>apt-cache</code> <code>apt-cdrom</code> 等，在 Debian 系列的发行版中使用。</p>
</blockquote>
<p>当你在执行安装操作时，首先<code>apt-get</code> 工具会在<strong>本地</strong>的一个数据库中搜索关于 <code>w3m</code> 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装，这里大家可能会一个疑问：既然是在线安装软件，为啥会在本地的数据库中搜索？要解释这个问题就得提到几个名词了：</p>
<ul>
<li><strong>软件源镜像服务器</strong></li>
<li><strong>软件源</strong></li>
</ul>
<p>我们需要定期从服务器上下载一个软件包列表，使用 <code>sudo apt-get update</code> 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有<strong>软件依赖</strong>信息的记录，对于软件依赖，我举个例子：我们安装 <code>w3m</code> 软件的时候，而这个软件需要 <code>libgc1c2</code> 这个软件包才能正常工作，这个时候 <code>apt-get</code> 在安装软件的时候会一并替我们安装了，以保证 <code>w3m</code> 能正常的工作。</p>
<h3 id="2-3-apt-get"><a href="#2-3-apt-get" class="headerlink" title="2.3 apt-get"></a>2.3 apt-get</h3><p><code>apt-get</code> 是用于处理 <code>apt</code>包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些<code>apt-get</code>包含的常用的一些工具：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>install</code></td>
<td>其后加上软件包名，用于安装一个软件包</td>
</tr>
<tr>
<td><code>update</code></td>
<td>从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表</td>
</tr>
<tr>
<td><code>upgrade</code></td>
<td>升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次<code>update</code></td>
</tr>
<tr>
<td><code>dist-upgrade</code></td>
<td>解决依赖关系并升级(存在一定危险性)</td>
</tr>
<tr>
<td><code>remove</code></td>
<td>移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件</td>
</tr>
<tr>
<td><code>autoremove</code></td>
<td>移除之前被其他软件包依赖，但现在不再被使用的软件包</td>
</tr>
<tr>
<td><code>purge</code></td>
<td>与 remove 相同，但会完全移除软件包，包含其配置文件</td>
</tr>
<tr>
<td><code>clean</code></td>
<td>移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/</td>
</tr>
<tr>
<td><code>autoclean</code></td>
<td>移除已安装的软件的旧版本软件包</td>
</tr>
</tbody></table>
<p>下面是一些<code>apt-get</code>常用的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-y</code></td>
<td>自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>模拟安装</td>
</tr>
<tr>
<td><code>-q</code></td>
<td>静默安装方式，指定多个<code>q</code>或者<code>-q=#</code>,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用</td>
</tr>
<tr>
<td><code>-f</code></td>
<td>修复损坏的依赖关系</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>只下载不安装</td>
</tr>
<tr>
<td><code>--reinstall</code></td>
<td>重新安装已经安装但可能存在问题的软件包</td>
</tr>
<tr>
<td><code>--install-suggests</code></td>
<td>同时安装 APT 给出的建议安装的软件包</td>
</tr>
</tbody></table>
<h3 id="2-4-安装软件包"><a href="#2-4-安装软件包" class="headerlink" title="2.4 安装软件包"></a>2.4 安装软件包</h3><p>关于安装，如前面演示的一样你只需要执行<code>apt-get install &lt;软件包名&gt;</code>即可，除了这一点，你还应该掌握的是如何重新安装软件包。 很多时候我们需要重新安装一个软件包，比如你的系统被破坏，或者一些错误的配置导致软件无法正常工作。</p>
<p>你可以使用如下方式重新安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get --reinstall install w3m<br></code></pre></td></tr></table></figure>

<p>另一个你需要掌握的是，如何在不知道软件包完整名的时候进行安装。通常我们是使用<code>Tab</code>键补全软件包名，后面会介绍更好的方法来搜索软件包。有时候你需要同时安装多个软件包，你还可以使用正则表达式匹配软件包名进行批量安装。</p>
<h3 id="2-5-软件升级"><a href="#2-5-软件升级" class="headerlink" title="2.5 软件升级"></a>2.5 软件升级</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"># 更新软件源<br>sudo apt-get update<br><br># 升级没有依赖问题的软件包<br>sudo apt-get upgrade<br><br># 升级并解决依赖关系<br>sudo apt-get dist-upgrade<br></code></pre></td></tr></table></figure>

<h3 id="2-6-卸载软件"><a href="#2-6-卸载软件" class="headerlink" title="2.6 卸载软件"></a>2.6 卸载软件</h3><p>如果你现在觉得 <code>w3m</code> 这个软件不合自己的胃口或者是找到了更好的，你需要卸载它。那么简单！同样是一个命令加回车 <code>sudo apt-get remove w3m</code>，系统会有一个确认的操作，之后这个软件便“滚蛋了”。</p>
<img src="https://doc.shiyanlou.com/document-uid735639labid356timestamp1532415931977.png" alt="此处输入图片的描述" style="zoom: 67%;">

<p>或者，你可以执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 不保留配置文件的移除</span><br>$ sudo apt-get purge w3m<br><span class="hljs-comment"># 或者 sudo apt-get --purge remove</span><br><span class="hljs-comment"># 移除不再需要的被依赖的软件包</span><br>$ sudo apt-get autoremove<br></code></pre></td></tr></table></figure>

<h3 id="2-7-软件搜索"><a href="#2-7-软件搜索" class="headerlink" title="2.7 软件搜索"></a>2.7 软件搜索</h3><p>当自己刚知道了一个软件，想下载使用，需要确认软件仓库里面有没有，就需要用到搜索功能了，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-cache search softname1 softname2 softname3……<br></code></pre></td></tr></table></figure>

<p><code>apt-cache</code> 命令则是针对本地数据进行相关操作的工具，<code>search</code> 顾名思义在本地的数据库中寻找有关 <code>softname1</code> <code>softname2</code> 相关软件的信息。现在我们试试搜索一下之前我们安装的软件 <code>w3m</code> ，如图：</p>
<p><img src="https://doc.shiyanlou.com/document-uid600404labid6129timestamp1523958065018.png" alt="此处输入图片的描述"></p>
<p>结果显示了 4 个 <code>w3m</code> 相关的软件，并且有相关软件的简介。</p>
<p>关于在线安装的内容我们就介绍这么多，想了解更多关于 APT 的内容，你可以参考：</p>
<ul>
<li><a href="http://www.debian.org/doc/manuals/apt-howto/index.zh-cn.html#contents">APT HowTo</a></li>
</ul>
<h2 id="三、使用-dpkg"><a href="#三、使用-dpkg" class="headerlink" title="三、使用 dpkg"></a>三、使用 dpkg</h2><p>本节讲解如何使用 dpkg 从本地磁盘安装 deb 软件包。</p>
<h3 id="3-1-dpkg-介绍"><a href="#3-1-dpkg-介绍" class="headerlink" title="3.1 dpkg 介绍"></a>3.1 dpkg 介绍</h3><blockquote>
<p>dpkg 是 Debian 软件包管理器的基础，它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似，同样被用于安装、卸载和供给和 .deb 软件包相关的信息。</p>
</blockquote>
<blockquote>
<p>dpkg 本身是一个底层的工具。上层的工具，像是 APT，被用于从远程获取软件包以及处理复杂的软件包关系。”dpkg”是”Debian Package”的简写。</p>
</blockquote>
<p>我们经常可以在网络上见到以<code>deb</code>形式打包的软件包，就需要使用<code>dpkg</code>命令来安装。</p>
<p><code>dpkg</code>常用参数介绍：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-i</code></td>
<td>安装指定 deb 包</td>
</tr>
<tr>
<td><code>-R</code></td>
<td>后面加上目录名，用于安装该目录下的所有 deb 安装包</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>remove，移除某个已安装的软件包</td>
</tr>
<tr>
<td><code>-I</code></td>
<td>显示<code>deb</code>包文件的信息</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>显示已安装软件的信息</td>
</tr>
<tr>
<td><code>-S</code></td>
<td>搜索已安装的软件包</td>
</tr>
<tr>
<td><code>-L</code></td>
<td>显示已安装软件包的目录信息</td>
</tr>
</tbody></table>
<h3 id="3-2-使用-dpkg-安装-deb-软件包"><a href="#3-2-使用-dpkg-安装-deb-软件包" class="headerlink" title="3.2 使用 dpkg 安装 deb 软件包"></a>3.2 使用 dpkg 安装 deb 软件包</h3><p>我们先使用<code>apt-get</code>加上<code>-d</code>参数只下载不安装，下载 emacs 编辑器的 deb 包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get -d install -y emacs<br></code></pre></td></tr></table></figure>

<p>下载完成后，我们可以查看/var/cache/apt/archives/目录下的内容，如下图：</p>
<img src="https://doc.shiyanlou.com/document-uid735639labid356timestamp1532416001019.png" alt="此处输入图片的描述" style="zoom:67%;">

<p>然后我们将第一个<code>deb</code>拷贝到 /home/shiyanlou 目录下，并使用<code>dpkg</code>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cp /var/cache/apt/archives/emacs24_24.5+1-6ubuntu1.1_amd64.deb ~<br><span class="hljs-comment"># 安装之前参看deb包的信息</span><br>sudo dpkg -I emacs24_24.5+1-6ubuntu1.1_amd64.deb<br></code></pre></td></tr></table></figure>

<p>如你所见，这个包还额外依赖了一些软件包，这意味着，如果主机目前没有这些被依赖的软件包，直接使用 dpkg 安装可能会存在一些问题，因为<code>dpkg</code>并不能为你解决依赖关系。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用dpkg安装</span><br>sudo dpkg -i emacs24_24.5+1-6ubuntu1.1_amd64.deb<br></code></pre></td></tr></table></figure>

<p>跟前面预料的一样，这里你可能出现了一些错误：</p>
<img src="https://doc.shiyanlou.com/document-uid735639labid356timestamp1532416027450.png" alt="此处输入图片的描述" style="zoom:67%;">

<p>我们将如何解决这个错误呢？这就要用到<code>apt-get</code>了，使用它的<code>-f</code>参数了，修复依赖关系的安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get -f install -y<br></code></pre></td></tr></table></figure>

<p>没有任何错误，这样我们就安装成功了，然后你可以运行 emacs 程序</p>
<img src="https://doc.shiyanlou.com/document-uid735639labid356timestamp1532416061661.png" alt="此处输入图片的描述" style="zoom:67%;">

<h3 id="3-3-查看已安装软件包的安装目录"><a href="#3-3-查看已安装软件包的安装目录" class="headerlink" title="3.3 查看已安装软件包的安装目录"></a>3.3 查看已安装软件包的安装目录</h3><p>如果你依然在纠结到底 linux 将软件安装到了什么地方，那么很幸运你将可以通过<code>dpkg</code>找到答案</p>
<p>使用<code>dpkg -L</code>查看<code>deb</code>包目录信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo dpkg -L emacs24<br></code></pre></td></tr></table></figure>

<img src="https://doc.shiyanlou.com/document-uid735639labid356timestamp1532416074969.png" alt="此处输入图片的描述" style="zoom:67%;">

<p><code>dpkg</code>还有一些其他的参数，这里将作为练习题由你自己来学习</p>
<h2 id="四、从二进制包安装"><a href="#四、从二进制包安装" class="headerlink" title="四、从二进制包安装"></a>四、从二进制包安装</h2><p>二进制包的安装比较简单，我们需要做的只是将从网络上下载的二进制包解压后放到合适的目录，然后将包含可执行的主程序文件的目录添加进<code>PATH</code>环境变量即可，如果你不知道该放到什么位置，请重新复习第四节关于 Linux 目录结构的内容。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>十、正则表达式</title>
    <url>/posts/1e5548e0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="十、正则表达式"><a href="#十、正则表达式" class="headerlink" title="十、正则表达式"></a>十、正则表达式</h2><h3 id="1-1-实验内容"><a href="#1-1-实验内容" class="headerlink" title="1.1 实验内容"></a>1.1 实验内容</h3><p>虽然我们这一节的标题是正则表达式，但实际这一节实验只是介绍<code>grep</code>，<code>sed</code>，<code>awk</code>这三个命令，而正则表达式作为这三个命令的一种使用方式（命令输出中可以包含正则表达式）。正则表达式本身的内容很多，要把它说明清楚需要单独一门课程来实现，不过我们这一节中涉及到的相关内容通常也能够满足很多情况下的需求了。</p>
<h3 id="1-2-实验知识点"><a href="#1-2-实验知识点" class="headerlink" title="1.2 实验知识点"></a>1.2 实验知识点</h3><ul>
<li>掌握基本命令：<code>sed</code> ,<code>grep</code> ,<code>awk</code>的用法</li>
<li>掌握正则表达式符号和语法</li>
</ul>
<blockquote>
<p>想要更深入地学习使用正则表达式，在这里 <a href="https://www.lanqiao.cn/courses/90">正则表达式基础</a>。</p>
</blockquote>
<h2 id="二、正则表达式"><a href="#二、正则表达式" class="headerlink" title="二、正则表达式"></a>二、正则表达式</h2><p>什么是正则表达式呢？</p>
<blockquote>
<p><strong>正则表达式</strong>，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p>
</blockquote>
<blockquote>
<p>许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在 Perl 中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由 UNIX 中的工具软件（例如<code>sed</code>和<code>grep</code>）普及开的。正则表达式通常缩写成“regex”，单数有 regexp、regex，复数有 regexps、regexes、regexen。</p>
</blockquote>
<p>简单的说形式和功能上正则表达式和我们前面讲的通配符很像，不过它们之间又有很大差别，特别在于一些特殊的匹配字符的含义上，希望初学者注意不要将两者弄混淆。</p>
<h3 id="2-1-举例"><a href="#2-1-举例" class="headerlink" title="2.1 举例"></a>2.1 举例</h3><p><img src="https://doc.shiyanlou.com/linux_base/lizi.jpg" alt="img"></p>
<p>假设我们有这样一个文本文件，包含”shiyanlou”，和”shilouyan”这两个字符串，同样一个表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">shi*<br></code></pre></td></tr></table></figure>

<p>如果这作为一个正则表达式，它将只能匹配 shi，而如果不是作为正则表达式<code>*</code>作为一个通配符，则将同时匹配这两个字符串。这是为什么呢？因为在正则表达式中<code>*</code>表示匹配前面的子表达式（这里就是它前面一个字符）零次或多次，比如它可以匹配”sh”,”shii”,”shish”,”shiishi”等等，而作为通配符表示匹配通配符后面任意多个任意字符，所以它可以匹配”shiyanlou”，和”shilouyan”两个字符。</p>
<p>体验完了，下面就来开始正式学习正则表达式吧。</p>
<h3 id="2-2-基本语法"><a href="#2-2-基本语法" class="headerlink" title="2.2 基本语法"></a>2.2 基本语法</h3><p>一个正则表达式通常被称为一个模式（<strong>pattern</strong>），为用来描述或者匹配一系列符合某个句法规则的字符串。</p>
<h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p><code>|</code>竖直分隔符表示选择，例如”boy|girl”可以匹配”boy”或者”girl”</p>
<h4 id="数量限定"><a href="#数量限定" class="headerlink" title="数量限定"></a>数量限定</h4><p>数量限定除了我们举例用的<code>*</code>,还有<code>+</code>加号,<code>?</code>问号,如果在一个模式中不加数量限定符则表示出现一次且仅出现一次：</p>
<ul>
<li><code>+</code>表示前面的字符必须出现至少一次(1 次或多次)，例如，”goo+gle”,可以匹配”gooogle”,”goooogle”等；</li>
<li><code>?</code>表示前面的字符最多出现一次(0 次或 1 次)，例如，”colou?r”,可以匹配”color”或者”colour”;</li>
<li><code>*</code>星号代表前面的字符可以不出现，也可以出现一次或者多次（0 次、或 1 次、或多次），例如，“0*42”可以匹配 42、042、0042、00042 等。</li>
</ul>
<h4 id="范围和优先级"><a href="#范围和优先级" class="headerlink" title="范围和优先级"></a>范围和优先级</h4><p><code>()</code>圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，”gr(a|e)y”等价于”gray|grey”，（这里体现了优先级，竖直分隔符用于选择 a 或者 e 而不是 gra 和 ey），”(grand)?father”匹配 father 和 grandfather（这里体现了范围，<code>?</code>将圆括号内容作为一个整体匹配）。</p>
<h4 id="语法（部分）"><a href="#语法（部分）" class="headerlink" title="语法（部分）"></a>语法（部分）</h4><p>正则表达式有多种不同的风格，下面列举一些常用的作为 PCRE 子集的适用于<code>perl</code>和<code>python</code>编程语言及<code>grep</code>或<code>egrep</code>的正则表达式匹配规则：(<strong>由于 markdown 表格解析的问题，下面的竖直分隔符用全角字符代替，实际使用时请换回半角字符</strong>)</p>
<blockquote>
<p>PCRE（Perl Compatible Regular Expressions 中文含义：perl 语言兼容正则表达式）是一个用 C 语言编写的正则表达式函数库，由菲利普.海泽(Philip Hazel)编写。PCRE 是一个轻量级的函数库，比 Boost 之类的正则表达式库小得多。PCRE 十分易用，同时功能也很强大，性能超过了 POSIX 正则表达式库和一些经典的正则表达式库。</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td><strong>将下一个字符标记为一个特殊字符、或一个原义字符。</strong>例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”。</td>
</tr>
<tr>
<td>^</td>
<td><strong>匹配输入字符串的开始位置。</strong></td>
</tr>
<tr>
<td>$</td>
<td><strong>匹配输入字符串的结束位置。</strong></td>
</tr>
<tr>
<td>{n}</td>
<td>n 是一个非负整数。<strong>匹配确定的 n 次</strong>。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个 o。</td>
</tr>
<tr>
<td>{n,}</td>
<td>n 是一个非负整数。<strong>至少匹配 n 次</strong>。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有 o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>m 和 n 均为非负整数，其中 n&lt;=m。<strong>最少匹配 n 次且最多匹配 m 次。</strong>例如，“o{1,3}”将匹配“fooooood”中的前三个 o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td>*</td>
<td><strong>匹配前面的子表达式零次或多次</strong>。例如，zo<em>能匹配“z”、“zo”以及“zoo”。</em>等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td><strong>匹配前面的子表达式一次或多次</strong>。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
</tr>
<tr>
<td>?</td>
<td><strong>匹配前面的子表达式零次或一次</strong>。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td>
</tr>
<tr>
<td>?</td>
<td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td>
</tr>
<tr>
<td>.</td>
<td><strong>匹配除“\n”之外的任何单个字符</strong>。要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。</td>
</tr>
<tr>
<td>(pattern)</td>
<td><strong>匹配 pattern 并获取这一匹配的子字符串</strong>。该子字符串用于向后引用。要匹配圆括号字符，请使用“(”或“)”。</td>
</tr>
<tr>
<td>x ｜ y</td>
<td><strong>匹配 x 或 y</strong>。例如，“z ｜ food”能匹配“z”或“food”。“(z ｜ f)ood”则匹配“zood”或“food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合（character class）。<strong>匹配所包含的任意一个字符</strong>。例如，“[abc]”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。<strong>连字符 <code>-</code> 如果出现在字符串中间表示字符范围描述；如果出现在首位则仅作为普通字符。</strong></td>
</tr>
<tr>
<td>[^xyz]</td>
<td>排除型（negate）字符集合。<strong>匹配未列出的任意字符。</strong>例如，“[^abc]”可以匹配“plain”中的“plin”。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。<strong>匹配指定范围内的任意字符。</strong>例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td>排除型的字符范围。<strong>匹配任何不在指定范围内的任意字符</strong>。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td>
</tr>
</tbody></table>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>优先级为从上到下从左到右，依次降低：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>(), (?:), (?=), []</td>
<td>括号和中括号</td>
</tr>
<tr>
<td>*、+、?、{n}、{n,}、{n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^、$、\任何元字符</td>
<td>定位点和序列</td>
</tr>
<tr>
<td>｜</td>
<td>选择</td>
</tr>
</tbody></table>
<p>更多正则表达式的内容可以参考以下链接：</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式 wiki</a></li>
<li><a href="http://www.greenend.org.uk/rjk/tech/regexp.html">几种正则表达式引擎的语法差异</a></li>
<li><a href="http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines">各语言各平台对正则表达式的支持</a></li>
</ul>
<p>regex 的思导图：</p>
<p><img src="https://doc.shiyanlou.com/linux_base/RegularExpression.png" alt="img"></p>
<h2 id="三、grep-模式匹配命令"><a href="#三、grep-模式匹配命令" class="headerlink" title="三、grep 模式匹配命令"></a>三、grep 模式匹配命令</h2><p>上面空谈了那么多正则表达式的内容也并没有提及具体该如何使用它，实在枯燥，如果说正则表达式是一门武功，那它也只能算得上一些口诀招式罢了，要把它真正练起来还得需要一些兵器在手才行，这里我们要介绍的<code>grep</code>命令以及后面要讲的<code>sed</code>,<code>awk</code>这些就该算作是这样的兵器了。</p>
<h3 id="3-1-基本操作"><a href="#3-1-基本操作" class="headerlink" title="3.1 基本操作"></a>3.1 基本操作</h3><p><code>grep</code>命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。<code>grep</code>支持三种正则表达式引擎，分别用三个参数指定：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-E</code></td>
<td>POSIX 扩展正则表达式，ERE</td>
</tr>
<tr>
<td><code>-G</code></td>
<td>POSIX 基本正则表达式，BRE</td>
</tr>
<tr>
<td><code>-P</code></td>
<td>Perl 正则表达式，PCRE</td>
</tr>
</tbody></table>
<p>不过在你没学过 perl 语言的大多数情况下你将只会使用到<code>ERE</code>和<code>BRE</code>,所以我们接下来的内容都不会讨论到 PCRE 中特有的一些正则表达式语法（它们之间大部分内容是存在交集的，所以你不用担心会遗漏多少重要内容）</p>
<p>在通过<code>grep</code>命令使用正则表达式之前，先介绍一下它的常用参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-b</code></td>
<td>将二进制文件作为文本来进行匹配</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>统计以模式匹配的数目</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>忽略大小写</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>显示匹配文本所在行的行号</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>反选，输出不匹配行的内容</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>递归匹配查找</td>
</tr>
<tr>
<td><code>-A n</code></td>
<td>n 为正整数，表示 after 的意思，除了列出匹配行之外，还列出后面的 n 行</td>
</tr>
<tr>
<td><code>-B n</code></td>
<td>n 为正整数，表示 before 的意思，除了列出匹配行之外，还列出前面的 n 行</td>
</tr>
<tr>
<td><code>--color=auto</code></td>
<td>将输出中的匹配项设置为自动颜色显示</td>
</tr>
</tbody></table>
<blockquote>
<p>注：在大多数发行版中是默认设置了 grep 的颜色的，你可以通过参数指定或修改<code>GREP_COLOR</code>环境变量。</p>
</blockquote>
<h3 id><a href="#" class="headerlink" title></a><img src="https://doc.shiyanlou.com/document-uid735639labid354timestamp1532415381859.png" alt="此处输入图片的描述" style="zoom:80%;"></h3><h3 id="3-2-使用正则表达式"><a href="#3-2-使用正则表达式" class="headerlink" title="3.2 使用正则表达式"></a>3.2 使用正则表达式</h3><h4 id="使用基本正则表达式，BRE"><a href="#使用基本正则表达式，BRE" class="headerlink" title="使用基本正则表达式，BRE"></a>使用基本正则表达式，BRE</h4><ul>
<li>位置</li>
</ul>
<p>查找<code>/etc/group</code>文件中以”shiyanlou”为开头的行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ grep <span class="hljs-string">&#x27;shiyanlou&#x27;</span> /etc/group<br>$ grep <span class="hljs-string">&#x27;^shiyanlou&#x27;</span> /etc/group<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid600404labid6128timestamp1523954676432.png" alt="此处输入图片的描述"></p>
<ul>
<li>数量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将匹配以&#x27;z&#x27;开头以&#x27;o&#x27;结尾的所有字符串</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;zero\nzo\nzoo&#x27;</span> | grep <span class="hljs-string">&#x27;z.*o&#x27;</span><br><span class="hljs-comment"># 将匹配以&#x27;z&#x27;开头以&#x27;o&#x27;结尾，中间包含一个任意字符的字符串</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;zero\nzo\nzoo&#x27;</span> | grep <span class="hljs-string">&#x27;z.o&#x27;</span><br><span class="hljs-comment"># 将匹配以&#x27;z&#x27;开头,以任意多个&#x27;o&#x27;结尾的字符串</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;zero\nzo\nzoo&#x27;</span> | grep <span class="hljs-string">&#x27;zo*&#x27;</span><br></code></pre></td></tr></table></figure>

<p>注意：其中<code>\n</code>为换行符</p>
<p><img src="https://doc.shiyanlou.com/document-uid735639labid354timestamp1532415422642.png" alt="此处输入图片的描述"></p>
<ul>
<li>选择</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># grep默认是区分大小写的，这里将匹配所有的小写字母</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[a-z]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的数字</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[0-9]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的数字</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[[:digit:]]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的小写字母</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[[:lower:]]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的大写字母</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[[:upper:]]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的字母和数字，包括0-9,a-z,A-Z</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[[:alnum:]]&#x27;</span><br><span class="hljs-comment"># 将匹配所有的字母</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;1234\nabcd&#x27;</span> | grep <span class="hljs-string">&#x27;[[:alpha:]]&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid354timestamp1532415449222.png" alt="此处输入图片的描述"></p>
<p>下面包含完整的特殊符号及说明：</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>[:alnum:]</code></td>
<td>代表英文大小写字母及数字，亦即 0-9, A-Z, a-z</td>
</tr>
<tr>
<td><code>[:alpha:]</code></td>
<td>代表任何英文大小写字母，亦即 A-Z, a-z</td>
</tr>
<tr>
<td><code>[:blank:]</code></td>
<td>代表空白键与 [Tab] 按键两者</td>
</tr>
<tr>
<td><code>[:cntrl:]</code></td>
<td>代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等</td>
</tr>
<tr>
<td><code>[:digit:]</code></td>
<td>代表数字而已，亦即 0-9</td>
</tr>
<tr>
<td><code>[:graph:]</code></td>
<td>除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键</td>
</tr>
<tr>
<td><code>[:lower:]</code></td>
<td>代表小写字母，亦即 a-z</td>
</tr>
<tr>
<td><code>[:print:]</code></td>
<td>代表任何可以被列印出来的字符</td>
</tr>
<tr>
<td><code>[:punct:]</code></td>
<td>代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $…</td>
</tr>
<tr>
<td><code>[:upper:]</code></td>
<td>代表大写字母，亦即 A-Z</td>
</tr>
<tr>
<td><code>[:space:]</code></td>
<td>任何会产生空白的字符，包括空白键, [Tab], CR 等等</td>
</tr>
<tr>
<td><code>[:xdigit:]</code></td>
<td>代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>：之所以要使用特殊符号，是因为上面的[a-z]不是在所有情况下都管用，这还与主机当前的语系有关，即设置在<code>LANG</code>环境变量的值，zh_CN.UTF-8 的话[a-z]，即为所有小写字母，其它语系可能是大小写交替的如，”a A b B…z Z”，[a-z]中就可能包含大写字母。所以在使用[a-z]时请确保当前语系的影响，使用[:lower:]则不会有这个问题。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 排除字符</span><br>$ $ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;geek\ngood&#x27;</span> | grep <span class="hljs-string">&#x27;[^o]&#x27;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>**注意:**当<code>^</code>放到中括号内为排除字符，否则表示行首。</p>
</blockquote>
<p><img src="https://doc.shiyanlou.com/document-uid735639labid354timestamp1532415467268.png" alt="此处输入图片的描述"></p>
<h4 id="使用扩展正则表达式，ERE"><a href="#使用扩展正则表达式，ERE" class="headerlink" title="使用扩展正则表达式，ERE"></a>使用扩展正则表达式，ERE</h4><p>要通过<code>grep</code>使用扩展正则表达式需要加上<code>-E</code>参数，或使用<code>egrep</code>。</p>
<ul>
<li>数量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 只匹配&quot;zo&quot;</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;zero\nzo\nzoo&#x27;</span> | grep -E <span class="hljs-string">&#x27;zo&#123;1&#125;&#x27;</span><br><span class="hljs-comment"># 匹配以&quot;zo&quot;开头的所有单词</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;zero\nzo\nzoo&#x27;</span> | grep -E <span class="hljs-string">&#x27;zo&#123;1,&#125;&#x27;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>推荐掌握<code>&#123;n,m&#125;</code>即可，<code>+</code>,<code>?</code>,<code>*</code>，这几个不太直观，且容易弄混淆。</p>
</blockquote>
<ul>
<li>选择</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 匹配&quot;www.shiyanlou.com&quot;和&quot;www.google.com&quot;</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27;</span> | grep -E <span class="hljs-string">&#x27;www\.(shiyanlou|google)\.com&#x27;</span><br><span class="hljs-comment"># 或者匹配不包含&quot;baidu&quot;的内容</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;www.shiyanlou.com\nwww.baidu.com\nwww.google.com&#x27;</span> | grep -Ev <span class="hljs-string">&#x27;www\.baidu\.com&#x27;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>因为<code>.</code>号有特殊含义，所以需要转义。</p>
</blockquote>
<p><img src="https://doc.shiyanlou.com/document-uid735639labid354timestamp1532415579510.png" alt="此处输入图片的描述"></p>
<p>关于正则表达式和<code>grep</code>命令的内容就介绍这么多，下面会介绍两个更强大的工具<code>sed</code>和<code>awk</code>，但同样也正是因为这两个工具的强大，我们的内容无法包含它们的全部，这里将只对基本内容作介绍。</p>
<h2 id="四、sed-流编辑器"><a href="#四、sed-流编辑器" class="headerlink" title="四、sed 流编辑器"></a>四、sed 流编辑器</h2><p><code>sed</code>工具在 man 手册里面的全名为”sed - stream editor for filtering and transforming text “，意即，用于过滤和转换文本的流编辑器。</p>
<p>在 Linux/UNIX 的世界里敢称为编辑器的工具，大都非等闲之辈，比如前面的”vi/vim(编辑器之神)”,”emacs(神的编辑器)”,”gedit”这些个编辑器。<code>sed</code>与上述的最大不同之处在于它是一个非交互式的编辑器，下面我们就开始介绍<code>sed</code>这个编辑器。</p>
<h3 id="4-1-sed-常用参数介绍"><a href="#4-1-sed-常用参数介绍" class="headerlink" title="4.1 sed 常用参数介绍"></a>4.1 sed 常用参数介绍</h3><p>sed 命令基本格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sed [参数]... [执行命令] [输入文件]...<br><span class="hljs-comment"># 形如：</span><br>$ sed -i <span class="hljs-string">&#x27;s/sad/happy/&#x27;</span> <span class="hljs-built_in">test</span> <span class="hljs-comment"># 表示将test文件中的&quot;sad&quot;替换为&quot;happy&quot;</span><br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>-n</code></td>
<td>安静模式，只打印受影响的行，默认打印输入数据的全部内容</td>
</tr>
<tr>
<td><code>-e</code></td>
<td>用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数</td>
</tr>
<tr>
<td><code>-f filename</code></td>
<td>指定执行 filename 文件中的命令</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>使用扩展正则表达式，默认为标准正则表达式</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>将直接修改输入文件内容，而不是打印到标准输出设备</td>
</tr>
</tbody></table>
<h3 id="4-2-sed-编辑器的执行命令（这里”执行“解释为名词）"><a href="#4-2-sed-编辑器的执行命令（这里”执行“解释为名词）" class="headerlink" title="4.2 sed 编辑器的执行命令（这里”执行“解释为名词）"></a>4.2 sed 编辑器的执行命令（这里”执行“解释为名词）</h3><p>sed 执行命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[n1][,n2]<span class="hljs-built_in">command</span><br>[n1][~step]<span class="hljs-built_in">command</span><br><span class="hljs-comment"># 其中一些命令可以在后面加上作用范围，形如：</span><br>$ sed -i <span class="hljs-string">&#x27;s/sad/happy/g&#x27;</span> <span class="hljs-built_in">test</span> <span class="hljs-comment"># g表示全局范围</span><br>$ sed -i <span class="hljs-string">&#x27;s/sad/happy/4&#x27;</span> <span class="hljs-built_in">test</span> <span class="hljs-comment"># 4表示指定行中的第四个匹配字符串</span><br></code></pre></td></tr></table></figure>

<p>其中 n1,n2 表示输入内容的行号，它们之间为<code>,</code>逗号则表示从 n1 到 n2 行，如果为<code>～</code>波浪号则表示从 n1 开始以 step 为步进的所有行；command 为执行动作，下面为一些常用动作指令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>s</code></td>
<td>行内替换</td>
</tr>
<tr>
<td><code>c</code></td>
<td>整行替换</td>
</tr>
<tr>
<td><code>a</code></td>
<td>插入到指定行的后面</td>
</tr>
<tr>
<td><code>i</code></td>
<td>插入到指定行的前面</td>
</tr>
<tr>
<td><code>p</code></td>
<td>打印指定行，通常与<code>-n</code>参数配合使用</td>
</tr>
<tr>
<td><code>d</code></td>
<td>删除指定行</td>
</tr>
</tbody></table>
<h3 id="4-3-sed-操作举例"><a href="#4-3-sed-操作举例" class="headerlink" title="4.3 sed 操作举例"></a>4.3 sed 操作举例</h3><p>我们先找一个用于练习的文本文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ cp /etc/passwd ~<br></code></pre></td></tr></table></figure>

<h4 id="打印指定行"><a href="#打印指定行" class="headerlink" title="打印指定行"></a>打印指定行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打印2-5行</span><br>$ nl passwd | sed -n <span class="hljs-string">&#x27;2,5p&#x27;</span><br><span class="hljs-comment"># 打印奇数行</span><br>$ nl passwd | sed -n <span class="hljs-string">&#x27;1~2p&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid354timestamp1532415685031.png" alt="此处输入图片的描述"></p>
<h4 id="行内替换"><a href="#行内替换" class="headerlink" title="行内替换"></a>行内替换</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将输入文本中&quot;shiyanlou&quot; 全局替换为&quot;hehe&quot;,并只打印替换的那一行，注意这里不能省略最后的&quot;p&quot;命令</span><br>$ sed -n <span class="hljs-string">&#x27;s/shiyanlou/hehe/gp&#x27;</span> passwd<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> 行内替换可以结合正则表达式使用。</p>
</blockquote>
<h4 id="删除某行"><a href="#删除某行" class="headerlink" title="删除某行"></a>删除某行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ nl passwd | grep <span class="hljs-string">&quot;shiyanlou&quot;</span><br><span class="hljs-comment"># 删除第30行</span><br>$ sed -i <span class="hljs-string">&#x27;30d&#x27;</span> passwd<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/courses/uid600404-20191015-1571118544931" alt="图片描述"></p>
<p>关于 sed 命令就介绍这么多，你如果希望了解更多 sed 的高级用法，你可以参看如下链接：</p>
<ul>
<li><a href="http://coolshell.cn/articles/9104.html">sed 简明教程</a></li>
<li><a href="http://sed.sourceforge.net/sed1line_zh-CN.html">sed 单行脚本快速参考</a></li>
<li><a href="http://www.gnu.org/software/sed/manual/sed.html">sed 完全手册</a></li>
</ul>
<h2 id="五、awk-文本处理语言"><a href="#五、awk-文本处理语言" class="headerlink" title="五、awk 文本处理语言"></a>五、awk 文本处理语言</h2><p>看到上面的标题，你可能会感到惊异，难道我们这里要学习的是一门“语言”么，确切的说，我们是要在这里学习<code>awk</code>文本处理语言，只是我们并不会在这里学习到比较完整的关于<code>awk</code>的内容，还是因为前面的原因，它太强大了，它的应用无处不在，我们无法在这里以简短的文字描述面面俱到，如果你有目标成为一个 linux 系统管理员，确实想学好 <code>awk</code>，不用担心，实验楼会在之后陆续上线 linux 系统管理员的学习路径，里面会有单独的关于<code>正则表达式</code>,<code>awk</code>,<code>sed</code>等相关课程，敬请期待吧。下面的内容，我们就作为一个关于<code>awk</code>的入门体验章节吧，其中会介绍一些<code>awk</code>的常用操作。</p>
<h3 id="5-1-awk-介绍"><a href="#5-1-awk-介绍" class="headerlink" title="5.1 awk 介绍"></a>5.1 awk 介绍</h3><blockquote>
<p><code>AWK</code>是一种优良的文本处理工具，Linux 及 Unix 环境中现有的功能最强大的数据处理引擎之一.其名称得自于它的创始人 Alfred Aho（阿尔佛雷德·艾侯）、Peter Jay Weinberger（彼得·温伯格）和 Brian Wilson Kernighan（布莱恩·柯林汉)姓氏的首个字母.AWK 程序设计语言，三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。最简单地说，AWK 是一种用于处理文本的编程语言工具。</p>
</blockquote>
<p>在大多数 linux 发行版上面，实际我们使用的是 gawk（GNU awk，awk 的 GNU 版本），在我们的环境中 ubuntu 上，默认提供的是 mawk，不过我们通常可以直接使用 awk 命令（awk 语言的解释器），因为系统已经为我们创建好了 awk 指向 mawk 的符号链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ ll /usr/bin/awk<br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid354timestamp1532416617431.png" alt="此处输入图片的描述"></p>
<blockquote>
<p>nawk： 在 20 世纪 80 年代中期，对 awk 语言进行了更新，并不同程度地使用一种称为 nawk(new awk) 的增强版本对其进行了替换。许多系统中仍然存在着旧的 awk 解释器，但通常将其安装为 oawk (old awk) 命令，而 nawk 解释器则安装为主要的 awk 命令，也可以使用 nawk 命令。Dr. Kernighan 仍然在对 nawk 进行维护，与 gawk 一样，它也是开放源代码的，并且可以免费获得; gawk： 是 GNU Project 的 awk 解释器的开放源代码实现。尽管早期的 GAWK 发行版是旧的 AWK 的替代程序，但不断地对其进行了更新，以包含 NAWK 的特性; mawk 也是 awk 编程语言的一种解释器，mawk 遵循 POSIX 1003.2 （草案 11.3）定义的 AWK 语言，包含了一些没有在 AWK 手册中提到的特色，同时 mawk 提供一小部分扩展,另外据说 mawk 是实现最快的 awk</p>
</blockquote>
<h3 id="5-2-awk-的一些基础概念"><a href="#5-2-awk-的一些基础概念" class="headerlink" title="5.2 awk 的一些基础概念"></a>5.2 awk 的一些基础概念</h3><p>awk 所有的操作都是基于 pattern(模式)—action(动作)对来完成的，如下面的形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ pattern &#123;action&#125;<br></code></pre></td></tr></table></figure>

<p>你可以看到就如同很多编程语言一样，它将所有的动作操作用一对<code>&#123;&#125;</code>花括号包围起来。其中 pattern 通常是表示用于匹配输入的文本的“关系式”或“正则表达式”，action 则是表示匹配后将执行的动作。在一个完整 awk 操作中，这两者可以只有其中一个，如果没有 pattern 则默认匹配输入的全部文本，如果没有 action 则默认为打印匹配内容到屏幕。</p>
<p><code>awk</code>处理文本的方式，是将文本分割成一些“字段”，然后再对这些字段进行处理，默认情况下，awk 以空格作为一个字段的分割符，不过这不是固定的，你可以任意指定分隔符，下面将告诉你如何做到这一点。</p>
<h3 id="5-3-awk-命令基本格式"><a href="#5-3-awk-命令基本格式" class="headerlink" title="5.3 awk 命令基本格式"></a>5.3 awk 命令基本格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs bahs">awk [-F fs] [-v var&#x3D;value] [-f prog-file | &#39;program text&#39;] [file...]<br></code></pre></td></tr></table></figure>

<p>其中<code>-F</code>参数用于预先指定前面提到的字段分隔符（还有其他指定字段的方式） ，<code>-v</code>用于预先为<code>awk</code>程序指定变量，<code>-f</code>参数用于指定<code>awk</code>命令要执行的程序文件，或者在不加<code>-f</code>参数的情况下直接将程序语句放在这里，最后为<code>awk</code>需要处理的文本输入，且可以同时输入多个文本文件。现在我们还是直接来具体体验一下吧。</p>
<h3 id="5-4-awk-操作体验"><a href="#5-4-awk-操作体验" class="headerlink" title="5.4 awk 操作体验"></a>5.4 awk 操作体验</h3><p>先用 vim 新建一个文本文档</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ vim <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>

<p>包含如下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">I like linux<br>www.shiyanlou.com<br></code></pre></td></tr></table></figure>

<ul>
<li>使用 awk 将文本内容打印到终端</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># &quot;quote&gt;&quot; 不用输入</span><br>$ awk <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; print</span><br><span class="hljs-string">&gt; &#125;&#x27;</span> <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 或者写到一行</span><br>$ awk <span class="hljs-string">&#x27;&#123;print&#125;&#x27;</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid354timestamp1532415757042.png" alt="此处输入图片的描述"></p>
<p>说明:在这个操作中我是省略了<code>pattern</code>，所以<code>awk</code>会默认匹配输入文本的全部内容，然后在”{}”花括号中执行动作，即<code>print</code>打印所有匹配项，这里是全部文本内容</p>
<ul>
<li>将 test 的第一行的每个字段单独显示为一行</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ awk <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; if(NR==1)&#123;</span><br><span class="hljs-string">&gt; print $1 &quot;\n&quot; $2 &quot;\n&quot; $3</span><br><span class="hljs-string">&gt; &#125; else &#123;</span><br><span class="hljs-string">&gt; print&#125;</span><br><span class="hljs-string">&gt; &#125;&#x27;</span> <span class="hljs-built_in">test</span><br><br><span class="hljs-comment"># 或者</span><br>$ awk <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; if(NR==1)&#123;</span><br><span class="hljs-string">&gt; OFS=&quot;\n&quot;</span><br><span class="hljs-string">&gt; print $1, $2, $3</span><br><span class="hljs-string">&gt; &#125; else &#123;</span><br><span class="hljs-string">&gt; print&#125;</span><br><span class="hljs-string">&gt; &#125;&#x27;</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid354timestamp1532415834591.png" alt="此处输入图片的描述"></p>
<p>说明:你首先应该注意的是，这里我使用了<code>awk</code>语言的分支选择语句<code>if</code>,它的使用和很多高级语言如<code>C/C++</code>语言基本一致，如果你有这些语言的基础，这里将很好理解。另一个你需要注意的是<code>NR</code>与<code>OFS</code>，这两个是<code>awk</code>内建的变量，<code>NR</code>表示当前读入的记录数，你可以简单的理解为当前处理的行数，<code>OFS</code>表示输出时的字段分隔符，默认为” “空格，如上图所见，我们将字段分隔符设置为<code>\n</code>换行符，所以第一行原本以空格为字段分隔的内容就分别输出到单独一行了。然后是<code>$N</code>其中 N 为相应的字段号，这也是<code>awk</code>的内建变量，它表示引用相应的字段，因为我们这里第一行只有三个字段，所以只引用到了<code>$3</code>。除此之外另一个这里没有出现的<code>$0</code>，它表示引用当前记录（当前行）的全部内容。</p>
<ul>
<li>将 test 的第二行的以点为分段的字段换成以空格为分隔</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">$ awk -F<span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-string">&#x27;&#123;</span><br><span class="hljs-string">&gt; if(NR==2)&#123;</span><br><span class="hljs-string">&gt; print $1 &quot;\t&quot; $2 &quot;\t&quot; $3</span><br><span class="hljs-string">&gt; &#125;&#125;&#x27;</span> <span class="hljs-built_in">test</span><br><br><span class="hljs-comment"># 或者</span><br>$ awk <span class="hljs-string">&#x27;</span><br><span class="hljs-string">&gt; BEGIN&#123;</span><br><span class="hljs-string">&gt; FS=&quot;.&quot;</span><br><span class="hljs-string">&gt; OFS=&quot;\t&quot;  # 如果写为一行，两个动作语句之间应该以&quot;;&quot;号分开</span><br><span class="hljs-string">&gt; &#125;&#123;</span><br><span class="hljs-string">&gt; if(NR==2)&#123;</span><br><span class="hljs-string">&gt; print $1, $2, $3</span><br><span class="hljs-string">&gt; &#125;&#125;&#x27;</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>

<p><img src="https://doc.shiyanlou.com/document-uid735639labid354timestamp1532415838840.png" alt="此处输入图片的描述"></p>
<p>说明：这里的<code>-F</code>参数，前面已经介绍过，它是用来预先指定待处理记录的字段分隔符。我们需要注意的是除了指定<code>OFS</code>我们还可以在<code>print</code> 语句中直接打印特殊符号如这里的<code>\t</code>，<strong>print 打印的非变量内容都需要用””一对引号包围起来</strong>。上面另一个版本，展示了实现预先指定变量分隔符的另一种方式，即使用<code>BEGIN</code>，就这个表达式指示了，其后的动作将在所有动作之前执行，这里是<code>FS</code>赋值了新的”.”点号代替默认的” “空格</p>
<p><strong>注意</strong>:首先说明一点，我们在学习和使用 awk 的时候应该尽可能将其作为一门程序语言来理解，这样将会使你学习起来更容易，所以初学阶段在练习<code>awk</code>时应该尽量按照我那样的方式分多行按照一般程序语言的换行和缩进来输入，而不是全部写到一行（当然这在你熟练了之后是没有任何问题的）。</p>
<h3 id="5-5-awk-常用的内置变量"><a href="#5-5-awk-常用的内置变量" class="headerlink" title="5.5 awk 常用的内置变量"></a>5.5 awk 常用的内置变量</h3><table>
<thead>
<tr>
<th>变量名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>FILENAME</code></td>
<td>当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串</td>
</tr>
<tr>
<td><code>$0</code></td>
<td>当前记录的内容</td>
</tr>
<tr>
<td><code>$N</code></td>
<td>N 表示字段号，最大值为<code>NF</code>变量的值</td>
</tr>
<tr>
<td><code>FS</code></td>
<td>字段分隔符，由正则表达式表示，默认为” “空格</td>
</tr>
<tr>
<td><code>RS</code></td>
<td>输入记录分隔符，默认为”\n”，即一行为一个记录</td>
</tr>
<tr>
<td><code>NF</code></td>
<td>当前记录字段数</td>
</tr>
<tr>
<td><code>NR</code></td>
<td>已经读入的记录数</td>
</tr>
<tr>
<td><code>FNR</code></td>
<td>当前输入文件的记录数，请注意它与 NR 的区别</td>
</tr>
<tr>
<td><code>OFS</code></td>
<td>输出字段分隔符，默认为” “空格</td>
</tr>
<tr>
<td><code>ORS</code></td>
<td>输出记录分隔符，默认为”\n”</td>
</tr>
</tbody></table>
<p>关于<code>awk</code>的内容本课程将只会包含这些内容，如果你想了解更多，请期待后续课程，或者参看一下链接内容：</p>
<ul>
<li><a href="http://awk.readthedocs.org/en/latest/chapter-one.html">awk 程序设计语言</a></li>
<li><a href="http://coolshell.cn/articles/9070.html">awk 简明教程</a></li>
<li><a href="http://www.gnu.org/software/gawk/manual/gawk.html">awk 用户指南</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>实验楼</category>
        <category>Linux</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>实验楼</tag>
      </tags>
  </entry>
  <entry>
    <title>存储空间</title>
    <url>/posts/60bae8b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 删除向量中的所有元素，然后将选代器first和last指示范围中的元素插入该向量中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(iterator first,iterator last)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//删除向量中的所有元素，然后将cdl的n个副本插入该向量中</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(size_type n,constT&amp;el=T())</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量中位置为n的元素</span></span><br><span class="hljs-function">T&amp;<span class="hljs-title">at</span><span class="hljs-params">(siz type n)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量中位置为n的元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">const</span> T&amp;<span class="hljs-title">at</span><span class="hljs-params">(size_type n)</span><span class="hljs-keyword">const</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量的最后一个元素</span></span><br><span class="hljs-function">T&amp;<span class="hljs-title">back</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量的最后一个元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">const</span> T&amp;<span class="hljs-title">back</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//返回一个选代器，该选代器引用向量的第一个元素</span></span><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回一个迭代器∶该送代都引用向量的第一个元素</span></span><br><span class="hljs-function">const_iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//返回可以存储在向量中的元素数目</span></span><br><span class="hljs-function">siz_type <span class="hljs-title">capacity</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//清除向量中的所有元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//如果向量不包括元素，则返回true，否则返回false</span></span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回一个迭代器。，该选代器位于向量的最后一个元素之后</span></span><br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回一个const达代器，该达代器位于向量的最后一个元素之后</span></span><br><span class="hljs-function">const_iterator <span class="hljs-title">end</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span> </span><br><span class="hljs-function"><span class="hljs-comment">//除由迭代器i引用的元素，返回一个迭代器，用被除元素之后的元素</span></span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(teator i)</span></span><br><span class="hljs-function"><span class="hljs-comment">//删除迭代器first和last指示范围中的元素，返回一个达代器，引用被除的最后一个元素之后的元素</span></span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(iterator fist,iterator last)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量的第一个元素</span></span><br><span class="hljs-function">T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量的第一个元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">const</span> T&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span> </span><br><span class="hljs-function"><span class="hljs-comment">//在由选代器i引用的元素之前插入d，并返回引用新插入元素的选代器</span></span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(iterator <span class="hljs-keyword">const</span> T&amp; el=T())</span> </span><br><span class="hljs-function"><span class="hljs-comment">//在选代器i引用的元素之前插入el的n个副本</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(iterator i,size_type n, <span class="hljs-keyword">const</span> T&amp;el)</span>    </span><br><span class="hljs-function"><span class="hljs-comment">//在选代器i引用的元素之前插入迭代器frs和hst指示范围中的元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(iterator i,iterator fist,iterator last)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回向量的最大元素数</span></span><br><span class="hljs-function">size _type <span class="hljs-title">max_sizt</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span> </span><br><span class="hljs-function"><span class="hljs-comment">//下标运算符</span></span><br>T&amp;operator[] <br><span class="hljs-comment">//下标运算符</span><br><span class="hljs-keyword">const</span> T&amp; operatof[]<span class="hljs-keyword">const</span> <br><span class="hljs-comment">//删除向量的最后一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//在向量的末尾插入el</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; el)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回引用向量中最后一个元素的迭代器</span></span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rbegin</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//返回引用向量中最后一个元素的选代器</span></span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">rbegin</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//返回位于向量中第一个元素之前的选代器</span></span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rend</span><span class="hljs-params">()</span>     </span><br><span class="hljs-function"><span class="hljs-comment">//返回位于向量中第一个元素之前的迭代器</span></span><br><span class="hljs-function">const_reverse_iternator <span class="hljs-title">rend</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span>     </span><br><span class="hljs-function"><span class="hljs-comment">//如果向量的容量小于n，该函数就为向量预留保存n项的足够空间</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reserve</span><span class="hljs-params">(size_type n)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//反转向量</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//使向量保存n个元素，方法是∶通过元素el再添加n-size()个位置，或者丢弃向量末尾溢出的sizs()-n个位置</span></span><br>void resize(size_type n,const T&amp;el=T))     <br><span class="hljs-comment">//返回向量中的元素数量</span><br><span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span><span class="hljs-keyword">const</span>    </span><br><span class="hljs-function"><span class="hljs-comment">//与另一个向量v交换内容</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(vector&lt;T&gt;&amp;v)</span>    </span><br><span class="hljs-function"><span class="hljs-comment">//创建空向量</span></span><br><span class="hljs-function"><span class="hljs-title">vector</span><span class="hljs-params">()</span>    </span><br><span class="hljs-function"><span class="hljs-comment">//用类型T的n个el副本创建一个向量（如果没有提供ed，则使用默认的构造函数T()）</span></span><br><span class="hljs-function"><span class="hljs-title">vector</span><span class="hljs-params">(siz_type n, <span class="hljs-keyword">const</span> T&amp;el=T())</span>     </span><br><span class="hljs-function"><span class="hljs-comment">//用达代器fist 和last指示范围中的元素构造一个向量</span></span><br><span class="hljs-function"><span class="hljs-title">vector</span><span class="hljs-params">(iterator fist,iterator last)</span>   </span><br><span class="hljs-function"><span class="hljs-comment">//复制构造函数</span></span><br><span class="hljs-function"><span class="hljs-title">vector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> vector&lt;T&gt;&amp; v)</span> </span><br></code></pre></td></tr></table></figure>



<h3 id="sort-排序函数"><a href="#sort-排序函数" class="headerlink" title="sort()排序函数"></a>sort()排序函数</h3><blockquote>
<p>排序算法具有同样的灵活性，在对向量v5排序的例子中，v5是以升序来排序的。那么v5如何</p>
<p>按降序排序呢?方法之一先对向量进行升序排序，然后用 reverse()算法来反转向量。另一种方法是</p>
<p>强制sort0算法在得出结果时使用&gt;运算符。为此，可以直接把函数对象作为参数∶</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">sort</span>(v5.<span class="hljs-built_in">begin</span>(),v5.<span class="hljs-built_in">end</span>(),greater&lt;<span class="hljs-keyword">int</span>&gt;());<br><br><br><span class="hljs-comment">//或者间接使用</span><br><span class="hljs-built_in">sort</span>(v5.<span class="hljs-built_in">begin</span>(),v5.<span class="hljs-built_in">end</span>(),f2);<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> m &gt; n ;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="greater-函数"><a href="#greater-函数" class="headerlink" title="greater()函数"></a>greater()函数</h5><blockquote>
<p>头文件 #include <functional></functional></p>
<p>STL已定义的函数，这个函数对象定义为模板结构，实际上该函数重载了运算符&gt;。</p>
</blockquote>
<blockquote>
<p>函数size()： 返回向量当前的元素数目（即：向量大小）</p>
<p>函数capacity()：返回向量能够拥有的元素数目（即：向量的容量）</p>
<p>函数resize() ：可以改变函数的容量</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arhc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> a[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>	<span class="hljs-keyword">int</span> b[] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">//	b[1] = 5;</span><br>	<span class="hljs-comment">//cout &lt;&lt; &quot;b1:&quot; &lt;&lt; b[1] &lt;&lt;endl;</span><br>	vector&lt;<span class="hljs-keyword">int</span>&gt; v1;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>; j++)<br>	&#123;<br>		v1.<span class="hljs-built_in">push_back</span>(j);<br>	&#125;<br>	cout &lt;&lt; <span class="hljs-string">&quot;v1:&quot;</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>)</span></span>;<br><br>	cout &lt;&lt; <span class="hljs-string">&quot;v2:&quot;</span> &lt;&lt; v2.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>	<span class="hljs-comment">//获取v1的下标为【1】的元素复制给i1</span><br>	vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator i1 = v1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(i1, i1 + <span class="hljs-number">3</span>)</span></span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;v3:&quot;</span> &lt;&lt; v3.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>) &lt;&lt; endl;<br>	v3[<span class="hljs-number">1</span>] = v3.<span class="hljs-built_in">front</span>();<br>	<span class="hljs-keyword">for</span> (SIZE_T i = <span class="hljs-number">0</span>; i &lt; v3.<span class="hljs-built_in">size</span>(); i++) &#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;V3[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; v3[i] &lt;&lt; endl;<br>	&#125;<br><br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v1)</span></span>; <span class="hljs-comment">// v4=(1 2 3 4 5),size=5,capacity=5</span><br>	<span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v5</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// v5=&#123;0 0 0 0 0&#125;</span><br>	v5[<span class="hljs-number">1</span>] = v5.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>)=<span class="hljs-number">9</span>;  <span class="hljs-comment">// v5 = (0 9 0 9 0)</span><br>	v3.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// v3=(2 3),size= 2,capacity=6</span><br>	v4.<span class="hljs-built_in">resize</span>(<span class="hljs-number">7</span>); <span class="hljs-comment">// v4=(1234500),size=7,capacity=10</span><br>	v4.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// v4=(123),size=3,capacity=10</span><br>	v4.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// v4 is empty,size=0,capacity=10(!)</span><br>	v4.<span class="hljs-built_in">insert</span>(v4.<span class="hljs-built_in">end</span>(), v3[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// v4 = (3)</span><br>	v4.<span class="hljs-built_in">insert</span>(v4.<span class="hljs-built_in">end</span>(), v3.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>));  <span class="hljs-comment">// v - (33)</span><br>	v4.<span class="hljs-built_in">insert</span>(v4.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 4=(3344)</span><br>	v4.<span class="hljs-built_in">insert</span>(v4.<span class="hljs-built_in">end</span>(), v1.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, v1.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);<span class="hljs-comment">// v4=(3 3 4 4 2 3 4)</span><br>	v4.<span class="hljs-built_in">erase</span>(v4.<span class="hljs-built_in">end</span>() - <span class="hljs-number">2</span>); <span class="hljs-comment">//v4=(3 3 4 4 2 4)</span><br>	v4.<span class="hljs-built_in">erase</span>(v4.<span class="hljs-built_in">begin</span>(), v4.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">4</span>); <span class="hljs-comment">// v4 = (2 4)</span><br>	v4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>); <span class="hljs-comment">// v4 = (8 8 8)</span><br>	v4.<span class="hljs-built_in">assign</span>(a, a + <span class="hljs-number">3</span>);  <span class="hljs-comment">// v4 = (1 2 3)</span><br><br>	<span class="hljs-built_in">replace</span>(v5.<span class="hljs-built_in">begin</span>(), v5.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">7</span>);<br>	<span class="hljs-built_in">printVector</span>(v5);<br><br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s = <span class="hljs-string">&quot;Green&quot;</span>;<br>	<span class="hljs-function">vector&lt;Person&gt; <span class="hljs-title">v6</span><span class="hljs-params">(<span class="hljs-number">1</span>,Person(s,<span class="hljs-number">25</span>))</span></span>;<br>	v6.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Ann&quot;</span>, <span class="hljs-number">30</span>));<br>	v6.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Bill&quot;</span>, <span class="hljs-number">20</span>));<br><br>	<span class="hljs-built_in">sort</span>(v6.<span class="hljs-built_in">begin</span>(), v6.<span class="hljs-built_in">end</span>(),greater&lt;Person&gt;());<br><br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; v6.<span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		info manInfo = v6[i].<span class="hljs-built_in">getInfo</span>(v6[i]);<br>		cout &lt;&lt; manInfo.name &lt;&lt; <span class="hljs-string">&quot;今年&quot;</span> &lt;&lt; manInfo.age &lt;&lt; <span class="hljs-string">&quot;了&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br>	<span class="hljs-built_in">sort</span>(v6.<span class="hljs-built_in">begin</span>(), v6.<span class="hljs-built_in">end</span>(),lesserAge);<br><br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; v6.<span class="hljs-built_in">size</span>(); i++)<br>	&#123;<br>		info manInfo = v6[i].<span class="hljs-built_in">getInfo</span>(v6[i]);<br>		cout &lt;&lt; manInfo.name &lt;&lt; <span class="hljs-string">&quot;今年&quot;</span> &lt;&lt; manInfo.age &lt;&lt; <span class="hljs-string">&quot;了&quot;</span> &lt;&lt; endl;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/.work//Users\明明\AppData\Roaming\Typora\typora-user-images\image-20200908075126062.png" alt="image-20200908075126062"></p>
<p><img src="/.work//Users\明明\AppData\Roaming\Typora\typora-user-images\image-20200908075157346.png" alt="image-20200908075157346"></p>
<p><img src="/.work//Users\明明\AppData\Roaming\Typora\typora-user-images\image-20200908075434653.png" alt="image-20200908075434653"></p>
<p><img src="/.work//Users\明明\AppData\Roaming\Typora\typora-user-images\image-20200908075524946.png" alt="image-20200908075524946"></p>
<p><img src="/.work//Users\明明\AppData\Roaming\Typora\typora-user-images\image-20200908075611896.png" alt="image-20200908075611896"></p>
<p><img src="/.work//Users\明明\AppData\Roaming\Typora\typora-user-images\image-20200908075627415.png" alt="image-20200908075627415"></p>
<p><img src="/.work//Users\明明\AppData\Roaming\Typora\typora-user-images\image-20200908075652847.png" alt="image-20200908075652847"></p>
]]></content>
      <categories>
        <category>C++笔记</category>
        <category>C++_Primer_Plus</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>STL实现—C++STL简介</title>
    <url>/posts/9b43cc40.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span>

<h1 id="C-STL简介"><a href="#C-STL简介" class="headerlink" title="C++ STL简介"></a>C++ STL简介</h1><h2 id="一、STL介绍"><a href="#一、STL介绍" class="headerlink" title="一、STL介绍"></a>一、STL介绍</h2><p>本次课程主要面对有一定 c++ 基础（了解基本语法，熟悉常用特性）的 ，想要学习 c++ 更深入特性 ，掌握 c++ 强大标准库的同学 。通过本次课程，你将学习到 c++ template ，异常处理 ，并回顾数据库的部分知识 ，初步掌握 STL 开发 ，避免重复制造轮子。</p>
<ul>
<li>将学习到的知识点：<ul>
<li>模板编程</li>
<li>泛型编程</li>
<li>STL 常用组件</li>
<li>lambda 表达式</li>
<li>异常处理</li>
<li>内存处理</li>
<li>部分数据结构</li>
<li>部分算法</li>
</ul>
</li>
</ul>
<blockquote>
<p>提示：本课程所有代码至少需要开启 -std=c++11 选项来支持 C++11 相关特性，在介绍 C++14 特性时的相关代码需要开启 -std=c++14 的编译选项，例如：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">+ g++ main.cpp -std&#x3D;c++11<br>+ g++ main.cpp -std&#x3D;c++14<br></code></pre></td></tr></table></figure>

<p><strong>如果你没有使用过 STL，那么你是不爱 c++ 的</strong>，STL 的原名是“Standard Template Library”，翻译过来就是标准模板库。STL 是 C++ 标准库的一个重要组成部分，STL 实现了常用的数据结构和算法 ，蕴含其间的泛型编程和代码复用的思想深刻的影响了编程习惯，像微积分延长天文学家寿命一样，STL 延长了程序员的寿命。 STL 由<strong>算法</strong>，<strong>容器</strong>，<strong>迭代器</strong>，<strong>适配器</strong>，<strong>仿函数（函数对象）</strong>，<strong>空间适配器</strong>六大部件组成 。我们将主要讲解容器，迭代器，算法和仿函数。适配器的部分会交给学员来实现，而空间适配器不会太过于深入。从上往下学习 STL，学习曲线不再那么陡峭。</p>
<h2 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h2><p>鱼缸是容器，瓶子是容器，饭碗也是容器，STL 的容器也不列外。这里的容器首先是一个模板类，在类中实现对数据的操作，而包含这样的类的实现就叫一个容器。STL 有许多这样的容器，它们包括：向量（vector），列表（list），队列（queue），双端队列（deque），优先队列（Priority queue），集合（set），多种集合（multiset），映射（map），多重映射（multimap）。</p>
<h2 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h2><p>数据结构加算法等于程序，如果说容器实现了数据结构的话，那么算法就是 STL 的灵魂 ，STL 的算法是一种通用的算法，并不依赖于特定的数据结构和对象 。这样的好处是不用针对每种情况编写特定的代码，而是给出一种通用的做法，是代码复用的一种实现方法，模板编程则是泛型编程的基础。</p>
<h2 id="四、迭代器"><a href="#四、迭代器" class="headerlink" title="四、迭代器"></a>四、迭代器</h2><p>让我们演示一个简单的函数： <code>add（int &amp;a ，int &amp;b）</code> ，它传入两个引用，然后执行加法操作，可以看到它依赖于 int 这个特定的类型，而且暴露了这个函数的内部结构不利于对底层的隔离和封装。那么 STL 是怎么解决这个问题的呢？他们使用了迭代器（<strong>对指针的一种泛化</strong>）。迭代器底层是由指针实现的，是容器和算法的桥梁。STL 里大多数容器都实现了自己的迭代器，我们可以使用迭代器来完成对容器的访问。后面我们会详细讲到迭代器的种类，性质，使用，实现。</p>
<h2 id="五、适配器"><a href="#五、适配器" class="headerlink" title="五、适配器"></a>五、适配器</h2><p>学习过数据结构的同学大都知道，数据结构不是独立的，部分数据结构是可以相互转换的。比如栈和队列可以互相实现。当我们需要一个碗的时候我们不一定重新制造，我们可以把瓶子的上部去掉。同样的道理，当我们需要队列（queue）的时候，也可以用双端队列（deque）去实现。而 queue 就叫做适配器。STL 有三种基本容器 vector，deque，list。有用基本容器扩展的适配器 queue，stack 等。适配器主要有容器适配器，迭代器适配器，函数适配器，它们的作用范围不同，意思大致一致。后面我们也会详细讲到。</p>
<h2 id="六、仿函数"><a href="#六、仿函数" class="headerlink" title="六、仿函数"></a>六、仿函数</h2><p>仿函数又叫做函数对象，<strong>其本质是类的对象，一种可回调机制</strong>，在类中重载了<strong>（）</strong>运算符，使对象在用（）时呈现出函数的特性，所以叫做仿函数。叫仿函数体现了它的作用，叫函数对象体现其本质，大家喜欢叫什么都可以。而为什么需要仿函数呢？因为 STL 没有也不可能将所有东西都包含到函数中，而程序是对现实的模拟，现实又是最复杂的，一个<code>sort（）</code>，你要 &lt; ，我要 &gt; 。如何协调呢？我们可以定义自己需要的仿函数，定制自己的操作。具体的内容我们后面会讲。这儿只做说明。</p>
<h2 id="七、空间配置器"><a href="#七、空间配置器" class="headerlink" title="七、空间配置器"></a>七、空间配置器</h2><p>c++ 的一大魅力就是对底层的操作，你像一个魔法师一样，挥舞着魔杖操纵着底层的各种资源。当然一个不好，程序也崩给你看。而空间配置器就是 STL 自己的“内存池”。完成对内存的申请，释放，维护。配置器有两个部分：一级空间配置器，二级空间配置器。本次课程不会过度讲解配置器，感兴趣的同学可以去看一下实验楼另外一个课程：<a href="https://www.lanqiao.cn/courses/566">c++ 实现高性能内存池</a>。</p>
]]></content>
      <categories>
        <category>实验楼</category>
        <category>实现STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
</search>
