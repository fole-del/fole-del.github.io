<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式</title>
    <url>/posts/364ea8cc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="除了“设计模式”，你还应该知道什么"><a href="#除了“设计模式”，你还应该知道什么" class="headerlink" title="除了“设计模式”，你还应该知道什么"></a>除了“设计模式”，你还应该知道什么</h1><p>程序员内功之设计模式🔥</p>
<blockquote>
<p>推荐学习视频<a href="https://www.bilibili.com/video/BV1W7411M7vB">C++常用设计模式</a></p>
</blockquote>
<span id="more"></span>

<h1 id="设计模式从何而来"><a href="#设计模式从何而来" class="headerlink" title="设计模式从何而来"></a>设计模式从何而来</h1><p>四人组（Gang of Four)，简称<mark style="color:green;font-size:30px;">GoF</mark>.</p>
<p>GoF将模式的概念引入软件工程领域，这标志着<mark>软件模式</mark>的诞生。软件模式（Software Pattern是）是将模式的一半概念应用于软件开发领域，即<b>软件开发的总体指导思路或参照样板</b>.</p>
<p>需要了解软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等。</p>
<blockquote>
<p>“软件设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可充用代码，让代码更容易被他人理解并且保证代码可靠性。”</p>
<div style="text-align:right;font-weight:900;font-size:20px;">——软件设计模式的定义</div>
</blockquote>
<p>一句大白话就是：“<mark>在一定环境下，用固定套路解决问题</mark>”。</p>
<h1 id="软件设计模式的种类"><a href="#软件设计模式的种类" class="headerlink" title="软件设计模式的种类"></a>软件设计模式的种类</h1><p><strong>GoF提出的设计模式有23个，包括：</strong></p>
<ul>
<li><p><a href="./%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><mark><a href="/posts/3dfd8b5b.html" title="设计模式之创建型模式">设计模式之创建型模式</a></mark></a>(Creational)：如何创建对象; </p>
<div class="note blue no-icon simple"><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p>
<ol>
<li><p>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</p>
</li>
<li><p>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p>
</li>
<li><p>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</p>
</li>
<li><p>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</p>
</li>
<li><p>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p>
</li>
</ol>
</div></li>
</ul>
<ul>
<li><p><a href="%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F.md"><mark><a href="/posts/eea0cb26.html" title="设计模式之结构型模式">设计模式之结构型模式</a></mark></a>(Structional)：如何实现类或对象的组合；</p>
<div class="note green no-icon simple"><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>，前者采用<strong>继承机制</strong>来组织接口和类，后者釆用<strong>组合或聚合</strong>来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ol>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ol>
</div></li>
<li><p><a href="./%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F.md"><mark><a href="/posts/69f2f423.html" title="设计模式之行为型模式">设计模式之行为型模式</a></mark></a>(Behavioral)：类或对象怎样交互以及怎么分配职责。</p>
<div class="note pink no-icon simple"><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式是 GoF <a href="http://c.biancheng.net/design_pattern/">设计模式</a>中最为庞大的一类，它包含以下 11 种模式。</p>
<ol>
<li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>
<p>以上 11 种行为型模式，除了模板方法模式和<a href="http://c.biancheng.net/view/1402.html">解释器模式</a>是类行为型模式，其他的全部属于对象行为型模式。</p>
</div></li>
</ul>
<p>设计模式目前的种类：GoF的23种 +“简答工厂模式” = <mark>24</mark>种 </p>
<h1 id="软件设计模式有什么用？"><a href="#软件设计模式有什么用？" class="headerlink" title="软件设计模式有什么用？"></a>软件设计模式有什么用？</h1><p><mark>有助于更加深入地理解面向对象思想</mark>，让你知道：</p>
<pre><code>1. 如何将代码分散在几个不同的类中
2. 为什么要有“接口”
3. 何为针对抽象编程
4. 合适不应该使用继承
5. 如何不修改源代码增加新功能
6. 更好地阅读和理解现有类库与其他系统中的源代码
</code></pre>
<h1 id="如何学好设计模式"><a href="#如何学好设计模式" class="headerlink" title="如何学好设计模式"></a>如何学好设计模式</h1><p>设计模式的基础是：<mark style="font-size:18px">多态</mark>，参考书上给的建议就是：</p>
<p>初学者：积累案例，不要盲目的背类图（我就是）</p>
<p>初级开发人员：多思考，多梳理，归纳总结，尊重事物的认知规律，注意临界点的突破，不要浮躁。</p>
<p>中级开发人员：合适的开发环境，寻找合适的设计模式来解决问题。多应用，对经典的组合设计模式，大量自由的运用，要不断地追求。</p>
<h1 id="关于语言"><a href="#关于语言" class="headerlink" title="关于语言"></a>关于语言</h1><p>语言是基础，学习设计模式之前一定要对自己现在使用和运用的语言加以了解；熟悉、掌握多态。</p>
<p>C++学习者建议可以读一遍《c++ Primer Plus》，尤其是面向对象部分</p>
<h1 id="设计模式总览"><a href="#设计模式总览" class="headerlink" title="设计模式总览"></a>设计模式总览</h1><h2 id="创建型模式（Creational）"><a href="#创建型模式（Creational）" class="headerlink" title="创建型模式（Creational）"></a>创建型模式（Creational）</h2><img src="https://tva3.sinaimg.cn/large/0072YHp3ly1gjvts4pq4ij30k207ljs6.jpg" alt="创建型模式" width="722" data-width="722" data-height="273">

<h2 id="结构型模式-Structural"><a href="#结构型模式-Structural" class="headerlink" title="结构型模式(Structural)"></a>结构型模式(Structural)</h2><img src="https://tvax4.sinaimg.cn/large/0072YHp3ly1gjvtri85hgj31430gttfr.jpg" alt="结构型模式" width="722" data-width="1443" data-height="605">

<h2 id="行为型模式（Behavioral）"><a href="#行为型模式（Behavioral）" class="headerlink" title="行为型模式（Behavioral）"></a>行为型模式（Behavioral）</h2><img src="https://cdn.jsdelivr.net/gh/pic-cdn/cdn2@782567680f7acccab170d2fe9b08cfa2726c7a22/2020/10/10/388b31a1de6af885d18daa816f9342f5.png" width="722px" height="auto" alt="行为型模式">



<h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单一职责原则<br>（Single Responsibility Principle,SRP)<br>⭐️⭐️⭐️⭐️</td>
<td align="center">类的职责单一，对外只提供一种可能，而引起类变化的原因都应该只有一个。</td>
</tr>
<tr>
<td align="center">开闭原则<br>（Open-Closed Principle,OCP)<br>⭐️⭐️⭐️⭐️⭐️</td>
<td align="center"><strong>类的改动是通过增加代码进行的，而不是修改源代码</strong></td>
</tr>
<tr>
<td align="center">里氏代换原则<br>(Liskov Substitution Principle,LSP)<br>⭐️⭐️⭐️⭐️⭐️</td>
<td align="center">任何抽象类出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。</td>
</tr>
<tr>
<td align="center">依赖倒转原则<br>（Dependence Inversion Priciple,DIP)<br>⭐️⭐️⭐️⭐️⭐️</td>
<td align="center"><font color="red">依赖于抽象（接口），不要依赖具体的实现（类），也就是针对接口编程。</font></td>
</tr>
<tr>
<td align="center">接口隔离原则<br>（Interface Segregation Principle,ISP)<br>⭐️⭐️</td>
<td align="center"><strong>不应该强迫用户的程序依赖他们不需要的接口方法。一个接口只提供一种对外功能，不应该把所有操作都封装到一个接口中去。</strong></td>
</tr>
<tr>
<td align="center">合成复用原则<br>（Composite Reuse Principle，CRP)<br>⭐️⭐️⭐️⭐️</td>
<td align="center">如果使用继承，会导致父类的任何变化都可能影响到子类的行为，如果使用对象组合，就降低了这种依赖关系，对于继承和类，优先使用该组合。</td>
</tr>
<tr>
<td align="center">迪米特法则<br>（Law of Demeter,LoD)<br>⭐️⭐️⭐️</td>
<td align="center">一个对象应当对其他对象尽可能少的了解,从而降低各个对象之间的耦合,提高系统的可维护性。例如在一个程序中,各个模块之间相互调用时,通常会提供- -个统- -的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节, 这样当一个模块内部的实现发生改变时,不会影响其他模块的使用。( 黑盒原理)</td>
</tr>
</tbody></table>
<blockquote>
<p>借鉴了《Easy搞定设计模式》</p>
</blockquote>
]]></content>
      <categories>
        <category>程序员内功</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣高效算法入门</title>
    <url>/posts/8cb5320c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= nums.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>  <strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code> 的算法吗？</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i,x := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br>            <span class="hljs-keyword">if</span> x+nums[j] == target &#123;<br>                <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;i,j&#125; <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h1><p>给定一个已按照**非递减顺序排列 ** 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p>
<p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值_。_<code>numbers</code> 的下标 <strong>从 1 开始计数</strong> ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code> 。</p>
<p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：numbers &#x3D; [2,3,4], target &#x3D; 6<br>输出：[1,3]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：numbers &#x3D; [-1,0], target &#x3D; -1<br>输出：[1,2]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>2 &lt;= numbers.length &lt;= 3 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
<li>  <code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li>
<li>  <code>-1000 &lt;= target &lt;= 1000</code></li>
<li>  <strong>仅存在一个有效答案</strong></li>
</ul>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>#双指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(numbers []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    left,right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        sum := numbers[left] + numbers [right]<br>        <span class="hljs-keyword">if</span> sum == target &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &lt; target &#123;<br>            left++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h1><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 _a，b，c ，_使得 <em>a + b + c =</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; []<br>输出：[]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [0]<br>输出：[]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= nums.length &lt;= 3000</code></li>
<li>  <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>#三指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">class Solution &#123;<br>public:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; threeSum(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">// 先排序</span><br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        sort(nums.begin(), nums.end());<br><br>        <span class="hljs-comment">// 定义首指针==target</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> ( i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <br>                <span class="hljs-keyword">continue</span>;<br>            <br>            <span class="hljs-keyword">int</span> k = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 内层首指针</span><br>            <span class="hljs-keyword">int</span> target = -nums[i];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) <span class="hljs-comment">// 内层尾指针</span><br>            &#123; <br>                <span class="hljs-keyword">if</span>( j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>]) <br>                    <span class="hljs-keyword">continue</span>;<br><br>                while (j &lt; k &amp;&amp; nums[j] + nums[k] &gt; target) &#123; <span class="hljs-comment">// 遍历尾指针，找合适序列</span><br>                    --k;<br>                &#125;<br><br>                <span class="hljs-comment">// 当前i不满足</span><br>                <span class="hljs-keyword">if</span>(j == k) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 得到符合条件序列</span><br>                <span class="hljs-keyword">if</span>(nums[j] + nums[k] == target) &#123;<br>                    ans.push_back(&#123;nums[i],nums[j],nums[k]&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h1><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li>  <code>0 &lt;= a, b, c, d &lt; n</code></li>
<li>  <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li>  <code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= target &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">class Solution &#123;<br>public:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; fourSum(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">int</span> n = nums.size();<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        sort(nums.begin(), nums.end());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> ((long) nums[i] + nums[i + <span class="hljs-number">1</span>] + nums[i + <span class="hljs-number">2</span>] + nums[i + <span class="hljs-number">3</span>] &gt; target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((long) nums[i] + nums[n - <span class="hljs-number">3</span>] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>])<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> ((long) nums[i] + nums[j] + nums[j + <span class="hljs-number">1</span>] + nums[j + <span class="hljs-number">2</span>] &gt; target) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> ((long) nums[i] + nums[j] + nums[n - <span class="hljs-number">2</span>] + nums[n - <span class="hljs-number">1</span>] &lt; target) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 最内层首尾指针</span><br>                <span class="hljs-keyword">int</span> m = n - <span class="hljs-number">1</span>, k = j + <span class="hljs-number">1</span>;<br>                while(k &lt; m) &#123;<br>                    <span class="hljs-keyword">int</span> sum = nums[i] + nums[j] + nums[k] + nums[m];<br>                    <span class="hljs-keyword">if</span> (sum == target) &#123;<br>                        ans.push_back(&#123;nums[i], nums[j], nums[k], nums[m]&#125;);<br>                        while (k &lt; m &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]) &#123;<br>                            k++;<br>                        &#125;<br>                        k++;<br>                        while (k &lt; m &amp;&amp; nums[m] == nums[m - <span class="hljs-number">1</span>]) &#123;<br>                            m--;<br>                        &#125;<br>                        m--;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                        k++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        m--;<br>                    &#125;<br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h1><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">F(0) &#x3D; 0，F(1) &#x3D; 1<br>F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1<br></code></pre></td></tr></table></figure>

<p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：2<br>输出：1<br>解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：3<br>输出：2<br>解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：4<br>输出：3<br>解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= n &lt;= 30</code></li>
</ul>
<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> fib(n<span class="hljs-number">-2</span>) + fib(n<span class="hljs-number">-1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1\.  1 阶 + 1 阶<br>2\.  2 阶<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1\.  1 阶 + 1 阶 + 1 阶<br>2\.  1 阶 + 2 阶<br>3\.  2 阶 + 1 阶<br></code></pre></td></tr></table></figure>


<h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    pre1,pre2 := <span class="hljs-number">2</span>,<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>        cur := pre1 + pre2<br>        pre2 = pre1<br>        pre1 = cur<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre1<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1]<br>输出：1<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [5,4,-1,7,8]<br>输出：23<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h2 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    sum := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] + nums[i<span class="hljs-number">-1</span>] &gt; nums[i] &#123;<br>            nums[i] += nums[i<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-keyword">if</span>  nums[i] &gt; sum &#123;<br>            sum = nums[i]<br>        &#125;<br>    &#125;  <br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h1><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums.length &lt;= 200</code></li>
<li>  <code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h2 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划 #背包问题 #difficult</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    sum, maxNum := <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _,num := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += num<br>        <span class="hljs-keyword">if</span> num &gt; maxNum &#123;<br>            maxNum = num<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断总和是不是奇数</span><br>    <span class="hljs-keyword">if</span> sum%<span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    target := sum / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> target &lt; maxNum &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, target+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        v := nums[i]<br>        <span class="hljs-keyword">for</span> j := target; j &gt;= v; j-- &#123;<br>            dp[j] = dp[j] || dp[j-v]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[target]<br><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h1><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3 <br>解释：11 &#x3D; 5 + 5 + 1<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1], amount &#x3D; 1<br>输出：1<br></code></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：coins &#x3D; [1], amount &#x3D; 2<br>输出：2<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= coins.length &lt;= 12</code></li>
<li>  <code>1 &lt;= coins[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li>
<li>  <code>0 &lt;= amount &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-keyword">int</span>, amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, amount + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 初始化为math.MaxInt32</span><br>	<span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= amount; j++ &#123;<br>		dp[j] = math.MaxInt32<br>	&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(coins); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := coins[i]; j &lt;= amount ; j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[j-coins[i]] != math.MaxInt32 &#123;<br>                dp[j] = min(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 没找到能装满背包的, 就返回-1</span><br>	<span class="hljs-keyword">if</span> dp[amount] == math.MaxInt32 &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> dp[amount]<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b&#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li> 左括号必须用相同类型的右括号闭合。</li>
<li> 左括号必须以正确的顺序闭合。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;(]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;([)]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;&#123;[]&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<h2 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h2><p>#栈</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">byte</span> &#123;<br>        <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-string">&#x27;(&#x27;</span>,<br>        <span class="hljs-string">&#x27;]&#x27;</span>:<span class="hljs-string">&#x27;[&#x27;</span>,<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>:<span class="hljs-string">&#x27;&#123;&#x27;</span>,<br>    &#125;<br><br>    stack := []<span class="hljs-keyword">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> pairs[s[i]] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != pairs[s[i]] &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack,s[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="20-有效的括号-1"><a href="#20-有效的括号-1" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li> 左括号必须用相同类型的右括号闭合。</li>
<li> 左括号必须以正确的顺序闭合。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;()[]&#123;&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;(]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;([)]&quot;<br>输出：false<br></code></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：s &#x3D; &quot;&#123;[]&#125;&quot;<br>输出：true<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= s.length &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<h2 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h2><p>#栈</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">byte</span> &#123;<br>        <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-string">&#x27;(&#x27;</span>,<br>        <span class="hljs-string">&#x27;]&#x27;</span>:<span class="hljs-string">&#x27;[&#x27;</span>,<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>:<span class="hljs-string">&#x27;&#123;&#x27;</span>,<br>    &#125;<br><br>    stack := []<span class="hljs-keyword">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> pairs[s[i]] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != pairs[s[i]] &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack,s[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h1><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code>大的元素。</p>
<p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>
<p>返回一个长度为 <code>nums1.length</code> 的数组<code>ans</code>作为答案，满足<code>ans[i]</code>是如上所述的 <strong>下一个更大元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].<br>输出：[-1,3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：<br>- 4 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br>- 1 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。下一个更大元素是 3 。<br>- 2 ，用加粗斜体标识，nums2 &#x3D; [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].<br>输出：[3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：<br>- 2 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。下一个更大元素是 3 。<br>- 4 ，用加粗斜体标识，nums2 &#x3D; [1,2,3,4]。不存在下一个更大元素，所以答案是 -1 。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
<li>  <code>0 &lt;= nums1[i], nums2[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>
<li>  <code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>
</ul>
<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>
<h2 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h2><p>/#暴力解</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(nums1 []<span class="hljs-keyword">int</span>, nums2 []<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    m,n := <span class="hljs-built_in">len</span>(nums1),<span class="hljs-built_in">len</span>(nums2)<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        j := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j &lt; n &amp;&amp; nums2[j] != nums1[i] &#123;<br>            j++<br>        &#125;<br>        k := j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> k &lt; n &amp;&amp; nums2[k] &lt; nums2[j] &#123;<br>            k++<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> k &lt; n &#123;<br>            res[i] = nums2[k]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[i] = <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="456-132-模式"><a href="#456-132-模式" class="headerlink" title="456. 132 模式"></a><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式</a></h1><p>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。<strong>132 模式的子序列</strong> 由三个整数 <code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 组成，并同时满足：<code>i &lt; j &lt; k</code> 和 <code>nums[i] &lt; nums[k] &lt; nums[j]</code> 。</p>
<p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [1,2,3,4]<br>输出：false<br>解释：序列中不存在 132 模式的子序列。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [3,1,4,2]<br>输出：true<br>解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：nums &#x3D; [-1,3,2,0]<br>输出：true<br>解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>n == nums.length</code></li>
<li>  <code>1 &lt;= n &lt;= 2 * 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>-10&lt;sup&gt;9&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;9&lt;/sup&gt;</code></li>
</ul>
<h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h4><p>#栈 #单调栈</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    candidateK := []<span class="hljs-keyword">int</span>&#123;nums[n<span class="hljs-number">-1</span>]&#125;<br><br>    maxK := math.MinInt64<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &lt; maxK &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(candidateK) &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt; candidateK[<span class="hljs-built_in">len</span>(candidateK)<span class="hljs-number">-1</span>] &#123;<br>            maxK = candidateK[<span class="hljs-built_in">len</span>(candidateK)<span class="hljs-number">-1</span>]<br>            candidateK = candidateK[:<span class="hljs-built_in">len</span>(candidateK)<span class="hljs-number">-1</span>]<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> nums[i] &gt; maxK &#123;<br>            candidateK = <span class="hljs-built_in">append</span>(candidateK, nums[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></h1><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code>行。</p>
<p><small style="display: inline;">在「杨辉三角」中，每个数是它左上方和右上方的数的和。</small></p>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: rowIndex &#x3D; 3<br>输出: [1,3,3,1]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: rowIndex &#x3D; 0<br>输出: [1]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: rowIndex &#x3D; 1<br>输出: [1,1]<br></code></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>  <code>0 &lt;= rowIndex &lt;= 33</code></li>
</ul>
<p><strong>进阶：</strong></p>
<p>你可以优化你的算法到 <code>_O_(_rowIndex_)</code> 空间复杂度吗？</p>
<h2 id="Solution-13"><a href="#Solution-13" class="headerlink" title="Solution"></a>Solution</h2><p>#数学</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRow</span><span class="hljs-params">(rowIndex <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    C := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, rowIndex+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> C &#123;<br>        C[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>,i+<span class="hljs-number">1</span>)<br>        C[i][<span class="hljs-number">0</span>],C[i][i] = <span class="hljs-number">1</span>,<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; i; j++ &#123;<br>            C[i][j] = C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + C[i<span class="hljs-number">-1</span>][j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> C[rowIndex]<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h1><p>给定正整数 _n_，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 _n_。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：n &#x3D; 12<br>输出：3 <br>解释：12 &#x3D; 4 + 4 + 4<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：n &#x3D; 13<br>输出：2<br>解释：13 &#x3D; 4 + 9<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= n &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-14"><a href="#Solution-14" class="headerlink" title="Solution"></a>Solution</h2><p>#动态规划</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    f := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        minn := math.MaxInt32<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j*j &lt;= i; j++ &#123;<br>            minn = min(minn, f[i-j*j])<br>        &#125;<br>        f[i] = minn + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h1><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：false<br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 --&gt; 2): 和为 3<br>(1 --&gt; 3): 和为 4<br>不存在 sum &#x3D; 5 的根节点到叶子节点的路径。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：root &#x3D; [], targetSum &#x3D; 0<br>输出：false<br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li>  <code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>  <code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h2 id="Solution-15"><a href="#Solution-15" class="headerlink" title="Solution"></a>Solution</h2><p>#广度搜索</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    queNode := []*TreeNode&#123;&#125;<br>    queVal := []<span class="hljs-keyword">int</span>&#123;&#125;<br>    queNode = <span class="hljs-built_in">append</span>(queNode,root)<br>    queVal = <span class="hljs-built_in">append</span>(queVal,root.Val)<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queNode) != <span class="hljs-number">0</span> &#123;<br>        now := queNode[<span class="hljs-number">0</span>]<br>        queNode = queNode[<span class="hljs-number">1</span>:]<br>        temp := queVal[<span class="hljs-number">0</span>]<br>        queVal = queVal[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-keyword">if</span> now.Left == <span class="hljs-literal">nil</span> &amp;&amp; now.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> temp == targetSum &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> now.Left != <span class="hljs-literal">nil</span> &#123;<br>            queNode = <span class="hljs-built_in">append</span>(queNode,now.Left)<br>            queVal = <span class="hljs-built_in">append</span>(queVal,now.Left.Val + temp)<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> now.Right != <span class="hljs-literal">nil</span> &#123;<br>            queNode = <span class="hljs-built_in">append</span>(queNode, now.Right)<br>            queVal = <span class="hljs-built_in">append</span>(queVal, now.Right.Val + temp)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<h1 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720. 词典中最长的单词"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/">720. 词典中最长的单词</a></h1><p>给出一个字符串数组<code>words</code>组成的一本英语词典。从中找出最长的一个单词，该单词是由<code>words</code>词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。</p>
<p>若无答案，则返回空字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：<br>words &#x3D; [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]<br>输出：&quot;world&quot;<br>解释： <br>单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;添加一个字母组成。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：<br>words &#x3D; [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]<br>输出：&quot;apple&quot;<br>解释：<br>&quot;apply&quot;和&quot;apple&quot;都能由词典中的单词组成。但是&quot;apple&quot;的字典序小于&quot;apply&quot;。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  所有输入的字符串都只包含小写字母。</li>
<li>  <code>words</code>数组长度范围为<code>[1,1000]</code>。</li>
<li>  <code>words[i]</code>的长度范围为<code>[1,30]</code>。</li>
</ul>
<h4 id="Solution-16"><a href="#Solution-16" class="headerlink" title="Solution"></a>Solution</h4><p>Language: ****</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestWord</span><span class="hljs-params">(words []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-comment">// 排序哈希</span><br>    sort.Strings(words)<br><br>    <span class="hljs-comment">// 字符串/是否出现</span><br>    wordsMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)<br>    res := <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-keyword">for</span> _,word := <span class="hljs-keyword">range</span> words &#123;<br>        wlen, reslen := <span class="hljs-built_in">len</span>(word), <span class="hljs-built_in">len</span>(res)<br><br>        <span class="hljs-comment">// 字符串前缀</span><br>        <span class="hljs-keyword">if</span> wlen == <span class="hljs-number">1</span> || wordsMap[word[:wlen<span class="hljs-number">-1</span>]] &#123;<br>            wordsMap[word] = <span class="hljs-literal">true</span><br>            <span class="hljs-comment">// 更新res为最长的单词</span><br>            <span class="hljs-keyword">if</span> reslen == <span class="hljs-number">0</span> || reslen &lt; wlen &#123;<br>                res = word<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 **最长子串 **的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;abcabcbb&quot;<br>输出: 3 <br>解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;bbbbb&quot;<br>输出: 1<br>解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;pwwkew&quot;<br>输出: 3<br>解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入: s &#x3D; &quot;&quot;<br>输出: 0<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= s.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<h2 id="Solution-17"><a href="#Solution-17" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">int</span>&#123;&#125;<br>    n := <span class="hljs-built_in">len</span>(s)<br><br>    rk, ans := <span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">delete</span>(m,s[i<span class="hljs-number">-1</span>])<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> rk + <span class="hljs-number">1</span> &lt; n &amp;&amp; m[s[rk+<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span> &#123;<br>            m[s[rk+<span class="hljs-number">1</span>]]++<br>            rk++<br>        &#125; <br><br>        ans = max(ans, rk - i + <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; y &#123;<br>        <span class="hljs-keyword">return</span> y<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<h1 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></h1><p>实现  函数。</p>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  <code>-1</code>。</p>
<p><strong>说明：</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的  以及 Java 的  定义相符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;<br>输出：2<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;<br>输出：-1<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;<br>输出：0<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>0 &lt;= haystack.length, needle.length &lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>
</ul>
<h2 id="Solution-18"><a href="#Solution-18" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strStr</span><span class="hljs-params">(haystack <span class="hljs-keyword">string</span>, needle <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n,m := <span class="hljs-built_in">len</span>(haystack), <span class="hljs-built_in">len</span>(needle)<br>outer:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i + m &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j:= <span class="hljs-keyword">range</span> needle &#123;<br>            <span class="hljs-keyword">if</span> haystack[i+j] != needle[j] &#123;<br>                <span class="hljs-keyword">continue</span> outer<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>1 &lt;= prices.length &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>0 &lt;= prices[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h2 id="Solution-19"><a href="#Solution-19" class="headerlink" title="Solution"></a>Solution</h2><p>#贪心 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(max <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    min := prices[<span class="hljs-number">0</span>]<br>    max = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _,price := <span class="hljs-keyword">range</span> prices &#123;<br>        <span class="hljs-keyword">if</span> price &lt; min &#123;<br>            min = price<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> max &gt; price - min &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                max = price - min<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Python端口占用测试（检测Socket）</title>
    <url>/posts/2498e501.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="windows-端口相关"><a href="#windows-端口相关" class="headerlink" title="windows 端口相关"></a>windows 端口相关</h1><h2 id="动态端口查询"><a href="#动态端口查询" class="headerlink" title="动态端口查询"></a>动态端口查询</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">netsh int ipv4 show dynamicport tcp<br><br>协议 tcp 动态端口范围<br>---------------------------------<br>启动端口        : <span class="hljs-number">49152</span><br>端口数          : <span class="hljs-number">16384</span><br></code></pre></td></tr></table></figure>

<h2 id="动态端口设置"><a href="#动态端口设置" class="headerlink" title="动态端口设置"></a>动态端口设置</h2><p>需要再管理员命令行下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell">netsh int ipv4 <span class="hljs-built_in">set</span> dynamicport tcp <span class="hljs-built_in">start</span>=<span class="hljs-number">49152</span> num=<span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure>

<h1 id="Python实现的端口测试接口"><a href="#Python实现的端口测试接口" class="headerlink" title="Python实现的端口测试接口"></a>Python实现的端口测试接口</h1><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-comment"># 文件名：client.py</span><br> <br><span class="hljs-keyword">from</span> ast <span class="hljs-keyword">import</span> Try<br><span class="hljs-keyword">import</span> socket               <span class="hljs-comment"># 导入 socket 模块</span><br><span class="hljs-keyword">import</span> sys<br><br>socketList = []<br><br>host = socket.gethostname() <span class="hljs-comment"># 获取本地主机名</span><br>remoteHost = <span class="hljs-string">&#x27;192.168.3.171&#x27;</span><br>remotePort = <span class="hljs-number">6000</span>                <span class="hljs-comment"># 设置端口号</span><br><br>errNum = <span class="hljs-number">0</span><br>ToTalNum = <span class="hljs-number">0</span><br>errPorts = &#123;&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请通过\&#x27;netsh int ipv4 show dynamicport tcp\&#x27;查看启动端口和端口数,一般情况下该值为49152&quot;</span>)<br>start = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;启动端口:&quot;</span>))<br>end = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;终止端口:&quot;</span>))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start , end): <br>    ToTalNum += <span class="hljs-number">1</span><br>    s = socket.socket()         <span class="hljs-comment"># 创建 socket 对象</span><br>    localHostAndPort = (host,i)<br>    <span class="hljs-keyword">try</span>:<br>        s.bind(localHostAndPort)<br>        <span class="hljs-keyword">if</span> s.connect((remoteHost, remotePort)) == socket.error:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;FAILED&#x27;</span>, i)<br>        <span class="hljs-built_in">print</span>(s.recv(<span class="hljs-number">1024</span>).decode(), i)<br>        socketList.append(s)<br>    <span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> e:<br>        errNum += <span class="hljs-number">1</span><br>        errPorts[i] = (localHostAndPort, <span class="hljs-string">&quot;OSError:&quot;</span>, e)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Total Port Number(%r)&quot;</span>%ToTalNum, <span class="hljs-string">&quot;Error Port Number(%r)&quot;</span>%errNum)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error Ports:&quot;</span>)<br><span class="hljs-keyword">for</span> err <span class="hljs-keyword">in</span> errPorts.keys():<br>    <span class="hljs-built_in">print</span>(err, errPorts[err])<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(errPorts) == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;All Ports success (%d) ~&quot;</span>%start, <span class="hljs-string">&quot;(%d)&quot;</span>% end)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入\&#x27;exit\&#x27;关闭CLIENT:&quot;</span>)<br>char = <span class="hljs-built_in">input</span>()<br><span class="hljs-keyword">while</span> char != <span class="hljs-string">&quot;exit&quot;</span>:<br>	<span class="hljs-comment"># print(char)</span><br>	char = <span class="hljs-built_in">input</span>()<br><br><span class="hljs-keyword">for</span> skt <span class="hljs-keyword">in</span> socketList:<br>    skt.close()<br><span class="hljs-comment"># print(socketList)</span><br></code></pre></td></tr></table></figure>



<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-comment"># 文件名：server.py</span><br> <br><span class="hljs-keyword">import</span> socket               <span class="hljs-comment"># 导入 socket 模块</span><br> <br>s = socket.socket()         <span class="hljs-comment"># 创建 socket 对象</span><br>host = socket.gethostname() <span class="hljs-comment"># 获取本地主机名</span><br>port = <span class="hljs-number">12345</span>                <span class="hljs-comment"># 设置端口</span><br>s.bind((host, port))        <span class="hljs-comment"># 绑定端口</span><br><br>msg = <span class="hljs-string">&#x27;Success！&#x27;</span>  <span class="hljs-comment">#strip默认取出字符串的头尾空格</span><br> <br>s.listen(<span class="hljs-number">5</span>)                 <span class="hljs-comment"># 等待客户端连接</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    c,addr = s.accept()     <span class="hljs-comment"># 建立客户端连接</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;连接地址：&#x27;</span>, addr)<br>    c.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    c.close()                <span class="hljs-comment"># 关闭连接</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>(Golang)链表学习记录</title>
    <url>/posts/85980731.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[toc]</p>
<hr>
<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  链表中节点的数目范围是 <code>[0, 10&lt;sup&gt;4&lt;/sup&gt;]</code></li>
<li>  <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>#快慢指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-comment">// 快慢指针</span><br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    slow, fast := head, head.Next<br><br>    <span class="hljs-keyword">for</span> fast != slow &#123;<br>        <span class="hljs-keyword">if</span> fast == <span class="hljs-literal">nil</span> || fast.Next == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br><br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  链表中节点的数目范围在范围 <code>[0, 10&lt;sup&gt;4&lt;/sup&gt;]</code> 内</li>
<li>  <code>-10&lt;sup&gt;5&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    seen := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> _,ok := seen[head]; ok &#123;<br>            <span class="hljs-keyword">return</span> head<br>        &#125;<br>        seen[head] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>        head = head.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>#快慢指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        <span class="hljs-keyword">if</span> fast.Next == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        fast = fast.Next.Next<br><br>        <span class="hljs-keyword">if</span> fast == slow &#123;<br>            p := head<br>            <span class="hljs-keyword">for</span> p != slow &#123;<br>                p = p.Next<br>                slow = slow.Next<br>            &#125;<br>            <span class="hljs-keyword">return</span> p<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h1><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li>  <code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li>  <code>listA</code> - 第一个链表</li>
<li>  <code>listB</code> - 第二个链表</li>
<li>  <code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li>  <code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at &#39;8&#39;<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at &#39;2&#39;<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>listA</code> 中节点数目为 <code>m</code></li>
<li>  <code>listB</code> 中节点数目为 <code>n</code></li>
<li>  <code>1 &lt;= m, n &lt;= 3 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  <code>1 &lt;= Node.val &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
<li>  <code>0 &lt;= skipA &lt;= m</code></li>
<li>  <code>0 &lt;= skipB &lt;= n</code></li>
<li>  如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>  如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> || headB == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    pa,pb := headA, headB<br>    <span class="hljs-keyword">for</span> pa != pb &#123;<br>        <span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>            pa = headB<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pa = pa.Next<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> pb == <span class="hljs-literal">nil</span> &#123;<br>            pb = headA<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pb = pb.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pa<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h1><p>Difficulty: **给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。   示例 1： 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1]   提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz   进阶：你能尝试使用一趟扫描实现吗？ **</p>
<p>给你一个链表，删除链表的倒数第 <code>n</code>个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  链表中结点的数目为 <code>sz</code></li>
<li>  <code>1 &lt;= sz &lt;= 30</code></li>
<li>  <code>0 &lt;= Node.val &lt;= 100</code></li>
<li>  <code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><p>#双指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> cur <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>,head&#125;<br>    first, second := head, dummy<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        first = first.Next<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> ; first != <span class="hljs-literal">nil</span>; first = first.Next &#123;<br>        second = second.Next<br>    &#125;<br><br>    second.Next = second.Next.Next<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题</title>
    <url>/posts/206c9e3b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[Toc]</p>
<h1 id="382-链表随机节点"><a href="#382-链表随机节点" class="headerlink" title="382. 链表随机节点"></a><a href="https://leetcode-cn.com/problems/linked-list-random-node/">382. 链表随机节点</a></h1><p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 <strong>被选中的概率一样</strong> 。</p>
<p>实现 <code>Solution</code> 类：</p>
<ul>
<li>  <code>Solution(ListNode head)</code> 使用整数数组初始化对象。</li>
<li>  <code>int getRandom()</code> 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。</li>
</ul>
<p><strong>示例：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入<br>[&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;]<br>[[[1, 2, 3]], [], [], [], [], []]<br>输出<br>[null, 1, 3, 2, 2, 3]<br><br>解释<br>Solution solution &#x3D; new Solution([1, 2, 3]);<br>solution.getRandom(); &#x2F;&#x2F; 返回 1<br>solution.getRandom(); &#x2F;&#x2F; 返回 3<br>solution.getRandom(); &#x2F;&#x2F; 返回 2<br>solution.getRandom(); &#x2F;&#x2F; 返回 2<br>solution.getRandom(); &#x2F;&#x2F; 返回 3<br>&#x2F;&#x2F; getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  链表中的节点数在范围 <code>[1, 10&lt;sup&gt;4&lt;/sup&gt;]</code> 内</li>
<li>  <code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= Node.val &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li>  至多调用 <code>getRandom</code> 方法 <code>10&lt;sup&gt;4&lt;/sup&gt;</code> 次</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>  如果链表非常大且长度未知，该怎么处理？</li>
<li>  你能否在不使用额外空间的情况下解决此问题？</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>#链表</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">type</span> Solution []<span class="hljs-keyword">int</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-params">(s Solution)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> node := head; node != <span class="hljs-literal">nil</span>; node = node.Next &#123;<br>        s = <span class="hljs-built_in">append</span>(s, node.Val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Solution)</span> <span class="hljs-title">GetRandom</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> s[rand.Intn(<span class="hljs-built_in">len</span>(s))]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(head);</span><br><span class="hljs-comment"> * param_1 := obj.GetRandom();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Go</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go_hard_Algorithm</title>
    <url>/posts/24feca74.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="913-猫和老鼠-图-dfs-dp"><a href="#913-猫和老鼠-图-dfs-dp" class="headerlink" title="913. 猫和老鼠 #图 #dfs #dp"></a><a href="https://leetcode-cn.com/problems/cat-and-mouse/">913. 猫和老鼠</a> #图 #dfs #dp</h1><p>两位玩家分别扮演猫和老鼠，在一张 <strong>无向</strong> 图上进行游戏，两人轮流行动。</p>
<p>图的形式是：<code>graph[a]</code> 是一个列表，由满足 <code>ab</code> 是图中的一条边的所有节点 <code>b</code> 组成。</p>
<p>老鼠从节点 <code>1</code> 开始，第一个出发；猫从节点 <code>2</code> 开始，第二个出发。在节点 <code>0</code> 处有一个洞。</p>
<p>在每个玩家的行动中，他们 <strong>必须</strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 <code>1</code> ，那么它必须移动到 <code>graph[1]</code> 中的任一节点。</p>
<p>此外，猫无法移动到洞中（节点 <code>0</code>）。</p>
<p>然后，游戏在出现以下三种情形之一时结束：</p>
<ul>
<li>  如果猫和老鼠出现在同一个节点，猫获胜。</li>
<li>  如果老鼠到达洞中，老鼠获胜。</li>
<li>  如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li>
</ul>
<p>给你一张图 <code>graph</code> ，并假设两位玩家都都以最佳状态参与游戏：</p>
<ul>
<li>  如果老鼠获胜，则返回 <code>1</code>；</li>
<li>  如果猫获胜，则返回 <code>2</code>；</li>
<li>  如果平局，则返回 <code>0</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：graph &#x3D; [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]<br>输出：0<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/17/cat2.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">输入：graph &#x3D; [[1,3],[0],[3],[0,2]]<br>输出：1<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>  <code>3 &lt;= graph.length &lt;= 50</code></li>
<li>  <code>1 &lt;= graph[i].length &lt; graph.length</code></li>
<li>  <code>0 &lt;= graph[i][j] &lt; graph.length</code></li>
<li>  <code>graph[i][j] != i</code></li>
<li>  <code>graph[i]</code> 互不相同</li>
<li>  猫和老鼠在游戏中总是移动</li>
</ul>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOUSE_WIN = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> CAT_WIN = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> DRAW = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">51</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">int</span> dp[MAXN][MAXN][MAXN*<span class="hljs-number">2</span>];<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; graph;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">catMouseGame</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;graph = graph;<br>        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dp));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getResult</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mouse, <span class="hljs-keyword">int</span> cat, <span class="hljs-keyword">int</span> turns)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(turns == n * <span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> DRAW;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>( dp[mouse][cat][turns] &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mouse == <span class="hljs-number">0</span>)<br>            &#123;<br>                dp[mouse][cat][turns] = MOUSE_WIN;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cat == mouse)<br>            &#123;<br>                dp[mouse][cat][turns] = CAT_WIN;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">getNextResult</span>(mouse, cat, turns);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[mouse][cat][turns];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNextResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mouse, <span class="hljs-keyword">int</span> cat, <span class="hljs-keyword">int</span> turns)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> curMove = turns % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? mouse : cat;<br>        <span class="hljs-keyword">int</span> defaultResult = curMove == mouse ? CAT_WIN : MOUSE_WIN;<br>        <span class="hljs-keyword">int</span> result = defaultResult;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> next : graph[curMove])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(curMove == cat &amp;&amp; next == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> nextMouse = curMove == mouse ? next : mouse;<br>            <span class="hljs-keyword">int</span> nextCat = curMove == cat ? next : cat;<br>            <span class="hljs-keyword">int</span> nextResult = <span class="hljs-built_in">getResult</span>(nextMouse, nextCat, turns+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(nextResult != defaultResult)<br>            &#123;<br>                result = nextResult;<br>                <span class="hljs-keyword">if</span>(result != DRAW)<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        dp[mouse][cat][turns] = result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    draw = <span class="hljs-number">0</span><br>    mouseWin = <span class="hljs-number">1</span><br>    catWin = <span class="hljs-number">2</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">catMouseGame</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(graph)<br>    dp := <span class="hljs-built_in">make</span>([][][]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i:= <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br>        <span class="hljs-keyword">for</span> j:= <span class="hljs-keyword">range</span> dp[i] &#123;<br>            dp[i][j] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n*<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">for</span> k:= <span class="hljs-keyword">range</span> dp[i][j] &#123;<br>                dp[i][j][k] = <span class="hljs-number">-1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> getResult, getNextResult <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> <br>    getResult = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(mouse, cat, turns <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>        <span class="hljs-keyword">if</span> turns == n*<span class="hljs-number">2</span> &#123;<br>            <span class="hljs-keyword">return</span> draw<br>        &#125;<br><br>        res := dp[mouse][cat][turns]<br>        <span class="hljs-keyword">if</span> res != <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">return</span> res<br>        &#125;<br>        <span class="hljs-keyword">if</span> mouse == <span class="hljs-number">0</span> &#123;<br>            res = mouseWin<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cat == mouse &#123;<br>            res = catWin<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res = getNextResult(mouse, cat, turns)<br>        &#125;<br>        dp[mouse][cat][turns] = res<br>        <span class="hljs-keyword">return</span> res<br>        &#125;<br><br>        getNextResult = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(mouse, cat, turns <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>        curMove := mouse<br>        <span class="hljs-keyword">if</span> turns % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>            curMove = cat<br>        &#125;<br>        defaultRes := mouseWin<br>        <span class="hljs-keyword">if</span> curMove == mouse &#123;<br>            defaultRes = catWin<br>        &#125;<br>        <br>        res := defaultRes<br>        <span class="hljs-keyword">for</span> _,next := <span class="hljs-keyword">range</span> graph[curMove] &#123;<br>            <span class="hljs-keyword">if</span> curMove == cat &amp;&amp; next == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            nextMouse, nextCat := mouse,cat<br>            <span class="hljs-keyword">if</span> curMove == mouse &#123;<br>                nextMouse = next<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> curMove == cat 